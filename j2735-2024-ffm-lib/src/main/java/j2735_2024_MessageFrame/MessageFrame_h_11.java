// Generated by jextract

package j2735_2024_MessageFrame;

import java.lang.invoke.*;
import java.lang.foreign.*;
import java.util.*;
import java.util.stream.*;

import static java.lang.foreign.ValueLayout.*;

public class MessageFrame_h_11 {

    MessageFrame_h_11() {
        // Should not be called directly
    }

    static final Arena LIBRARY_ARENA = Arena.ofAuto();
    static final boolean TRACE_DOWNCALLS = Boolean.getBoolean("jextract.trace.downcalls");

    static void traceDowncall(String name, Object... args) {
         String traceArgs = Arrays.stream(args)
                       .map(Object::toString)
                       .collect(Collectors.joining(", "));
         System.out.printf("%s(%s)\n", name, traceArgs);
    }

    static MemorySegment findOrThrow(String symbol) {
        return SYMBOL_LOOKUP.find(symbol)
            .orElseThrow(() -> new UnsatisfiedLinkError("unresolved symbol: " + symbol));
    }

    static MethodHandle upcallHandle(Class<?> fi, String name, FunctionDescriptor fdesc) {
        try {
            return MethodHandles.lookup().findVirtual(fi, name, fdesc.toMethodType());
        } catch (ReflectiveOperationException ex) {
            throw new AssertionError(ex);
        }
    }

    static MemoryLayout align(MemoryLayout layout, long align) {
        return switch (layout) {
            case PaddingLayout p -> p;
            case ValueLayout v -> v.withByteAlignment(align);
            case GroupLayout g -> {
                MemoryLayout[] alignedMembers = g.memberLayouts().stream()
                        .map(m -> align(m, align)).toArray(MemoryLayout[]::new);
                yield g instanceof StructLayout ?
                        MemoryLayout.structLayout(alignedMembers) : MemoryLayout.unionLayout(alignedMembers);
            }
            case SequenceLayout s -> MemoryLayout.sequenceLayout(s.elementCount(), align(s.elementLayout(), align));
        };
    }

    static final SymbolLookup SYMBOL_LOOKUP = SymbolLookup.libraryLookup(System.mapLibraryName("asnapplication"), LIBRARY_ARENA)
            .or(SymbolLookup.loaderLookup())
            .or(Linker.nativeLinker().defaultLookup());

    public static final OfBoolean C_BOOL = ValueLayout.JAVA_BOOLEAN;
    public static final OfByte C_CHAR = ValueLayout.JAVA_BYTE;
    public static final OfShort C_SHORT = ValueLayout.JAVA_SHORT;
    public static final OfInt C_INT = ValueLayout.JAVA_INT;
    public static final OfLong C_LONG_LONG = ValueLayout.JAVA_LONG;
    public static final OfFloat C_FLOAT = ValueLayout.JAVA_FLOAT;
    public static final OfDouble C_DOUBLE = ValueLayout.JAVA_DOUBLE;
    public static final AddressLayout C_POINTER = ValueLayout.ADDRESS
            .withTargetLayout(MemoryLayout.sequenceLayout(Long.MAX_VALUE, JAVA_BYTE));
    public static final OfLong C_LONG = ValueLayout.JAVA_LONG;
    private static final int _DEFAULT_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _DEFAULT_SOURCE 1
     * }
     */
    public static int _DEFAULT_SOURCE() {
        return _DEFAULT_SOURCE;
    }
    private static final int _STDIO_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDIO_H 1
     * }
     */
    public static int _STDIO_H() {
        return _STDIO_H;
    }
    private static final int _FEATURES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _FEATURES_H 1
     * }
     */
    public static int _FEATURES_H() {
        return _FEATURES_H;
    }
    private static final int __GLIBC_USE_ISOC2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_ISOC2X 0
     * }
     */
    public static int __GLIBC_USE_ISOC2X() {
        return __GLIBC_USE_ISOC2X;
    }
    private static final int __USE_ISOC11 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC11 1
     * }
     */
    public static int __USE_ISOC11() {
        return __USE_ISOC11;
    }
    private static final int __USE_ISOC99 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC99 1
     * }
     */
    public static int __USE_ISOC99() {
        return __USE_ISOC99;
    }
    private static final int __USE_ISOC95 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ISOC95 1
     * }
     */
    public static int __USE_ISOC95() {
        return __USE_ISOC95;
    }
    private static final int __USE_POSIX_IMPLICITLY = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX_IMPLICITLY 1
     * }
     */
    public static int __USE_POSIX_IMPLICITLY() {
        return __USE_POSIX_IMPLICITLY;
    }
    private static final int _POSIX_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SOURCE 1
     * }
     */
    public static int _POSIX_SOURCE() {
        return _POSIX_SOURCE;
    }
    private static final int __USE_POSIX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX 1
     * }
     */
    public static int __USE_POSIX() {
        return __USE_POSIX;
    }
    private static final int __USE_POSIX2 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX2 1
     * }
     */
    public static int __USE_POSIX2() {
        return __USE_POSIX2;
    }
    private static final int __USE_POSIX199309 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199309 1
     * }
     */
    public static int __USE_POSIX199309() {
        return __USE_POSIX199309;
    }
    private static final int __USE_POSIX199506 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_POSIX199506 1
     * }
     */
    public static int __USE_POSIX199506() {
        return __USE_POSIX199506;
    }
    private static final int __USE_XOPEN2K = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K 1
     * }
     */
    public static int __USE_XOPEN2K() {
        return __USE_XOPEN2K;
    }
    private static final int __USE_XOPEN2K8 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_XOPEN2K8 1
     * }
     */
    public static int __USE_XOPEN2K8() {
        return __USE_XOPEN2K8;
    }
    private static final int _ATFILE_SOURCE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ATFILE_SOURCE 1
     * }
     */
    public static int _ATFILE_SOURCE() {
        return _ATFILE_SOURCE;
    }
    private static final int __WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE 64
     * }
     */
    public static int __WORDSIZE() {
        return __WORDSIZE;
    }
    private static final int __WORDSIZE_TIME64_COMPAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __WORDSIZE_TIME64_COMPAT32 1
     * }
     */
    public static int __WORDSIZE_TIME64_COMPAT32() {
        return __WORDSIZE_TIME64_COMPAT32;
    }
    private static final int __SYSCALL_WORDSIZE = (int)64L;
    /**
     * {@snippet lang=c :
     * #define __SYSCALL_WORDSIZE 64
     * }
     */
    public static int __SYSCALL_WORDSIZE() {
        return __SYSCALL_WORDSIZE;
    }
    private static final int __USE_MISC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_MISC 1
     * }
     */
    public static int __USE_MISC() {
        return __USE_MISC;
    }
    private static final int __USE_ATFILE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __USE_ATFILE 1
     * }
     */
    public static int __USE_ATFILE() {
        return __USE_ATFILE;
    }
    private static final int __USE_FORTIFY_LEVEL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __USE_FORTIFY_LEVEL 0
     * }
     */
    public static int __USE_FORTIFY_LEVEL() {
        return __USE_FORTIFY_LEVEL;
    }
    private static final int __GLIBC_USE_DEPRECATED_GETS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_GETS 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_GETS() {
        return __GLIBC_USE_DEPRECATED_GETS;
    }
    private static final int __GLIBC_USE_DEPRECATED_SCANF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_DEPRECATED_SCANF 0
     * }
     */
    public static int __GLIBC_USE_DEPRECATED_SCANF() {
        return __GLIBC_USE_DEPRECATED_SCANF;
    }
    private static final int __GLIBC_USE_C2X_STRTOL = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_C2X_STRTOL 0
     * }
     */
    public static int __GLIBC_USE_C2X_STRTOL() {
        return __GLIBC_USE_C2X_STRTOL;
    }
    private static final int _STDC_PREDEF_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDC_PREDEF_H 1
     * }
     */
    public static int _STDC_PREDEF_H() {
        return _STDC_PREDEF_H;
    }
    private static final int __STDC_IEC_559__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559__ 1
     * }
     */
    public static int __STDC_IEC_559__() {
        return __STDC_IEC_559__;
    }
    private static final int __STDC_IEC_559_COMPLEX__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STDC_IEC_559_COMPLEX__ 1
     * }
     */
    public static int __STDC_IEC_559_COMPLEX__() {
        return __STDC_IEC_559_COMPLEX__;
    }
    private static final int __GNU_LIBRARY__ = (int)6L;
    /**
     * {@snippet lang=c :
     * #define __GNU_LIBRARY__ 6
     * }
     */
    public static int __GNU_LIBRARY__() {
        return __GNU_LIBRARY__;
    }
    private static final int __GLIBC__ = (int)2L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC__ 2
     * }
     */
    public static int __GLIBC__() {
        return __GLIBC__;
    }
    private static final int __GLIBC_MINOR__ = (int)39L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_MINOR__ 39
     * }
     */
    public static int __GLIBC_MINOR__() {
        return __GLIBC_MINOR__;
    }
    private static final int _SYS_CDEFS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_CDEFS_H 1
     * }
     */
    public static int _SYS_CDEFS_H() {
        return _SYS_CDEFS_H;
    }
    private static final int __glibc_c99_flexarr_available = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __glibc_c99_flexarr_available 1
     * }
     */
    public static int __glibc_c99_flexarr_available() {
        return __glibc_c99_flexarr_available;
    }
    private static final int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI 0
     * }
     */
    public static int __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI() {
        return __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI;
    }
    private static final int __HAVE_GENERIC_SELECTION = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_GENERIC_SELECTION 1
     * }
     */
    public static int __HAVE_GENERIC_SELECTION() {
        return __HAVE_GENERIC_SELECTION;
    }
    private static final int __GLIBC_USE_LIB_EXT2 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_LIB_EXT2 0
     * }
     */
    public static int __GLIBC_USE_LIB_EXT2() {
        return __GLIBC_USE_LIB_EXT2;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT() {
        return __GLIBC_USE_IEC_60559_BFP_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_BFP_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_BFP_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_BFP_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_BFP_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_EXT() {
        return __GLIBC_USE_IEC_60559_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT;
    }
    private static final int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X() {
        return __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X;
    }
    private static final int __GLIBC_USE_IEC_60559_TYPES_EXT = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __GLIBC_USE_IEC_60559_TYPES_EXT 0
     * }
     */
    public static int __GLIBC_USE_IEC_60559_TYPES_EXT() {
        return __GLIBC_USE_IEC_60559_TYPES_EXT;
    }
    private static final int __GNUC_VA_LIST = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __GNUC_VA_LIST 1
     * }
     */
    public static int __GNUC_VA_LIST() {
        return __GNUC_VA_LIST;
    }
    private static final int _BITS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_H 1
     * }
     */
    public static int _BITS_TYPES_H() {
        return _BITS_TYPES_H;
    }
    private static final int _BITS_TYPESIZES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPESIZES_H 1
     * }
     */
    public static int _BITS_TYPESIZES_H() {
        return _BITS_TYPESIZES_H;
    }
    private static final int __OFF_T_MATCHES_OFF64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __OFF_T_MATCHES_OFF64_T 1
     * }
     */
    public static int __OFF_T_MATCHES_OFF64_T() {
        return __OFF_T_MATCHES_OFF64_T;
    }
    private static final int __INO_T_MATCHES_INO64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __INO_T_MATCHES_INO64_T 1
     * }
     */
    public static int __INO_T_MATCHES_INO64_T() {
        return __INO_T_MATCHES_INO64_T;
    }
    private static final int __RLIM_T_MATCHES_RLIM64_T = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __RLIM_T_MATCHES_RLIM64_T 1
     * }
     */
    public static int __RLIM_T_MATCHES_RLIM64_T() {
        return __RLIM_T_MATCHES_RLIM64_T;
    }
    private static final int __STATFS_MATCHES_STATFS64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __STATFS_MATCHES_STATFS64 1
     * }
     */
    public static int __STATFS_MATCHES_STATFS64() {
        return __STATFS_MATCHES_STATFS64;
    }
    private static final int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64 1
     * }
     */
    public static int __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64() {
        return __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64;
    }
    private static final int __FD_SETSIZE = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define __FD_SETSIZE 1024
     * }
     */
    public static int __FD_SETSIZE() {
        return __FD_SETSIZE;
    }
    private static final int _BITS_TIME64_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TIME64_H 1
     * }
     */
    public static int _BITS_TIME64_H() {
        return _BITS_TIME64_H;
    }
    private static final int _____fpos_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos_t_defined 1
     * }
     */
    public static int _____fpos_t_defined() {
        return _____fpos_t_defined;
    }
    private static final int ____mbstate_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____mbstate_t_defined 1
     * }
     */
    public static int ____mbstate_t_defined() {
        return ____mbstate_t_defined;
    }
    private static final int _____fpos64_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _____fpos64_t_defined 1
     * }
     */
    public static int _____fpos64_t_defined() {
        return _____fpos64_t_defined;
    }
    private static final int ____FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____FILE_defined 1
     * }
     */
    public static int ____FILE_defined() {
        return ____FILE_defined;
    }
    private static final int __FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __FILE_defined 1
     * }
     */
    public static int __FILE_defined() {
        return __FILE_defined;
    }
    private static final int __struct_FILE_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __struct_FILE_defined 1
     * }
     */
    public static int __struct_FILE_defined() {
        return __struct_FILE_defined;
    }
    private static final int _IO_EOF_SEEN = (int)16L;
    /**
     * {@snippet lang=c :
     * #define _IO_EOF_SEEN 16
     * }
     */
    public static int _IO_EOF_SEEN() {
        return _IO_EOF_SEEN;
    }
    private static final int _IO_ERR_SEEN = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _IO_ERR_SEEN 32
     * }
     */
    public static int _IO_ERR_SEEN() {
        return _IO_ERR_SEEN;
    }
    private static final int _IO_USER_LOCK = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define _IO_USER_LOCK 32768
     * }
     */
    public static int _IO_USER_LOCK() {
        return _IO_USER_LOCK;
    }
    private static final int __cookie_io_functions_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __cookie_io_functions_t_defined 1
     * }
     */
    public static int __cookie_io_functions_t_defined() {
        return __cookie_io_functions_t_defined;
    }
    private static final int _IOFBF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define _IOFBF 0
     * }
     */
    public static int _IOFBF() {
        return _IOFBF;
    }
    private static final int _IOLBF = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _IOLBF 1
     * }
     */
    public static int _IOLBF() {
        return _IOLBF;
    }
    private static final int _IONBF = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _IONBF 2
     * }
     */
    public static int _IONBF() {
        return _IONBF;
    }
    private static final int BUFSIZ = (int)8192L;
    /**
     * {@snippet lang=c :
     * #define BUFSIZ 8192
     * }
     */
    public static int BUFSIZ() {
        return BUFSIZ;
    }
    private static final int SEEK_SET = (int)0L;
    /**
     * {@snippet lang=c :
     * #define SEEK_SET 0
     * }
     */
    public static int SEEK_SET() {
        return SEEK_SET;
    }
    private static final int SEEK_CUR = (int)1L;
    /**
     * {@snippet lang=c :
     * #define SEEK_CUR 1
     * }
     */
    public static int SEEK_CUR() {
        return SEEK_CUR;
    }
    private static final int SEEK_END = (int)2L;
    /**
     * {@snippet lang=c :
     * #define SEEK_END 2
     * }
     */
    public static int SEEK_END() {
        return SEEK_END;
    }
    private static final int L_tmpnam = (int)20L;
    /**
     * {@snippet lang=c :
     * #define L_tmpnam 20
     * }
     */
    public static int L_tmpnam() {
        return L_tmpnam;
    }
    private static final int TMP_MAX = (int)238328L;
    /**
     * {@snippet lang=c :
     * #define TMP_MAX 238328
     * }
     */
    public static int TMP_MAX() {
        return TMP_MAX;
    }
    private static final int _BITS_STDIO_LIM_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDIO_LIM_H 1
     * }
     */
    public static int _BITS_STDIO_LIM_H() {
        return _BITS_STDIO_LIM_H;
    }
    private static final int FILENAME_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define FILENAME_MAX 4096
     * }
     */
    public static int FILENAME_MAX() {
        return FILENAME_MAX;
    }
    private static final int L_ctermid = (int)9L;
    /**
     * {@snippet lang=c :
     * #define L_ctermid 9
     * }
     */
    public static int L_ctermid() {
        return L_ctermid;
    }
    private static final int FOPEN_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define FOPEN_MAX 16
     * }
     */
    public static int FOPEN_MAX() {
        return FOPEN_MAX;
    }
    private static final int __HAVE_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128 0
     * }
     */
    public static int __HAVE_FLOAT128() {
        return __HAVE_FLOAT128;
    }
    private static final int __HAVE_DISTINCT_FLOAT128 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT128 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT128() {
        return __HAVE_DISTINCT_FLOAT128;
    }
    private static final int __HAVE_FLOAT64X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X 1
     * }
     */
    public static int __HAVE_FLOAT64X() {
        return __HAVE_FLOAT64X;
    }
    private static final int __HAVE_FLOAT64X_LONG_DOUBLE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64X_LONG_DOUBLE 1
     * }
     */
    public static int __HAVE_FLOAT64X_LONG_DOUBLE() {
        return __HAVE_FLOAT64X_LONG_DOUBLE;
    }
    private static final int __HAVE_FLOAT16 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT16 0
     * }
     */
    public static int __HAVE_FLOAT16() {
        return __HAVE_FLOAT16;
    }
    private static final int __HAVE_FLOAT32 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32 1
     * }
     */
    public static int __HAVE_FLOAT32() {
        return __HAVE_FLOAT32;
    }
    private static final int __HAVE_FLOAT64 = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT64 1
     * }
     */
    public static int __HAVE_FLOAT64() {
        return __HAVE_FLOAT64;
    }
    private static final int __HAVE_FLOAT32X = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT32X 1
     * }
     */
    public static int __HAVE_FLOAT32X() {
        return __HAVE_FLOAT32X;
    }
    private static final int __HAVE_FLOAT128X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOAT128X 0
     * }
     */
    public static int __HAVE_FLOAT128X() {
        return __HAVE_FLOAT128X;
    }
    private static final int __HAVE_DISTINCT_FLOAT32 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32() {
        return __HAVE_DISTINCT_FLOAT32;
    }
    private static final int __HAVE_DISTINCT_FLOAT64 = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64() {
        return __HAVE_DISTINCT_FLOAT64;
    }
    private static final int __HAVE_DISTINCT_FLOAT32X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT32X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT32X() {
        return __HAVE_DISTINCT_FLOAT32X;
    }
    private static final int __HAVE_DISTINCT_FLOAT64X = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_DISTINCT_FLOAT64X 0
     * }
     */
    public static int __HAVE_DISTINCT_FLOAT64X() {
        return __HAVE_DISTINCT_FLOAT64X;
    }
    private static final int __HAVE_FLOATN_NOT_TYPEDEF = (int)0L;
    /**
     * {@snippet lang=c :
     * #define __HAVE_FLOATN_NOT_TYPEDEF 0
     * }
     */
    public static int __HAVE_FLOATN_NOT_TYPEDEF() {
        return __HAVE_FLOATN_NOT_TYPEDEF;
    }
    private static final int _STDLIB_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDLIB_H 1
     * }
     */
    public static int _STDLIB_H() {
        return _STDLIB_H;
    }
    private static final int WNOHANG = (int)1L;
    /**
     * {@snippet lang=c :
     * #define WNOHANG 1
     * }
     */
    public static int WNOHANG() {
        return WNOHANG;
    }
    private static final int WUNTRACED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WUNTRACED 2
     * }
     */
    public static int WUNTRACED() {
        return WUNTRACED;
    }
    private static final int WSTOPPED = (int)2L;
    /**
     * {@snippet lang=c :
     * #define WSTOPPED 2
     * }
     */
    public static int WSTOPPED() {
        return WSTOPPED;
    }
    private static final int WEXITED = (int)4L;
    /**
     * {@snippet lang=c :
     * #define WEXITED 4
     * }
     */
    public static int WEXITED() {
        return WEXITED;
    }
    private static final int WCONTINUED = (int)8L;
    /**
     * {@snippet lang=c :
     * #define WCONTINUED 8
     * }
     */
    public static int WCONTINUED() {
        return WCONTINUED;
    }
    private static final int WNOWAIT = (int)16777216L;
    /**
     * {@snippet lang=c :
     * #define WNOWAIT 16777216
     * }
     */
    public static int WNOWAIT() {
        return WNOWAIT;
    }
    private static final int __WNOTHREAD = (int)536870912L;
    /**
     * {@snippet lang=c :
     * #define __WNOTHREAD 536870912
     * }
     */
    public static int __WNOTHREAD() {
        return __WNOTHREAD;
    }
    private static final int __WALL = (int)1073741824L;
    /**
     * {@snippet lang=c :
     * #define __WALL 1073741824
     * }
     */
    public static int __WALL() {
        return __WALL;
    }
    private static final int __W_CONTINUED = (int)65535L;
    /**
     * {@snippet lang=c :
     * #define __W_CONTINUED 65535
     * }
     */
    public static int __W_CONTINUED() {
        return __W_CONTINUED;
    }
    private static final int __WCOREFLAG = (int)128L;
    /**
     * {@snippet lang=c :
     * #define __WCOREFLAG 128
     * }
     */
    public static int __WCOREFLAG() {
        return __WCOREFLAG;
    }
    private static final int __ldiv_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __ldiv_t_defined 1
     * }
     */
    public static int __ldiv_t_defined() {
        return __ldiv_t_defined;
    }
    private static final int __lldiv_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __lldiv_t_defined 1
     * }
     */
    public static int __lldiv_t_defined() {
        return __lldiv_t_defined;
    }
    private static final int RAND_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define RAND_MAX 2147483647
     * }
     */
    public static int RAND_MAX() {
        return RAND_MAX;
    }
    private static final int EXIT_FAILURE = (int)1L;
    /**
     * {@snippet lang=c :
     * #define EXIT_FAILURE 1
     * }
     */
    public static int EXIT_FAILURE() {
        return EXIT_FAILURE;
    }
    private static final int EXIT_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * #define EXIT_SUCCESS 0
     * }
     */
    public static int EXIT_SUCCESS() {
        return EXIT_SUCCESS;
    }
    private static final int _SYS_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_TYPES_H 1
     * }
     */
    public static int _SYS_TYPES_H() {
        return _SYS_TYPES_H;
    }
    private static final int __clock_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clock_t_defined 1
     * }
     */
    public static int __clock_t_defined() {
        return __clock_t_defined;
    }
    private static final int __clockid_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __clockid_t_defined 1
     * }
     */
    public static int __clockid_t_defined() {
        return __clockid_t_defined;
    }
    private static final int __time_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __time_t_defined 1
     * }
     */
    public static int __time_t_defined() {
        return __time_t_defined;
    }
    private static final int __timer_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timer_t_defined 1
     * }
     */
    public static int __timer_t_defined() {
        return __timer_t_defined;
    }
    private static final int _BITS_STDINT_INTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_INTN_H 1
     * }
     */
    public static int _BITS_STDINT_INTN_H() {
        return _BITS_STDINT_INTN_H;
    }
    private static final int __BIT_TYPES_DEFINED__ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __BIT_TYPES_DEFINED__ 1
     * }
     */
    public static int __BIT_TYPES_DEFINED__() {
        return __BIT_TYPES_DEFINED__;
    }
    private static final int _ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ENDIAN_H 1
     * }
     */
    public static int _ENDIAN_H() {
        return _ENDIAN_H;
    }
    private static final int _BITS_ENDIAN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIAN_H 1
     * }
     */
    public static int _BITS_ENDIAN_H() {
        return _BITS_ENDIAN_H;
    }
    private static final int __LITTLE_ENDIAN = (int)1234L;
    /**
     * {@snippet lang=c :
     * #define __LITTLE_ENDIAN 1234
     * }
     */
    public static int __LITTLE_ENDIAN() {
        return __LITTLE_ENDIAN;
    }
    private static final int __BIG_ENDIAN = (int)4321L;
    /**
     * {@snippet lang=c :
     * #define __BIG_ENDIAN 4321
     * }
     */
    public static int __BIG_ENDIAN() {
        return __BIG_ENDIAN;
    }
    private static final int __PDP_ENDIAN = (int)3412L;
    /**
     * {@snippet lang=c :
     * #define __PDP_ENDIAN 3412
     * }
     */
    public static int __PDP_ENDIAN() {
        return __PDP_ENDIAN;
    }
    private static final int _BITS_ENDIANNESS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_ENDIANNESS_H 1
     * }
     */
    public static int _BITS_ENDIANNESS_H() {
        return _BITS_ENDIANNESS_H;
    }
    private static final int _BITS_BYTESWAP_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_BYTESWAP_H 1
     * }
     */
    public static int _BITS_BYTESWAP_H() {
        return _BITS_BYTESWAP_H;
    }
    private static final int _BITS_UINTN_IDENTITY_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_UINTN_IDENTITY_H 1
     * }
     */
    public static int _BITS_UINTN_IDENTITY_H() {
        return _BITS_UINTN_IDENTITY_H;
    }
    private static final int _SYS_SELECT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _SYS_SELECT_H 1
     * }
     */
    public static int _SYS_SELECT_H() {
        return _SYS_SELECT_H;
    }
    private static final int __sigset_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __sigset_t_defined 1
     * }
     */
    public static int __sigset_t_defined() {
        return __sigset_t_defined;
    }
    private static final int __timeval_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __timeval_defined 1
     * }
     */
    public static int __timeval_defined() {
        return __timeval_defined;
    }
    private static final int _STRUCT_TIMESPEC = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRUCT_TIMESPEC 1
     * }
     */
    public static int _STRUCT_TIMESPEC() {
        return _STRUCT_TIMESPEC;
    }
    private static final int _BITS_PTHREADTYPES_COMMON_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_COMMON_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_COMMON_H() {
        return _BITS_PTHREADTYPES_COMMON_H;
    }
    private static final int _THREAD_SHARED_TYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_SHARED_TYPES_H 1
     * }
     */
    public static int _THREAD_SHARED_TYPES_H() {
        return _THREAD_SHARED_TYPES_H;
    }
    private static final int _BITS_PTHREADTYPES_ARCH_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_PTHREADTYPES_ARCH_H 1
     * }
     */
    public static int _BITS_PTHREADTYPES_ARCH_H() {
        return _BITS_PTHREADTYPES_ARCH_H;
    }
    private static final int __SIZEOF_PTHREAD_MUTEX_T = (int)40L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEX_T 40
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEX_T() {
        return __SIZEOF_PTHREAD_MUTEX_T;
    }
    private static final int __SIZEOF_PTHREAD_ATTR_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_ATTR_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_ATTR_T() {
        return __SIZEOF_PTHREAD_ATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCK_T = (int)56L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCK_T 56
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCK_T() {
        return __SIZEOF_PTHREAD_RWLOCK_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIER_T = (int)32L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIER_T 32
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIER_T() {
        return __SIZEOF_PTHREAD_BARRIER_T;
    }
    private static final int __SIZEOF_PTHREAD_MUTEXATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_MUTEXATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_MUTEXATTR_T() {
        return __SIZEOF_PTHREAD_MUTEXATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_COND_T = (int)48L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_COND_T 48
     * }
     */
    public static int __SIZEOF_PTHREAD_COND_T() {
        return __SIZEOF_PTHREAD_COND_T;
    }
    private static final int __SIZEOF_PTHREAD_CONDATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_CONDATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_CONDATTR_T() {
        return __SIZEOF_PTHREAD_CONDATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_RWLOCKATTR_T = (int)8L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
     * }
     */
    public static int __SIZEOF_PTHREAD_RWLOCKATTR_T() {
        return __SIZEOF_PTHREAD_RWLOCKATTR_T;
    }
    private static final int __SIZEOF_PTHREAD_BARRIERATTR_T = (int)4L;
    /**
     * {@snippet lang=c :
     * #define __SIZEOF_PTHREAD_BARRIERATTR_T 4
     * }
     */
    public static int __SIZEOF_PTHREAD_BARRIERATTR_T() {
        return __SIZEOF_PTHREAD_BARRIERATTR_T;
    }
    private static final int _THREAD_MUTEX_INTERNAL_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _THREAD_MUTEX_INTERNAL_H 1
     * }
     */
    public static int _THREAD_MUTEX_INTERNAL_H() {
        return _THREAD_MUTEX_INTERNAL_H;
    }
    private static final int __PTHREAD_MUTEX_HAVE_PREV = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __PTHREAD_MUTEX_HAVE_PREV 1
     * }
     */
    public static int __PTHREAD_MUTEX_HAVE_PREV() {
        return __PTHREAD_MUTEX_HAVE_PREV;
    }
    private static final int __have_pthread_attr_t = (int)1L;
    /**
     * {@snippet lang=c :
     * #define __have_pthread_attr_t 1
     * }
     */
    public static int __have_pthread_attr_t() {
        return __have_pthread_attr_t;
    }
    private static final int _ALLOCA_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ALLOCA_H 1
     * }
     */
    public static int _ALLOCA_H() {
        return _ALLOCA_H;
    }
    private static final int _STRING_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRING_H 1
     * }
     */
    public static int _STRING_H() {
        return _STRING_H;
    }
    private static final int _BITS_TYPES_LOCALE_T_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES_LOCALE_T_H 1
     * }
     */
    public static int _BITS_TYPES_LOCALE_T_H() {
        return _BITS_TYPES_LOCALE_T_H;
    }
    private static final int _BITS_TYPES___LOCALE_T_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_TYPES___LOCALE_T_H 1
     * }
     */
    public static int _BITS_TYPES___LOCALE_T_H() {
        return _BITS_TYPES___LOCALE_T_H;
    }
    private static final int _STRINGS_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STRINGS_H 1
     * }
     */
    public static int _STRINGS_H() {
        return _STRINGS_H;
    }
    private static final int _LIBC_LIMITS_H_ = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _LIBC_LIMITS_H_ 1
     * }
     */
    public static int _LIBC_LIMITS_H_() {
        return _LIBC_LIMITS_H_;
    }
    private static final int MB_LEN_MAX = (int)16L;
    /**
     * {@snippet lang=c :
     * #define MB_LEN_MAX 16
     * }
     */
    public static int MB_LEN_MAX() {
        return MB_LEN_MAX;
    }
    private static final int _BITS_POSIX1_LIM_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_POSIX1_LIM_H 1
     * }
     */
    public static int _BITS_POSIX1_LIM_H() {
        return _BITS_POSIX1_LIM_H;
    }
    private static final int _POSIX_AIO_LISTIO_MAX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_AIO_LISTIO_MAX 2
     * }
     */
    public static int _POSIX_AIO_LISTIO_MAX() {
        return _POSIX_AIO_LISTIO_MAX;
    }
    private static final int _POSIX_AIO_MAX = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_AIO_MAX 1
     * }
     */
    public static int _POSIX_AIO_MAX() {
        return _POSIX_AIO_MAX;
    }
    private static final int _POSIX_ARG_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_ARG_MAX 4096
     * }
     */
    public static int _POSIX_ARG_MAX() {
        return _POSIX_ARG_MAX;
    }
    private static final int _POSIX_CHILD_MAX = (int)25L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_CHILD_MAX 25
     * }
     */
    public static int _POSIX_CHILD_MAX() {
        return _POSIX_CHILD_MAX;
    }
    private static final int _POSIX_DELAYTIMER_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_DELAYTIMER_MAX 32
     * }
     */
    public static int _POSIX_DELAYTIMER_MAX() {
        return _POSIX_DELAYTIMER_MAX;
    }
    private static final int _POSIX_HOST_NAME_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_HOST_NAME_MAX 255
     * }
     */
    public static int _POSIX_HOST_NAME_MAX() {
        return _POSIX_HOST_NAME_MAX;
    }
    private static final int _POSIX_LINK_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_LINK_MAX 8
     * }
     */
    public static int _POSIX_LINK_MAX() {
        return _POSIX_LINK_MAX;
    }
    private static final int _POSIX_LOGIN_NAME_MAX = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_LOGIN_NAME_MAX 9
     * }
     */
    public static int _POSIX_LOGIN_NAME_MAX() {
        return _POSIX_LOGIN_NAME_MAX;
    }
    private static final int _POSIX_MAX_CANON = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MAX_CANON 255
     * }
     */
    public static int _POSIX_MAX_CANON() {
        return _POSIX_MAX_CANON;
    }
    private static final int _POSIX_MAX_INPUT = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MAX_INPUT 255
     * }
     */
    public static int _POSIX_MAX_INPUT() {
        return _POSIX_MAX_INPUT;
    }
    private static final int _POSIX_MQ_OPEN_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MQ_OPEN_MAX 8
     * }
     */
    public static int _POSIX_MQ_OPEN_MAX() {
        return _POSIX_MQ_OPEN_MAX;
    }
    private static final int _POSIX_MQ_PRIO_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_MQ_PRIO_MAX 32
     * }
     */
    public static int _POSIX_MQ_PRIO_MAX() {
        return _POSIX_MQ_PRIO_MAX;
    }
    private static final int _POSIX_NAME_MAX = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_NAME_MAX 14
     * }
     */
    public static int _POSIX_NAME_MAX() {
        return _POSIX_NAME_MAX;
    }
    private static final int _POSIX_NGROUPS_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_NGROUPS_MAX 8
     * }
     */
    public static int _POSIX_NGROUPS_MAX() {
        return _POSIX_NGROUPS_MAX;
    }
    private static final int _POSIX_OPEN_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_OPEN_MAX 20
     * }
     */
    public static int _POSIX_OPEN_MAX() {
        return _POSIX_OPEN_MAX;
    }
    private static final int _POSIX_PATH_MAX = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_PATH_MAX 256
     * }
     */
    public static int _POSIX_PATH_MAX() {
        return _POSIX_PATH_MAX;
    }
    private static final int _POSIX_PIPE_BUF = (int)512L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_PIPE_BUF 512
     * }
     */
    public static int _POSIX_PIPE_BUF() {
        return _POSIX_PIPE_BUF;
    }
    private static final int _POSIX_RE_DUP_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_RE_DUP_MAX 255
     * }
     */
    public static int _POSIX_RE_DUP_MAX() {
        return _POSIX_RE_DUP_MAX;
    }
    private static final int _POSIX_RTSIG_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_RTSIG_MAX 8
     * }
     */
    public static int _POSIX_RTSIG_MAX() {
        return _POSIX_RTSIG_MAX;
    }
    private static final int _POSIX_SEM_NSEMS_MAX = (int)256L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SEM_NSEMS_MAX 256
     * }
     */
    public static int _POSIX_SEM_NSEMS_MAX() {
        return _POSIX_SEM_NSEMS_MAX;
    }
    private static final int _POSIX_SEM_VALUE_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SEM_VALUE_MAX 32767
     * }
     */
    public static int _POSIX_SEM_VALUE_MAX() {
        return _POSIX_SEM_VALUE_MAX;
    }
    private static final int _POSIX_SIGQUEUE_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SIGQUEUE_MAX 32
     * }
     */
    public static int _POSIX_SIGQUEUE_MAX() {
        return _POSIX_SIGQUEUE_MAX;
    }
    private static final int _POSIX_SSIZE_MAX = (int)32767L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SSIZE_MAX 32767
     * }
     */
    public static int _POSIX_SSIZE_MAX() {
        return _POSIX_SSIZE_MAX;
    }
    private static final int _POSIX_STREAM_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_STREAM_MAX 8
     * }
     */
    public static int _POSIX_STREAM_MAX() {
        return _POSIX_STREAM_MAX;
    }
    private static final int _POSIX_SYMLINK_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SYMLINK_MAX 255
     * }
     */
    public static int _POSIX_SYMLINK_MAX() {
        return _POSIX_SYMLINK_MAX;
    }
    private static final int _POSIX_SYMLOOP_MAX = (int)8L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_SYMLOOP_MAX 8
     * }
     */
    public static int _POSIX_SYMLOOP_MAX() {
        return _POSIX_SYMLOOP_MAX;
    }
    private static final int _POSIX_TIMER_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TIMER_MAX 32
     * }
     */
    public static int _POSIX_TIMER_MAX() {
        return _POSIX_TIMER_MAX;
    }
    private static final int _POSIX_TTY_NAME_MAX = (int)9L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TTY_NAME_MAX 9
     * }
     */
    public static int _POSIX_TTY_NAME_MAX() {
        return _POSIX_TTY_NAME_MAX;
    }
    private static final int _POSIX_TZNAME_MAX = (int)6L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_TZNAME_MAX 6
     * }
     */
    public static int _POSIX_TZNAME_MAX() {
        return _POSIX_TZNAME_MAX;
    }
    private static final int _POSIX_CLOCKRES_MIN = (int)20000000L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_CLOCKRES_MIN 20000000
     * }
     */
    public static int _POSIX_CLOCKRES_MIN() {
        return _POSIX_CLOCKRES_MIN;
    }
    private static final int NR_OPEN = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define NR_OPEN 1024
     * }
     */
    public static int NR_OPEN() {
        return NR_OPEN;
    }
    private static final int NGROUPS_MAX = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define NGROUPS_MAX 65536
     * }
     */
    public static int NGROUPS_MAX() {
        return NGROUPS_MAX;
    }
    private static final int ARG_MAX = (int)131072L;
    /**
     * {@snippet lang=c :
     * #define ARG_MAX 131072
     * }
     */
    public static int ARG_MAX() {
        return ARG_MAX;
    }
    private static final int LINK_MAX = (int)127L;
    /**
     * {@snippet lang=c :
     * #define LINK_MAX 127
     * }
     */
    public static int LINK_MAX() {
        return LINK_MAX;
    }
    private static final int MAX_CANON = (int)255L;
    /**
     * {@snippet lang=c :
     * #define MAX_CANON 255
     * }
     */
    public static int MAX_CANON() {
        return MAX_CANON;
    }
    private static final int MAX_INPUT = (int)255L;
    /**
     * {@snippet lang=c :
     * #define MAX_INPUT 255
     * }
     */
    public static int MAX_INPUT() {
        return MAX_INPUT;
    }
    private static final int NAME_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define NAME_MAX 255
     * }
     */
    public static int NAME_MAX() {
        return NAME_MAX;
    }
    private static final int PATH_MAX = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define PATH_MAX 4096
     * }
     */
    public static int PATH_MAX() {
        return PATH_MAX;
    }
    private static final int PIPE_BUF = (int)4096L;
    /**
     * {@snippet lang=c :
     * #define PIPE_BUF 4096
     * }
     */
    public static int PIPE_BUF() {
        return PIPE_BUF;
    }
    private static final int XATTR_NAME_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define XATTR_NAME_MAX 255
     * }
     */
    public static int XATTR_NAME_MAX() {
        return XATTR_NAME_MAX;
    }
    private static final int XATTR_SIZE_MAX = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define XATTR_SIZE_MAX 65536
     * }
     */
    public static int XATTR_SIZE_MAX() {
        return XATTR_SIZE_MAX;
    }
    private static final int XATTR_LIST_MAX = (int)65536L;
    /**
     * {@snippet lang=c :
     * #define XATTR_LIST_MAX 65536
     * }
     */
    public static int XATTR_LIST_MAX() {
        return XATTR_LIST_MAX;
    }
    private static final int RTSIG_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define RTSIG_MAX 32
     * }
     */
    public static int RTSIG_MAX() {
        return RTSIG_MAX;
    }
    private static final int _POSIX_THREAD_KEYS_MAX = (int)128L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_KEYS_MAX 128
     * }
     */
    public static int _POSIX_THREAD_KEYS_MAX() {
        return _POSIX_THREAD_KEYS_MAX;
    }
    private static final int PTHREAD_KEYS_MAX = (int)1024L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_KEYS_MAX 1024
     * }
     */
    public static int PTHREAD_KEYS_MAX() {
        return PTHREAD_KEYS_MAX;
    }
    private static final int _POSIX_THREAD_DESTRUCTOR_ITERATIONS = (int)4L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_DESTRUCTOR_ITERATIONS 4
     * }
     */
    public static int _POSIX_THREAD_DESTRUCTOR_ITERATIONS() {
        return _POSIX_THREAD_DESTRUCTOR_ITERATIONS;
    }
    private static final int _POSIX_THREAD_THREADS_MAX = (int)64L;
    /**
     * {@snippet lang=c :
     * #define _POSIX_THREAD_THREADS_MAX 64
     * }
     */
    public static int _POSIX_THREAD_THREADS_MAX() {
        return _POSIX_THREAD_THREADS_MAX;
    }
    private static final int AIO_PRIO_DELTA_MAX = (int)20L;
    /**
     * {@snippet lang=c :
     * #define AIO_PRIO_DELTA_MAX 20
     * }
     */
    public static int AIO_PRIO_DELTA_MAX() {
        return AIO_PRIO_DELTA_MAX;
    }
    private static final int PTHREAD_STACK_MIN = (int)16384L;
    /**
     * {@snippet lang=c :
     * #define PTHREAD_STACK_MIN 16384
     * }
     */
    public static int PTHREAD_STACK_MIN() {
        return PTHREAD_STACK_MIN;
    }
    private static final int DELAYTIMER_MAX = (int)2147483647L;
    /**
     * {@snippet lang=c :
     * #define DELAYTIMER_MAX 2147483647
     * }
     */
    public static int DELAYTIMER_MAX() {
        return DELAYTIMER_MAX;
    }
    private static final int TTY_NAME_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define TTY_NAME_MAX 32
     * }
     */
    public static int TTY_NAME_MAX() {
        return TTY_NAME_MAX;
    }
    private static final int LOGIN_NAME_MAX = (int)256L;
    /**
     * {@snippet lang=c :
     * #define LOGIN_NAME_MAX 256
     * }
     */
    public static int LOGIN_NAME_MAX() {
        return LOGIN_NAME_MAX;
    }
    private static final int HOST_NAME_MAX = (int)64L;
    /**
     * {@snippet lang=c :
     * #define HOST_NAME_MAX 64
     * }
     */
    public static int HOST_NAME_MAX() {
        return HOST_NAME_MAX;
    }
    private static final int MQ_PRIO_MAX = (int)32768L;
    /**
     * {@snippet lang=c :
     * #define MQ_PRIO_MAX 32768
     * }
     */
    public static int MQ_PRIO_MAX() {
        return MQ_PRIO_MAX;
    }
    private static final int _BITS_POSIX2_LIM_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_POSIX2_LIM_H 1
     * }
     */
    public static int _BITS_POSIX2_LIM_H() {
        return _BITS_POSIX2_LIM_H;
    }
    private static final int _POSIX2_BC_BASE_MAX = (int)99L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_BASE_MAX 99
     * }
     */
    public static int _POSIX2_BC_BASE_MAX() {
        return _POSIX2_BC_BASE_MAX;
    }
    private static final int _POSIX2_BC_DIM_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_DIM_MAX 2048
     * }
     */
    public static int _POSIX2_BC_DIM_MAX() {
        return _POSIX2_BC_DIM_MAX;
    }
    private static final int _POSIX2_BC_SCALE_MAX = (int)99L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_SCALE_MAX 99
     * }
     */
    public static int _POSIX2_BC_SCALE_MAX() {
        return _POSIX2_BC_SCALE_MAX;
    }
    private static final int _POSIX2_BC_STRING_MAX = (int)1000L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_BC_STRING_MAX 1000
     * }
     */
    public static int _POSIX2_BC_STRING_MAX() {
        return _POSIX2_BC_STRING_MAX;
    }
    private static final int _POSIX2_COLL_WEIGHTS_MAX = (int)2L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_COLL_WEIGHTS_MAX 2
     * }
     */
    public static int _POSIX2_COLL_WEIGHTS_MAX() {
        return _POSIX2_COLL_WEIGHTS_MAX;
    }
    private static final int _POSIX2_EXPR_NEST_MAX = (int)32L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_EXPR_NEST_MAX 32
     * }
     */
    public static int _POSIX2_EXPR_NEST_MAX() {
        return _POSIX2_EXPR_NEST_MAX;
    }
    private static final int _POSIX2_LINE_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_LINE_MAX 2048
     * }
     */
    public static int _POSIX2_LINE_MAX() {
        return _POSIX2_LINE_MAX;
    }
    private static final int _POSIX2_RE_DUP_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_RE_DUP_MAX 255
     * }
     */
    public static int _POSIX2_RE_DUP_MAX() {
        return _POSIX2_RE_DUP_MAX;
    }
    private static final int _POSIX2_CHARCLASS_NAME_MAX = (int)14L;
    /**
     * {@snippet lang=c :
     * #define _POSIX2_CHARCLASS_NAME_MAX 14
     * }
     */
    public static int _POSIX2_CHARCLASS_NAME_MAX() {
        return _POSIX2_CHARCLASS_NAME_MAX;
    }
    private static final int COLL_WEIGHTS_MAX = (int)255L;
    /**
     * {@snippet lang=c :
     * #define COLL_WEIGHTS_MAX 255
     * }
     */
    public static int COLL_WEIGHTS_MAX() {
        return COLL_WEIGHTS_MAX;
    }
    private static final int CHARCLASS_NAME_MAX = (int)2048L;
    /**
     * {@snippet lang=c :
     * #define CHARCLASS_NAME_MAX 2048
     * }
     */
    public static int CHARCLASS_NAME_MAX() {
        return CHARCLASS_NAME_MAX;
    }
    private static final int _INTTYPES_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _INTTYPES_H 1
     * }
     */
    public static int _INTTYPES_H() {
        return _INTTYPES_H;
    }
    private static final int _STDINT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _STDINT_H 1
     * }
     */
    public static int _STDINT_H() {
        return _STDINT_H;
    }
    private static final int _BITS_WCHAR_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_WCHAR_H 1
     * }
     */
    public static int _BITS_WCHAR_H() {
        return _BITS_WCHAR_H;
    }
    private static final int _BITS_STDINT_UINTN_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_UINTN_H 1
     * }
     */
    public static int _BITS_STDINT_UINTN_H() {
        return _BITS_STDINT_UINTN_H;
    }
    private static final int _BITS_STDINT_LEAST_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _BITS_STDINT_LEAST_H 1
     * }
     */
    public static int _BITS_STDINT_LEAST_H() {
        return _BITS_STDINT_LEAST_H;
    }
    private static final int ____gwchar_t_defined = (int)1L;
    /**
     * {@snippet lang=c :
     * #define ____gwchar_t_defined 1
     * }
     */
    public static int ____gwchar_t_defined() {
        return ____gwchar_t_defined;
    }
    private static final int _ASSERT_H = (int)1L;
    /**
     * {@snippet lang=c :
     * #define _ASSERT_H 1
     * }
     */
    public static int _ASSERT_H() {
        return _ASSERT_H;
    }
    private static final int ASN1C_ENVIRONMENT_VERSION = (int)923L;
    /**
     * {@snippet lang=c :
     * #define ASN1C_ENVIRONMENT_VERSION 923
     * }
     */
    public static int ASN1C_ENVIRONMENT_VERSION() {
        return ASN1C_ENVIRONMENT_VERSION;
    }
    private static final int asn_debug_indent = (int)0L;
    /**
     * {@snippet lang=c :
     * #define asn_debug_indent 0
     * }
     */
    public static int asn_debug_indent() {
        return asn_debug_indent;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned long size_t
     * }
     */
    public static final OfLong size_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __u_char
     * }
     */
    public static final OfByte __u_char = MessageFrame_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __u_short
     * }
     */
    public static final OfShort __u_short = MessageFrame_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __u_int
     * }
     */
    public static final OfInt __u_int = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_long
     * }
     */
    public static final OfLong __u_long = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char __int8_t
     * }
     */
    public static final OfByte __int8_t = MessageFrame_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned char __uint8_t
     * }
     */
    public static final OfByte __uint8_t = MessageFrame_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef short __int16_t
     * }
     */
    public static final OfShort __int16_t = MessageFrame_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned short __uint16_t
     * }
     */
    public static final OfShort __uint16_t = MessageFrame_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef int __int32_t
     * }
     */
    public static final OfInt __int32_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uint32_t
     * }
     */
    public static final OfInt __uint32_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __int64_t
     * }
     */
    public static final OfLong __int64_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uint64_t
     * }
     */
    public static final OfLong __uint64_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int8_t __int_least8_t
     * }
     */
    public static final OfByte __int_least8_t = MessageFrame_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t __uint_least8_t
     * }
     */
    public static final OfByte __uint_least8_t = MessageFrame_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t __int_least16_t
     * }
     */
    public static final OfShort __int_least16_t = MessageFrame_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t __uint_least16_t
     * }
     */
    public static final OfShort __uint_least16_t = MessageFrame_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t __int_least32_t
     * }
     */
    public static final OfInt __int_least32_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t __uint_least32_t
     * }
     */
    public static final OfInt __uint_least32_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t __int_least64_t
     * }
     */
    public static final OfLong __int_least64_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t __uint_least64_t
     * }
     */
    public static final OfLong __uint_least64_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __quad_t
     * }
     */
    public static final OfLong __quad_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __u_quad_t
     * }
     */
    public static final OfLong __u_quad_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __intmax_t
     * }
     */
    public static final OfLong __intmax_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __uintmax_t
     * }
     */
    public static final OfLong __uintmax_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __dev_t
     * }
     */
    public static final OfLong __dev_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __uid_t
     * }
     */
    public static final OfInt __uid_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __gid_t
     * }
     */
    public static final OfInt __gid_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino_t
     * }
     */
    public static final OfLong __ino_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __ino64_t
     * }
     */
    public static final OfLong __ino64_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __mode_t
     * }
     */
    public static final OfInt __mode_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __nlink_t
     * }
     */
    public static final OfLong __nlink_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off_t
     * }
     */
    public static final OfLong __off_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __off64_t
     * }
     */
    public static final OfLong __off64_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __pid_t
     * }
     */
    public static final OfInt __pid_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __clock_t
     * }
     */
    public static final OfLong __clock_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim_t
     * }
     */
    public static final OfLong __rlim_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __rlim64_t
     * }
     */
    public static final OfLong __rlim64_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __id_t
     * }
     */
    public static final OfInt __id_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __time_t
     * }
     */
    public static final OfLong __time_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __useconds_t
     * }
     */
    public static final OfInt __useconds_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds_t
     * }
     */
    public static final OfLong __suseconds_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __suseconds64_t
     * }
     */
    public static final OfLong __suseconds64_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __daddr_t
     * }
     */
    public static final OfInt __daddr_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __key_t
     * }
     */
    public static final OfInt __key_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __clockid_t
     * }
     */
    public static final OfInt __clockid_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef void *__timer_t
     * }
     */
    public static final AddressLayout __timer_t = MessageFrame_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __blksize_t
     * }
     */
    public static final OfLong __blksize_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt_t
     * }
     */
    public static final OfLong __blkcnt_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __blkcnt64_t
     * }
     */
    public static final OfLong __blkcnt64_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt_t
     * }
     */
    public static final OfLong __fsblkcnt_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsblkcnt64_t
     * }
     */
    public static final OfLong __fsblkcnt64_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt_t
     * }
     */
    public static final OfLong __fsfilcnt_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __fsfilcnt64_t
     * }
     */
    public static final OfLong __fsfilcnt64_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fsword_t
     * }
     */
    public static final OfLong __fsword_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __ssize_t
     * }
     */
    public static final OfLong __ssize_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __syscall_slong_t
     * }
     */
    public static final OfLong __syscall_slong_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __syscall_ulong_t
     * }
     */
    public static final OfLong __syscall_ulong_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __off64_t __loff_t
     * }
     */
    public static final OfLong __loff_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef char *__caddr_t
     * }
     */
    public static final AddressLayout __caddr_t = MessageFrame_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef long __intptr_t
     * }
     */
    public static final OfLong __intptr_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __socklen_t
     * }
     */
    public static final OfInt __socklen_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int __sig_atomic_t
     * }
     */
    public static final OfInt __sig_atomic_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __off_t off_t
     * }
     */
    public static final OfLong off_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ssize_t ssize_t
     * }
     */
    public static final OfLong ssize_t = MessageFrame_h.C_LONG;

    private static class stdin$constants {
        public static final AddressLayout LAYOUT = MessageFrame_h.C_POINTER;
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("stdin").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static AddressLayout stdin$layout() {
        return stdin$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin$segment() {
        return stdin$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static MemorySegment stdin() {
        return stdin$constants.SEGMENT.get(stdin$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdin
     * }
     */
    public static void stdin(MemorySegment varValue) {
        stdin$constants.SEGMENT.set(stdin$constants.LAYOUT, 0L, varValue);
    }

    private static class stdout$constants {
        public static final AddressLayout LAYOUT = MessageFrame_h.C_POINTER;
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("stdout").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static AddressLayout stdout$layout() {
        return stdout$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout$segment() {
        return stdout$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static MemorySegment stdout() {
        return stdout$constants.SEGMENT.get(stdout$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stdout
     * }
     */
    public static void stdout(MemorySegment varValue) {
        stdout$constants.SEGMENT.set(stdout$constants.LAYOUT, 0L, varValue);
    }

    private static class stderr$constants {
        public static final AddressLayout LAYOUT = MessageFrame_h.C_POINTER;
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("stderr").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static AddressLayout stderr$layout() {
        return stderr$constants.LAYOUT;
    }

    /**
     * Segment for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr$segment() {
        return stderr$constants.SEGMENT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static MemorySegment stderr() {
        return stderr$constants.SEGMENT.get(stderr$constants.LAYOUT, 0L);
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern FILE *stderr
     * }
     */
    public static void stderr(MemorySegment varValue) {
        stderr$constants.SEGMENT.set(stderr$constants.LAYOUT, 0L, varValue);
    }

    private static class remove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("remove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static FunctionDescriptor remove$descriptor() {
        return remove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MethodHandle remove$handle() {
        return remove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static MemorySegment remove$address() {
        return remove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int remove(const char *__filename)
     * }
     */
    public static int remove(MemorySegment __filename) {
        var mh$ = remove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("remove", __filename);
            }
            return (int)mh$.invokeExact(__filename);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rename {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("rename");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static FunctionDescriptor rename$descriptor() {
        return rename.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MethodHandle rename$handle() {
        return rename.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static MemorySegment rename$address() {
        return rename.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rename(const char *__old, const char *__new)
     * }
     */
    public static int rename(MemorySegment __old, MemorySegment __new) {
        var mh$ = rename.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rename", __old, __new);
            }
            return (int)mh$.invokeExact(__old, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class renameat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("renameat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static FunctionDescriptor renameat$descriptor() {
        return renameat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MethodHandle renameat$handle() {
        return renameat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static MemorySegment renameat$address() {
        return renameat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int renameat(int __oldfd, const char *__old, int __newfd, const char *__new)
     * }
     */
    public static int renameat(int __oldfd, MemorySegment __old, int __newfd, MemorySegment __new) {
        var mh$ = renameat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("renameat", __oldfd, __old, __newfd, __new);
            }
            return (int)mh$.invokeExact(__oldfd, __old, __newfd, __new);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fclose$descriptor() {
        return fclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MethodHandle fclose$handle() {
        return fclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static MemorySegment fclose$address() {
        return fclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fclose(FILE *__stream)
     * }
     */
    public static int fclose(MemorySegment __stream) {
        var mh$ = fclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER    );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("tmpfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static FunctionDescriptor tmpfile$descriptor() {
        return tmpfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MethodHandle tmpfile$handle() {
        return tmpfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile$address() {
        return tmpfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *tmpfile()
     * }
     */
    public static MemorySegment tmpfile() {
        var mh$ = tmpfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpfile");
            }
            return (MemorySegment)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("tmpnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static FunctionDescriptor tmpnam$descriptor() {
        return tmpnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MethodHandle tmpnam$handle() {
        return tmpnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam$address() {
        return tmpnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam(char [20])
     * }
     */
    public static MemorySegment tmpnam(MemorySegment x0) {
        var mh$ = tmpnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tmpnam_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("tmpnam_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static FunctionDescriptor tmpnam_r$descriptor() {
        return tmpnam_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MethodHandle tmpnam_r$handle() {
        return tmpnam_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r$address() {
        return tmpnam_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tmpnam_r(char __s[20])
     * }
     */
    public static MemorySegment tmpnam_r(MemorySegment __s) {
        var mh$ = tmpnam_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tmpnam_r", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class tempnam {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("tempnam");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static FunctionDescriptor tempnam$descriptor() {
        return tempnam.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MethodHandle tempnam$handle() {
        return tempnam.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam$address() {
        return tempnam.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *tempnam(const char *__dir, const char *__pfx)
     * }
     */
    public static MemorySegment tempnam(MemorySegment __dir, MemorySegment __pfx) {
        var mh$ = tempnam.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("tempnam", __dir, __pfx);
            }
            return (MemorySegment)mh$.invokeExact(__dir, __pfx);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fflush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush$descriptor() {
        return fflush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MethodHandle fflush$handle() {
        return fflush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static MemorySegment fflush$address() {
        return fflush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush(FILE *__stream)
     * }
     */
    public static int fflush(MemorySegment __stream) {
        var mh$ = fflush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fflush_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fflush_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fflush_unlocked$descriptor() {
        return fflush_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fflush_unlocked$handle() {
        return fflush_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fflush_unlocked$address() {
        return fflush_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fflush_unlocked(FILE *__stream)
     * }
     */
    public static int fflush_unlocked(MemorySegment __stream) {
        var mh$ = fflush_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fflush_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static FunctionDescriptor fopen$descriptor() {
        return fopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MethodHandle fopen$handle() {
        return fopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen$address() {
        return fopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fopen(const char *restrict __filename, const char *restrict __modes)
     * }
     */
    public static MemorySegment fopen(MemorySegment __filename, MemorySegment __modes) {
        var mh$ = fopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopen", __filename, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class freopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("freopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor freopen$descriptor() {
        return freopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MethodHandle freopen$handle() {
        return freopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen$address() {
        return freopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *freopen(const char *restrict __filename, const char *restrict __modes, FILE *restrict __stream)
     * }
     */
    public static MemorySegment freopen(MemorySegment __filename, MemorySegment __modes, MemorySegment __stream) {
        var mh$ = freopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("freopen", __filename, __modes, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__filename, __modes, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fdopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fdopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static FunctionDescriptor fdopen$descriptor() {
        return fdopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MethodHandle fdopen$handle() {
        return fdopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen$address() {
        return fdopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fdopen(int __fd, const char *__modes)
     * }
     */
    public static MemorySegment fdopen(int __fd, MemorySegment __modes) {
        var mh$ = fdopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fdopen", __fd, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__fd, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fopencookie {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            _IO_cookie_io_functions_t.layout()
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fopencookie");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static FunctionDescriptor fopencookie$descriptor() {
        return fopencookie.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static MethodHandle fopencookie$handle() {
        return fopencookie.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static MemorySegment fopencookie$address() {
        return fopencookie.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fopencookie(void *restrict __magic_cookie, const char *restrict __modes, cookie_io_functions_t __io_funcs)
     * }
     */
    public static MemorySegment fopencookie(MemorySegment __magic_cookie, MemorySegment __modes, MemorySegment __io_funcs) {
        var mh$ = fopencookie.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fopencookie", __magic_cookie, __modes, __io_funcs);
            }
            return (MemorySegment)mh$.invokeExact(__magic_cookie, __modes, __io_funcs);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fmemopen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fmemopen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static FunctionDescriptor fmemopen$descriptor() {
        return fmemopen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MethodHandle fmemopen$handle() {
        return fmemopen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen$address() {
        return fmemopen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *fmemopen(void *__s, size_t __len, const char *__modes)
     * }
     */
    public static MemorySegment fmemopen(MemorySegment __s, long __len, MemorySegment __modes) {
        var mh$ = fmemopen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fmemopen", __s, __len, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__s, __len, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class open_memstream {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("open_memstream");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static FunctionDescriptor open_memstream$descriptor() {
        return open_memstream.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MethodHandle open_memstream$handle() {
        return open_memstream.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream$address() {
        return open_memstream.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *open_memstream(char **__bufloc, size_t *__sizeloc)
     * }
     */
    public static MemorySegment open_memstream(MemorySegment __bufloc, MemorySegment __sizeloc) {
        var mh$ = open_memstream.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("open_memstream", __bufloc, __sizeloc);
            }
            return (MemorySegment)mh$.invokeExact(__bufloc, __sizeloc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("setbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static FunctionDescriptor setbuf$descriptor() {
        return setbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MethodHandle setbuf$handle() {
        return setbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static MemorySegment setbuf$address() {
        return setbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuf(FILE *restrict __stream, char *restrict __buf)
     * }
     */
    public static void setbuf(MemorySegment __stream, MemorySegment __buf) {
        var mh$ = setbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuf", __stream, __buf);
            }
            mh$.invokeExact(__stream, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setvbuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("setvbuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static FunctionDescriptor setvbuf$descriptor() {
        return setvbuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MethodHandle setvbuf$handle() {
        return setvbuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static MemorySegment setvbuf$address() {
        return setvbuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setvbuf(FILE *restrict __stream, char *restrict __buf, int __modes, size_t __n)
     * }
     */
    public static int setvbuf(MemorySegment __stream, MemorySegment __buf, int __modes, long __n) {
        var mh$ = setvbuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setvbuf", __stream, __buf, __modes, __n);
            }
            return (int)mh$.invokeExact(__stream, __buf, __modes, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setbuffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("setbuffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static FunctionDescriptor setbuffer$descriptor() {
        return setbuffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MethodHandle setbuffer$handle() {
        return setbuffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static MemorySegment setbuffer$address() {
        return setbuffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setbuffer(FILE *restrict __stream, char *restrict __buf, size_t __size)
     * }
     */
    public static void setbuffer(MemorySegment __stream, MemorySegment __buf, long __size) {
        var mh$ = setbuffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setbuffer", __stream, __buf, __size);
            }
            mh$.invokeExact(__stream, __buf, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setlinebuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("setlinebuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static FunctionDescriptor setlinebuf$descriptor() {
        return setlinebuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MethodHandle setlinebuf$handle() {
        return setlinebuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static MemorySegment setlinebuf$address() {
        return setlinebuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void setlinebuf(FILE *__stream)
     * }
     */
    public static void setlinebuf(MemorySegment __stream) {
        var mh$ = setlinebuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setlinebuf", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                MessageFrame_h.C_INT,
                MessageFrame_h.C_POINTER,
                MessageFrame_h.C_POINTER
            );
        private static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fprintf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fprintf", __stream, __format, x2);
                }
                return (int) spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int printf(const char *restrict __format, ...)
     * }
     */
    public static class printf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                MessageFrame_h.C_INT,
                MessageFrame_h.C_POINTER
            );
        private static final MemorySegment ADDR = MessageFrame_h.findOrThrow("printf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private printf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int printf(const char *restrict __format, ...)
         * }
         */
        public static printf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new printf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("printf", __format, x1);
                }
                return (int) spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                MessageFrame_h.C_INT,
                MessageFrame_h.C_POINTER,
                MessageFrame_h.C_POINTER
            );
        private static final MemorySegment ADDR = MessageFrame_h.findOrThrow("sprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sprintf(char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sprintf", __s, __format, x2);
                }
                return (int) spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vfprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("vfprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfprintf$descriptor() {
        return vfprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfprintf$handle() {
        return vfprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfprintf$address() {
        return vfprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfprintf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("vprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vprintf$descriptor() {
        return vprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vprintf$handle() {
        return vprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vprintf$address() {
        return vprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vprintf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vprintf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vprintf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("vsprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsprintf$descriptor() {
        return vsprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsprintf$handle() {
        return vsprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsprintf$address() {
        return vsprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsprintf(char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsprintf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsprintf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
     * }
     */
    public static class snprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                MessageFrame_h.C_INT,
                MessageFrame_h.C_POINTER,
                MessageFrame_h.C_LONG,
                MessageFrame_h.C_POINTER
            );
        private static final MemorySegment ADDR = MessageFrame_h.findOrThrow("snprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private snprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int snprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, ...)
         * }
         */
        public static snprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new snprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, long __maxlen, MemorySegment __format, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("snprintf", __s, __maxlen, __format, x3);
                }
                return (int) spreader.invokeExact(__s, __maxlen, __format, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vsnprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("vsnprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsnprintf$descriptor() {
        return vsnprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsnprintf$handle() {
        return vsnprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsnprintf$address() {
        return vsnprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsnprintf(char *restrict __s, size_t __maxlen, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsnprintf(MemorySegment __s, long __maxlen, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsnprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsnprintf", __s, __maxlen, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __maxlen, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vasprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("vasprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vasprintf$descriptor() {
        return vasprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vasprintf$handle() {
        return vasprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vasprintf$address() {
        return vasprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vasprintf(char **restrict __ptr, const char *restrict __f, __gnuc_va_list __arg)
     * }
     */
    public static int vasprintf(MemorySegment __ptr, MemorySegment __f, MemorySegment __arg) {
        var mh$ = vasprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vasprintf", __ptr, __f, __arg);
            }
            return (int)mh$.invokeExact(__ptr, __f, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int __asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
     * }
     */
    public static class __asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                MessageFrame_h.C_INT,
                MessageFrame_h.C_POINTER,
                MessageFrame_h.C_POINTER
            );
        private static final MemorySegment ADDR = MessageFrame_h.findOrThrow("__asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private __asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int __asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
         * }
         */
        public static __asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new __asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __ptr, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("__asprintf", __ptr, __fmt, x2);
                }
                return (int) spreader.invokeExact(__ptr, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
     * }
     */
    public static class asprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                MessageFrame_h.C_INT,
                MessageFrame_h.C_POINTER,
                MessageFrame_h.C_POINTER
            );
        private static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private asprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int asprintf(char **restrict __ptr, const char *restrict __fmt, ...)
         * }
         */
        public static asprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new asprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __ptr, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("asprintf", __ptr, __fmt, x2);
                }
                return (int) spreader.invokeExact(__ptr, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class vdprintf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("vdprintf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vdprintf$descriptor() {
        return vdprintf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vdprintf$handle() {
        return vdprintf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vdprintf$address() {
        return vdprintf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vdprintf(int __fd, const char *restrict __fmt, __gnuc_va_list __arg)
     * }
     */
    public static int vdprintf(int __fd, MemorySegment __fmt, MemorySegment __arg) {
        var mh$ = vdprintf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vdprintf", __fd, __fmt, __arg);
            }
            return (int)mh$.invokeExact(__fd, __fmt, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int dprintf(int __fd, const char *restrict __fmt, ...)
     * }
     */
    public static class dprintf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                MessageFrame_h.C_INT,
                MessageFrame_h.C_INT,
                MessageFrame_h.C_POINTER
            );
        private static final MemorySegment ADDR = MessageFrame_h.findOrThrow("dprintf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private dprintf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int dprintf(int __fd, const char *restrict __fmt, ...)
         * }
         */
        public static dprintf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new dprintf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(int __fd, MemorySegment __fmt, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("dprintf", __fd, __fmt, x2);
                }
                return (int) spreader.invokeExact(__fd, __fmt, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
     * }
     */
    public static class fscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                MessageFrame_h.C_INT,
                MessageFrame_h.C_POINTER,
                MessageFrame_h.C_POINTER
            );
        private static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private fscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int fscanf(FILE *restrict __stream, const char *restrict __format, ...)
         * }
         */
        public static fscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new fscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __stream, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("fscanf", __stream, __format, x2);
                }
                return (int) spreader.invokeExact(__stream, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int scanf(const char *restrict __format, ...)
     * }
     */
    public static class scanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                MessageFrame_h.C_INT,
                MessageFrame_h.C_POINTER
            );
        private static final MemorySegment ADDR = MessageFrame_h.findOrThrow("scanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private scanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int scanf(const char *restrict __format, ...)
         * }
         */
        public static scanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new scanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __format, Object... x1) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("scanf", __format, x1);
                }
                return (int) spreader.invokeExact(__format, x1);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
     * }
     */
    public static class sscanf {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                MessageFrame_h.C_INT,
                MessageFrame_h.C_POINTER,
                MessageFrame_h.C_POINTER
            );
        private static final MemorySegment ADDR = MessageFrame_h.findOrThrow("sscanf");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private sscanf(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * extern int sscanf(const char *restrict __s, const char *restrict __format, ...)
         * }
         */
        public static sscanf makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new sscanf(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public int apply(MemorySegment __s, MemorySegment __format, Object... x2) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("sscanf", __s, __format, x2);
                }
                return (int) spreader.invokeExact(__s, __format, x2);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }
    /**
     * {@snippet lang=c :
     * typedef float _Float32
     * }
     */
    public static final OfFloat _Float32 = MessageFrame_h.C_FLOAT;
    /**
     * {@snippet lang=c :
     * typedef double _Float64
     * }
     */
    public static final OfDouble _Float64 = MessageFrame_h.C_DOUBLE;
    /**
     * {@snippet lang=c :
     * typedef double _Float32x
     * }
     */
    public static final OfDouble _Float32x = MessageFrame_h.C_DOUBLE;

    private static class vfscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("vfscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vfscanf$descriptor() {
        return vfscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vfscanf$handle() {
        return vfscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vfscanf$address() {
        return vfscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vfscanf(FILE *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vfscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vfscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vfscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("vscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vscanf$descriptor() {
        return vscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vscanf$handle() {
        return vscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vscanf$address() {
        return vscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vscanf(const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vscanf(MemorySegment __format, MemorySegment __arg) {
        var mh$ = vscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vscanf", __format, __arg);
            }
            return (int)mh$.invokeExact(__format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class vsscanf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("vsscanf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static FunctionDescriptor vsscanf$descriptor() {
        return vsscanf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MethodHandle vsscanf$handle() {
        return vsscanf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static MemorySegment vsscanf$address() {
        return vsscanf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int vsscanf(const char *restrict __s, const char *restrict __format, __gnuc_va_list __arg)
     * }
     */
    public static int vsscanf(MemorySegment __s, MemorySegment __format, MemorySegment __arg) {
        var mh$ = vsscanf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("vsscanf", __s, __format, __arg);
            }
            return (int)mh$.invokeExact(__s, __format, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fgetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc$descriptor() {
        return fgetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc$handle() {
        return fgetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc$address() {
        return fgetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc(FILE *__stream)
     * }
     */
    public static int fgetc(MemorySegment __stream) {
        var mh$ = fgetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("getc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc$descriptor() {
        return getc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MethodHandle getc$handle() {
        return getc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static MemorySegment getc$address() {
        return getc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc(FILE *__stream)
     * }
     */
    public static int getc(MemorySegment __stream) {
        var mh$ = getc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT    );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("getchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static FunctionDescriptor getchar$descriptor() {
        return getchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MethodHandle getchar$handle() {
        return getchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static MemorySegment getchar$address() {
        return getchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar()
     * }
     */
    public static int getchar() {
        var mh$ = getchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("getc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getc_unlocked$descriptor() {
        return getc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle getc_unlocked$handle() {
        return getc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment getc_unlocked$address() {
        return getc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getc_unlocked(FILE *__stream)
     * }
     */
    public static int getc_unlocked(MemorySegment __stream) {
        var mh$ = getc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT    );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("getchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static FunctionDescriptor getchar_unlocked$descriptor() {
        return getchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MethodHandle getchar_unlocked$handle() {
        return getchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static MemorySegment getchar_unlocked$address() {
        return getchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getchar_unlocked()
     * }
     */
    public static int getchar_unlocked() {
        var mh$ = getchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getchar_unlocked");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fgetc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fgetc_unlocked$descriptor() {
        return fgetc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fgetc_unlocked$handle() {
        return fgetc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fgetc_unlocked$address() {
        return fgetc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetc_unlocked(FILE *__stream)
     * }
     */
    public static int fgetc_unlocked(MemorySegment __stream) {
        var mh$ = fgetc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetc_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fputc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc$descriptor() {
        return fputc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc$handle() {
        return fputc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc$address() {
        return fputc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc(int __c, FILE *__stream)
     * }
     */
    public static int fputc(int __c, MemorySegment __stream) {
        var mh$ = fputc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("putc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc$descriptor() {
        return putc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc$handle() {
        return putc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc$address() {
        return putc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc(int __c, FILE *__stream)
     * }
     */
    public static int putc(int __c, MemorySegment __stream) {
        var mh$ = putc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("putchar");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static FunctionDescriptor putchar$descriptor() {
        return putchar.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MethodHandle putchar$handle() {
        return putchar.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static MemorySegment putchar$address() {
        return putchar.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar(int __c)
     * }
     */
    public static int putchar(int __c) {
        var mh$ = putchar.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fputc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor fputc_unlocked$descriptor() {
        return fputc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle fputc_unlocked$handle() {
        return fputc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment fputc_unlocked$address() {
        return fputc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int fputc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = fputc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putc_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("putc_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putc_unlocked$descriptor() {
        return putc_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle putc_unlocked$handle() {
        return putc_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment putc_unlocked$address() {
        return putc_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putc_unlocked(int __c, FILE *__stream)
     * }
     */
    public static int putc_unlocked(int __c, MemorySegment __stream) {
        var mh$ = putc_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putc_unlocked", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putchar_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("putchar_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static FunctionDescriptor putchar_unlocked$descriptor() {
        return putchar_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MethodHandle putchar_unlocked$handle() {
        return putchar_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static MemorySegment putchar_unlocked$address() {
        return putchar_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putchar_unlocked(int __c)
     * }
     */
    public static int putchar_unlocked(int __c) {
        var mh$ = putchar_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putchar_unlocked", __c);
            }
            return (int)mh$.invokeExact(__c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("getw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static FunctionDescriptor getw$descriptor() {
        return getw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MethodHandle getw$handle() {
        return getw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static MemorySegment getw$address() {
        return getw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getw(FILE *__stream)
     * }
     */
    public static int getw(MemorySegment __stream) {
        var mh$ = getw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getw", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putw {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("putw");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static FunctionDescriptor putw$descriptor() {
        return putw.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MethodHandle putw$handle() {
        return putw.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static MemorySegment putw$address() {
        return putw.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putw(int __w, FILE *__stream)
     * }
     */
    public static int putw(int __w, MemorySegment __stream) {
        var mh$ = putw.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putw", __w, __stream);
            }
            return (int)mh$.invokeExact(__w, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgets {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fgets");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fgets$descriptor() {
        return fgets.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fgets$handle() {
        return fgets.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets$address() {
        return fgets.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *fgets(char *restrict __s, int __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fgets(MemorySegment __s, int __n, MemorySegment __stream) {
        var mh$ = fgets.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgets", __s, __n, __stream);
            }
            return (MemorySegment)mh$.invokeExact(__s, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("__getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor __getdelim$descriptor() {
        return __getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle __getdelim$handle() {
        return __getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment __getdelim$address() {
        return __getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t __getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long __getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = __getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getdelim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("getdelim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getdelim$descriptor() {
        return getdelim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getdelim$handle() {
        return getdelim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getdelim$address() {
        return getdelim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getdelim(char **restrict __lineptr, size_t *restrict __n, int __delimiter, FILE *restrict __stream)
     * }
     */
    public static long getdelim(MemorySegment __lineptr, MemorySegment __n, int __delimiter, MemorySegment __stream) {
        var mh$ = getdelim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getdelim", __lineptr, __n, __delimiter, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __delimiter, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getline {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("getline");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor getline$descriptor() {
        return getline.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle getline$handle() {
        return getline.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment getline$address() {
        return getline.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __ssize_t getline(char **restrict __lineptr, size_t *restrict __n, FILE *restrict __stream)
     * }
     */
    public static long getline(MemorySegment __lineptr, MemorySegment __n, MemorySegment __stream) {
        var mh$ = getline.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getline", __lineptr, __n, __stream);
            }
            return (long)mh$.invokeExact(__lineptr, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fputs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fputs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fputs$descriptor() {
        return fputs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fputs$handle() {
        return fputs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fputs$address() {
        return fputs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fputs(const char *restrict __s, FILE *restrict __stream)
     * }
     */
    public static int fputs(MemorySegment __s, MemorySegment __stream) {
        var mh$ = fputs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fputs", __s, __stream);
            }
            return (int)mh$.invokeExact(__s, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class puts {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("puts");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static FunctionDescriptor puts$descriptor() {
        return puts.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MethodHandle puts$handle() {
        return puts.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static MemorySegment puts$address() {
        return puts.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int puts(const char *__s)
     * }
     */
    public static int puts(MemorySegment __s) {
        var mh$ = puts.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("puts", __s);
            }
            return (int)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ungetc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ungetc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static FunctionDescriptor ungetc$descriptor() {
        return ungetc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MethodHandle ungetc$handle() {
        return ungetc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static MemorySegment ungetc$address() {
        return ungetc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ungetc(int __c, FILE *__stream)
     * }
     */
    public static int ungetc(int __c, MemorySegment __stream) {
        var mh$ = ungetc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ungetc", __c, __stream);
            }
            return (int)mh$.invokeExact(__c, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fread");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread$descriptor() {
        return fread.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread$handle() {
        return fread.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread$address() {
        return fread.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fread(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static FunctionDescriptor fwrite$descriptor() {
        return fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MethodHandle fwrite$handle() {
        return fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static MemorySegment fwrite$address() {
        return fwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long fwrite(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __s)
     * }
     */
    public static long fwrite(MemorySegment __ptr, long __size, long __n, MemorySegment __s) {
        var mh$ = fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite", __ptr, __size, __n, __s);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fread_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fread_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fread_unlocked$descriptor() {
        return fread_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fread_unlocked$handle() {
        return fread_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fread_unlocked$address() {
        return fread_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fread_unlocked(void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fread_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fread_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fread_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fwrite_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fwrite_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static FunctionDescriptor fwrite_unlocked$descriptor() {
        return fwrite_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MethodHandle fwrite_unlocked$handle() {
        return fwrite_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static MemorySegment fwrite_unlocked$address() {
        return fwrite_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t fwrite_unlocked(const void *restrict __ptr, size_t __size, size_t __n, FILE *restrict __stream)
     * }
     */
    public static long fwrite_unlocked(MemorySegment __ptr, long __size, long __n, MemorySegment __stream) {
        var mh$ = fwrite_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fwrite_unlocked", __ptr, __size, __n, __stream);
            }
            return (long)mh$.invokeExact(__ptr, __size, __n, __stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseek {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fseek");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseek$descriptor() {
        return fseek.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MethodHandle fseek$handle() {
        return fseek.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static MemorySegment fseek$address() {
        return fseek.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseek(FILE *__stream, long __off, int __whence)
     * }
     */
    public static int fseek(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseek.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseek", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftell {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ftell");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftell$descriptor() {
        return ftell.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MethodHandle ftell$handle() {
        return ftell.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static MemorySegment ftell$address() {
        return ftell.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long ftell(FILE *__stream)
     * }
     */
    public static long ftell(MemorySegment __stream) {
        var mh$ = ftell.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftell", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rewind {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("rewind");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static FunctionDescriptor rewind$descriptor() {
        return rewind.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MethodHandle rewind$handle() {
        return rewind.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static MemorySegment rewind$address() {
        return rewind.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void rewind(FILE *__stream)
     * }
     */
    public static void rewind(MemorySegment __stream) {
        var mh$ = rewind.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rewind", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fseeko {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fseeko");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static FunctionDescriptor fseeko$descriptor() {
        return fseeko.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MethodHandle fseeko$handle() {
        return fseeko.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static MemorySegment fseeko$address() {
        return fseeko.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fseeko(FILE *__stream, __off_t __off, int __whence)
     * }
     */
    public static int fseeko(MemorySegment __stream, long __off, int __whence) {
        var mh$ = fseeko.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fseeko", __stream, __off, __whence);
            }
            return (int)mh$.invokeExact(__stream, __off, __whence);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftello {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ftello");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftello$descriptor() {
        return ftello.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MethodHandle ftello$handle() {
        return ftello.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static MemorySegment ftello$address() {
        return ftello.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __off_t ftello(FILE *__stream)
     * }
     */
    public static long ftello(MemorySegment __stream) {
        var mh$ = ftello.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftello", __stream);
            }
            return (long)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fgetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fgetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static FunctionDescriptor fgetpos$descriptor() {
        return fgetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MethodHandle fgetpos$handle() {
        return fgetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static MemorySegment fgetpos$address() {
        return fgetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fgetpos(FILE *restrict __stream, fpos_t *restrict __pos)
     * }
     */
    public static int fgetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fgetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fgetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fsetpos {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fsetpos");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static FunctionDescriptor fsetpos$descriptor() {
        return fsetpos.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MethodHandle fsetpos$handle() {
        return fsetpos.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static MemorySegment fsetpos$address() {
        return fsetpos.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fsetpos(FILE *__stream, const fpos_t *__pos)
     * }
     */
    public static int fsetpos(MemorySegment __stream, MemorySegment __pos) {
        var mh$ = fsetpos.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fsetpos", __stream, __pos);
            }
            return (int)mh$.invokeExact(__stream, __pos);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("clearerr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr$descriptor() {
        return clearerr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr$handle() {
        return clearerr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr$address() {
        return clearerr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr(FILE *__stream)
     * }
     */
    public static void clearerr(MemorySegment __stream) {
        var mh$ = clearerr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("feof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof$descriptor() {
        return feof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MethodHandle feof$handle() {
        return feof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static MemorySegment feof$address() {
        return feof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof(FILE *__stream)
     * }
     */
    public static int feof(MemorySegment __stream) {
        var mh$ = feof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ferror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror$descriptor() {
        return ferror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MethodHandle ferror$handle() {
        return ferror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static MemorySegment ferror$address() {
        return ferror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror(FILE *__stream)
     * }
     */
    public static int ferror(MemorySegment __stream) {
        var mh$ = ferror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearerr_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("clearerr_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor clearerr_unlocked$descriptor() {
        return clearerr_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle clearerr_unlocked$handle() {
        return clearerr_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment clearerr_unlocked$address() {
        return clearerr_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void clearerr_unlocked(FILE *__stream)
     * }
     */
    public static void clearerr_unlocked(MemorySegment __stream) {
        var mh$ = clearerr_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearerr_unlocked", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class feof_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("feof_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor feof_unlocked$descriptor() {
        return feof_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle feof_unlocked$handle() {
        return feof_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment feof_unlocked$address() {
        return feof_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int feof_unlocked(FILE *__stream)
     * }
     */
    public static int feof_unlocked(MemorySegment __stream) {
        var mh$ = feof_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("feof_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ferror_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ferror_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ferror_unlocked$descriptor() {
        return ferror_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle ferror_unlocked$handle() {
        return ferror_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment ferror_unlocked$address() {
        return ferror_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ferror_unlocked(FILE *__stream)
     * }
     */
    public static int ferror_unlocked(MemorySegment __stream) {
        var mh$ = ferror_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ferror_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class perror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("perror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static FunctionDescriptor perror$descriptor() {
        return perror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MethodHandle perror$handle() {
        return perror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static MemorySegment perror$address() {
        return perror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void perror(const char *__s)
     * }
     */
    public static void perror(MemorySegment __s) {
        var mh$ = perror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("perror", __s);
            }
            mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fileno");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno$descriptor() {
        return fileno.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MethodHandle fileno$handle() {
        return fileno.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static MemorySegment fileno$address() {
        return fileno.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno(FILE *__stream)
     * }
     */
    public static int fileno(MemorySegment __stream) {
        var mh$ = fileno.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fileno_unlocked {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fileno_unlocked");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static FunctionDescriptor fileno_unlocked$descriptor() {
        return fileno_unlocked.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MethodHandle fileno_unlocked$handle() {
        return fileno_unlocked.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static MemorySegment fileno_unlocked$address() {
        return fileno_unlocked.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fileno_unlocked(FILE *__stream)
     * }
     */
    public static int fileno_unlocked(MemorySegment __stream) {
        var mh$ = fileno_unlocked.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fileno_unlocked", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pclose {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("pclose");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static FunctionDescriptor pclose$descriptor() {
        return pclose.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MethodHandle pclose$handle() {
        return pclose.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static MemorySegment pclose$address() {
        return pclose.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pclose(FILE *__stream)
     * }
     */
    public static int pclose(MemorySegment __stream) {
        var mh$ = pclose.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pclose", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class popen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("popen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static FunctionDescriptor popen$descriptor() {
        return popen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MethodHandle popen$handle() {
        return popen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen$address() {
        return popen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern FILE *popen(const char *__command, const char *__modes)
     * }
     */
    public static MemorySegment popen(MemorySegment __command, MemorySegment __modes) {
        var mh$ = popen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("popen", __command, __modes);
            }
            return (MemorySegment)mh$.invokeExact(__command, __modes);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ctermid {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ctermid");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static FunctionDescriptor ctermid$descriptor() {
        return ctermid.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MethodHandle ctermid$handle() {
        return ctermid.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid$address() {
        return ctermid.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ctermid(char *__s)
     * }
     */
    public static MemorySegment ctermid(MemorySegment __s) {
        var mh$ = ctermid.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ctermid", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class flockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("flockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor flockfile$descriptor() {
        return flockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MethodHandle flockfile$handle() {
        return flockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static MemorySegment flockfile$address() {
        return flockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void flockfile(FILE *__stream)
     * }
     */
    public static void flockfile(MemorySegment __stream) {
        var mh$ = flockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("flockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ftrylockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ftrylockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor ftrylockfile$descriptor() {
        return ftrylockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MethodHandle ftrylockfile$handle() {
        return ftrylockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static MemorySegment ftrylockfile$address() {
        return ftrylockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ftrylockfile(FILE *__stream)
     * }
     */
    public static int ftrylockfile(MemorySegment __stream) {
        var mh$ = ftrylockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ftrylockfile", __stream);
            }
            return (int)mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class funlockfile {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("funlockfile");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static FunctionDescriptor funlockfile$descriptor() {
        return funlockfile.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MethodHandle funlockfile$handle() {
        return funlockfile.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static MemorySegment funlockfile$address() {
        return funlockfile.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void funlockfile(FILE *__stream)
     * }
     */
    public static void funlockfile(MemorySegment __stream) {
        var mh$ = funlockfile.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("funlockfile", __stream);
            }
            mh$.invokeExact(__stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __uflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("__uflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static FunctionDescriptor __uflow$descriptor() {
        return __uflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MethodHandle __uflow$handle() {
        return __uflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static MemorySegment __uflow$address() {
        return __uflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __uflow(FILE *)
     * }
     */
    public static int __uflow(MemorySegment x0) {
        var mh$ = __uflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__uflow", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __overflow {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("__overflow");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static FunctionDescriptor __overflow$descriptor() {
        return __overflow.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MethodHandle __overflow$handle() {
        return __overflow.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static MemorySegment __overflow$address() {
        return __overflow.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __overflow(FILE *, int)
     * }
     */
    public static int __overflow(MemorySegment x0, int x1) {
        var mh$ = __overflow.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__overflow", x0, x1);
            }
            return (int)mh$.invokeExact(x0, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef int wchar_t
     * }
     */
    public static final OfInt wchar_t = MessageFrame_h.C_INT;

    private static class __ctype_get_mb_cur_max {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG    );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("__ctype_get_mb_cur_max");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static FunctionDescriptor __ctype_get_mb_cur_max$descriptor() {
        return __ctype_get_mb_cur_max.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static MethodHandle __ctype_get_mb_cur_max$handle() {
        return __ctype_get_mb_cur_max.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static MemorySegment __ctype_get_mb_cur_max$address() {
        return __ctype_get_mb_cur_max.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t __ctype_get_mb_cur_max()
     * }
     */
    public static long __ctype_get_mb_cur_max() {
        var mh$ = __ctype_get_mb_cur_max.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__ctype_get_mb_cur_max");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_DOUBLE,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("atof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atof$descriptor() {
        return atof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static MethodHandle atof$handle() {
        return atof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static MemorySegment atof$address() {
        return atof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double atof(const char *__nptr)
     * }
     */
    public static double atof(MemorySegment __nptr) {
        var mh$ = atof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atof", __nptr);
            }
            return (double)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoi {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("atoi");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atoi$descriptor() {
        return atoi.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static MethodHandle atoi$handle() {
        return atoi.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static MemorySegment atoi$address() {
        return atoi.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int atoi(const char *__nptr)
     * }
     */
    public static int atoi(MemorySegment __nptr) {
        var mh$ = atoi.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoi", __nptr);
            }
            return (int)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("atol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atol$descriptor() {
        return atol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static MethodHandle atol$handle() {
        return atol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static MemorySegment atol$address() {
        return atol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long atol(const char *__nptr)
     * }
     */
    public static long atol(MemorySegment __nptr) {
        var mh$ = atol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atol", __nptr);
            }
            return (long)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("atoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static FunctionDescriptor atoll$descriptor() {
        return atoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static MethodHandle atoll$handle() {
        return atoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static MemorySegment atoll$address() {
        return atoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long atoll(const char *__nptr)
     * }
     */
    public static long atoll(MemorySegment __nptr) {
        var mh$ = atoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atoll", __nptr);
            }
            return (long)mh$.invokeExact(__nptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtod {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_DOUBLE,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strtod");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static FunctionDescriptor strtod$descriptor() {
        return strtod.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MethodHandle strtod$handle() {
        return strtod.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MemorySegment strtod$address() {
        return strtod.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double strtod(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static double strtod(MemorySegment __nptr, MemorySegment __endptr) {
        var mh$ = strtod.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtod", __nptr, __endptr);
            }
            return (double)mh$.invokeExact(__nptr, __endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtof {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_FLOAT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strtof");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static FunctionDescriptor strtof$descriptor() {
        return strtof.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MethodHandle strtof$handle() {
        return strtof.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static MemorySegment strtof$address() {
        return strtof.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern float strtof(const char *restrict __nptr, char **restrict __endptr)
     * }
     */
    public static float strtof(MemorySegment __nptr, MemorySegment __endptr) {
        var mh$ = strtof.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtof", __nptr, __endptr);
            }
            return (float)mh$.invokeExact(__nptr, __endptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtol {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strtol");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtol$descriptor() {
        return strtol.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtol$handle() {
        return strtol.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtol$address() {
        return strtol.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long strtol(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtol(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtol.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtol", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strtoul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoul$descriptor() {
        return strtoul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoul$handle() {
        return strtoul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoul$address() {
        return strtoul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strtoul(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoul(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoul", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strtoq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoq$descriptor() {
        return strtoq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoq$handle() {
        return strtoq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoq$address() {
        return strtoq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long strtoq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoq(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoq", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtouq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strtouq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtouq$descriptor() {
        return strtouq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtouq$handle() {
        return strtouq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtouq$address() {
        return strtouq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long long strtouq(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtouq(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtouq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtouq", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strtoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoll$descriptor() {
        return strtoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoll$handle() {
        return strtoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoll$address() {
        return strtoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long strtoll(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoll(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoll", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoull {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strtoull");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoull$descriptor() {
        return strtoull.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoull$handle() {
        return strtoull.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoull$address() {
        return strtoull.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long long strtoull(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoull(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoull.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoull", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class l64a {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("l64a");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static FunctionDescriptor l64a$descriptor() {
        return l64a.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MethodHandle l64a$handle() {
        return l64a.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MemorySegment l64a$address() {
        return l64a.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *l64a(long __n)
     * }
     */
    public static MemorySegment l64a(long __n) {
        var mh$ = l64a.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("l64a", __n);
            }
            return (MemorySegment)mh$.invokeExact(__n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class a64l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("a64l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static FunctionDescriptor a64l$descriptor() {
        return a64l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static MethodHandle a64l$handle() {
        return a64l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static MemorySegment a64l$address() {
        return a64l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long a64l(const char *__s)
     * }
     */
    public static long a64l(MemorySegment __s) {
        var mh$ = a64l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("a64l", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __u_char u_char
     * }
     */
    public static final OfByte u_char = MessageFrame_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __u_short u_short
     * }
     */
    public static final OfShort u_short = MessageFrame_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __u_int u_int
     * }
     */
    public static final OfInt u_int = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __u_long u_long
     * }
     */
    public static final OfLong u_long = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __quad_t quad_t
     * }
     */
    public static final OfLong quad_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __u_quad_t u_quad_t
     * }
     */
    public static final OfLong u_quad_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __loff_t loff_t
     * }
     */
    public static final OfLong loff_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __ino_t ino_t
     * }
     */
    public static final OfLong ino_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __dev_t dev_t
     * }
     */
    public static final OfLong dev_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __gid_t gid_t
     * }
     */
    public static final OfInt gid_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __mode_t mode_t
     * }
     */
    public static final OfInt mode_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __nlink_t nlink_t
     * }
     */
    public static final OfLong nlink_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uid_t uid_t
     * }
     */
    public static final OfInt uid_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __pid_t pid_t
     * }
     */
    public static final OfInt pid_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __id_t id_t
     * }
     */
    public static final OfInt id_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __daddr_t daddr_t
     * }
     */
    public static final OfInt daddr_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __caddr_t caddr_t
     * }
     */
    public static final AddressLayout caddr_t = MessageFrame_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __key_t key_t
     * }
     */
    public static final OfInt key_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __clock_t clock_t
     * }
     */
    public static final OfLong clock_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __clockid_t clockid_t
     * }
     */
    public static final OfInt clockid_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __time_t time_t
     * }
     */
    public static final OfLong time_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __timer_t timer_t
     * }
     */
    public static final AddressLayout timer_t = MessageFrame_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef unsigned long ulong
     * }
     */
    public static final OfLong ulong = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned short ushort
     * }
     */
    public static final OfShort ushort = MessageFrame_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef unsigned int uint
     * }
     */
    public static final OfInt uint = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int8_t int8_t
     * }
     */
    public static final OfByte int8_t = MessageFrame_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int16_t int16_t
     * }
     */
    public static final OfShort int16_t = MessageFrame_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int32_t int32_t
     * }
     */
    public static final OfInt int32_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int64_t int64_t
     * }
     */
    public static final OfLong int64_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t u_int8_t
     * }
     */
    public static final OfByte u_int8_t = MessageFrame_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t u_int16_t
     * }
     */
    public static final OfShort u_int16_t = MessageFrame_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t u_int32_t
     * }
     */
    public static final OfInt u_int32_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t u_int64_t
     * }
     */
    public static final OfLong u_int64_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int register_t
     * }
     */
    public static final OfLong register_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __suseconds_t suseconds_t
     * }
     */
    public static final OfLong suseconds_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long __fd_mask
     * }
     */
    public static final OfLong __fd_mask = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fd_mask fd_mask
     * }
     */
    public static final OfLong fd_mask = MessageFrame_h.C_LONG;

    private static class select {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("select");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static FunctionDescriptor select$descriptor() {
        return select.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MethodHandle select$handle() {
        return select.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static MemorySegment select$address() {
        return select.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int select(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, struct timeval *restrict __timeout)
     * }
     */
    public static int select(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout) {
        var mh$ = select.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("select", __nfds, __readfds, __writefds, __exceptfds, __timeout);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class pselect {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("pselect");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static FunctionDescriptor pselect$descriptor() {
        return pselect.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MethodHandle pselect$handle() {
        return pselect.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static MemorySegment pselect$address() {
        return pselect.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int pselect(int __nfds, fd_set *restrict __readfds, fd_set *restrict __writefds, fd_set *restrict __exceptfds, const struct timespec *restrict __timeout, const __sigset_t *restrict __sigmask)
     * }
     */
    public static int pselect(int __nfds, MemorySegment __readfds, MemorySegment __writefds, MemorySegment __exceptfds, MemorySegment __timeout, MemorySegment __sigmask) {
        var mh$ = pselect.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pselect", __nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
            }
            return (int)mh$.invokeExact(__nfds, __readfds, __writefds, __exceptfds, __timeout, __sigmask);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef __blksize_t blksize_t
     * }
     */
    public static final OfLong blksize_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __blkcnt_t blkcnt_t
     * }
     */
    public static final OfLong blkcnt_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsblkcnt_t fsblkcnt_t
     * }
     */
    public static final OfLong fsblkcnt_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __fsfilcnt_t fsfilcnt_t
     * }
     */
    public static final OfLong fsfilcnt_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int __tss_t
     * }
     */
    public static final OfInt __tss_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef unsigned long __thrd_t
     * }
     */
    public static final OfLong __thrd_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long pthread_t
     * }
     */
    public static final OfLong pthread_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned int pthread_key_t
     * }
     */
    public static final OfInt pthread_key_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef int pthread_once_t
     * }
     */
    public static final OfInt pthread_once_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef volatile int pthread_spinlock_t
     * }
     */
    public static final OfInt pthread_spinlock_t = MessageFrame_h.C_INT;

    private static class random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG    );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static FunctionDescriptor random$descriptor() {
        return random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static MethodHandle random$handle() {
        return random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static MemorySegment random$address() {
        return random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long random()
     * }
     */
    public static long random() {
        var mh$ = random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("srandom");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static FunctionDescriptor srandom$descriptor() {
        return srandom.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static MethodHandle srandom$handle() {
        return srandom.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static MemorySegment srandom$address() {
        return srandom.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srandom(unsigned int __seed)
     * }
     */
    public static void srandom(int __seed) {
        var mh$ = srandom.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom", __seed);
            }
            mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("initstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static FunctionDescriptor initstate$descriptor() {
        return initstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MethodHandle initstate$handle() {
        return initstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MemorySegment initstate$address() {
        return initstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *initstate(unsigned int __seed, char *__statebuf, size_t __statelen)
     * }
     */
    public static MemorySegment initstate(int __seed, MemorySegment __statebuf, long __statelen) {
        var mh$ = initstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate", __seed, __statebuf, __statelen);
            }
            return (MemorySegment)mh$.invokeExact(__seed, __statebuf, __statelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("setstate");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static FunctionDescriptor setstate$descriptor() {
        return setstate.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MethodHandle setstate$handle() {
        return setstate.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MemorySegment setstate$address() {
        return setstate.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *setstate(char *__statebuf)
     * }
     */
    public static MemorySegment setstate(MemorySegment __statebuf) {
        var mh$ = setstate.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate", __statebuf);
            }
            return (MemorySegment)mh$.invokeExact(__statebuf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class random_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("random_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static FunctionDescriptor random_r$descriptor() {
        return random_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static MethodHandle random_r$handle() {
        return random_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static MemorySegment random_r$address() {
        return random_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int random_r(struct random_data *restrict __buf, int32_t *restrict __result)
     * }
     */
    public static int random_r(MemorySegment __buf, MemorySegment __result) {
        var mh$ = random_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("random_r", __buf, __result);
            }
            return (int)mh$.invokeExact(__buf, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srandom_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("srandom_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static FunctionDescriptor srandom_r$descriptor() {
        return srandom_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static MethodHandle srandom_r$handle() {
        return srandom_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static MemorySegment srandom_r$address() {
        return srandom_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int srandom_r(unsigned int __seed, struct random_data *__buf)
     * }
     */
    public static int srandom_r(int __seed, MemorySegment __buf) {
        var mh$ = srandom_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srandom_r", __seed, __buf);
            }
            return (int)mh$.invokeExact(__seed, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class initstate_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("initstate_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static FunctionDescriptor initstate_r$descriptor() {
        return initstate_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static MethodHandle initstate_r$handle() {
        return initstate_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static MemorySegment initstate_r$address() {
        return initstate_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int initstate_r(unsigned int __seed, char *restrict __statebuf, size_t __statelen, struct random_data *restrict __buf)
     * }
     */
    public static int initstate_r(int __seed, MemorySegment __statebuf, long __statelen, MemorySegment __buf) {
        var mh$ = initstate_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("initstate_r", __seed, __statebuf, __statelen, __buf);
            }
            return (int)mh$.invokeExact(__seed, __statebuf, __statelen, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setstate_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("setstate_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static FunctionDescriptor setstate_r$descriptor() {
        return setstate_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static MethodHandle setstate_r$handle() {
        return setstate_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static MemorySegment setstate_r$address() {
        return setstate_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setstate_r(char *restrict __statebuf, struct random_data *restrict __buf)
     * }
     */
    public static int setstate_r(MemorySegment __statebuf, MemorySegment __buf) {
        var mh$ = setstate_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setstate_r", __statebuf, __buf);
            }
            return (int)mh$.invokeExact(__statebuf, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT    );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("rand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static FunctionDescriptor rand$descriptor() {
        return rand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static MethodHandle rand$handle() {
        return rand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static MemorySegment rand$address() {
        return rand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rand()
     * }
     */
    public static int rand() {
        var mh$ = rand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("srand");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static FunctionDescriptor srand$descriptor() {
        return srand.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static MethodHandle srand$handle() {
        return srand.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static MemorySegment srand$address() {
        return srand.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srand(unsigned int __seed)
     * }
     */
    public static void srand(int __seed) {
        var mh$ = srand.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand", __seed);
            }
            mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rand_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("rand_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static FunctionDescriptor rand_r$descriptor() {
        return rand_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static MethodHandle rand_r$handle() {
        return rand_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static MemorySegment rand_r$address() {
        return rand_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rand_r(unsigned int *__seed)
     * }
     */
    public static int rand_r(MemorySegment __seed) {
        var mh$ = rand_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rand_r", __seed);
            }
            return (int)mh$.invokeExact(__seed);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_DOUBLE    );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("drand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static FunctionDescriptor drand48$descriptor() {
        return drand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static MethodHandle drand48$handle() {
        return drand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static MemorySegment drand48$address() {
        return drand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double drand48()
     * }
     */
    public static double drand48() {
        var mh$ = drand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48");
            }
            return (double)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_DOUBLE,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("erand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor erand48$descriptor() {
        return erand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle erand48$handle() {
        return erand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment erand48$address() {
        return erand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern double erand48(unsigned short __xsubi[3])
     * }
     */
    public static double erand48(MemorySegment __xsubi) {
        var mh$ = erand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48", __xsubi);
            }
            return (double)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG    );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("lrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static FunctionDescriptor lrand48$descriptor() {
        return lrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static MethodHandle lrand48$handle() {
        return lrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static MemorySegment lrand48$address() {
        return lrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long lrand48()
     * }
     */
    public static long lrand48() {
        var mh$ = lrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("nrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor nrand48$descriptor() {
        return nrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle nrand48$handle() {
        return nrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment nrand48$address() {
        return nrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long nrand48(unsigned short __xsubi[3])
     * }
     */
    public static long nrand48(MemorySegment __xsubi) {
        var mh$ = nrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48", __xsubi);
            }
            return (long)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG    );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("mrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static FunctionDescriptor mrand48$descriptor() {
        return mrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static MethodHandle mrand48$handle() {
        return mrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static MemorySegment mrand48$address() {
        return mrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long mrand48()
     * }
     */
    public static long mrand48() {
        var mh$ = mrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48");
            }
            return (long)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("jrand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static FunctionDescriptor jrand48$descriptor() {
        return jrand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static MethodHandle jrand48$handle() {
        return jrand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static MemorySegment jrand48$address() {
        return jrand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long jrand48(unsigned short __xsubi[3])
     * }
     */
    public static long jrand48(MemorySegment __xsubi) {
        var mh$ = jrand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48", __xsubi);
            }
            return (long)mh$.invokeExact(__xsubi);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("srand48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static FunctionDescriptor srand48$descriptor() {
        return srand48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static MethodHandle srand48$handle() {
        return srand48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static MemorySegment srand48$address() {
        return srand48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void srand48(long __seedval)
     * }
     */
    public static void srand48(long __seedval) {
        var mh$ = srand48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48", __seedval);
            }
            mh$.invokeExact(__seedval);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("seed48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static FunctionDescriptor seed48$descriptor() {
        return seed48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MethodHandle seed48$handle() {
        return seed48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MemorySegment seed48$address() {
        return seed48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned short *seed48(unsigned short __seed16v[3])
     * }
     */
    public static MemorySegment seed48(MemorySegment __seed16v) {
        var mh$ = seed48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48", __seed16v);
            }
            return (MemorySegment)mh$.invokeExact(__seed16v);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("lcong48");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static FunctionDescriptor lcong48$descriptor() {
        return lcong48.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static MethodHandle lcong48$handle() {
        return lcong48.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static MemorySegment lcong48$address() {
        return lcong48.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void lcong48(unsigned short __param[7])
     * }
     */
    public static void lcong48(MemorySegment __param) {
        var mh$ = lcong48.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48", __param);
            }
            mh$.invokeExact(__param);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class drand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("drand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static FunctionDescriptor drand48_r$descriptor() {
        return drand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MethodHandle drand48_r$handle() {
        return drand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MemorySegment drand48_r$address() {
        return drand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int drand48_r(struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static int drand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = drand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("drand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class erand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("erand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static FunctionDescriptor erand48_r$descriptor() {
        return erand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MethodHandle erand48_r$handle() {
        return erand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static MemorySegment erand48_r$address() {
        return erand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int erand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, double *restrict __result)
     * }
     */
    public static int erand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = erand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("erand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("lrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor lrand48_r$descriptor() {
        return lrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle lrand48_r$handle() {
        return lrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment lrand48_r$address() {
        return lrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int lrand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = lrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lrand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class nrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("nrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor nrand48_r$descriptor() {
        return nrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle nrand48_r$handle() {
        return nrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment nrand48_r$address() {
        return nrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int nrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int nrand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = nrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("nrand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("mrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor mrand48_r$descriptor() {
        return mrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle mrand48_r$handle() {
        return mrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment mrand48_r$address() {
        return mrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mrand48_r(struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int mrand48_r(MemorySegment __buffer, MemorySegment __result) {
        var mh$ = mrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mrand48_r", __buffer, __result);
            }
            return (int)mh$.invokeExact(__buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jrand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("jrand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static FunctionDescriptor jrand48_r$descriptor() {
        return jrand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MethodHandle jrand48_r$handle() {
        return jrand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static MemorySegment jrand48_r$address() {
        return jrand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int jrand48_r(unsigned short __xsubi[3], struct drand48_data *restrict __buffer, long *restrict __result)
     * }
     */
    public static int jrand48_r(MemorySegment __xsubi, MemorySegment __buffer, MemorySegment __result) {
        var mh$ = jrand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jrand48_r", __xsubi, __buffer, __result);
            }
            return (int)mh$.invokeExact(__xsubi, __buffer, __result);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class srand48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("srand48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor srand48_r$descriptor() {
        return srand48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle srand48_r$handle() {
        return srand48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment srand48_r$address() {
        return srand48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int srand48_r(long __seedval, struct drand48_data *__buffer)
     * }
     */
    public static int srand48_r(long __seedval, MemorySegment __buffer) {
        var mh$ = srand48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("srand48_r", __seedval, __buffer);
            }
            return (int)mh$.invokeExact(__seedval, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class seed48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("seed48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor seed48_r$descriptor() {
        return seed48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle seed48_r$handle() {
        return seed48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment seed48_r$address() {
        return seed48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int seed48_r(unsigned short __seed16v[3], struct drand48_data *__buffer)
     * }
     */
    public static int seed48_r(MemorySegment __seed16v, MemorySegment __buffer) {
        var mh$ = seed48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("seed48_r", __seed16v, __buffer);
            }
            return (int)mh$.invokeExact(__seed16v, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lcong48_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("lcong48_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static FunctionDescriptor lcong48_r$descriptor() {
        return lcong48_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static MethodHandle lcong48_r$handle() {
        return lcong48_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static MemorySegment lcong48_r$address() {
        return lcong48_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int lcong48_r(unsigned short __param[7], struct drand48_data *__buffer)
     * }
     */
    public static int lcong48_r(MemorySegment __param, MemorySegment __buffer) {
        var mh$ = lcong48_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lcong48_r", __param, __buffer);
            }
            return (int)mh$.invokeExact(__param, __buffer);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT    );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("arc4random");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static FunctionDescriptor arc4random$descriptor() {
        return arc4random.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static MethodHandle arc4random$handle() {
        return arc4random.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static MemorySegment arc4random$address() {
        return arc4random.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __uint32_t arc4random()
     * }
     */
    public static int arc4random() {
        var mh$ = arc4random.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_buf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("arc4random_buf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static FunctionDescriptor arc4random_buf$descriptor() {
        return arc4random_buf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static MethodHandle arc4random_buf$handle() {
        return arc4random_buf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static MemorySegment arc4random_buf$address() {
        return arc4random_buf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void arc4random_buf(void *__buf, size_t __size)
     * }
     */
    public static void arc4random_buf(MemorySegment __buf, long __size) {
        var mh$ = arc4random_buf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_buf", __buf, __size);
            }
            mh$.invokeExact(__buf, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class arc4random_uniform {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("arc4random_uniform");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static FunctionDescriptor arc4random_uniform$descriptor() {
        return arc4random_uniform.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static MethodHandle arc4random_uniform$handle() {
        return arc4random_uniform.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static MemorySegment arc4random_uniform$address() {
        return arc4random_uniform.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern __uint32_t arc4random_uniform(__uint32_t __upper_bound)
     * }
     */
    public static int arc4random_uniform(int __upper_bound) {
        var mh$ = arc4random_uniform.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("arc4random_uniform", __upper_bound);
            }
            return (int)mh$.invokeExact(__upper_bound);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class malloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("malloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static FunctionDescriptor malloc$descriptor() {
        return malloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MethodHandle malloc$handle() {
        return malloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc$address() {
        return malloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *malloc(size_t __size)
     * }
     */
    public static MemorySegment malloc(long __size) {
        var mh$ = malloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("malloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class calloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("calloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static FunctionDescriptor calloc$descriptor() {
        return calloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MethodHandle calloc$handle() {
        return calloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment calloc$address() {
        return calloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *calloc(size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment calloc(long __nmemb, long __size) {
        var mh$ = calloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("calloc", __nmemb, __size);
            }
            return (MemorySegment)mh$.invokeExact(__nmemb, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("realloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static FunctionDescriptor realloc$descriptor() {
        return realloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MethodHandle realloc$handle() {
        return realloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc$address() {
        return realloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *realloc(void *__ptr, size_t __size)
     * }
     */
    public static MemorySegment realloc(MemorySegment __ptr, long __size) {
        var mh$ = realloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realloc", __ptr, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static FunctionDescriptor free$descriptor() {
        return free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static MethodHandle free$handle() {
        return free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static MemorySegment free$address() {
        return free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void free(void *__ptr)
     * }
     */
    public static void free(MemorySegment __ptr) {
        var mh$ = free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("free", __ptr);
            }
            mh$.invokeExact(__ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class reallocarray {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("reallocarray");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static FunctionDescriptor reallocarray$descriptor() {
        return reallocarray.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MethodHandle reallocarray$handle() {
        return reallocarray.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment reallocarray$address() {
        return reallocarray.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *reallocarray(void *__ptr, size_t __nmemb, size_t __size)
     * }
     */
    public static MemorySegment reallocarray(MemorySegment __ptr, long __nmemb, long __size) {
        var mh$ = reallocarray.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("reallocarray", __ptr, __nmemb, __size);
            }
            return (MemorySegment)mh$.invokeExact(__ptr, __nmemb, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class alloca {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("alloca");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static FunctionDescriptor alloca$descriptor() {
        return alloca.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MethodHandle alloca$handle() {
        return alloca.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca$address() {
        return alloca.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *alloca(size_t __size)
     * }
     */
    public static MemorySegment alloca(long __size) {
        var mh$ = alloca.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("alloca", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class valloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("valloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static FunctionDescriptor valloc$descriptor() {
        return valloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MethodHandle valloc$handle() {
        return valloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc$address() {
        return valloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *valloc(size_t __size)
     * }
     */
    public static MemorySegment valloc(long __size) {
        var mh$ = valloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("valloc", __size);
            }
            return (MemorySegment)mh$.invokeExact(__size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class posix_memalign {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("posix_memalign");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor posix_memalign$descriptor() {
        return posix_memalign.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle posix_memalign$handle() {
        return posix_memalign.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment posix_memalign$address() {
        return posix_memalign.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int posix_memalign(void **__memptr, size_t __alignment, size_t __size)
     * }
     */
    public static int posix_memalign(MemorySegment __memptr, long __alignment, long __size) {
        var mh$ = posix_memalign.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("posix_memalign", __memptr, __alignment, __size);
            }
            return (int)mh$.invokeExact(__memptr, __alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aligned_alloc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("aligned_alloc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static FunctionDescriptor aligned_alloc$descriptor() {
        return aligned_alloc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MethodHandle aligned_alloc$handle() {
        return aligned_alloc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc$address() {
        return aligned_alloc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *aligned_alloc(size_t __alignment, size_t __size)
     * }
     */
    public static MemorySegment aligned_alloc(long __alignment, long __size) {
        var mh$ = aligned_alloc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aligned_alloc", __alignment, __size);
            }
            return (MemorySegment)mh$.invokeExact(__alignment, __size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(    );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("abort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static FunctionDescriptor abort$descriptor() {
        return abort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static MethodHandle abort$handle() {
        return abort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static MemorySegment abort$address() {
        return abort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void abort()
     * }
     */
    public static void abort() {
        var mh$ = abort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abort");
            }
            mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class atexit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("atexit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor atexit$descriptor() {
        return atexit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static MethodHandle atexit$handle() {
        return atexit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static MemorySegment atexit$address() {
        return atexit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int atexit(void (*__func)(void))
     * }
     */
    public static int atexit(MemorySegment __func) {
        var mh$ = atexit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("atexit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class at_quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("at_quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static FunctionDescriptor at_quick_exit$descriptor() {
        return at_quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static MethodHandle at_quick_exit$handle() {
        return at_quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static MemorySegment at_quick_exit$address() {
        return at_quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int at_quick_exit(void (*__func)(void))
     * }
     */
    public static int at_quick_exit(MemorySegment __func) {
        var mh$ = at_quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("at_quick_exit", __func);
            }
            return (int)mh$.invokeExact(__func);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class on_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("on_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static FunctionDescriptor on_exit$descriptor() {
        return on_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static MethodHandle on_exit$handle() {
        return on_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static MemorySegment on_exit$address() {
        return on_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int on_exit(void (*__func)(int, void *), void *__arg)
     * }
     */
    public static int on_exit(MemorySegment __func, MemorySegment __arg) {
        var mh$ = on_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("on_exit", __func, __arg);
            }
            return (int)mh$.invokeExact(__func, __arg);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static FunctionDescriptor exit$descriptor() {
        return exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static MethodHandle exit$handle() {
        return exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static MemorySegment exit$address() {
        return exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void exit(int __status)
     * }
     */
    public static void exit(int __status) {
        var mh$ = exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class quick_exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("quick_exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static FunctionDescriptor quick_exit$descriptor() {
        return quick_exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static MethodHandle quick_exit$handle() {
        return quick_exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static MemorySegment quick_exit$address() {
        return quick_exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void quick_exit(int __status)
     * }
     */
    public static void quick_exit(int __status) {
        var mh$ = quick_exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("quick_exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class _Exit {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("_Exit");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static FunctionDescriptor _Exit$descriptor() {
        return _Exit.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static MethodHandle _Exit$handle() {
        return _Exit.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static MemorySegment _Exit$address() {
        return _Exit.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void _Exit(int __status)
     * }
     */
    public static void _Exit(int __status) {
        var mh$ = _Exit.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("_Exit", __status);
            }
            mh$.invokeExact(__status);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("getenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static FunctionDescriptor getenv$descriptor() {
        return getenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MethodHandle getenv$handle() {
        return getenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MemorySegment getenv$address() {
        return getenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *getenv(const char *__name)
     * }
     */
    public static MemorySegment getenv(MemorySegment __name) {
        var mh$ = getenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getenv", __name);
            }
            return (MemorySegment)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class putenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("putenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static FunctionDescriptor putenv$descriptor() {
        return putenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static MethodHandle putenv$handle() {
        return putenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static MemorySegment putenv$address() {
        return putenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int putenv(char *__string)
     * }
     */
    public static int putenv(MemorySegment __string) {
        var mh$ = putenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("putenv", __string);
            }
            return (int)mh$.invokeExact(__string);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class setenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("setenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static FunctionDescriptor setenv$descriptor() {
        return setenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static MethodHandle setenv$handle() {
        return setenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static MemorySegment setenv$address() {
        return setenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int setenv(const char *__name, const char *__value, int __replace)
     * }
     */
    public static int setenv(MemorySegment __name, MemorySegment __value, int __replace) {
        var mh$ = setenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("setenv", __name, __value, __replace);
            }
            return (int)mh$.invokeExact(__name, __value, __replace);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class unsetenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("unsetenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static FunctionDescriptor unsetenv$descriptor() {
        return unsetenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static MethodHandle unsetenv$handle() {
        return unsetenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static MemorySegment unsetenv$address() {
        return unsetenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int unsetenv(const char *__name)
     * }
     */
    public static int unsetenv(MemorySegment __name) {
        var mh$ = unsetenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("unsetenv", __name);
            }
            return (int)mh$.invokeExact(__name);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class clearenv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT    );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("clearenv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static FunctionDescriptor clearenv$descriptor() {
        return clearenv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static MethodHandle clearenv$handle() {
        return clearenv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static MemorySegment clearenv$address() {
        return clearenv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int clearenv()
     * }
     */
    public static int clearenv() {
        var mh$ = clearenv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("clearenv");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mktemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("mktemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static FunctionDescriptor mktemp$descriptor() {
        return mktemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MethodHandle mktemp$handle() {
        return mktemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MemorySegment mktemp$address() {
        return mktemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *mktemp(char *__template)
     * }
     */
    public static MemorySegment mktemp(MemorySegment __template) {
        var mh$ = mktemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mktemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("mkstemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkstemp$descriptor() {
        return mkstemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static MethodHandle mkstemp$handle() {
        return mkstemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static MemorySegment mkstemp$address() {
        return mkstemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkstemp(char *__template)
     * }
     */
    public static int mkstemp(MemorySegment __template) {
        var mh$ = mkstemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemp", __template);
            }
            return (int)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkstemps {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("mkstemps");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static FunctionDescriptor mkstemps$descriptor() {
        return mkstemps.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static MethodHandle mkstemps$handle() {
        return mkstemps.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static MemorySegment mkstemps$address() {
        return mkstemps.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mkstemps(char *__template, int __suffixlen)
     * }
     */
    public static int mkstemps(MemorySegment __template, int __suffixlen) {
        var mh$ = mkstemps.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkstemps", __template, __suffixlen);
            }
            return (int)mh$.invokeExact(__template, __suffixlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mkdtemp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("mkdtemp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static FunctionDescriptor mkdtemp$descriptor() {
        return mkdtemp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MethodHandle mkdtemp$handle() {
        return mkdtemp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MemorySegment mkdtemp$address() {
        return mkdtemp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *mkdtemp(char *__template)
     * }
     */
    public static MemorySegment mkdtemp(MemorySegment __template) {
        var mh$ = mkdtemp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mkdtemp", __template);
            }
            return (MemorySegment)mh$.invokeExact(__template);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class system {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("system");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static FunctionDescriptor system$descriptor() {
        return system.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static MethodHandle system$handle() {
        return system.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static MemorySegment system$address() {
        return system.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int system(const char *__command)
     * }
     */
    public static int system(MemorySegment __command) {
        var mh$ = system.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("system", __command);
            }
            return (int)mh$.invokeExact(__command);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class realpath {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("realpath");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static FunctionDescriptor realpath$descriptor() {
        return realpath.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MethodHandle realpath$handle() {
        return realpath.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MemorySegment realpath$address() {
        return realpath.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *realpath(const char *restrict __name, char *restrict __resolved)
     * }
     */
    public static MemorySegment realpath(MemorySegment __name, MemorySegment __resolved) {
        var mh$ = realpath.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("realpath", __name, __resolved);
            }
            return (MemorySegment)mh$.invokeExact(__name, __resolved);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bsearch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("bsearch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor bsearch$descriptor() {
        return bsearch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle bsearch$handle() {
        return bsearch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment bsearch$address() {
        return bsearch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *bsearch(const void *__key, const void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment bsearch(MemorySegment __key, MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = bsearch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bsearch", __key, __base, __nmemb, __size, __compar);
            }
            return (MemorySegment)mh$.invokeExact(__key, __base, __nmemb, __size, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class qsort {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("qsort");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static FunctionDescriptor qsort$descriptor() {
        return qsort.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MethodHandle qsort$handle() {
        return qsort.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static MemorySegment qsort$address() {
        return qsort.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void qsort(void *__base, size_t __nmemb, size_t __size, __compar_fn_t __compar)
     * }
     */
    public static void qsort(MemorySegment __base, long __nmemb, long __size, MemorySegment __compar) {
        var mh$ = qsort.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("qsort", __base, __nmemb, __size, __compar);
            }
            mh$.invokeExact(__base, __nmemb, __size, __compar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class abs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("abs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static FunctionDescriptor abs$descriptor() {
        return abs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static MethodHandle abs$handle() {
        return abs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static MemorySegment abs$address() {
        return abs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int abs(int __x)
     * }
     */
    public static int abs(int __x) {
        var mh$ = abs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("abs", __x);
            }
            return (int)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class labs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("labs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static FunctionDescriptor labs$descriptor() {
        return labs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static MethodHandle labs$handle() {
        return labs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static MemorySegment labs$address() {
        return labs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long labs(long __x)
     * }
     */
    public static long labs(long __x) {
        var mh$ = labs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("labs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class llabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG_LONG,
            MessageFrame_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("llabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static FunctionDescriptor llabs$descriptor() {
        return llabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static MethodHandle llabs$handle() {
        return llabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static MemorySegment llabs$address() {
        return llabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern long long llabs(long long __x)
     * }
     */
    public static long llabs(long __x) {
        var mh$ = llabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("llabs", __x);
            }
            return (long)mh$.invokeExact(__x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class div {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            div_t.layout(),
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("div");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static FunctionDescriptor div$descriptor() {
        return div.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MethodHandle div$handle() {
        return div.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MemorySegment div$address() {
        return div.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern div_t div(int __numer, int __denom)
     * }
     */
    public static MemorySegment div(SegmentAllocator allocator, int __numer, int __denom) {
        var mh$ = div.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("div", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            ldiv_t.layout(),
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static FunctionDescriptor ldiv$descriptor() {
        return ldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MethodHandle ldiv$handle() {
        return ldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MemorySegment ldiv$address() {
        return ldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern ldiv_t ldiv(long __numer, long __denom)
     * }
     */
    public static MemorySegment ldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = ldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class lldiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            lldiv_t.layout(),
            MessageFrame_h.C_LONG_LONG,
            MessageFrame_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("lldiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static FunctionDescriptor lldiv$descriptor() {
        return lldiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MethodHandle lldiv$handle() {
        return lldiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MemorySegment lldiv$address() {
        return lldiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern lldiv_t lldiv(long long __numer, long long __denom)
     * }
     */
    public static MemorySegment lldiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = lldiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("lldiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_DOUBLE,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ecvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor ecvt$descriptor() {
        return ecvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle ecvt$handle() {
        return ecvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment ecvt$address() {
        return ecvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *ecvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment ecvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = ecvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_DOUBLE,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static FunctionDescriptor fcvt$descriptor() {
        return fcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MethodHandle fcvt$handle() {
        return fcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment fcvt$address() {
        return fcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *fcvt(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign)
     * }
     */
    public static MemorySegment fcvt(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign) {
        var mh$ = fcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt", __value, __ndigit, __decpt, __sign);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __decpt, __sign);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class gcvt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_DOUBLE,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("gcvt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static FunctionDescriptor gcvt$descriptor() {
        return gcvt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MethodHandle gcvt$handle() {
        return gcvt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MemorySegment gcvt$address() {
        return gcvt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *gcvt(double __value, int __ndigit, char *__buf)
     * }
     */
    public static MemorySegment gcvt(double __value, int __ndigit, MemorySegment __buf) {
        var mh$ = gcvt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("gcvt", __value, __ndigit, __buf);
            }
            return (MemorySegment)mh$.invokeExact(__value, __ndigit, __buf);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ecvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_DOUBLE,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ecvt_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor ecvt_r$descriptor() {
        return ecvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle ecvt_r$handle() {
        return ecvt_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment ecvt_r$address() {
        return ecvt_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ecvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int ecvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = ecvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ecvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class fcvt_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_DOUBLE,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("fcvt_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static FunctionDescriptor fcvt_r$descriptor() {
        return fcvt_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MethodHandle fcvt_r$handle() {
        return fcvt_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static MemorySegment fcvt_r$address() {
        return fcvt_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int fcvt_r(double __value, int __ndigit, int *restrict __decpt, int *restrict __sign, char *restrict __buf, size_t __len)
     * }
     */
    public static int fcvt_r(double __value, int __ndigit, MemorySegment __decpt, MemorySegment __sign, MemorySegment __buf, long __len) {
        var mh$ = fcvt_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("fcvt_r", __value, __ndigit, __decpt, __sign, __buf, __len);
            }
            return (int)mh$.invokeExact(__value, __ndigit, __decpt, __sign, __buf, __len);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mblen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("mblen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor mblen$descriptor() {
        return mblen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static MethodHandle mblen$handle() {
        return mblen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static MemorySegment mblen$address() {
        return mblen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mblen(const char *__s, size_t __n)
     * }
     */
    public static int mblen(MemorySegment __s, long __n) {
        var mh$ = mblen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mblen", __s, __n);
            }
            return (int)mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbtowc {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("mbtowc");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbtowc$descriptor() {
        return mbtowc.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbtowc$handle() {
        return mbtowc.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static MemorySegment mbtowc$address() {
        return mbtowc.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int mbtowc(wchar_t *restrict __pwc, const char *restrict __s, size_t __n)
     * }
     */
    public static int mbtowc(MemorySegment __pwc, MemorySegment __s, long __n) {
        var mh$ = mbtowc.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbtowc", __pwc, __s, __n);
            }
            return (int)mh$.invokeExact(__pwc, __s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wctomb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("wctomb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static FunctionDescriptor wctomb$descriptor() {
        return wctomb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static MethodHandle wctomb$handle() {
        return wctomb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static MemorySegment wctomb$address() {
        return wctomb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int wctomb(char *__s, wchar_t __wchar)
     * }
     */
    public static int wctomb(MemorySegment __s, int __wchar) {
        var mh$ = wctomb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wctomb", __s, __wchar);
            }
            return (int)mh$.invokeExact(__s, __wchar);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mbstowcs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("mbstowcs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static FunctionDescriptor mbstowcs$descriptor() {
        return mbstowcs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static MethodHandle mbstowcs$handle() {
        return mbstowcs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static MemorySegment mbstowcs$address() {
        return mbstowcs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t mbstowcs(wchar_t *restrict __pwcs, const char *restrict __s, size_t __n)
     * }
     */
    public static long mbstowcs(MemorySegment __pwcs, MemorySegment __s, long __n) {
        var mh$ = mbstowcs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mbstowcs", __pwcs, __s, __n);
            }
            return (long)mh$.invokeExact(__pwcs, __s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstombs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("wcstombs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static FunctionDescriptor wcstombs$descriptor() {
        return wcstombs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static MethodHandle wcstombs$handle() {
        return wcstombs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static MemorySegment wcstombs$address() {
        return wcstombs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t wcstombs(char *restrict __s, const wchar_t *restrict __pwcs, size_t __n)
     * }
     */
    public static long wcstombs(MemorySegment __s, MemorySegment __pwcs, long __n) {
        var mh$ = wcstombs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstombs", __s, __pwcs, __n);
            }
            return (long)mh$.invokeExact(__s, __pwcs, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rpmatch {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("rpmatch");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static FunctionDescriptor rpmatch$descriptor() {
        return rpmatch.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static MethodHandle rpmatch$handle() {
        return rpmatch.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static MemorySegment rpmatch$address() {
        return rpmatch.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int rpmatch(const char *__response)
     * }
     */
    public static int rpmatch(MemorySegment __response) {
        var mh$ = rpmatch.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rpmatch", __response);
            }
            return (int)mh$.invokeExact(__response);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getsubopt {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("getsubopt");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static FunctionDescriptor getsubopt$descriptor() {
        return getsubopt.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static MethodHandle getsubopt$handle() {
        return getsubopt.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static MemorySegment getsubopt$address() {
        return getsubopt.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getsubopt(char **restrict __optionp, char *const *restrict __tokens, char **restrict __valuep)
     * }
     */
    public static int getsubopt(MemorySegment __optionp, MemorySegment __tokens, MemorySegment __valuep) {
        var mh$ = getsubopt.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getsubopt", __optionp, __tokens, __valuep);
            }
            return (int)mh$.invokeExact(__optionp, __tokens, __valuep);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class getloadavg {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("getloadavg");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static FunctionDescriptor getloadavg$descriptor() {
        return getloadavg.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static MethodHandle getloadavg$handle() {
        return getloadavg.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static MemorySegment getloadavg$address() {
        return getloadavg.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int getloadavg(double __loadavg[], int __nelem)
     * }
     */
    public static int getloadavg(MemorySegment __loadavg, int __nelem) {
        var mh$ = getloadavg.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("getloadavg", __loadavg, __nelem);
            }
            return (int)mh$.invokeExact(__loadavg, __nelem);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("memcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor memcpy$descriptor() {
        return memcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle memcpy$handle() {
        return memcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment memcpy$address() {
        return memcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment memcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = memcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmove {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("memmove");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static FunctionDescriptor memmove$descriptor() {
        return memmove.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static MethodHandle memmove$handle() {
        return memmove.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memmove$address() {
        return memmove.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memmove(void *__dest, const void *__src, size_t __n)
     * }
     */
    public static MemorySegment memmove(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = memmove.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmove", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memccpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("memccpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memccpy$descriptor() {
        return memccpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static MethodHandle memccpy$handle() {
        return memccpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy$address() {
        return memccpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memccpy(void *restrict __dest, const void *restrict __src, int __c, size_t __n)
     * }
     */
    public static MemorySegment memccpy(MemorySegment __dest, MemorySegment __src, int __c, long __n) {
        var mh$ = memccpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memccpy", __dest, __src, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memset {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("memset");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memset$descriptor() {
        return memset.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memset$handle() {
        return memset.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memset$address() {
        return memset.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memset(void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memset(MemorySegment __s, int __c, long __n) {
        var mh$ = memset.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memset", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("memcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor memcmp$descriptor() {
        return memcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle memcmp$handle() {
        return memcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment memcmp$address() {
        return memcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int memcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int memcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = memcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __memcmpeq {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("__memcmpeq");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor __memcmpeq$descriptor() {
        return __memcmpeq.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle __memcmpeq$handle() {
        return __memcmpeq.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment __memcmpeq$address() {
        return __memcmpeq.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int __memcmpeq(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int __memcmpeq(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = __memcmpeq.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__memcmpeq", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("memchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static FunctionDescriptor memchr$descriptor() {
        return memchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MethodHandle memchr$handle() {
        return memchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr$address() {
        return memchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memchr(const void *__s, int __c, size_t __n)
     * }
     */
    public static MemorySegment memchr(MemorySegment __s, int __c, long __n) {
        var mh$ = memchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memchr", __s, __c, __n);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor strcpy$descriptor() {
        return strcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle strcpy$handle() {
        return strcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcpy$address() {
        return strcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = strcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncpy$descriptor() {
        return strncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strncpy$handle() {
        return strncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncpy$address() {
        return strncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor strcat$descriptor() {
        return strcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle strcat$handle() {
        return strcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcat$address() {
        return strcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strcat(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment strcat(MemorySegment __dest, MemorySegment __src) {
        var mh$ = strcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcat", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strncat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strncat$descriptor() {
        return strncat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strncat$handle() {
        return strncat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncat$address() {
        return strncat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strncat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strncat(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strncat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncat", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcmp$descriptor() {
        return strcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcmp$handle() {
        return strcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcmp$address() {
        return strcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strncmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncmp$descriptor() {
        return strncmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncmp$handle() {
        return strncmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncmp$address() {
        return strncmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strncmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcoll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strcoll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcoll$descriptor() {
        return strcoll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcoll$handle() {
        return strcoll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcoll$address() {
        return strcoll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcoll(const char *__s1, const char *__s2)
     * }
     */
    public static int strcoll(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcoll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strxfrm");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strxfrm$descriptor() {
        return strxfrm.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strxfrm$handle() {
        return strxfrm.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strxfrm$address() {
        return strxfrm.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strxfrm(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static long strxfrm(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strxfrm.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm", __dest, __src, __n);
            }
            return (long)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef struct __locale_struct {
     *     struct __locale_data *__locales[13];
     *     const unsigned short *__ctype_b;
     *     const int *__ctype_tolower;
     *     const int *__ctype_toupper;
     *     const char *__names[13];
     * } *__locale_t
     * }
     */
    public static final AddressLayout __locale_t = MessageFrame_h.C_POINTER;
    /**
     * {@snippet lang=c :
     * typedef __locale_t locale_t
     * }
     */
    public static final AddressLayout locale_t = MessageFrame_h.C_POINTER;

    private static class strcoll_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strcoll_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static FunctionDescriptor strcoll_l$descriptor() {
        return strcoll_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static MethodHandle strcoll_l$handle() {
        return strcoll_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static MemorySegment strcoll_l$address() {
        return strcoll_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcoll_l(const char *__s1, const char *__s2, locale_t __l)
     * }
     */
    public static int strcoll_l(MemorySegment __s1, MemorySegment __s2, MemorySegment __l) {
        var mh$ = strcoll_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcoll_l", __s1, __s2, __l);
            }
            return (int)mh$.invokeExact(__s1, __s2, __l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strxfrm_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strxfrm_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static FunctionDescriptor strxfrm_l$descriptor() {
        return strxfrm_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static MethodHandle strxfrm_l$handle() {
        return strxfrm_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static MemorySegment strxfrm_l$address() {
        return strxfrm_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strxfrm_l(char *__dest, const char *__src, size_t __n, locale_t __l)
     * }
     */
    public static long strxfrm_l(MemorySegment __dest, MemorySegment __src, long __n, MemorySegment __l) {
        var mh$ = strxfrm_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strxfrm_l", __dest, __src, __n, __l);
            }
            return (long)mh$.invokeExact(__dest, __src, __n, __l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strdup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strdup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static FunctionDescriptor strdup$descriptor() {
        return strdup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static MethodHandle strdup$handle() {
        return strdup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static MemorySegment strdup$address() {
        return strdup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strdup(const char *__s)
     * }
     */
    public static MemorySegment strdup(MemorySegment __s) {
        var mh$ = strdup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strdup", __s);
            }
            return (MemorySegment)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strndup {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strndup");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static FunctionDescriptor strndup$descriptor() {
        return strndup.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static MethodHandle strndup$handle() {
        return strndup.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static MemorySegment strndup$address() {
        return strndup.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strndup(const char *__string, size_t __n)
     * }
     */
    public static MemorySegment strndup(MemorySegment __string, long __n) {
        var mh$ = strndup.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strndup", __string, __n);
            }
            return (MemorySegment)mh$.invokeExact(__string, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchr$descriptor() {
        return strchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchr$handle() {
        return strchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr$address() {
        return strchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchr(MemorySegment __s, int __c) {
        var mh$ = strchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strrchr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strrchr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strrchr$descriptor() {
        return strrchr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static MethodHandle strrchr$handle() {
        return strrchr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr$address() {
        return strrchr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strrchr(const char *__s, int __c)
     * }
     */
    public static MemorySegment strrchr(MemorySegment __s, int __c) {
        var mh$ = strrchr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strrchr", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strchrnul {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strchrnul");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strchrnul(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor strchrnul$descriptor() {
        return strchrnul.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strchrnul(const char *__s, int __c)
     * }
     */
    public static MethodHandle strchrnul$handle() {
        return strchrnul.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strchrnul(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchrnul$address() {
        return strchrnul.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strchrnul(const char *__s, int __c)
     * }
     */
    public static MemorySegment strchrnul(MemorySegment __s, int __c) {
        var mh$ = strchrnul.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strchrnul", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strcspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static FunctionDescriptor strcspn$descriptor() {
        return strcspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static MethodHandle strcspn$handle() {
        return strcspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static MemorySegment strcspn$address() {
        return strcspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strcspn(const char *__s, const char *__reject)
     * }
     */
    public static long strcspn(MemorySegment __s, MemorySegment __reject) {
        var mh$ = strcspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcspn", __s, __reject);
            }
            return (long)mh$.invokeExact(__s, __reject);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strspn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strspn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static FunctionDescriptor strspn$descriptor() {
        return strspn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static MethodHandle strspn$handle() {
        return strspn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static MemorySegment strspn$address() {
        return strspn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strspn(const char *__s, const char *__accept)
     * }
     */
    public static long strspn(MemorySegment __s, MemorySegment __accept) {
        var mh$ = strspn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strspn", __s, __accept);
            }
            return (long)mh$.invokeExact(__s, __accept);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strpbrk {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strpbrk");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static FunctionDescriptor strpbrk$descriptor() {
        return strpbrk.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static MethodHandle strpbrk$handle() {
        return strpbrk.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static MemorySegment strpbrk$address() {
        return strpbrk.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strpbrk(const char *__s, const char *__accept)
     * }
     */
    public static MemorySegment strpbrk(MemorySegment __s, MemorySegment __accept) {
        var mh$ = strpbrk.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strpbrk", __s, __accept);
            }
            return (MemorySegment)mh$.invokeExact(__s, __accept);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strstr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strstr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static FunctionDescriptor strstr$descriptor() {
        return strstr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static MethodHandle strstr$handle() {
        return strstr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strstr$address() {
        return strstr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strstr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strstr(MemorySegment __haystack, MemorySegment __needle) {
        var mh$ = strstr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strstr", __haystack, __needle);
            }
            return (MemorySegment)mh$.invokeExact(__haystack, __needle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strtok");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static FunctionDescriptor strtok$descriptor() {
        return strtok.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static MethodHandle strtok$handle() {
        return strtok.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static MemorySegment strtok$address() {
        return strtok.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strtok(char *restrict __s, const char *restrict __delim)
     * }
     */
    public static MemorySegment strtok(MemorySegment __s, MemorySegment __delim) {
        var mh$ = strtok.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok", __s, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("__strtok_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static FunctionDescriptor __strtok_r$descriptor() {
        return __strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MethodHandle __strtok_r$handle() {
        return __strtok_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment __strtok_r$address() {
        return __strtok_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *__strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment __strtok_r(MemorySegment __s, MemorySegment __delim, MemorySegment __save_ptr) {
        var mh$ = __strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__strtok_r", __s, __delim, __save_ptr);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim, __save_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtok_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strtok_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static FunctionDescriptor strtok_r$descriptor() {
        return strtok_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MethodHandle strtok_r$handle() {
        return strtok_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment strtok_r$address() {
        return strtok_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strtok_r(char *restrict __s, const char *restrict __delim, char **restrict __save_ptr)
     * }
     */
    public static MemorySegment strtok_r(MemorySegment __s, MemorySegment __delim, MemorySegment __save_ptr) {
        var mh$ = strtok_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtok_r", __s, __delim, __save_ptr);
            }
            return (MemorySegment)mh$.invokeExact(__s, __delim, __save_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasestr {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strcasestr");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strcasestr(const char *__haystack, const char *__needle)
     * }
     */
    public static FunctionDescriptor strcasestr$descriptor() {
        return strcasestr.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strcasestr(const char *__haystack, const char *__needle)
     * }
     */
    public static MethodHandle strcasestr$handle() {
        return strcasestr.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strcasestr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strcasestr$address() {
        return strcasestr.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strcasestr(const char *__haystack, const char *__needle)
     * }
     */
    public static MemorySegment strcasestr(MemorySegment __haystack, MemorySegment __needle) {
        var mh$ = strcasestr.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasestr", __haystack, __needle);
            }
            return (MemorySegment)mh$.invokeExact(__haystack, __needle);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class memmem {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("memmem");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *memmem(const void *__haystack, size_t __haystacklen, const void *__needle, size_t __needlelen)
     * }
     */
    public static FunctionDescriptor memmem$descriptor() {
        return memmem.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *memmem(const void *__haystack, size_t __haystacklen, const void *__needle, size_t __needlelen)
     * }
     */
    public static MethodHandle memmem$handle() {
        return memmem.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *memmem(const void *__haystack, size_t __haystacklen, const void *__needle, size_t __needlelen)
     * }
     */
    public static MemorySegment memmem$address() {
        return memmem.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *memmem(const void *__haystack, size_t __haystacklen, const void *__needle, size_t __needlelen)
     * }
     */
    public static MemorySegment memmem(MemorySegment __haystack, long __haystacklen, MemorySegment __needle, long __needlelen) {
        var mh$ = memmem.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("memmem", __haystack, __haystacklen, __needle, __needlelen);
            }
            return (MemorySegment)mh$.invokeExact(__haystack, __haystacklen, __needle, __needlelen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __mempcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("__mempcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *__mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor __mempcpy$descriptor() {
        return __mempcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *__mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle __mempcpy$handle() {
        return __mempcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *__mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __mempcpy$address() {
        return __mempcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *__mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __mempcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = __mempcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__mempcpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class mempcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("mempcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void *mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor mempcpy$descriptor() {
        return mempcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void *mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle mempcpy$handle() {
        return mempcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void *mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment mempcpy$address() {
        return mempcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void *mempcpy(void *restrict __dest, const void *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment mempcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = mempcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("mempcpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static FunctionDescriptor strlen$descriptor() {
        return strlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static MethodHandle strlen$handle() {
        return strlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static MemorySegment strlen$address() {
        return strlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strlen(const char *__s)
     * }
     */
    public static long strlen(MemorySegment __s) {
        var mh$ = strlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlen", __s);
            }
            return (long)mh$.invokeExact(__s);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strnlen {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strnlen");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static FunctionDescriptor strnlen$descriptor() {
        return strnlen.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static MethodHandle strnlen$handle() {
        return strnlen.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static MemorySegment strnlen$address() {
        return strnlen.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern size_t strnlen(const char *__string, size_t __maxlen)
     * }
     */
    public static long strnlen(MemorySegment __string, long __maxlen) {
        var mh$ = strnlen.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strnlen", __string, __maxlen);
            }
            return (long)mh$.invokeExact(__string, __maxlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strerror");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static FunctionDescriptor strerror$descriptor() {
        return strerror.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static MethodHandle strerror$handle() {
        return strerror.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror$address() {
        return strerror.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strerror(int __errnum)
     * }
     */
    public static MemorySegment strerror(int __errnum) {
        var mh$ = strerror.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror", __errnum);
            }
            return (MemorySegment)mh$.invokeExact(__errnum);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_r {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("__xpg_strerror_r");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static FunctionDescriptor strerror_r$descriptor() {
        return strerror_r.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static MethodHandle strerror_r$handle() {
        return strerror_r.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static MemorySegment strerror_r$address() {
        return strerror_r.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strerror_r(int __errnum, char *__buf, size_t __buflen)
     * }
     */
    public static int strerror_r(int __errnum, MemorySegment __buf, long __buflen) {
        var mh$ = strerror_r.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_r", __errnum, __buf, __buflen);
            }
            return (int)mh$.invokeExact(__errnum, __buf, __buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strerror_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strerror_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static FunctionDescriptor strerror_l$descriptor() {
        return strerror_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static MethodHandle strerror_l$handle() {
        return strerror_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static MemorySegment strerror_l$address() {
        return strerror_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strerror_l(int __errnum, locale_t __l)
     * }
     */
    public static MemorySegment strerror_l(int __errnum, MemorySegment __l) {
        var mh$ = strerror_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strerror_l", __errnum, __l);
            }
            return (MemorySegment)mh$.invokeExact(__errnum, __l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("bcmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor bcmp$descriptor() {
        return bcmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MethodHandle bcmp$handle() {
        return bcmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static MemorySegment bcmp$address() {
        return bcmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int bcmp(const void *__s1, const void *__s2, size_t __n)
     * }
     */
    public static int bcmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = bcmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bcopy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("bcopy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static FunctionDescriptor bcopy$descriptor() {
        return bcopy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static MethodHandle bcopy$handle() {
        return bcopy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static MemorySegment bcopy$address() {
        return bcopy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void bcopy(const void *__src, void *__dest, size_t __n)
     * }
     */
    public static void bcopy(MemorySegment __src, MemorySegment __dest, long __n) {
        var mh$ = bcopy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bcopy", __src, __dest, __n);
            }
            mh$.invokeExact(__src, __dest, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class bzero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("bzero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor bzero$descriptor() {
        return bzero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static MethodHandle bzero$handle() {
        return bzero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static MemorySegment bzero$address() {
        return bzero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void bzero(void *__s, size_t __n)
     * }
     */
    public static void bzero(MemorySegment __s, long __n) {
        var mh$ = bzero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("bzero", __s, __n);
            }
            mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class index {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("index");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor index$descriptor() {
        return index.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static MethodHandle index$handle() {
        return index.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static MemorySegment index$address() {
        return index.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *index(const char *__s, int __c)
     * }
     */
    public static MemorySegment index(MemorySegment __s, int __c) {
        var mh$ = index.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("index", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class rindex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("rindex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static FunctionDescriptor rindex$descriptor() {
        return rindex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static MethodHandle rindex$handle() {
        return rindex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static MemorySegment rindex$address() {
        return rindex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *rindex(const char *__s, int __c)
     * }
     */
    public static MemorySegment rindex(MemorySegment __s, int __c) {
        var mh$ = rindex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("rindex", __s, __c);
            }
            return (MemorySegment)mh$.invokeExact(__s, __c);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ffs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static FunctionDescriptor ffs$descriptor() {
        return ffs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static MethodHandle ffs$handle() {
        return ffs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static MemorySegment ffs$address() {
        return ffs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ffs(int __i)
     * }
     */
    public static int ffs(int __i) {
        var mh$ = ffs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffs", __i);
            }
            return (int)mh$.invokeExact(__i);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsl {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ffsl");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static FunctionDescriptor ffsl$descriptor() {
        return ffsl.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static MethodHandle ffsl$handle() {
        return ffsl.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static MemorySegment ffsl$address() {
        return ffsl.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ffsl(long __l)
     * }
     */
    public static int ffsl(long __l) {
        var mh$ = ffsl.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsl", __l);
            }
            return (int)mh$.invokeExact(__l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ffsll {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_LONG_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ffsll");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static FunctionDescriptor ffsll$descriptor() {
        return ffsll.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static MethodHandle ffsll$handle() {
        return ffsll.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static MemorySegment ffsll$address() {
        return ffsll.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int ffsll(long long __ll)
     * }
     */
    public static int ffsll(long __ll) {
        var mh$ = ffsll.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ffsll", __ll);
            }
            return (int)mh$.invokeExact(__ll);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strcasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static FunctionDescriptor strcasecmp$descriptor() {
        return strcasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static MethodHandle strcasecmp$handle() {
        return strcasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static MemorySegment strcasecmp$address() {
        return strcasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcasecmp(const char *__s1, const char *__s2)
     * }
     */
    public static int strcasecmp(MemorySegment __s1, MemorySegment __s2) {
        var mh$ = strcasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasecmp", __s1, __s2);
            }
            return (int)mh$.invokeExact(__s1, __s2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncasecmp {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strncasecmp");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static FunctionDescriptor strncasecmp$descriptor() {
        return strncasecmp.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MethodHandle strncasecmp$handle() {
        return strncasecmp.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static MemorySegment strncasecmp$address() {
        return strncasecmp.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strncasecmp(const char *__s1, const char *__s2, size_t __n)
     * }
     */
    public static int strncasecmp(MemorySegment __s1, MemorySegment __s2, long __n) {
        var mh$ = strncasecmp.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncasecmp", __s1, __s2, __n);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strcasecmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strcasecmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strcasecmp_l$descriptor() {
        return strcasecmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static MethodHandle strcasecmp_l$handle() {
        return strcasecmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static MemorySegment strcasecmp_l$address() {
        return strcasecmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strcasecmp_l(const char *__s1, const char *__s2, locale_t __loc)
     * }
     */
    public static int strcasecmp_l(MemorySegment __s1, MemorySegment __s2, MemorySegment __loc) {
        var mh$ = strcasecmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strcasecmp_l", __s1, __s2, __loc);
            }
            return (int)mh$.invokeExact(__s1, __s2, __loc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strncasecmp_l {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strncasecmp_l");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static FunctionDescriptor strncasecmp_l$descriptor() {
        return strncasecmp_l.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static MethodHandle strncasecmp_l$handle() {
        return strncasecmp_l.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static MemorySegment strncasecmp_l$address() {
        return strncasecmp_l.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern int strncasecmp_l(const char *__s1, const char *__s2, size_t __n, locale_t __loc)
     * }
     */
    public static int strncasecmp_l(MemorySegment __s1, MemorySegment __s2, long __n, MemorySegment __loc) {
        var mh$ = strncasecmp_l.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strncasecmp_l", __s1, __s2, __n, __loc);
            }
            return (int)mh$.invokeExact(__s1, __s2, __n, __loc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class explicit_bzero {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("explicit_bzero");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static FunctionDescriptor explicit_bzero$descriptor() {
        return explicit_bzero.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static MethodHandle explicit_bzero$handle() {
        return explicit_bzero.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static MemorySegment explicit_bzero$address() {
        return explicit_bzero.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void explicit_bzero(void *__s, size_t __n)
     * }
     */
    public static void explicit_bzero(MemorySegment __s, long __n) {
        var mh$ = explicit_bzero.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("explicit_bzero", __s, __n);
            }
            mh$.invokeExact(__s, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsep {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strsep");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static FunctionDescriptor strsep$descriptor() {
        return strsep.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static MethodHandle strsep$handle() {
        return strsep.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static MemorySegment strsep$address() {
        return strsep.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strsep(char **restrict __stringp, const char *restrict __delim)
     * }
     */
    public static MemorySegment strsep(MemorySegment __stringp, MemorySegment __delim) {
        var mh$ = strsep.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsep", __stringp, __delim);
            }
            return (MemorySegment)mh$.invokeExact(__stringp, __delim);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strsignal {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strsignal");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static FunctionDescriptor strsignal$descriptor() {
        return strsignal.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static MethodHandle strsignal$handle() {
        return strsignal.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal$address() {
        return strsignal.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *strsignal(int __sig)
     * }
     */
    public static MemorySegment strsignal(int __sig) {
        var mh$ = strsignal.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strsignal", __sig);
            }
            return (MemorySegment)mh$.invokeExact(__sig);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("__stpcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor __stpcpy$descriptor() {
        return __stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle __stpcpy$handle() {
        return __stpcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment __stpcpy$address() {
        return __stpcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *__stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment __stpcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = __stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stpcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("stpcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static FunctionDescriptor stpcpy$descriptor() {
        return stpcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MethodHandle stpcpy$handle() {
        return stpcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment stpcpy$address() {
        return stpcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *stpcpy(char *restrict __dest, const char *restrict __src)
     * }
     */
    public static MemorySegment stpcpy(MemorySegment __dest, MemorySegment __src) {
        var mh$ = stpcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpcpy", __dest, __src);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("__stpncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor __stpncpy$descriptor() {
        return __stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle __stpncpy$handle() {
        return __stpncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __stpncpy$address() {
        return __stpncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *__stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment __stpncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = __stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__stpncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class stpncpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("stpncpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor stpncpy$descriptor() {
        return stpncpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle stpncpy$handle() {
        return stpncpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy$address() {
        return stpncpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern char *stpncpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment stpncpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = stpncpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("stpncpy", __dest, __src, __n);
            }
            return (MemorySegment)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcpy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strlcpy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strlcpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strlcpy$descriptor() {
        return strlcpy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strlcpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strlcpy$handle() {
        return strlcpy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strlcpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strlcpy$address() {
        return strlcpy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strlcpy(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static long strlcpy(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strlcpy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcpy", __dest, __src, __n);
            }
            return (long)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strlcat {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strlcat");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern unsigned long strlcat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static FunctionDescriptor strlcat$descriptor() {
        return strlcat.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern unsigned long strlcat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MethodHandle strlcat$handle() {
        return strlcat.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern unsigned long strlcat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static MemorySegment strlcat$address() {
        return strlcat.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern unsigned long strlcat(char *restrict __dest, const char *restrict __src, size_t __n)
     * }
     */
    public static long strlcat(MemorySegment __dest, MemorySegment __src, long __n) {
        var mh$ = strlcat.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strlcat", __dest, __src, __n);
            }
            return (long)mh$.invokeExact(__dest, __src, __n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long ptrdiff_t
     * }
     */
    public static final OfLong ptrdiff_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint8_t uint8_t
     * }
     */
    public static final OfByte uint8_t = MessageFrame_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint16_t uint16_t
     * }
     */
    public static final OfShort uint16_t = MessageFrame_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint32_t uint32_t
     * }
     */
    public static final OfInt uint32_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint64_t uint64_t
     * }
     */
    public static final OfLong uint64_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __int_least8_t int_least8_t
     * }
     */
    public static final OfByte int_least8_t = MessageFrame_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __int_least16_t int_least16_t
     * }
     */
    public static final OfShort int_least16_t = MessageFrame_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __int_least32_t int_least32_t
     * }
     */
    public static final OfInt int_least32_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __int_least64_t int_least64_t
     * }
     */
    public static final OfLong int_least64_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uint_least8_t uint_least8_t
     * }
     */
    public static final OfByte uint_least8_t = MessageFrame_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef __uint_least16_t uint_least16_t
     * }
     */
    public static final OfShort uint_least16_t = MessageFrame_h.C_SHORT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least32_t uint_least32_t
     * }
     */
    public static final OfInt uint_least32_t = MessageFrame_h.C_INT;
    /**
     * {@snippet lang=c :
     * typedef __uint_least64_t uint_least64_t
     * }
     */
    public static final OfLong uint_least64_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef signed char int_fast8_t
     * }
     */
    public static final OfByte int_fast8_t = MessageFrame_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef long int_fast16_t
     * }
     */
    public static final OfLong int_fast16_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast32_t
     * }
     */
    public static final OfLong int_fast32_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long int_fast64_t
     * }
     */
    public static final OfLong int_fast64_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned char uint_fast8_t
     * }
     */
    public static final OfByte uint_fast8_t = MessageFrame_h.C_CHAR;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast16_t
     * }
     */
    public static final OfLong uint_fast16_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast32_t
     * }
     */
    public static final OfLong uint_fast32_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uint_fast64_t
     * }
     */
    public static final OfLong uint_fast64_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef long intptr_t
     * }
     */
    public static final OfLong intptr_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef unsigned long uintptr_t
     * }
     */
    public static final OfLong uintptr_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __intmax_t intmax_t
     * }
     */
    public static final OfLong intmax_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef __uintmax_t uintmax_t
     * }
     */
    public static final OfLong uintmax_t = MessageFrame_h.C_LONG;
    /**
     * {@snippet lang=c :
     * typedef int __gwchar_t
     * }
     */
    public static final OfInt __gwchar_t = MessageFrame_h.C_INT;

    private static class imaxabs {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("imaxabs");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static FunctionDescriptor imaxabs$descriptor() {
        return imaxabs.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static MethodHandle imaxabs$handle() {
        return imaxabs.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static MemorySegment imaxabs$address() {
        return imaxabs.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t imaxabs(intmax_t __n)
     * }
     */
    public static long imaxabs(long __n) {
        var mh$ = imaxabs.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxabs", __n);
            }
            return (long)mh$.invokeExact(__n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class imaxdiv {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            imaxdiv_t.layout(),
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("imaxdiv");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static FunctionDescriptor imaxdiv$descriptor() {
        return imaxdiv.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MethodHandle imaxdiv$handle() {
        return imaxdiv.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv$address() {
        return imaxdiv.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern imaxdiv_t imaxdiv(intmax_t __numer, intmax_t __denom)
     * }
     */
    public static MemorySegment imaxdiv(SegmentAllocator allocator, long __numer, long __denom) {
        var mh$ = imaxdiv.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("imaxdiv", allocator, __numer, __denom);
            }
            return (MemorySegment)mh$.invokeExact(allocator, __numer, __denom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strtoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoimax$descriptor() {
        return strtoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoimax$handle() {
        return strtoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoimax$address() {
        return strtoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t strtoimax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class strtoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("strtoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor strtoumax$descriptor() {
        return strtoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle strtoumax$handle() {
        return strtoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment strtoumax$address() {
        return strtoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t strtoumax(const char *restrict __nptr, char **restrict __endptr, int __base)
     * }
     */
    public static long strtoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = strtoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("strtoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoimax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("wcstoimax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoimax$descriptor() {
        return wcstoimax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoimax$handle() {
        return wcstoimax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoimax$address() {
        return wcstoimax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern intmax_t wcstoimax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoimax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoimax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoimax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class wcstoumax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("wcstoumax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static FunctionDescriptor wcstoumax$descriptor() {
        return wcstoumax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MethodHandle wcstoumax$handle() {
        return wcstoumax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static MemorySegment wcstoumax$address() {
        return wcstoumax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern uintmax_t wcstoumax(const __gwchar_t *restrict __nptr, __gwchar_t **restrict __endptr, int __base)
     * }
     */
    public static long wcstoumax(MemorySegment __nptr, MemorySegment __endptr, int __base) {
        var mh$ = wcstoumax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("wcstoumax", __nptr, __endptr, __base);
            }
            return (long)mh$.invokeExact(__nptr, __endptr, __base);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int RC_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * enum asn_dec_rval_code_e.RC_OK = 0
     * }
     */
    public static int RC_OK() {
        return RC_OK;
    }
    private static final int RC_WMORE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum asn_dec_rval_code_e.RC_WMORE = 1
     * }
     */
    public static int RC_WMORE() {
        return RC_WMORE;
    }
    private static final int RC_FAIL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum asn_dec_rval_code_e.RC_FAIL = 2
     * }
     */
    public static int RC_FAIL() {
        return RC_FAIL;
    }
    private static final int ATS_INVALID = (int)0L;
    /**
     * {@snippet lang=c :
     * enum asn_transfer_syntax.ATS_INVALID = 0
     * }
     */
    public static int ATS_INVALID() {
        return ATS_INVALID;
    }
    private static final int ATS_NONSTANDARD_PLAINTEXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum asn_transfer_syntax.ATS_NONSTANDARD_PLAINTEXT = 1
     * }
     */
    public static int ATS_NONSTANDARD_PLAINTEXT() {
        return ATS_NONSTANDARD_PLAINTEXT;
    }
    private static final int ATS_RANDOM = (int)2L;
    /**
     * {@snippet lang=c :
     * enum asn_transfer_syntax.ATS_RANDOM = 2
     * }
     */
    public static int ATS_RANDOM() {
        return ATS_RANDOM;
    }
    private static final int ATS_BER = (int)3L;
    /**
     * {@snippet lang=c :
     * enum asn_transfer_syntax.ATS_BER = 3
     * }
     */
    public static int ATS_BER() {
        return ATS_BER;
    }
    private static final int ATS_DER = (int)4L;
    /**
     * {@snippet lang=c :
     * enum asn_transfer_syntax.ATS_DER = 4
     * }
     */
    public static int ATS_DER() {
        return ATS_DER;
    }
    private static final int ATS_CER = (int)5L;
    /**
     * {@snippet lang=c :
     * enum asn_transfer_syntax.ATS_CER = 5
     * }
     */
    public static int ATS_CER() {
        return ATS_CER;
    }
    private static final int ATS_BASIC_OER = (int)6L;
    /**
     * {@snippet lang=c :
     * enum asn_transfer_syntax.ATS_BASIC_OER = 6
     * }
     */
    public static int ATS_BASIC_OER() {
        return ATS_BASIC_OER;
    }
    private static final int ATS_CANONICAL_OER = (int)7L;
    /**
     * {@snippet lang=c :
     * enum asn_transfer_syntax.ATS_CANONICAL_OER = 7
     * }
     */
    public static int ATS_CANONICAL_OER() {
        return ATS_CANONICAL_OER;
    }
    private static final int ATS_UNALIGNED_BASIC_PER = (int)8L;
    /**
     * {@snippet lang=c :
     * enum asn_transfer_syntax.ATS_UNALIGNED_BASIC_PER = 8
     * }
     */
    public static int ATS_UNALIGNED_BASIC_PER() {
        return ATS_UNALIGNED_BASIC_PER;
    }
    private static final int ATS_UNALIGNED_CANONICAL_PER = (int)9L;
    /**
     * {@snippet lang=c :
     * enum asn_transfer_syntax.ATS_UNALIGNED_CANONICAL_PER = 9
     * }
     */
    public static int ATS_UNALIGNED_CANONICAL_PER() {
        return ATS_UNALIGNED_CANONICAL_PER;
    }
    private static final int ATS_ALIGNED_BASIC_PER = (int)10L;
    /**
     * {@snippet lang=c :
     * enum asn_transfer_syntax.ATS_ALIGNED_BASIC_PER = 10
     * }
     */
    public static int ATS_ALIGNED_BASIC_PER() {
        return ATS_ALIGNED_BASIC_PER;
    }
    private static final int ATS_ALIGNED_CANONICAL_PER = (int)11L;
    /**
     * {@snippet lang=c :
     * enum asn_transfer_syntax.ATS_ALIGNED_CANONICAL_PER = 11
     * }
     */
    public static int ATS_ALIGNED_CANONICAL_PER() {
        return ATS_ALIGNED_CANONICAL_PER;
    }
    private static final int ATS_BASIC_XER = (int)12L;
    /**
     * {@snippet lang=c :
     * enum asn_transfer_syntax.ATS_BASIC_XER = 12
     * }
     */
    public static int ATS_BASIC_XER() {
        return ATS_BASIC_XER;
    }
    private static final int ATS_CANONICAL_XER = (int)13L;
    /**
     * {@snippet lang=c :
     * enum asn_transfer_syntax.ATS_CANONICAL_XER = 13
     * }
     */
    public static int ATS_CANONICAL_XER() {
        return ATS_CANONICAL_XER;
    }
    private static final int ATS_JER = (int)14L;
    /**
     * {@snippet lang=c :
     * enum asn_transfer_syntax.ATS_JER = 14
     * }
     */
    public static int ATS_JER() {
        return ATS_JER;
    }
    private static final int ATS_JER_MINIFIED = (int)15L;
    /**
     * {@snippet lang=c :
     * enum asn_transfer_syntax.ATS_JER_MINIFIED = 15
     * }
     */
    public static int ATS_JER_MINIFIED() {
        return ATS_JER_MINIFIED;
    }

    private static class asn_encode_to_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_encode_to_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t asn_encode_to_buffer(const asn_codec_ctx_t *opt_codec_parameters, enum asn_transfer_syntax, const struct asn_TYPE_descriptor_s *type_to_encode, const void *structure_to_encode, void *buffer, size_t buffer_size)
     * }
     */
    public static FunctionDescriptor asn_encode_to_buffer$descriptor() {
        return asn_encode_to_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t asn_encode_to_buffer(const asn_codec_ctx_t *opt_codec_parameters, enum asn_transfer_syntax, const struct asn_TYPE_descriptor_s *type_to_encode, const void *structure_to_encode, void *buffer, size_t buffer_size)
     * }
     */
    public static MethodHandle asn_encode_to_buffer$handle() {
        return asn_encode_to_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t asn_encode_to_buffer(const asn_codec_ctx_t *opt_codec_parameters, enum asn_transfer_syntax, const struct asn_TYPE_descriptor_s *type_to_encode, const void *structure_to_encode, void *buffer, size_t buffer_size)
     * }
     */
    public static MemorySegment asn_encode_to_buffer$address() {
        return asn_encode_to_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t asn_encode_to_buffer(const asn_codec_ctx_t *opt_codec_parameters, enum asn_transfer_syntax, const struct asn_TYPE_descriptor_s *type_to_encode, const void *structure_to_encode, void *buffer, size_t buffer_size)
     * }
     */
    public static MemorySegment asn_encode_to_buffer(SegmentAllocator allocator, MemorySegment opt_codec_parameters, int x1, MemorySegment type_to_encode, MemorySegment structure_to_encode, MemorySegment buffer, long buffer_size) {
        var mh$ = asn_encode_to_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_encode_to_buffer", allocator, opt_codec_parameters, x1, type_to_encode, structure_to_encode, buffer, buffer_size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, opt_codec_parameters, x1, type_to_encode, structure_to_encode, buffer, buffer_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_encode_to_new_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_encode_to_new_buffer_result_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_encode_to_new_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_encode_to_new_buffer_result_t asn_encode_to_new_buffer(const asn_codec_ctx_t *opt_codec_parameters, enum asn_transfer_syntax, const struct asn_TYPE_descriptor_s *type_to_encode, const void *structure_to_encode)
     * }
     */
    public static FunctionDescriptor asn_encode_to_new_buffer$descriptor() {
        return asn_encode_to_new_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_encode_to_new_buffer_result_t asn_encode_to_new_buffer(const asn_codec_ctx_t *opt_codec_parameters, enum asn_transfer_syntax, const struct asn_TYPE_descriptor_s *type_to_encode, const void *structure_to_encode)
     * }
     */
    public static MethodHandle asn_encode_to_new_buffer$handle() {
        return asn_encode_to_new_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_encode_to_new_buffer_result_t asn_encode_to_new_buffer(const asn_codec_ctx_t *opt_codec_parameters, enum asn_transfer_syntax, const struct asn_TYPE_descriptor_s *type_to_encode, const void *structure_to_encode)
     * }
     */
    public static MemorySegment asn_encode_to_new_buffer$address() {
        return asn_encode_to_new_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_encode_to_new_buffer_result_t asn_encode_to_new_buffer(const asn_codec_ctx_t *opt_codec_parameters, enum asn_transfer_syntax, const struct asn_TYPE_descriptor_s *type_to_encode, const void *structure_to_encode)
     * }
     */
    public static MemorySegment asn_encode_to_new_buffer(SegmentAllocator allocator, MemorySegment opt_codec_parameters, int x1, MemorySegment type_to_encode, MemorySegment structure_to_encode) {
        var mh$ = asn_encode_to_new_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_encode_to_new_buffer", allocator, opt_codec_parameters, x1, type_to_encode, structure_to_encode);
            }
            return (MemorySegment)mh$.invokeExact(allocator, opt_codec_parameters, x1, type_to_encode, structure_to_encode);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_encode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_encode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t asn_encode(const asn_codec_ctx_t *opt_codec_parameters, enum asn_transfer_syntax, const struct asn_TYPE_descriptor_s *type_to_encode, const void *structure_to_encode, asn_app_consume_bytes_f *callback, void *callback_key)
     * }
     */
    public static FunctionDescriptor asn_encode$descriptor() {
        return asn_encode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t asn_encode(const asn_codec_ctx_t *opt_codec_parameters, enum asn_transfer_syntax, const struct asn_TYPE_descriptor_s *type_to_encode, const void *structure_to_encode, asn_app_consume_bytes_f *callback, void *callback_key)
     * }
     */
    public static MethodHandle asn_encode$handle() {
        return asn_encode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t asn_encode(const asn_codec_ctx_t *opt_codec_parameters, enum asn_transfer_syntax, const struct asn_TYPE_descriptor_s *type_to_encode, const void *structure_to_encode, asn_app_consume_bytes_f *callback, void *callback_key)
     * }
     */
    public static MemorySegment asn_encode$address() {
        return asn_encode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t asn_encode(const asn_codec_ctx_t *opt_codec_parameters, enum asn_transfer_syntax, const struct asn_TYPE_descriptor_s *type_to_encode, const void *structure_to_encode, asn_app_consume_bytes_f *callback, void *callback_key)
     * }
     */
    public static MemorySegment asn_encode(SegmentAllocator allocator, MemorySegment opt_codec_parameters, int x1, MemorySegment type_to_encode, MemorySegment structure_to_encode, MemorySegment callback, MemorySegment callback_key) {
        var mh$ = asn_encode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_encode", allocator, opt_codec_parameters, x1, type_to_encode, structure_to_encode, callback, callback_key);
            }
            return (MemorySegment)mh$.invokeExact(allocator, opt_codec_parameters, x1, type_to_encode, structure_to_encode, callback, callback_key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_decode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_decode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t asn_decode(const asn_codec_ctx_t *opt_codec_parameters, enum asn_transfer_syntax, const struct asn_TYPE_descriptor_s *type_to_decode, void **structure_ptr, const void *buffer, size_t size)
     * }
     */
    public static FunctionDescriptor asn_decode$descriptor() {
        return asn_decode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t asn_decode(const asn_codec_ctx_t *opt_codec_parameters, enum asn_transfer_syntax, const struct asn_TYPE_descriptor_s *type_to_decode, void **structure_ptr, const void *buffer, size_t size)
     * }
     */
    public static MethodHandle asn_decode$handle() {
        return asn_decode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t asn_decode(const asn_codec_ctx_t *opt_codec_parameters, enum asn_transfer_syntax, const struct asn_TYPE_descriptor_s *type_to_decode, void **structure_ptr, const void *buffer, size_t size)
     * }
     */
    public static MemorySegment asn_decode$address() {
        return asn_decode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t asn_decode(const asn_codec_ctx_t *opt_codec_parameters, enum asn_transfer_syntax, const struct asn_TYPE_descriptor_s *type_to_decode, void **structure_ptr, const void *buffer, size_t size)
     * }
     */
    public static MemorySegment asn_decode(SegmentAllocator allocator, MemorySegment opt_codec_parameters, int x1, MemorySegment type_to_decode, MemorySegment structure_ptr, MemorySegment buffer, long size) {
        var mh$ = asn_decode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_decode", allocator, opt_codec_parameters, x1, type_to_decode, structure_ptr, buffer, size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, opt_codec_parameters, x1, type_to_decode, structure_ptr, buffer, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef ssize_t ber_tlv_len_t
     * }
     */
    public static final OfLong ber_tlv_len_t = MessageFrame_h.C_LONG;

    private static class ber_fetch_length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ber_fetch_length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t ber_fetch_length(int _is_constructed, const void *bufptr, size_t size, ber_tlv_len_t *len_r)
     * }
     */
    public static FunctionDescriptor ber_fetch_length$descriptor() {
        return ber_fetch_length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t ber_fetch_length(int _is_constructed, const void *bufptr, size_t size, ber_tlv_len_t *len_r)
     * }
     */
    public static MethodHandle ber_fetch_length$handle() {
        return ber_fetch_length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t ber_fetch_length(int _is_constructed, const void *bufptr, size_t size, ber_tlv_len_t *len_r)
     * }
     */
    public static MemorySegment ber_fetch_length$address() {
        return ber_fetch_length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t ber_fetch_length(int _is_constructed, const void *bufptr, size_t size, ber_tlv_len_t *len_r)
     * }
     */
    public static long ber_fetch_length(int _is_constructed, MemorySegment bufptr, long size, MemorySegment len_r) {
        var mh$ = ber_fetch_length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ber_fetch_length", _is_constructed, bufptr, size, len_r);
            }
            return (long)mh$.invokeExact(_is_constructed, bufptr, size, len_r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ber_skip_length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ber_skip_length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t ber_skip_length(const struct asn_codec_ctx_s *opt_codec_ctx, int _is_constructed, const void *bufptr, size_t size)
     * }
     */
    public static FunctionDescriptor ber_skip_length$descriptor() {
        return ber_skip_length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t ber_skip_length(const struct asn_codec_ctx_s *opt_codec_ctx, int _is_constructed, const void *bufptr, size_t size)
     * }
     */
    public static MethodHandle ber_skip_length$handle() {
        return ber_skip_length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t ber_skip_length(const struct asn_codec_ctx_s *opt_codec_ctx, int _is_constructed, const void *bufptr, size_t size)
     * }
     */
    public static MemorySegment ber_skip_length$address() {
        return ber_skip_length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t ber_skip_length(const struct asn_codec_ctx_s *opt_codec_ctx, int _is_constructed, const void *bufptr, size_t size)
     * }
     */
    public static long ber_skip_length(MemorySegment opt_codec_ctx, int _is_constructed, MemorySegment bufptr, long size) {
        var mh$ = ber_skip_length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ber_skip_length", opt_codec_ctx, _is_constructed, bufptr, size);
            }
            return (long)mh$.invokeExact(opt_codec_ctx, _is_constructed, bufptr, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class der_tlv_length_serialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("der_tlv_length_serialize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t der_tlv_length_serialize(ber_tlv_len_t len, void *bufptr, size_t size)
     * }
     */
    public static FunctionDescriptor der_tlv_length_serialize$descriptor() {
        return der_tlv_length_serialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t der_tlv_length_serialize(ber_tlv_len_t len, void *bufptr, size_t size)
     * }
     */
    public static MethodHandle der_tlv_length_serialize$handle() {
        return der_tlv_length_serialize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t der_tlv_length_serialize(ber_tlv_len_t len, void *bufptr, size_t size)
     * }
     */
    public static MemorySegment der_tlv_length_serialize$address() {
        return der_tlv_length_serialize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t der_tlv_length_serialize(ber_tlv_len_t len, void *bufptr, size_t size)
     * }
     */
    public static long der_tlv_length_serialize(long len, MemorySegment bufptr, long size) {
        var mh$ = der_tlv_length_serialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("der_tlv_length_serialize", len, bufptr, size);
            }
            return (long)mh$.invokeExact(len, bufptr, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ASN_TAG_CLASS_UNIVERSAL = (int)0L;
    /**
     * {@snippet lang=c :
     * enum asn_tag_class.ASN_TAG_CLASS_UNIVERSAL = 0
     * }
     */
    public static int ASN_TAG_CLASS_UNIVERSAL() {
        return ASN_TAG_CLASS_UNIVERSAL;
    }
    private static final int ASN_TAG_CLASS_APPLICATION = (int)1L;
    /**
     * {@snippet lang=c :
     * enum asn_tag_class.ASN_TAG_CLASS_APPLICATION = 1
     * }
     */
    public static int ASN_TAG_CLASS_APPLICATION() {
        return ASN_TAG_CLASS_APPLICATION;
    }
    private static final int ASN_TAG_CLASS_CONTEXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum asn_tag_class.ASN_TAG_CLASS_CONTEXT = 2
     * }
     */
    public static int ASN_TAG_CLASS_CONTEXT() {
        return ASN_TAG_CLASS_CONTEXT;
    }
    private static final int ASN_TAG_CLASS_PRIVATE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum asn_tag_class.ASN_TAG_CLASS_PRIVATE = 3
     * }
     */
    public static int ASN_TAG_CLASS_PRIVATE() {
        return ASN_TAG_CLASS_PRIVATE;
    }
    /**
     * {@snippet lang=c :
     * typedef unsigned int ber_tlv_tag_t
     * }
     */
    public static final OfInt ber_tlv_tag_t = MessageFrame_h.C_INT;

    private static class ber_tlv_tag_snprint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ber_tlv_tag_snprint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t ber_tlv_tag_snprint(ber_tlv_tag_t tag, char *buf, size_t buflen)
     * }
     */
    public static FunctionDescriptor ber_tlv_tag_snprint$descriptor() {
        return ber_tlv_tag_snprint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t ber_tlv_tag_snprint(ber_tlv_tag_t tag, char *buf, size_t buflen)
     * }
     */
    public static MethodHandle ber_tlv_tag_snprint$handle() {
        return ber_tlv_tag_snprint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t ber_tlv_tag_snprint(ber_tlv_tag_t tag, char *buf, size_t buflen)
     * }
     */
    public static MemorySegment ber_tlv_tag_snprint$address() {
        return ber_tlv_tag_snprint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t ber_tlv_tag_snprint(ber_tlv_tag_t tag, char *buf, size_t buflen)
     * }
     */
    public static long ber_tlv_tag_snprint(int tag, MemorySegment buf, long buflen) {
        var mh$ = ber_tlv_tag_snprint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ber_tlv_tag_snprint", tag, buf, buflen);
            }
            return (long)mh$.invokeExact(tag, buf, buflen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ber_tlv_tag_fwrite {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ber_tlv_tag_fwrite");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t ber_tlv_tag_fwrite(ber_tlv_tag_t tag, FILE *)
     * }
     */
    public static FunctionDescriptor ber_tlv_tag_fwrite$descriptor() {
        return ber_tlv_tag_fwrite.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t ber_tlv_tag_fwrite(ber_tlv_tag_t tag, FILE *)
     * }
     */
    public static MethodHandle ber_tlv_tag_fwrite$handle() {
        return ber_tlv_tag_fwrite.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t ber_tlv_tag_fwrite(ber_tlv_tag_t tag, FILE *)
     * }
     */
    public static MemorySegment ber_tlv_tag_fwrite$address() {
        return ber_tlv_tag_fwrite.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t ber_tlv_tag_fwrite(ber_tlv_tag_t tag, FILE *)
     * }
     */
    public static long ber_tlv_tag_fwrite(int tag, MemorySegment x1) {
        var mh$ = ber_tlv_tag_fwrite.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ber_tlv_tag_fwrite", tag, x1);
            }
            return (long)mh$.invokeExact(tag, x1);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ber_tlv_tag_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ber_tlv_tag_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *ber_tlv_tag_string(ber_tlv_tag_t tag)
     * }
     */
    public static FunctionDescriptor ber_tlv_tag_string$descriptor() {
        return ber_tlv_tag_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *ber_tlv_tag_string(ber_tlv_tag_t tag)
     * }
     */
    public static MethodHandle ber_tlv_tag_string$handle() {
        return ber_tlv_tag_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *ber_tlv_tag_string(ber_tlv_tag_t tag)
     * }
     */
    public static MemorySegment ber_tlv_tag_string$address() {
        return ber_tlv_tag_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *ber_tlv_tag_string(ber_tlv_tag_t tag)
     * }
     */
    public static MemorySegment ber_tlv_tag_string(int tag) {
        var mh$ = ber_tlv_tag_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ber_tlv_tag_string", tag);
            }
            return (MemorySegment)mh$.invokeExact(tag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ber_fetch_tag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ber_fetch_tag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t ber_fetch_tag(const void *bufptr, size_t size, ber_tlv_tag_t *tag_r)
     * }
     */
    public static FunctionDescriptor ber_fetch_tag$descriptor() {
        return ber_fetch_tag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t ber_fetch_tag(const void *bufptr, size_t size, ber_tlv_tag_t *tag_r)
     * }
     */
    public static MethodHandle ber_fetch_tag$handle() {
        return ber_fetch_tag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t ber_fetch_tag(const void *bufptr, size_t size, ber_tlv_tag_t *tag_r)
     * }
     */
    public static MemorySegment ber_fetch_tag$address() {
        return ber_fetch_tag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t ber_fetch_tag(const void *bufptr, size_t size, ber_tlv_tag_t *tag_r)
     * }
     */
    public static long ber_fetch_tag(MemorySegment bufptr, long size, MemorySegment tag_r) {
        var mh$ = ber_fetch_tag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ber_fetch_tag", bufptr, size, tag_r);
            }
            return (long)mh$.invokeExact(bufptr, size, tag_r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ber_tlv_tag_serialize {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ber_tlv_tag_serialize");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t ber_tlv_tag_serialize(ber_tlv_tag_t tag, void *bufptr, size_t size)
     * }
     */
    public static FunctionDescriptor ber_tlv_tag_serialize$descriptor() {
        return ber_tlv_tag_serialize.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t ber_tlv_tag_serialize(ber_tlv_tag_t tag, void *bufptr, size_t size)
     * }
     */
    public static MethodHandle ber_tlv_tag_serialize$handle() {
        return ber_tlv_tag_serialize.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t ber_tlv_tag_serialize(ber_tlv_tag_t tag, void *bufptr, size_t size)
     * }
     */
    public static MemorySegment ber_tlv_tag_serialize$address() {
        return ber_tlv_tag_serialize.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t ber_tlv_tag_serialize(ber_tlv_tag_t tag, void *bufptr, size_t size)
     * }
     */
    public static long ber_tlv_tag_serialize(int tag, MemorySegment bufptr, long size) {
        var mh$ = ber_tlv_tag_serialize.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ber_tlv_tag_serialize", tag, bufptr, size);
            }
            return (long)mh$.invokeExact(tag, bufptr, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ber_decode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ber_decode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ber_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static FunctionDescriptor ber_decode$descriptor() {
        return ber_decode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ber_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static MethodHandle ber_decode$handle() {
        return ber_decode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ber_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static MemorySegment ber_decode$address() {
        return ber_decode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ber_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static MemorySegment ber_decode(SegmentAllocator allocator, MemorySegment opt_codec_ctx, MemorySegment type_descriptor, MemorySegment struct_ptr, MemorySegment buffer, long size) {
        var mh$ = ber_decode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ber_decode", allocator, opt_codec_ctx, type_descriptor, struct_ptr, buffer, size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, opt_codec_ctx, type_descriptor, struct_ptr, buffer, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ber_check_tags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ber_check_tags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ber_check_tags(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, asn_struct_ctx_t *opt_ctx, const void *ptr, size_t size, int tag_mode, int last_tag_form, ber_tlv_len_t *last_length, int *opt_tlv_form)
     * }
     */
    public static FunctionDescriptor ber_check_tags$descriptor() {
        return ber_check_tags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ber_check_tags(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, asn_struct_ctx_t *opt_ctx, const void *ptr, size_t size, int tag_mode, int last_tag_form, ber_tlv_len_t *last_length, int *opt_tlv_form)
     * }
     */
    public static MethodHandle ber_check_tags$handle() {
        return ber_check_tags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ber_check_tags(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, asn_struct_ctx_t *opt_ctx, const void *ptr, size_t size, int tag_mode, int last_tag_form, ber_tlv_len_t *last_length, int *opt_tlv_form)
     * }
     */
    public static MemorySegment ber_check_tags$address() {
        return ber_check_tags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ber_check_tags(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, asn_struct_ctx_t *opt_ctx, const void *ptr, size_t size, int tag_mode, int last_tag_form, ber_tlv_len_t *last_length, int *opt_tlv_form)
     * }
     */
    public static MemorySegment ber_check_tags(SegmentAllocator allocator, MemorySegment opt_codec_ctx, MemorySegment type_descriptor, MemorySegment opt_ctx, MemorySegment ptr, long size, int tag_mode, int last_tag_form, MemorySegment last_length, MemorySegment opt_tlv_form) {
        var mh$ = ber_check_tags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ber_check_tags", allocator, opt_codec_ctx, type_descriptor, opt_ctx, ptr, size, tag_mode, last_tag_form, last_length, opt_tlv_form);
            }
            return (MemorySegment)mh$.invokeExact(allocator, opt_codec_ctx, type_descriptor, opt_ctx, ptr, size, tag_mode, last_tag_form, last_length, opt_tlv_form);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class der_encode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("der_encode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t der_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static FunctionDescriptor der_encode$descriptor() {
        return der_encode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t der_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static MethodHandle der_encode$handle() {
        return der_encode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t der_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static MemorySegment der_encode$address() {
        return der_encode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t der_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static MemorySegment der_encode(SegmentAllocator allocator, MemorySegment type_descriptor, MemorySegment struct_ptr, MemorySegment consume_bytes_cb, MemorySegment app_key) {
        var mh$ = der_encode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("der_encode", allocator, type_descriptor, struct_ptr, consume_bytes_cb, app_key);
            }
            return (MemorySegment)mh$.invokeExact(allocator, type_descriptor, struct_ptr, consume_bytes_cb, app_key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class der_encode_to_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("der_encode_to_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t der_encode_to_buffer(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, void *buffer, size_t buffer_size)
     * }
     */
    public static FunctionDescriptor der_encode_to_buffer$descriptor() {
        return der_encode_to_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t der_encode_to_buffer(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, void *buffer, size_t buffer_size)
     * }
     */
    public static MethodHandle der_encode_to_buffer$handle() {
        return der_encode_to_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t der_encode_to_buffer(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, void *buffer, size_t buffer_size)
     * }
     */
    public static MemorySegment der_encode_to_buffer$address() {
        return der_encode_to_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t der_encode_to_buffer(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, void *buffer, size_t buffer_size)
     * }
     */
    public static MemorySegment der_encode_to_buffer(SegmentAllocator allocator, MemorySegment type_descriptor, MemorySegment struct_ptr, MemorySegment buffer, long buffer_size) {
        var mh$ = der_encode_to_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("der_encode_to_buffer", allocator, type_descriptor, struct_ptr, buffer, buffer_size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, type_descriptor, struct_ptr, buffer, buffer_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class der_write_tags {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("der_write_tags");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t der_write_tags(const struct asn_TYPE_descriptor_s *type_descriptor, size_t struct_length, int tag_mode, int last_tag_form, ber_tlv_tag_t tag, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static FunctionDescriptor der_write_tags$descriptor() {
        return der_write_tags.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t der_write_tags(const struct asn_TYPE_descriptor_s *type_descriptor, size_t struct_length, int tag_mode, int last_tag_form, ber_tlv_tag_t tag, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static MethodHandle der_write_tags$handle() {
        return der_write_tags.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t der_write_tags(const struct asn_TYPE_descriptor_s *type_descriptor, size_t struct_length, int tag_mode, int last_tag_form, ber_tlv_tag_t tag, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static MemorySegment der_write_tags$address() {
        return der_write_tags.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t der_write_tags(const struct asn_TYPE_descriptor_s *type_descriptor, size_t struct_length, int tag_mode, int last_tag_form, ber_tlv_tag_t tag, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static long der_write_tags(MemorySegment type_descriptor, long struct_length, int tag_mode, int last_tag_form, int tag, MemorySegment consume_bytes_cb, MemorySegment app_key) {
        var mh$ = der_write_tags.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("der_write_tags", type_descriptor, struct_length, tag_mode, last_tag_form, tag, consume_bytes_cb, app_key);
            }
            return (long)mh$.invokeExact(type_descriptor, struct_length, tag_mode, last_tag_form, tag, consume_bytes_cb, app_key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xer_decode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("xer_decode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t xer_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static FunctionDescriptor xer_decode$descriptor() {
        return xer_decode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t xer_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static MethodHandle xer_decode$handle() {
        return xer_decode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t xer_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static MemorySegment xer_decode$address() {
        return xer_decode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t xer_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static MemorySegment xer_decode(SegmentAllocator allocator, MemorySegment opt_codec_ctx, MemorySegment type_descriptor, MemorySegment struct_ptr, MemorySegment buffer, long size) {
        var mh$ = xer_decode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xer_decode", allocator, opt_codec_ctx, type_descriptor, struct_ptr, buffer, size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, opt_codec_ctx, type_descriptor, struct_ptr, buffer, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xer_decode_general {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("xer_decode_general");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t xer_decode_general(const asn_codec_ctx_t *opt_codec_ctx, asn_struct_ctx_t *ctx, void *struct_key, const char *xml_tag, const void *buf_ptr, size_t size, int (*opt_unexpected_tag_decoder)(void *, const void *, size_t), ssize_t (*body_receiver)(void *, const void *, size_t, int))
     * }
     */
    public static FunctionDescriptor xer_decode_general$descriptor() {
        return xer_decode_general.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t xer_decode_general(const asn_codec_ctx_t *opt_codec_ctx, asn_struct_ctx_t *ctx, void *struct_key, const char *xml_tag, const void *buf_ptr, size_t size, int (*opt_unexpected_tag_decoder)(void *, const void *, size_t), ssize_t (*body_receiver)(void *, const void *, size_t, int))
     * }
     */
    public static MethodHandle xer_decode_general$handle() {
        return xer_decode_general.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t xer_decode_general(const asn_codec_ctx_t *opt_codec_ctx, asn_struct_ctx_t *ctx, void *struct_key, const char *xml_tag, const void *buf_ptr, size_t size, int (*opt_unexpected_tag_decoder)(void *, const void *, size_t), ssize_t (*body_receiver)(void *, const void *, size_t, int))
     * }
     */
    public static MemorySegment xer_decode_general$address() {
        return xer_decode_general.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t xer_decode_general(const asn_codec_ctx_t *opt_codec_ctx, asn_struct_ctx_t *ctx, void *struct_key, const char *xml_tag, const void *buf_ptr, size_t size, int (*opt_unexpected_tag_decoder)(void *, const void *, size_t), ssize_t (*body_receiver)(void *, const void *, size_t, int))
     * }
     */
    public static MemorySegment xer_decode_general(SegmentAllocator allocator, MemorySegment opt_codec_ctx, MemorySegment ctx, MemorySegment struct_key, MemorySegment xml_tag, MemorySegment buf_ptr, long size, MemorySegment opt_unexpected_tag_decoder, MemorySegment body_receiver) {
        var mh$ = xer_decode_general.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xer_decode_general", allocator, opt_codec_ctx, ctx, struct_key, xml_tag, buf_ptr, size, opt_unexpected_tag_decoder, body_receiver);
            }
            return (MemorySegment)mh$.invokeExact(allocator, opt_codec_ctx, ctx, struct_key, xml_tag, buf_ptr, size, opt_unexpected_tag_decoder, body_receiver);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PXER_WMORE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum pxer_chunk_type.PXER_WMORE = 0
     * }
     */
    public static int PXER_WMORE() {
        return PXER_WMORE;
    }
    private static final int PXER_TAG = (int)1L;
    /**
     * {@snippet lang=c :
     * enum pxer_chunk_type.PXER_TAG = 1
     * }
     */
    public static int PXER_TAG() {
        return PXER_TAG;
    }
    private static final int PXER_TEXT = (int)2L;
    /**
     * {@snippet lang=c :
     * enum pxer_chunk_type.PXER_TEXT = 2
     * }
     */
    public static int PXER_TEXT() {
        return PXER_TEXT;
    }
    private static final int PXER_COMMENT = (int)3L;
    /**
     * {@snippet lang=c :
     * enum pxer_chunk_type.PXER_COMMENT = 3
     * }
     */
    public static int PXER_COMMENT() {
        return PXER_COMMENT;
    }

    private static class xer_next_token {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("xer_next_token");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t xer_next_token(int *stateContext, const void *buffer, size_t size, pxer_chunk_type_e *_ch_type)
     * }
     */
    public static FunctionDescriptor xer_next_token$descriptor() {
        return xer_next_token.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t xer_next_token(int *stateContext, const void *buffer, size_t size, pxer_chunk_type_e *_ch_type)
     * }
     */
    public static MethodHandle xer_next_token$handle() {
        return xer_next_token.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t xer_next_token(int *stateContext, const void *buffer, size_t size, pxer_chunk_type_e *_ch_type)
     * }
     */
    public static MemorySegment xer_next_token$address() {
        return xer_next_token.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t xer_next_token(int *stateContext, const void *buffer, size_t size, pxer_chunk_type_e *_ch_type)
     * }
     */
    public static long xer_next_token(MemorySegment stateContext, MemorySegment buffer, long size, MemorySegment _ch_type) {
        var mh$ = xer_next_token.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xer_next_token", stateContext, buffer, size, _ch_type);
            }
            return (long)mh$.invokeExact(stateContext, buffer, size, _ch_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int XCT_BROKEN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum xer_check_tag.XCT_BROKEN = 0
     * }
     */
    public static int XCT_BROKEN() {
        return XCT_BROKEN;
    }
    private static final int XCT_OPENING = (int)1L;
    /**
     * {@snippet lang=c :
     * enum xer_check_tag.XCT_OPENING = 1
     * }
     */
    public static int XCT_OPENING() {
        return XCT_OPENING;
    }
    private static final int XCT_CLOSING = (int)2L;
    /**
     * {@snippet lang=c :
     * enum xer_check_tag.XCT_CLOSING = 2
     * }
     */
    public static int XCT_CLOSING() {
        return XCT_CLOSING;
    }
    private static final int XCT_BOTH = (int)3L;
    /**
     * {@snippet lang=c :
     * enum xer_check_tag.XCT_BOTH = 3
     * }
     */
    public static int XCT_BOTH() {
        return XCT_BOTH;
    }
    private static final int XCT__UNK__MASK = (int)4L;
    /**
     * {@snippet lang=c :
     * enum xer_check_tag.XCT__UNK__MASK = 4
     * }
     */
    public static int XCT__UNK__MASK() {
        return XCT__UNK__MASK;
    }
    private static final int XCT_UNKNOWN_OP = (int)5L;
    /**
     * {@snippet lang=c :
     * enum xer_check_tag.XCT_UNKNOWN_OP = 5
     * }
     */
    public static int XCT_UNKNOWN_OP() {
        return XCT_UNKNOWN_OP;
    }
    private static final int XCT_UNKNOWN_CL = (int)6L;
    /**
     * {@snippet lang=c :
     * enum xer_check_tag.XCT_UNKNOWN_CL = 6
     * }
     */
    public static int XCT_UNKNOWN_CL() {
        return XCT_UNKNOWN_CL;
    }
    private static final int XCT_UNKNOWN_BO = (int)7L;
    /**
     * {@snippet lang=c :
     * enum xer_check_tag.XCT_UNKNOWN_BO = 7
     * }
     */
    public static int XCT_UNKNOWN_BO() {
        return XCT_UNKNOWN_BO;
    }

    private static class xer_check_tag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("xer_check_tag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * xer_check_tag_e xer_check_tag(const void *buf_ptr, int size, const char *need_tag)
     * }
     */
    public static FunctionDescriptor xer_check_tag$descriptor() {
        return xer_check_tag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * xer_check_tag_e xer_check_tag(const void *buf_ptr, int size, const char *need_tag)
     * }
     */
    public static MethodHandle xer_check_tag$handle() {
        return xer_check_tag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * xer_check_tag_e xer_check_tag(const void *buf_ptr, int size, const char *need_tag)
     * }
     */
    public static MemorySegment xer_check_tag$address() {
        return xer_check_tag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * xer_check_tag_e xer_check_tag(const void *buf_ptr, int size, const char *need_tag)
     * }
     */
    public static int xer_check_tag(MemorySegment buf_ptr, int size, MemorySegment need_tag) {
        var mh$ = xer_check_tag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xer_check_tag", buf_ptr, size, need_tag);
            }
            return (int)mh$.invokeExact(buf_ptr, size, need_tag);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xer_whitespace_span {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("xer_whitespace_span");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t xer_whitespace_span(const void *chunk_buf, size_t chunk_size)
     * }
     */
    public static FunctionDescriptor xer_whitespace_span$descriptor() {
        return xer_whitespace_span.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t xer_whitespace_span(const void *chunk_buf, size_t chunk_size)
     * }
     */
    public static MethodHandle xer_whitespace_span$handle() {
        return xer_whitespace_span.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t xer_whitespace_span(const void *chunk_buf, size_t chunk_size)
     * }
     */
    public static MemorySegment xer_whitespace_span$address() {
        return xer_whitespace_span.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t xer_whitespace_span(const void *chunk_buf, size_t chunk_size)
     * }
     */
    public static long xer_whitespace_span(MemorySegment chunk_buf, long chunk_size) {
        var mh$ = xer_whitespace_span.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xer_whitespace_span", chunk_buf, chunk_size);
            }
            return (long)mh$.invokeExact(chunk_buf, chunk_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xer_skip_unknown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("xer_skip_unknown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xer_skip_unknown(xer_check_tag_e tcv, ber_tlv_len_t *depth)
     * }
     */
    public static FunctionDescriptor xer_skip_unknown$descriptor() {
        return xer_skip_unknown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xer_skip_unknown(xer_check_tag_e tcv, ber_tlv_len_t *depth)
     * }
     */
    public static MethodHandle xer_skip_unknown$handle() {
        return xer_skip_unknown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xer_skip_unknown(xer_check_tag_e tcv, ber_tlv_len_t *depth)
     * }
     */
    public static MemorySegment xer_skip_unknown$address() {
        return xer_skip_unknown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xer_skip_unknown(xer_check_tag_e tcv, ber_tlv_len_t *depth)
     * }
     */
    public static int xer_skip_unknown(int tcv, MemorySegment depth) {
        var mh$ = xer_skip_unknown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xer_skip_unknown", tcv, depth);
            }
            return (int)mh$.invokeExact(tcv, depth);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int XER_F_BASIC = (int)1L;
    /**
     * {@snippet lang=c :
     * enum xer_encoder_flags_e.XER_F_BASIC = 1
     * }
     */
    public static int XER_F_BASIC() {
        return XER_F_BASIC;
    }
    private static final int XER_F_CANONICAL = (int)2L;
    /**
     * {@snippet lang=c :
     * enum xer_encoder_flags_e.XER_F_CANONICAL = 2
     * }
     */
    public static int XER_F_CANONICAL() {
        return XER_F_CANONICAL;
    }

    private static class xer_encode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("xer_encode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t xer_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, enum xer_encoder_flags_e xer_flags, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static FunctionDescriptor xer_encode$descriptor() {
        return xer_encode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t xer_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, enum xer_encoder_flags_e xer_flags, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static MethodHandle xer_encode$handle() {
        return xer_encode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t xer_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, enum xer_encoder_flags_e xer_flags, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static MemorySegment xer_encode$address() {
        return xer_encode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t xer_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, enum xer_encoder_flags_e xer_flags, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static MemorySegment xer_encode(SegmentAllocator allocator, MemorySegment type_descriptor, MemorySegment struct_ptr, int xer_flags, MemorySegment consume_bytes_cb, MemorySegment app_key) {
        var mh$ = xer_encode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xer_encode", allocator, type_descriptor, struct_ptr, xer_flags, consume_bytes_cb, app_key);
            }
            return (MemorySegment)mh$.invokeExact(allocator, type_descriptor, struct_ptr, xer_flags, consume_bytes_cb, app_key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class xer_fprint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("xer_fprint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int xer_fprint(FILE *stream, const struct asn_TYPE_descriptor_s *td, const void *struct_ptr)
     * }
     */
    public static FunctionDescriptor xer_fprint$descriptor() {
        return xer_fprint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int xer_fprint(FILE *stream, const struct asn_TYPE_descriptor_s *td, const void *struct_ptr)
     * }
     */
    public static MethodHandle xer_fprint$handle() {
        return xer_fprint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int xer_fprint(FILE *stream, const struct asn_TYPE_descriptor_s *td, const void *struct_ptr)
     * }
     */
    public static MemorySegment xer_fprint$address() {
        return xer_fprint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int xer_fprint(FILE *stream, const struct asn_TYPE_descriptor_s *td, const void *struct_ptr)
     * }
     */
    public static int xer_fprint(MemorySegment stream, MemorySegment td, MemorySegment struct_ptr) {
        var mh$ = xer_fprint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xer_fprint", stream, td, struct_ptr);
            }
            return (int)mh$.invokeExact(stream, td, struct_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int XEQ_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum xer_equivalence_e.XEQ_SUCCESS = 0
     * }
     */
    public static int XEQ_SUCCESS() {
        return XEQ_SUCCESS;
    }
    private static final int XEQ_FAILURE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum xer_equivalence_e.XEQ_FAILURE = 1
     * }
     */
    public static int XEQ_FAILURE() {
        return XEQ_FAILURE;
    }
    private static final int XEQ_ENCODE1_FAILED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum xer_equivalence_e.XEQ_ENCODE1_FAILED = 2
     * }
     */
    public static int XEQ_ENCODE1_FAILED() {
        return XEQ_ENCODE1_FAILED;
    }
    private static final int XEQ_ENCODE2_FAILED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum xer_equivalence_e.XEQ_ENCODE2_FAILED = 3
     * }
     */
    public static int XEQ_ENCODE2_FAILED() {
        return XEQ_ENCODE2_FAILED;
    }
    private static final int XEQ_DIFFERENT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum xer_equivalence_e.XEQ_DIFFERENT = 4
     * }
     */
    public static int XEQ_DIFFERENT() {
        return XEQ_DIFFERENT;
    }
    private static final int XEQ_DECODE_FAILED = (int)5L;
    /**
     * {@snippet lang=c :
     * enum xer_equivalence_e.XEQ_DECODE_FAILED = 5
     * }
     */
    public static int XEQ_DECODE_FAILED() {
        return XEQ_DECODE_FAILED;
    }
    private static final int XEQ_ROUND_TRIP_FAILED = (int)6L;
    /**
     * {@snippet lang=c :
     * enum xer_equivalence_e.XEQ_ROUND_TRIP_FAILED = 6
     * }
     */
    public static int XEQ_ROUND_TRIP_FAILED() {
        return XEQ_ROUND_TRIP_FAILED;
    }

    private static class xer_equivalent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("xer_equivalent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum xer_equivalence_e xer_equivalent(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct1, const void *struct2, FILE *opt_debug_stream)
     * }
     */
    public static FunctionDescriptor xer_equivalent$descriptor() {
        return xer_equivalent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum xer_equivalence_e xer_equivalent(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct1, const void *struct2, FILE *opt_debug_stream)
     * }
     */
    public static MethodHandle xer_equivalent$handle() {
        return xer_equivalent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum xer_equivalence_e xer_equivalent(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct1, const void *struct2, FILE *opt_debug_stream)
     * }
     */
    public static MemorySegment xer_equivalent$address() {
        return xer_equivalent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum xer_equivalence_e xer_equivalent(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct1, const void *struct2, FILE *opt_debug_stream)
     * }
     */
    public static int xer_equivalent(MemorySegment type_descriptor, MemorySegment struct1, MemorySegment struct2, MemorySegment opt_debug_stream) {
        var mh$ = xer_equivalent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xer_equivalent", type_descriptor, struct1, struct2, opt_debug_stream);
            }
            return (int)mh$.invokeExact(type_descriptor, struct1, struct2, opt_debug_stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PJSON_TEXT = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJSON_TEXT = 0
     * }
     */
    public static int PJSON_TEXT() {
        return PJSON_TEXT;
    }
    private static final int PJSON_KEY = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJSON_KEY = 1
     * }
     */
    public static int PJSON_KEY() {
        return PJSON_KEY;
    }
    private static final int PJSON_VALUE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJSON_VALUE = 2
     * }
     */
    public static int PJSON_VALUE() {
        return PJSON_VALUE;
    }
    private static final int PJSON_DLM = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJSON_DLM = 3
     * }
     */
    public static int PJSON_DLM() {
        return PJSON_DLM;
    }
    private static final int PJSON_KEY_END = (int)4L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJSON_KEY_END = 4
     * }
     */
    public static int PJSON_KEY_END() {
        return PJSON_KEY_END;
    }
    private static final int PJSON_VALUE_END = (int)5L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.PJSON_VALUE_END = 5
     * }
     */
    public static int PJSON_VALUE_END() {
        return PJSON_VALUE_END;
    }

    private static class pjson_parse {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("pjson_parse");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t pjson_parse(int *_stateContext, const void *_buf, size_t _size, pjson_callback_f *cb, void *_key)
     * }
     */
    public static FunctionDescriptor pjson_parse$descriptor() {
        return pjson_parse.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t pjson_parse(int *_stateContext, const void *_buf, size_t _size, pjson_callback_f *cb, void *_key)
     * }
     */
    public static MethodHandle pjson_parse$handle() {
        return pjson_parse.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t pjson_parse(int *_stateContext, const void *_buf, size_t _size, pjson_callback_f *cb, void *_key)
     * }
     */
    public static MemorySegment pjson_parse$address() {
        return pjson_parse.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t pjson_parse(int *_stateContext, const void *_buf, size_t _size, pjson_callback_f *cb, void *_key)
     * }
     */
    public static long pjson_parse(MemorySegment _stateContext, MemorySegment _buf, long _size, MemorySegment cb, MemorySegment _key) {
        var mh$ = pjson_parse.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("pjson_parse", _stateContext, _buf, _size, cb, _key);
            }
            return (long)mh$.invokeExact(_stateContext, _buf, _size, cb, _key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jer_decode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("jer_decode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t jer_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static FunctionDescriptor jer_decode$descriptor() {
        return jer_decode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t jer_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static MethodHandle jer_decode$handle() {
        return jer_decode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t jer_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static MemorySegment jer_decode$address() {
        return jer_decode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t jer_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static MemorySegment jer_decode(SegmentAllocator allocator, MemorySegment opt_codec_ctx, MemorySegment type_descriptor, MemorySegment struct_ptr, MemorySegment buffer, long size) {
        var mh$ = jer_decode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jer_decode", allocator, opt_codec_ctx, type_descriptor, struct_ptr, buffer, size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, opt_codec_ctx, type_descriptor, struct_ptr, buffer, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jer_decode_general {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("jer_decode_general");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t jer_decode_general(const asn_codec_ctx_t *opt_codec_ctx, asn_struct_ctx_t *ctx, void *struct_key, const void *buf_ptr, size_t size, int (*opt_unexpected_tag_decoder)(void *, const void *, size_t), ssize_t (*body_receiver)(void *, const void *, size_t, int))
     * }
     */
    public static FunctionDescriptor jer_decode_general$descriptor() {
        return jer_decode_general.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t jer_decode_general(const asn_codec_ctx_t *opt_codec_ctx, asn_struct_ctx_t *ctx, void *struct_key, const void *buf_ptr, size_t size, int (*opt_unexpected_tag_decoder)(void *, const void *, size_t), ssize_t (*body_receiver)(void *, const void *, size_t, int))
     * }
     */
    public static MethodHandle jer_decode_general$handle() {
        return jer_decode_general.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t jer_decode_general(const asn_codec_ctx_t *opt_codec_ctx, asn_struct_ctx_t *ctx, void *struct_key, const void *buf_ptr, size_t size, int (*opt_unexpected_tag_decoder)(void *, const void *, size_t), ssize_t (*body_receiver)(void *, const void *, size_t, int))
     * }
     */
    public static MemorySegment jer_decode_general$address() {
        return jer_decode_general.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t jer_decode_general(const asn_codec_ctx_t *opt_codec_ctx, asn_struct_ctx_t *ctx, void *struct_key, const void *buf_ptr, size_t size, int (*opt_unexpected_tag_decoder)(void *, const void *, size_t), ssize_t (*body_receiver)(void *, const void *, size_t, int))
     * }
     */
    public static MemorySegment jer_decode_general(SegmentAllocator allocator, MemorySegment opt_codec_ctx, MemorySegment ctx, MemorySegment struct_key, MemorySegment buf_ptr, long size, MemorySegment opt_unexpected_tag_decoder, MemorySegment body_receiver) {
        var mh$ = jer_decode_general.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jer_decode_general", allocator, opt_codec_ctx, ctx, struct_key, buf_ptr, size, opt_unexpected_tag_decoder, body_receiver);
            }
            return (MemorySegment)mh$.invokeExact(allocator, opt_codec_ctx, ctx, struct_key, buf_ptr, size, opt_unexpected_tag_decoder, body_receiver);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PJER_WMORE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum pjer_chunk_type.PJER_WMORE = 0
     * }
     */
    public static int PJER_WMORE() {
        return PJER_WMORE;
    }
    private static final int PJER_TEXT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum pjer_chunk_type.PJER_TEXT = 1
     * }
     */
    public static int PJER_TEXT() {
        return PJER_TEXT;
    }
    private static final int PJER_KEY = (int)2L;
    /**
     * {@snippet lang=c :
     * enum pjer_chunk_type.PJER_KEY = 2
     * }
     */
    public static int PJER_KEY() {
        return PJER_KEY;
    }
    private static final int PJER_VALUE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum pjer_chunk_type.PJER_VALUE = 3
     * }
     */
    public static int PJER_VALUE() {
        return PJER_VALUE;
    }
    private static final int PJER_DLM = (int)4L;
    /**
     * {@snippet lang=c :
     * enum pjer_chunk_type.PJER_DLM = 4
     * }
     */
    public static int PJER_DLM() {
        return PJER_DLM;
    }

    private static class jer_next_token {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("jer_next_token");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t jer_next_token(int *stateContext, const void *buffer, size_t size, pjer_chunk_type_e *_ch_type)
     * }
     */
    public static FunctionDescriptor jer_next_token$descriptor() {
        return jer_next_token.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t jer_next_token(int *stateContext, const void *buffer, size_t size, pjer_chunk_type_e *_ch_type)
     * }
     */
    public static MethodHandle jer_next_token$handle() {
        return jer_next_token.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t jer_next_token(int *stateContext, const void *buffer, size_t size, pjer_chunk_type_e *_ch_type)
     * }
     */
    public static MemorySegment jer_next_token$address() {
        return jer_next_token.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t jer_next_token(int *stateContext, const void *buffer, size_t size, pjer_chunk_type_e *_ch_type)
     * }
     */
    public static long jer_next_token(MemorySegment stateContext, MemorySegment buffer, long size, MemorySegment _ch_type) {
        var mh$ = jer_next_token.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jer_next_token", stateContext, buffer, size, _ch_type);
            }
            return (long)mh$.invokeExact(stateContext, buffer, size, _ch_type);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int JCK_BROKEN = (int)0L;
    /**
     * {@snippet lang=c :
     * enum jer_check_sym.JCK_BROKEN = 0
     * }
     */
    public static int JCK_BROKEN() {
        return JCK_BROKEN;
    }
    private static final int JCK_UNKNOWN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum jer_check_sym.JCK_UNKNOWN = 1
     * }
     */
    public static int JCK_UNKNOWN() {
        return JCK_UNKNOWN;
    }
    private static final int JCK_KEY = (int)2L;
    /**
     * {@snippet lang=c :
     * enum jer_check_sym.JCK_KEY = 2
     * }
     */
    public static int JCK_KEY() {
        return JCK_KEY;
    }
    private static final int JCK_COMMA = (int)3L;
    /**
     * {@snippet lang=c :
     * enum jer_check_sym.JCK_COMMA = 3
     * }
     */
    public static int JCK_COMMA() {
        return JCK_COMMA;
    }
    private static final int JCK_OSTART = (int)4L;
    /**
     * {@snippet lang=c :
     * enum jer_check_sym.JCK_OSTART = 4
     * }
     */
    public static int JCK_OSTART() {
        return JCK_OSTART;
    }
    private static final int JCK_OEND = (int)5L;
    /**
     * {@snippet lang=c :
     * enum jer_check_sym.JCK_OEND = 5
     * }
     */
    public static int JCK_OEND() {
        return JCK_OEND;
    }
    private static final int JCK_ASTART = (int)6L;
    /**
     * {@snippet lang=c :
     * enum jer_check_sym.JCK_ASTART = 6
     * }
     */
    public static int JCK_ASTART() {
        return JCK_ASTART;
    }
    private static final int JCK_AEND = (int)7L;
    /**
     * {@snippet lang=c :
     * enum jer_check_sym.JCK_AEND = 7
     * }
     */
    public static int JCK_AEND() {
        return JCK_AEND;
    }

    private static class jer_check_sym {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("jer_check_sym");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * jer_check_sym_e jer_check_sym(const void *buf_ptr, int size, const char *need_key)
     * }
     */
    public static FunctionDescriptor jer_check_sym$descriptor() {
        return jer_check_sym.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * jer_check_sym_e jer_check_sym(const void *buf_ptr, int size, const char *need_key)
     * }
     */
    public static MethodHandle jer_check_sym$handle() {
        return jer_check_sym.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * jer_check_sym_e jer_check_sym(const void *buf_ptr, int size, const char *need_key)
     * }
     */
    public static MemorySegment jer_check_sym$address() {
        return jer_check_sym.ADDR;
    }

    /**
     * {@snippet lang=c :
     * jer_check_sym_e jer_check_sym(const void *buf_ptr, int size, const char *need_key)
     * }
     */
    public static int jer_check_sym(MemorySegment buf_ptr, int size, MemorySegment need_key) {
        var mh$ = jer_check_sym.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jer_check_sym", buf_ptr, size, need_key);
            }
            return (int)mh$.invokeExact(buf_ptr, size, need_key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jer_whitespace_span {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("jer_whitespace_span");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t jer_whitespace_span(const void *chunk_buf, size_t chunk_size)
     * }
     */
    public static FunctionDescriptor jer_whitespace_span$descriptor() {
        return jer_whitespace_span.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t jer_whitespace_span(const void *chunk_buf, size_t chunk_size)
     * }
     */
    public static MethodHandle jer_whitespace_span$handle() {
        return jer_whitespace_span.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t jer_whitespace_span(const void *chunk_buf, size_t chunk_size)
     * }
     */
    public static MemorySegment jer_whitespace_span$address() {
        return jer_whitespace_span.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t jer_whitespace_span(const void *chunk_buf, size_t chunk_size)
     * }
     */
    public static long jer_whitespace_span(MemorySegment chunk_buf, long chunk_size) {
        var mh$ = jer_whitespace_span.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jer_whitespace_span", chunk_buf, chunk_size);
            }
            return (long)mh$.invokeExact(chunk_buf, chunk_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jer_skip_unknown {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("jer_skip_unknown");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int jer_skip_unknown(jer_check_sym_e scv, ber_tlv_len_t *depth)
     * }
     */
    public static FunctionDescriptor jer_skip_unknown$descriptor() {
        return jer_skip_unknown.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int jer_skip_unknown(jer_check_sym_e scv, ber_tlv_len_t *depth)
     * }
     */
    public static MethodHandle jer_skip_unknown$handle() {
        return jer_skip_unknown.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int jer_skip_unknown(jer_check_sym_e scv, ber_tlv_len_t *depth)
     * }
     */
    public static MemorySegment jer_skip_unknown$address() {
        return jer_skip_unknown.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int jer_skip_unknown(jer_check_sym_e scv, ber_tlv_len_t *depth)
     * }
     */
    public static int jer_skip_unknown(int scv, MemorySegment depth) {
        var mh$ = jer_skip_unknown.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jer_skip_unknown", scv, depth);
            }
            return (int)mh$.invokeExact(scv, depth);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int JER_F = (int)1L;
    /**
     * {@snippet lang=c :
     * enum jer_encoder_flags_e.JER_F = 1
     * }
     */
    public static int JER_F() {
        return JER_F;
    }
    private static final int JER_F_MINIFIED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum jer_encoder_flags_e.JER_F_MINIFIED = 2
     * }
     */
    public static int JER_F_MINIFIED() {
        return JER_F_MINIFIED;
    }

    private static class jer_encode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("jer_encode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t jer_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, enum jer_encoder_flags_e jer_flags, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static FunctionDescriptor jer_encode$descriptor() {
        return jer_encode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t jer_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, enum jer_encoder_flags_e jer_flags, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static MethodHandle jer_encode$handle() {
        return jer_encode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t jer_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, enum jer_encoder_flags_e jer_flags, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static MemorySegment jer_encode$address() {
        return jer_encode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t jer_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, enum jer_encoder_flags_e jer_flags, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static MemorySegment jer_encode(SegmentAllocator allocator, MemorySegment type_descriptor, MemorySegment struct_ptr, int jer_flags, MemorySegment consume_bytes_cb, MemorySegment app_key) {
        var mh$ = jer_encode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jer_encode", allocator, type_descriptor, struct_ptr, jer_flags, consume_bytes_cb, app_key);
            }
            return (MemorySegment)mh$.invokeExact(allocator, type_descriptor, struct_ptr, jer_flags, consume_bytes_cb, app_key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class jer_fprint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("jer_fprint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int jer_fprint(FILE *stream, const struct asn_TYPE_descriptor_s *td, const void *struct_ptr)
     * }
     */
    public static FunctionDescriptor jer_fprint$descriptor() {
        return jer_fprint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int jer_fprint(FILE *stream, const struct asn_TYPE_descriptor_s *td, const void *struct_ptr)
     * }
     */
    public static MethodHandle jer_fprint$handle() {
        return jer_fprint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int jer_fprint(FILE *stream, const struct asn_TYPE_descriptor_s *td, const void *struct_ptr)
     * }
     */
    public static MemorySegment jer_fprint$address() {
        return jer_fprint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int jer_fprint(FILE *stream, const struct asn_TYPE_descriptor_s *td, const void *struct_ptr)
     * }
     */
    public static int jer_fprint(MemorySegment stream, MemorySegment td, MemorySegment struct_ptr) {
        var mh$ = jer_fprint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jer_fprint", stream, td, struct_ptr);
            }
            return (int)mh$.invokeExact(stream, td, struct_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int JEQ_SUCCESS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum jer_equivalence_e.JEQ_SUCCESS = 0
     * }
     */
    public static int JEQ_SUCCESS() {
        return JEQ_SUCCESS;
    }
    private static final int JEQ_FAILURE = (int)1L;
    /**
     * {@snippet lang=c :
     * enum jer_equivalence_e.JEQ_FAILURE = 1
     * }
     */
    public static int JEQ_FAILURE() {
        return JEQ_FAILURE;
    }
    private static final int JEQ_ENCODE1_FAILED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum jer_equivalence_e.JEQ_ENCODE1_FAILED = 2
     * }
     */
    public static int JEQ_ENCODE1_FAILED() {
        return JEQ_ENCODE1_FAILED;
    }
    private static final int JEQ_ENCODE2_FAILED = (int)3L;
    /**
     * {@snippet lang=c :
     * enum jer_equivalence_e.JEQ_ENCODE2_FAILED = 3
     * }
     */
    public static int JEQ_ENCODE2_FAILED() {
        return JEQ_ENCODE2_FAILED;
    }
    private static final int JEQ_DIFFERENT = (int)4L;
    /**
     * {@snippet lang=c :
     * enum jer_equivalence_e.JEQ_DIFFERENT = 4
     * }
     */
    public static int JEQ_DIFFERENT() {
        return JEQ_DIFFERENT;
    }
    private static final int JEQ_DECODE_FAILED = (int)5L;
    /**
     * {@snippet lang=c :
     * enum jer_equivalence_e.JEQ_DECODE_FAILED = 5
     * }
     */
    public static int JEQ_DECODE_FAILED() {
        return JEQ_DECODE_FAILED;
    }
    private static final int JEQ_ROUND_TRIP_FAILED = (int)6L;
    /**
     * {@snippet lang=c :
     * enum jer_equivalence_e.JEQ_ROUND_TRIP_FAILED = 6
     * }
     */
    public static int JEQ_ROUND_TRIP_FAILED() {
        return JEQ_ROUND_TRIP_FAILED;
    }

    private static class jer_equivalent {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("jer_equivalent");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum jer_equivalence_e jer_equivalent(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct1, const void *struct2, FILE *opt_debug_stream)
     * }
     */
    public static FunctionDescriptor jer_equivalent$descriptor() {
        return jer_equivalent.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum jer_equivalence_e jer_equivalent(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct1, const void *struct2, FILE *opt_debug_stream)
     * }
     */
    public static MethodHandle jer_equivalent$handle() {
        return jer_equivalent.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum jer_equivalence_e jer_equivalent(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct1, const void *struct2, FILE *opt_debug_stream)
     * }
     */
    public static MemorySegment jer_equivalent$address() {
        return jer_equivalent.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum jer_equivalence_e jer_equivalent(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct1, const void *struct2, FILE *opt_debug_stream)
     * }
     */
    public static int jer_equivalent(MemorySegment type_descriptor, MemorySegment struct1, MemorySegment struct2, MemorySegment opt_debug_stream) {
        var mh$ = jer_equivalent.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jer_equivalent", type_descriptor, struct1, struct2, opt_debug_stream);
            }
            return (int)mh$.invokeExact(type_descriptor, struct1, struct2, opt_debug_stream);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_bit_data_new_contiguous {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_bit_data_new_contiguous");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_bit_data_t *asn_bit_data_new_contiguous(const void *data, size_t size_bits)
     * }
     */
    public static FunctionDescriptor asn_bit_data_new_contiguous$descriptor() {
        return asn_bit_data_new_contiguous.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_bit_data_t *asn_bit_data_new_contiguous(const void *data, size_t size_bits)
     * }
     */
    public static MethodHandle asn_bit_data_new_contiguous$handle() {
        return asn_bit_data_new_contiguous.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_bit_data_t *asn_bit_data_new_contiguous(const void *data, size_t size_bits)
     * }
     */
    public static MemorySegment asn_bit_data_new_contiguous$address() {
        return asn_bit_data_new_contiguous.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_bit_data_t *asn_bit_data_new_contiguous(const void *data, size_t size_bits)
     * }
     */
    public static MemorySegment asn_bit_data_new_contiguous(MemorySegment data, long size_bits) {
        var mh$ = asn_bit_data_new_contiguous.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_bit_data_new_contiguous", data, size_bits);
            }
            return (MemorySegment)mh$.invokeExact(data, size_bits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_get_few_bits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_get_few_bits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t asn_get_few_bits(asn_bit_data_t *, int get_nbits)
     * }
     */
    public static FunctionDescriptor asn_get_few_bits$descriptor() {
        return asn_get_few_bits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t asn_get_few_bits(asn_bit_data_t *, int get_nbits)
     * }
     */
    public static MethodHandle asn_get_few_bits$handle() {
        return asn_get_few_bits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t asn_get_few_bits(asn_bit_data_t *, int get_nbits)
     * }
     */
    public static MemorySegment asn_get_few_bits$address() {
        return asn_get_few_bits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t asn_get_few_bits(asn_bit_data_t *, int get_nbits)
     * }
     */
    public static int asn_get_few_bits(MemorySegment x0, int get_nbits) {
        var mh$ = asn_get_few_bits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_get_few_bits", x0, get_nbits);
            }
            return (int)mh$.invokeExact(x0, get_nbits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_get_undo {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_get_undo");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void asn_get_undo(asn_bit_data_t *, int get_nbits)
     * }
     */
    public static FunctionDescriptor asn_get_undo$descriptor() {
        return asn_get_undo.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void asn_get_undo(asn_bit_data_t *, int get_nbits)
     * }
     */
    public static MethodHandle asn_get_undo$handle() {
        return asn_get_undo.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void asn_get_undo(asn_bit_data_t *, int get_nbits)
     * }
     */
    public static MemorySegment asn_get_undo$address() {
        return asn_get_undo.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void asn_get_undo(asn_bit_data_t *, int get_nbits)
     * }
     */
    public static void asn_get_undo(MemorySegment x0, int get_nbits) {
        var mh$ = asn_get_undo.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_get_undo", x0, get_nbits);
            }
            mh$.invokeExact(x0, get_nbits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_get_many_bits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_get_many_bits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int asn_get_many_bits(asn_bit_data_t *, uint8_t *dst, int right_align, int get_nbits)
     * }
     */
    public static FunctionDescriptor asn_get_many_bits$descriptor() {
        return asn_get_many_bits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int asn_get_many_bits(asn_bit_data_t *, uint8_t *dst, int right_align, int get_nbits)
     * }
     */
    public static MethodHandle asn_get_many_bits$handle() {
        return asn_get_many_bits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int asn_get_many_bits(asn_bit_data_t *, uint8_t *dst, int right_align, int get_nbits)
     * }
     */
    public static MemorySegment asn_get_many_bits$address() {
        return asn_get_many_bits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int asn_get_many_bits(asn_bit_data_t *, uint8_t *dst, int right_align, int get_nbits)
     * }
     */
    public static int asn_get_many_bits(MemorySegment x0, MemorySegment dst, int right_align, int get_nbits) {
        var mh$ = asn_get_many_bits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_get_many_bits", x0, dst, right_align, get_nbits);
            }
            return (int)mh$.invokeExact(x0, dst, right_align, get_nbits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_bit_data_string {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_bit_data_string");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * char *asn_bit_data_string(asn_bit_data_t *)
     * }
     */
    public static FunctionDescriptor asn_bit_data_string$descriptor() {
        return asn_bit_data_string.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * char *asn_bit_data_string(asn_bit_data_t *)
     * }
     */
    public static MethodHandle asn_bit_data_string$handle() {
        return asn_bit_data_string.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * char *asn_bit_data_string(asn_bit_data_t *)
     * }
     */
    public static MemorySegment asn_bit_data_string$address() {
        return asn_bit_data_string.ADDR;
    }

    /**
     * {@snippet lang=c :
     * char *asn_bit_data_string(asn_bit_data_t *)
     * }
     */
    public static MemorySegment asn_bit_data_string(MemorySegment x0) {
        var mh$ = asn_bit_data_string.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_bit_data_string", x0);
            }
            return (MemorySegment)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_put_few_bits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_put_few_bits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int asn_put_few_bits(asn_bit_outp_t *, uint32_t bits, int obits)
     * }
     */
    public static FunctionDescriptor asn_put_few_bits$descriptor() {
        return asn_put_few_bits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int asn_put_few_bits(asn_bit_outp_t *, uint32_t bits, int obits)
     * }
     */
    public static MethodHandle asn_put_few_bits$handle() {
        return asn_put_few_bits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int asn_put_few_bits(asn_bit_outp_t *, uint32_t bits, int obits)
     * }
     */
    public static MemorySegment asn_put_few_bits$address() {
        return asn_put_few_bits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int asn_put_few_bits(asn_bit_outp_t *, uint32_t bits, int obits)
     * }
     */
    public static int asn_put_few_bits(MemorySegment x0, int bits, int obits) {
        var mh$ = asn_put_few_bits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_put_few_bits", x0, bits, obits);
            }
            return (int)mh$.invokeExact(x0, bits, obits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_put_many_bits {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_put_many_bits");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int asn_put_many_bits(asn_bit_outp_t *, const uint8_t *src, int put_nbits)
     * }
     */
    public static FunctionDescriptor asn_put_many_bits$descriptor() {
        return asn_put_many_bits.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int asn_put_many_bits(asn_bit_outp_t *, const uint8_t *src, int put_nbits)
     * }
     */
    public static MethodHandle asn_put_many_bits$handle() {
        return asn_put_many_bits.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int asn_put_many_bits(asn_bit_outp_t *, const uint8_t *src, int put_nbits)
     * }
     */
    public static MemorySegment asn_put_many_bits$address() {
        return asn_put_many_bits.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int asn_put_many_bits(asn_bit_outp_t *, const uint8_t *src, int put_nbits)
     * }
     */
    public static int asn_put_many_bits(MemorySegment x0, MemorySegment src, int put_nbits) {
        var mh$ = asn_put_many_bits.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_put_many_bits", x0, src, put_nbits);
            }
            return (int)mh$.invokeExact(x0, src, put_nbits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_put_aligned_flush {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_put_aligned_flush");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int asn_put_aligned_flush(asn_bit_outp_t *)
     * }
     */
    public static FunctionDescriptor asn_put_aligned_flush$descriptor() {
        return asn_put_aligned_flush.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int asn_put_aligned_flush(asn_bit_outp_t *)
     * }
     */
    public static MethodHandle asn_put_aligned_flush$handle() {
        return asn_put_aligned_flush.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int asn_put_aligned_flush(asn_bit_outp_t *)
     * }
     */
    public static MemorySegment asn_put_aligned_flush$address() {
        return asn_put_aligned_flush.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int asn_put_aligned_flush(asn_bit_outp_t *)
     * }
     */
    public static int asn_put_aligned_flush(MemorySegment x0) {
        var mh$ = asn_put_aligned_flush.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_put_aligned_flush", x0);
            }
            return (int)mh$.invokeExact(x0);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int APC_UNCONSTRAINED = (int)0L;
    /**
     * {@snippet lang=c :
     * enum asn_per_constraint_flags.APC_UNCONSTRAINED = 0
     * }
     */
    public static int APC_UNCONSTRAINED() {
        return APC_UNCONSTRAINED;
    }
    private static final int APC_SEMI_CONSTRAINED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum asn_per_constraint_flags.APC_SEMI_CONSTRAINED = 1
     * }
     */
    public static int APC_SEMI_CONSTRAINED() {
        return APC_SEMI_CONSTRAINED;
    }
    private static final int APC_CONSTRAINED = (int)2L;
    /**
     * {@snippet lang=c :
     * enum asn_per_constraint_flags.APC_CONSTRAINED = 2
     * }
     */
    public static int APC_CONSTRAINED() {
        return APC_CONSTRAINED;
    }
    private static final int APC_EXTENSIBLE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum asn_per_constraint_flags.APC_EXTENSIBLE = 4
     * }
     */
    public static int APC_EXTENSIBLE() {
        return APC_EXTENSIBLE;
    }

    private static class ignore_output {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ignore_output");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ignore_output(const void *data, size_t size, void *app_key)
     * }
     */
    public static FunctionDescriptor ignore_output$descriptor() {
        return ignore_output.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ignore_output(const void *data, size_t size, void *app_key)
     * }
     */
    public static MethodHandle ignore_output$handle() {
        return ignore_output.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ignore_output(const void *data, size_t size, void *app_key)
     * }
     */
    public static MemorySegment ignore_output$address() {
        return ignore_output.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ignore_output(const void *data, size_t size, void *app_key)
     * }
     */
    public static int ignore_output(MemorySegment data, long size, MemorySegment app_key) {
        var mh$ = ignore_output.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ignore_output", data, size, app_key);
            }
            return (int)mh$.invokeExact(data, size, app_key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class encode_dyn_cb {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("encode_dyn_cb");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int encode_dyn_cb(const void *buffer, size_t size, void *key)
     * }
     */
    public static FunctionDescriptor encode_dyn_cb$descriptor() {
        return encode_dyn_cb.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int encode_dyn_cb(const void *buffer, size_t size, void *key)
     * }
     */
    public static MethodHandle encode_dyn_cb$handle() {
        return encode_dyn_cb.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int encode_dyn_cb(const void *buffer, size_t size, void *key)
     * }
     */
    public static MemorySegment encode_dyn_cb$address() {
        return encode_dyn_cb.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int encode_dyn_cb(const void *buffer, size_t size, void *key)
     * }
     */
    public static int encode_dyn_cb(MemorySegment buffer, long size, MemorySegment key) {
        var mh$ = encode_dyn_cb.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("encode_dyn_cb", buffer, size, key);
            }
            return (int)mh$.invokeExact(buffer, size, key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_check_constraints {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_check_constraints");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int asn_check_constraints(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, char *errbuf, size_t *errlen)
     * }
     */
    public static FunctionDescriptor asn_check_constraints$descriptor() {
        return asn_check_constraints.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int asn_check_constraints(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, char *errbuf, size_t *errlen)
     * }
     */
    public static MethodHandle asn_check_constraints$handle() {
        return asn_check_constraints.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int asn_check_constraints(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, char *errbuf, size_t *errlen)
     * }
     */
    public static MemorySegment asn_check_constraints$address() {
        return asn_check_constraints.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int asn_check_constraints(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, char *errbuf, size_t *errlen)
     * }
     */
    public static int asn_check_constraints(MemorySegment type_descriptor, MemorySegment struct_ptr, MemorySegment errbuf, MemorySegment errlen) {
        var mh$ = asn_check_constraints.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_check_constraints", type_descriptor, struct_ptr, errbuf, errlen);
            }
            return (int)mh$.invokeExact(type_descriptor, struct_ptr, errbuf, errlen);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_generic_no_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_generic_no_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int asn_generic_no_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor asn_generic_no_constraint$descriptor() {
        return asn_generic_no_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int asn_generic_no_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle asn_generic_no_constraint$handle() {
        return asn_generic_no_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int asn_generic_no_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment asn_generic_no_constraint$address() {
        return asn_generic_no_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int asn_generic_no_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int asn_generic_no_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = asn_generic_no_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_generic_no_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_generic_unknown_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_generic_unknown_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int asn_generic_unknown_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor asn_generic_unknown_constraint$descriptor() {
        return asn_generic_unknown_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int asn_generic_unknown_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle asn_generic_unknown_constraint$handle() {
        return asn_generic_unknown_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int asn_generic_unknown_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment asn_generic_unknown_constraint$address() {
        return asn_generic_unknown_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int asn_generic_unknown_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int asn_generic_unknown_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = asn_generic_unknown_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_generic_unknown_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ARFILL_FAILED = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ARFILL_FAILED = -1
     * }
     */
    public static int ARFILL_FAILED() {
        return ARFILL_FAILED;
    }
    private static final int ARFILL_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ARFILL_OK = 0
     * }
     */
    public static int ARFILL_OK() {
        return ARFILL_OK;
    }
    private static final int ARFILL_SKIPPED = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.ARFILL_SKIPPED = 1
     * }
     */
    public static int ARFILL_SKIPPED() {
        return ARFILL_SKIPPED;
    }

    private static class asn_random_fill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_random_fill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int asn_random_fill(const struct asn_TYPE_descriptor_s *td, void **struct_ptr, size_t approx_max_length_limit)
     * }
     */
    public static FunctionDescriptor asn_random_fill$descriptor() {
        return asn_random_fill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int asn_random_fill(const struct asn_TYPE_descriptor_s *td, void **struct_ptr, size_t approx_max_length_limit)
     * }
     */
    public static MethodHandle asn_random_fill$handle() {
        return asn_random_fill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int asn_random_fill(const struct asn_TYPE_descriptor_s *td, void **struct_ptr, size_t approx_max_length_limit)
     * }
     */
    public static MemorySegment asn_random_fill$address() {
        return asn_random_fill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int asn_random_fill(const struct asn_TYPE_descriptor_s *td, void **struct_ptr, size_t approx_max_length_limit)
     * }
     */
    public static int asn_random_fill(MemorySegment td, MemorySegment struct_ptr, long approx_max_length_limit) {
        var mh$ = asn_random_fill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_random_fill", td, struct_ptr, approx_max_length_limit);
            }
            return (int)mh$.invokeExact(td, struct_ptr, approx_max_length_limit);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_random_between {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_random_between");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * intmax_t asn_random_between(intmax_t min, intmax_t max)
     * }
     */
    public static FunctionDescriptor asn_random_between$descriptor() {
        return asn_random_between.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * intmax_t asn_random_between(intmax_t min, intmax_t max)
     * }
     */
    public static MethodHandle asn_random_between$handle() {
        return asn_random_between.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * intmax_t asn_random_between(intmax_t min, intmax_t max)
     * }
     */
    public static MemorySegment asn_random_between$address() {
        return asn_random_between.ADDR;
    }

    /**
     * {@snippet lang=c :
     * intmax_t asn_random_between(intmax_t min, intmax_t max)
     * }
     */
    public static long asn_random_between(long min, long max) {
        var mh$ = asn_random_between.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_random_between", min, max);
            }
            return (long)mh$.invokeExact(min, max);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oer_fetch_length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("oer_fetch_length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t oer_fetch_length(const void *bufptr, size_t size, size_t *len_r)
     * }
     */
    public static FunctionDescriptor oer_fetch_length$descriptor() {
        return oer_fetch_length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t oer_fetch_length(const void *bufptr, size_t size, size_t *len_r)
     * }
     */
    public static MethodHandle oer_fetch_length$handle() {
        return oer_fetch_length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t oer_fetch_length(const void *bufptr, size_t size, size_t *len_r)
     * }
     */
    public static MemorySegment oer_fetch_length$address() {
        return oer_fetch_length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t oer_fetch_length(const void *bufptr, size_t size, size_t *len_r)
     * }
     */
    public static long oer_fetch_length(MemorySegment bufptr, long size, MemorySegment len_r) {
        var mh$ = oer_fetch_length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oer_fetch_length", bufptr, size, len_r);
            }
            return (long)mh$.invokeExact(bufptr, size, len_r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oer_serialize_length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("oer_serialize_length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t oer_serialize_length(size_t length, asn_app_consume_bytes_f *cb, void *app_key)
     * }
     */
    public static FunctionDescriptor oer_serialize_length$descriptor() {
        return oer_serialize_length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t oer_serialize_length(size_t length, asn_app_consume_bytes_f *cb, void *app_key)
     * }
     */
    public static MethodHandle oer_serialize_length$handle() {
        return oer_serialize_length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t oer_serialize_length(size_t length, asn_app_consume_bytes_f *cb, void *app_key)
     * }
     */
    public static MemorySegment oer_serialize_length$address() {
        return oer_serialize_length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t oer_serialize_length(size_t length, asn_app_consume_bytes_f *cb, void *app_key)
     * }
     */
    public static long oer_serialize_length(long length, MemorySegment cb, MemorySegment app_key) {
        var mh$ = oer_serialize_length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oer_serialize_length", length, cb, app_key);
            }
            return (long)mh$.invokeExact(length, cb, app_key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oer_decode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("oer_decode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t oer_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static FunctionDescriptor oer_decode$descriptor() {
        return oer_decode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t oer_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static MethodHandle oer_decode$handle() {
        return oer_decode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t oer_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static MemorySegment oer_decode$address() {
        return oer_decode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t oer_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static MemorySegment oer_decode(SegmentAllocator allocator, MemorySegment opt_codec_ctx, MemorySegment type_descriptor, MemorySegment struct_ptr, MemorySegment buffer, long size) {
        var mh$ = oer_decode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oer_decode", allocator, opt_codec_ctx, type_descriptor, struct_ptr, buffer, size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, opt_codec_ctx, type_descriptor, struct_ptr, buffer, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oer_open_type_skip {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("oer_open_type_skip");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t oer_open_type_skip(const void *bufptr, size_t size)
     * }
     */
    public static FunctionDescriptor oer_open_type_skip$descriptor() {
        return oer_open_type_skip.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t oer_open_type_skip(const void *bufptr, size_t size)
     * }
     */
    public static MethodHandle oer_open_type_skip$handle() {
        return oer_open_type_skip.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t oer_open_type_skip(const void *bufptr, size_t size)
     * }
     */
    public static MemorySegment oer_open_type_skip$address() {
        return oer_open_type_skip.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t oer_open_type_skip(const void *bufptr, size_t size)
     * }
     */
    public static long oer_open_type_skip(MemorySegment bufptr, long size) {
        var mh$ = oer_open_type_skip.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oer_open_type_skip", bufptr, size);
            }
            return (long)mh$.invokeExact(bufptr, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oer_open_type_get {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("oer_open_type_get");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t oer_open_type_get(const asn_codec_ctx_t *opt_codec_ctx, const struct asn_TYPE_descriptor_s *td, const asn_oer_constraints_t *constraints, void **struct_ptr, const void *bufptr, size_t size)
     * }
     */
    public static FunctionDescriptor oer_open_type_get$descriptor() {
        return oer_open_type_get.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t oer_open_type_get(const asn_codec_ctx_t *opt_codec_ctx, const struct asn_TYPE_descriptor_s *td, const asn_oer_constraints_t *constraints, void **struct_ptr, const void *bufptr, size_t size)
     * }
     */
    public static MethodHandle oer_open_type_get$handle() {
        return oer_open_type_get.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t oer_open_type_get(const asn_codec_ctx_t *opt_codec_ctx, const struct asn_TYPE_descriptor_s *td, const asn_oer_constraints_t *constraints, void **struct_ptr, const void *bufptr, size_t size)
     * }
     */
    public static MemorySegment oer_open_type_get$address() {
        return oer_open_type_get.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t oer_open_type_get(const asn_codec_ctx_t *opt_codec_ctx, const struct asn_TYPE_descriptor_s *td, const asn_oer_constraints_t *constraints, void **struct_ptr, const void *bufptr, size_t size)
     * }
     */
    public static long oer_open_type_get(MemorySegment opt_codec_ctx, MemorySegment td, MemorySegment constraints, MemorySegment struct_ptr, MemorySegment bufptr, long size) {
        var mh$ = oer_open_type_get.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oer_open_type_get", opt_codec_ctx, td, constraints, struct_ptr, bufptr, size);
            }
            return (long)mh$.invokeExact(opt_codec_ctx, td, constraints, struct_ptr, bufptr, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oer_decode_primitive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("oer_decode_primitive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t oer_decode_primitive(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor oer_decode_primitive$descriptor() {
        return oer_decode_primitive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t oer_decode_primitive(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle oer_decode_primitive$handle() {
        return oer_decode_primitive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t oer_decode_primitive(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment oer_decode_primitive$address() {
        return oer_decode_primitive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t oer_decode_primitive(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment oer_decode_primitive(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = oer_decode_primitive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oer_decode_primitive", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oer_encode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("oer_encode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t oer_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static FunctionDescriptor oer_encode$descriptor() {
        return oer_encode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t oer_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static MethodHandle oer_encode$handle() {
        return oer_encode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t oer_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static MemorySegment oer_encode$address() {
        return oer_encode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t oer_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const void *struct_ptr, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static MemorySegment oer_encode(SegmentAllocator allocator, MemorySegment type_descriptor, MemorySegment struct_ptr, MemorySegment consume_bytes_cb, MemorySegment app_key) {
        var mh$ = oer_encode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oer_encode", allocator, type_descriptor, struct_ptr, consume_bytes_cb, app_key);
            }
            return (MemorySegment)mh$.invokeExact(allocator, type_descriptor, struct_ptr, consume_bytes_cb, app_key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oer_encode_to_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("oer_encode_to_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t oer_encode_to_buffer(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_oer_constraints_t *constraints, const void *struct_ptr, void *buffer, size_t buffer_size)
     * }
     */
    public static FunctionDescriptor oer_encode_to_buffer$descriptor() {
        return oer_encode_to_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t oer_encode_to_buffer(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_oer_constraints_t *constraints, const void *struct_ptr, void *buffer, size_t buffer_size)
     * }
     */
    public static MethodHandle oer_encode_to_buffer$handle() {
        return oer_encode_to_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t oer_encode_to_buffer(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_oer_constraints_t *constraints, const void *struct_ptr, void *buffer, size_t buffer_size)
     * }
     */
    public static MemorySegment oer_encode_to_buffer$address() {
        return oer_encode_to_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t oer_encode_to_buffer(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_oer_constraints_t *constraints, const void *struct_ptr, void *buffer, size_t buffer_size)
     * }
     */
    public static MemorySegment oer_encode_to_buffer(SegmentAllocator allocator, MemorySegment type_descriptor, MemorySegment constraints, MemorySegment struct_ptr, MemorySegment buffer, long buffer_size) {
        var mh$ = oer_encode_to_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oer_encode_to_buffer", allocator, type_descriptor, constraints, struct_ptr, buffer, buffer_size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, type_descriptor, constraints, struct_ptr, buffer, buffer_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oer_open_type_put {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("oer_open_type_put");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t oer_open_type_put(const struct asn_TYPE_descriptor_s *td, const asn_oer_constraints_t *constraints, const void *struct_ptr, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static FunctionDescriptor oer_open_type_put$descriptor() {
        return oer_open_type_put.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t oer_open_type_put(const struct asn_TYPE_descriptor_s *td, const asn_oer_constraints_t *constraints, const void *struct_ptr, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static MethodHandle oer_open_type_put$handle() {
        return oer_open_type_put.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t oer_open_type_put(const struct asn_TYPE_descriptor_s *td, const asn_oer_constraints_t *constraints, const void *struct_ptr, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static MemorySegment oer_open_type_put$address() {
        return oer_open_type_put.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t oer_open_type_put(const struct asn_TYPE_descriptor_s *td, const asn_oer_constraints_t *constraints, const void *struct_ptr, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static long oer_open_type_put(MemorySegment td, MemorySegment constraints, MemorySegment struct_ptr, MemorySegment consume_bytes_cb, MemorySegment app_key) {
        var mh$ = oer_open_type_put.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oer_open_type_put", td, constraints, struct_ptr, consume_bytes_cb, app_key);
            }
            return (long)mh$.invokeExact(td, constraints, struct_ptr, consume_bytes_cb, app_key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class oer_encode_primitive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("oer_encode_primitive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t oer_encode_primitive(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor oer_encode_primitive$descriptor() {
        return oer_encode_primitive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t oer_encode_primitive(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle oer_encode_primitive$handle() {
        return oer_encode_primitive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t oer_encode_primitive(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment oer_encode_primitive$address() {
        return oer_encode_primitive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t oer_encode_primitive(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment oer_encode_primitive(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = oer_encode_primitive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("oer_encode_primitive", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ASFM_FREE_EVERYTHING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum asn_struct_free_method.ASFM_FREE_EVERYTHING = 0
     * }
     */
    public static int ASFM_FREE_EVERYTHING() {
        return ASFM_FREE_EVERYTHING;
    }
    private static final int ASFM_FREE_UNDERLYING = (int)1L;
    /**
     * {@snippet lang=c :
     * enum asn_struct_free_method.ASFM_FREE_UNDERLYING = 1
     * }
     */
    public static int ASFM_FREE_UNDERLYING() {
        return ASFM_FREE_UNDERLYING;
    }
    private static final int ASFM_FREE_UNDERLYING_AND_RESET = (int)2L;
    /**
     * {@snippet lang=c :
     * enum asn_struct_free_method.ASFM_FREE_UNDERLYING_AND_RESET = 2
     * }
     */
    public static int ASFM_FREE_UNDERLYING_AND_RESET() {
        return ASFM_FREE_UNDERLYING_AND_RESET;
    }

    private static class asn_TYPE_outmost_tag {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_TYPE_outmost_tag");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ber_tlv_tag_t asn_TYPE_outmost_tag(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t)
     * }
     */
    public static FunctionDescriptor asn_TYPE_outmost_tag$descriptor() {
        return asn_TYPE_outmost_tag.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ber_tlv_tag_t asn_TYPE_outmost_tag(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t)
     * }
     */
    public static MethodHandle asn_TYPE_outmost_tag$handle() {
        return asn_TYPE_outmost_tag.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ber_tlv_tag_t asn_TYPE_outmost_tag(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t)
     * }
     */
    public static MemorySegment asn_TYPE_outmost_tag$address() {
        return asn_TYPE_outmost_tag.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ber_tlv_tag_t asn_TYPE_outmost_tag(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t)
     * }
     */
    public static int asn_TYPE_outmost_tag(MemorySegment x0, MemorySegment x1, int x2, int x3) {
        var mh$ = asn_TYPE_outmost_tag.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_TYPE_outmost_tag", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ATF_NOFLAGS = (int)0L;
    /**
     * {@snippet lang=c :
     * enum asn_TYPE_flags_e.ATF_NOFLAGS = 0
     * }
     */
    public static int ATF_NOFLAGS() {
        return ATF_NOFLAGS;
    }
    private static final int ATF_POINTER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum asn_TYPE_flags_e.ATF_POINTER = 1
     * }
     */
    public static int ATF_POINTER() {
        return ATF_POINTER;
    }
    private static final int ATF_OPEN_TYPE = (int)2L;
    /**
     * {@snippet lang=c :
     * enum asn_TYPE_flags_e.ATF_OPEN_TYPE = 2
     * }
     */
    public static int ATF_OPEN_TYPE() {
        return ATF_OPEN_TYPE;
    }
    private static final int ATF_ANY_TYPE = (int)4L;
    /**
     * {@snippet lang=c :
     * enum asn_TYPE_flags_e.ATF_ANY_TYPE = 4
     * }
     */
    public static int ATF_ANY_TYPE() {
        return ATF_ANY_TYPE;
    }

    private static class asn_fprint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_fprint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int asn_fprint(FILE *stream, const asn_TYPE_descriptor_t *td, const void *struct_ptr)
     * }
     */
    public static FunctionDescriptor asn_fprint$descriptor() {
        return asn_fprint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int asn_fprint(FILE *stream, const asn_TYPE_descriptor_t *td, const void *struct_ptr)
     * }
     */
    public static MethodHandle asn_fprint$handle() {
        return asn_fprint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int asn_fprint(FILE *stream, const asn_TYPE_descriptor_t *td, const void *struct_ptr)
     * }
     */
    public static MemorySegment asn_fprint$address() {
        return asn_fprint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int asn_fprint(FILE *stream, const asn_TYPE_descriptor_t *td, const void *struct_ptr)
     * }
     */
    public static int asn_fprint(MemorySegment stream, MemorySegment td, MemorySegment struct_ptr) {
        var mh$ = asn_fprint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_fprint", stream, td, struct_ptr);
            }
            return (int)mh$.invokeExact(stream, td, struct_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int asn_copy(const asn_TYPE_descriptor_t *td, void **struct_dst, const void *struct_src)
     * }
     */
    public static FunctionDescriptor asn_copy$descriptor() {
        return asn_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int asn_copy(const asn_TYPE_descriptor_t *td, void **struct_dst, const void *struct_src)
     * }
     */
    public static MethodHandle asn_copy$handle() {
        return asn_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int asn_copy(const asn_TYPE_descriptor_t *td, void **struct_dst, const void *struct_src)
     * }
     */
    public static MemorySegment asn_copy$address() {
        return asn_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int asn_copy(const asn_TYPE_descriptor_t *td, void **struct_dst, const void *struct_src)
     * }
     */
    public static int asn_copy(MemorySegment td, MemorySegment struct_dst, MemorySegment struct_src) {
        var mh$ = asn_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_copy", td, struct_dst, struct_src);
            }
            return (int)mh$.invokeExact(td, struct_dst, struct_src);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ASN__PRIMITIVE_TYPE_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ASN__PRIMITIVE_TYPE_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ASN__PRIMITIVE_TYPE_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor ASN__PRIMITIVE_TYPE_free$descriptor() {
        return ASN__PRIMITIVE_TYPE_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ASN__PRIMITIVE_TYPE_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle ASN__PRIMITIVE_TYPE_free$handle() {
        return ASN__PRIMITIVE_TYPE_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ASN__PRIMITIVE_TYPE_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment ASN__PRIMITIVE_TYPE_free$address() {
        return ASN__PRIMITIVE_TYPE_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ASN__PRIMITIVE_TYPE_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void ASN__PRIMITIVE_TYPE_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = ASN__PRIMITIVE_TYPE_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ASN__PRIMITIVE_TYPE_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ber_decode_primitive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ber_decode_primitive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ber_decode_primitive(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor ber_decode_primitive$descriptor() {
        return ber_decode_primitive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ber_decode_primitive(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle ber_decode_primitive$handle() {
        return ber_decode_primitive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ber_decode_primitive(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment ber_decode_primitive$address() {
        return ber_decode_primitive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ber_decode_primitive(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment ber_decode_primitive(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = ber_decode_primitive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ber_decode_primitive", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class der_encode_primitive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("der_encode_primitive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t der_encode_primitive(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor der_encode_primitive$descriptor() {
        return der_encode_primitive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t der_encode_primitive(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle der_encode_primitive$handle() {
        return der_encode_primitive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t der_encode_primitive(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment der_encode_primitive$address() {
        return der_encode_primitive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t der_encode_primitive(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment der_encode_primitive(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = der_encode_primitive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("der_encode_primitive", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int XPBD_SYSTEM_FAILURE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum xer_pbd_rval.XPBD_SYSTEM_FAILURE = 0
     * }
     */
    public static int XPBD_SYSTEM_FAILURE() {
        return XPBD_SYSTEM_FAILURE;
    }
    private static final int XPBD_DECODER_LIMIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum xer_pbd_rval.XPBD_DECODER_LIMIT = 1
     * }
     */
    public static int XPBD_DECODER_LIMIT() {
        return XPBD_DECODER_LIMIT;
    }
    private static final int XPBD_BROKEN_ENCODING = (int)2L;
    /**
     * {@snippet lang=c :
     * enum xer_pbd_rval.XPBD_BROKEN_ENCODING = 2
     * }
     */
    public static int XPBD_BROKEN_ENCODING() {
        return XPBD_BROKEN_ENCODING;
    }
    private static final int XPBD_NOT_BODY_IGNORE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum xer_pbd_rval.XPBD_NOT_BODY_IGNORE = 3
     * }
     */
    public static int XPBD_NOT_BODY_IGNORE() {
        return XPBD_NOT_BODY_IGNORE;
    }
    private static final int XPBD_BODY_CONSUMED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum xer_pbd_rval.XPBD_BODY_CONSUMED = 4
     * }
     */
    public static int XPBD_BODY_CONSUMED() {
        return XPBD_BODY_CONSUMED;
    }

    private static class xer_decode_primitive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("xer_decode_primitive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t xer_decode_primitive(const asn_codec_ctx_t *opt_codec_ctx, const asn_TYPE_descriptor_t *type_descriptor, void **struct_ptr, size_t struct_size, const char *opt_mname, const void *buf_ptr, size_t size, xer_primitive_body_decoder_f *prim_body_decoder)
     * }
     */
    public static FunctionDescriptor xer_decode_primitive$descriptor() {
        return xer_decode_primitive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t xer_decode_primitive(const asn_codec_ctx_t *opt_codec_ctx, const asn_TYPE_descriptor_t *type_descriptor, void **struct_ptr, size_t struct_size, const char *opt_mname, const void *buf_ptr, size_t size, xer_primitive_body_decoder_f *prim_body_decoder)
     * }
     */
    public static MethodHandle xer_decode_primitive$handle() {
        return xer_decode_primitive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t xer_decode_primitive(const asn_codec_ctx_t *opt_codec_ctx, const asn_TYPE_descriptor_t *type_descriptor, void **struct_ptr, size_t struct_size, const char *opt_mname, const void *buf_ptr, size_t size, xer_primitive_body_decoder_f *prim_body_decoder)
     * }
     */
    public static MemorySegment xer_decode_primitive$address() {
        return xer_decode_primitive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t xer_decode_primitive(const asn_codec_ctx_t *opt_codec_ctx, const asn_TYPE_descriptor_t *type_descriptor, void **struct_ptr, size_t struct_size, const char *opt_mname, const void *buf_ptr, size_t size, xer_primitive_body_decoder_f *prim_body_decoder)
     * }
     */
    public static MemorySegment xer_decode_primitive(SegmentAllocator allocator, MemorySegment opt_codec_ctx, MemorySegment type_descriptor, MemorySegment struct_ptr, long struct_size, MemorySegment opt_mname, MemorySegment buf_ptr, long size, MemorySegment prim_body_decoder) {
        var mh$ = xer_decode_primitive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("xer_decode_primitive", allocator, opt_codec_ctx, type_descriptor, struct_ptr, struct_size, opt_mname, buf_ptr, size, prim_body_decoder);
            }
            return (MemorySegment)mh$.invokeExact(allocator, opt_codec_ctx, type_descriptor, struct_ptr, struct_size, opt_mname, buf_ptr, size, prim_body_decoder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int JPBD_SYSTEM_FAILURE = (int)0L;
    /**
     * {@snippet lang=c :
     * enum jer_pbd_rval.JPBD_SYSTEM_FAILURE = 0
     * }
     */
    public static int JPBD_SYSTEM_FAILURE() {
        return JPBD_SYSTEM_FAILURE;
    }
    private static final int JPBD_DECODER_LIMIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum jer_pbd_rval.JPBD_DECODER_LIMIT = 1
     * }
     */
    public static int JPBD_DECODER_LIMIT() {
        return JPBD_DECODER_LIMIT;
    }
    private static final int JPBD_BROKEN_ENCODING = (int)2L;
    /**
     * {@snippet lang=c :
     * enum jer_pbd_rval.JPBD_BROKEN_ENCODING = 2
     * }
     */
    public static int JPBD_BROKEN_ENCODING() {
        return JPBD_BROKEN_ENCODING;
    }
    private static final int JPBD_NOT_BODY_IGNORE = (int)3L;
    /**
     * {@snippet lang=c :
     * enum jer_pbd_rval.JPBD_NOT_BODY_IGNORE = 3
     * }
     */
    public static int JPBD_NOT_BODY_IGNORE() {
        return JPBD_NOT_BODY_IGNORE;
    }
    private static final int JPBD_BODY_CONSUMED = (int)4L;
    /**
     * {@snippet lang=c :
     * enum jer_pbd_rval.JPBD_BODY_CONSUMED = 4
     * }
     */
    public static int JPBD_BODY_CONSUMED() {
        return JPBD_BODY_CONSUMED;
    }

    private static class jer_decode_primitive {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("jer_decode_primitive");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t jer_decode_primitive(const asn_codec_ctx_t *opt_codec_ctx, const asn_TYPE_descriptor_t *type_descriptor, void **struct_ptr, size_t struct_size, const void *buf_ptr, size_t size, jer_primitive_body_decoder_f *prim_body_decoder)
     * }
     */
    public static FunctionDescriptor jer_decode_primitive$descriptor() {
        return jer_decode_primitive.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t jer_decode_primitive(const asn_codec_ctx_t *opt_codec_ctx, const asn_TYPE_descriptor_t *type_descriptor, void **struct_ptr, size_t struct_size, const void *buf_ptr, size_t size, jer_primitive_body_decoder_f *prim_body_decoder)
     * }
     */
    public static MethodHandle jer_decode_primitive$handle() {
        return jer_decode_primitive.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t jer_decode_primitive(const asn_codec_ctx_t *opt_codec_ctx, const asn_TYPE_descriptor_t *type_descriptor, void **struct_ptr, size_t struct_size, const void *buf_ptr, size_t size, jer_primitive_body_decoder_f *prim_body_decoder)
     * }
     */
    public static MemorySegment jer_decode_primitive$address() {
        return jer_decode_primitive.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t jer_decode_primitive(const asn_codec_ctx_t *opt_codec_ctx, const asn_TYPE_descriptor_t *type_descriptor, void **struct_ptr, size_t struct_size, const void *buf_ptr, size_t size, jer_primitive_body_decoder_f *prim_body_decoder)
     * }
     */
    public static MemorySegment jer_decode_primitive(SegmentAllocator allocator, MemorySegment opt_codec_ctx, MemorySegment type_descriptor, MemorySegment struct_ptr, long struct_size, MemorySegment buf_ptr, long size, MemorySegment prim_body_decoder) {
        var mh$ = jer_decode_primitive.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("jer_decode_primitive", allocator, opt_codec_ctx, type_descriptor, struct_ptr, struct_size, buf_ptr, size, prim_body_decoder);
            }
            return (MemorySegment)mh$.invokeExact(allocator, opt_codec_ctx, type_descriptor, struct_ptr, struct_size, buf_ptr, size, prim_body_decoder);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_INTEGER$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_INTEGER").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_INTEGER
     * }
     */
    public static GroupLayout asn_DEF_INTEGER$layout() {
        return asn_DEF_INTEGER$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_INTEGER
     * }
     */
    public static MemorySegment asn_DEF_INTEGER() {
        return asn_DEF_INTEGER$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_INTEGER
     * }
     */
    public static void asn_DEF_INTEGER(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_INTEGER$constants.SEGMENT, 0L, asn_DEF_INTEGER$constants.LAYOUT.byteSize());
    }

    private static class asn_OP_INTEGER$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_operation_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_OP_INTEGER").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_INTEGER
     * }
     */
    public static GroupLayout asn_OP_INTEGER$layout() {
        return asn_OP_INTEGER$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_INTEGER
     * }
     */
    public static MemorySegment asn_OP_INTEGER() {
        return asn_OP_INTEGER$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_INTEGER
     * }
     */
    public static void asn_OP_INTEGER(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_OP_INTEGER$constants.SEGMENT, 0L, asn_OP_INTEGER$constants.LAYOUT.byteSize());
    }

    private static class INTEGER__dump {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("INTEGER__dump");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t INTEGER__dump(const asn_TYPE_descriptor_t *td, const INTEGER_t *st, asn_app_consume_bytes_f *cb, void *app_key, int plainOrXER)
     * }
     */
    public static FunctionDescriptor INTEGER__dump$descriptor() {
        return INTEGER__dump.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t INTEGER__dump(const asn_TYPE_descriptor_t *td, const INTEGER_t *st, asn_app_consume_bytes_f *cb, void *app_key, int plainOrXER)
     * }
     */
    public static MethodHandle INTEGER__dump$handle() {
        return INTEGER__dump.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t INTEGER__dump(const asn_TYPE_descriptor_t *td, const INTEGER_t *st, asn_app_consume_bytes_f *cb, void *app_key, int plainOrXER)
     * }
     */
    public static MemorySegment INTEGER__dump$address() {
        return INTEGER__dump.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t INTEGER__dump(const asn_TYPE_descriptor_t *td, const INTEGER_t *st, asn_app_consume_bytes_f *cb, void *app_key, int plainOrXER)
     * }
     */
    public static long INTEGER__dump(MemorySegment td, MemorySegment st, MemorySegment cb, MemorySegment app_key, int plainOrXER) {
        var mh$ = INTEGER__dump.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("INTEGER__dump", td, st, cb, app_key, plainOrXER);
            }
            return (long)mh$.invokeExact(td, st, cb, app_key, plainOrXER);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class INTEGER_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("INTEGER_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int INTEGER_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor INTEGER_print$descriptor() {
        return INTEGER_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int INTEGER_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle INTEGER_print$handle() {
        return INTEGER_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int INTEGER_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment INTEGER_print$address() {
        return INTEGER_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int INTEGER_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int INTEGER_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = INTEGER_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("INTEGER_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class INTEGER_compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("INTEGER_compare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int INTEGER_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static FunctionDescriptor INTEGER_compare$descriptor() {
        return INTEGER_compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int INTEGER_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static MethodHandle INTEGER_compare$handle() {
        return INTEGER_compare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int INTEGER_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static MemorySegment INTEGER_compare$address() {
        return INTEGER_compare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int INTEGER_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static int INTEGER_compare(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = INTEGER_compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("INTEGER_compare", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class INTEGER_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("INTEGER_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int INTEGER_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static FunctionDescriptor INTEGER_copy$descriptor() {
        return INTEGER_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int INTEGER_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static MethodHandle INTEGER_copy$handle() {
        return INTEGER_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int INTEGER_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static MemorySegment INTEGER_copy$address() {
        return INTEGER_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int INTEGER_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static int INTEGER_copy(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = INTEGER_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("INTEGER_copy", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class INTEGER_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("INTEGER_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor INTEGER_encode_der$descriptor() {
        return INTEGER_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle INTEGER_encode_der$handle() {
        return INTEGER_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment INTEGER_encode_der$address() {
        return INTEGER_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment INTEGER_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = INTEGER_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("INTEGER_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class INTEGER_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("INTEGER_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t INTEGER_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor INTEGER_decode_xer$descriptor() {
        return INTEGER_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t INTEGER_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle INTEGER_decode_xer$handle() {
        return INTEGER_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t INTEGER_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment INTEGER_decode_xer$address() {
        return INTEGER_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t INTEGER_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment INTEGER_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = INTEGER_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("INTEGER_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class INTEGER_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("INTEGER_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor INTEGER_encode_xer$descriptor() {
        return INTEGER_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle INTEGER_encode_xer$handle() {
        return INTEGER_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment INTEGER_encode_xer$address() {
        return INTEGER_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment INTEGER_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = INTEGER_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("INTEGER_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class INTEGER_decode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("INTEGER_decode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t INTEGER_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor INTEGER_decode_jer$descriptor() {
        return INTEGER_decode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t INTEGER_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle INTEGER_decode_jer$handle() {
        return INTEGER_decode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t INTEGER_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment INTEGER_decode_jer$address() {
        return INTEGER_decode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t INTEGER_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment INTEGER_decode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = INTEGER_decode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("INTEGER_decode_jer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class INTEGER_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("INTEGER_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor INTEGER_encode_jer$descriptor() {
        return INTEGER_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle INTEGER_encode_jer$handle() {
        return INTEGER_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment INTEGER_encode_jer$address() {
        return INTEGER_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment INTEGER_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = INTEGER_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("INTEGER_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class INTEGER_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("INTEGER_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t INTEGER_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor INTEGER_decode_oer$descriptor() {
        return INTEGER_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t INTEGER_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle INTEGER_decode_oer$handle() {
        return INTEGER_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t INTEGER_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment INTEGER_decode_oer$address() {
        return INTEGER_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t INTEGER_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment INTEGER_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = INTEGER_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("INTEGER_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class INTEGER_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("INTEGER_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor INTEGER_encode_oer$descriptor() {
        return INTEGER_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle INTEGER_encode_oer$handle() {
        return INTEGER_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment INTEGER_encode_oer$address() {
        return INTEGER_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment INTEGER_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = INTEGER_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("INTEGER_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class INTEGER_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("INTEGER_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t INTEGER_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor INTEGER_decode_uper$descriptor() {
        return INTEGER_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t INTEGER_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle INTEGER_decode_uper$handle() {
        return INTEGER_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t INTEGER_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment INTEGER_decode_uper$address() {
        return INTEGER_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t INTEGER_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment INTEGER_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = INTEGER_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("INTEGER_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class INTEGER_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("INTEGER_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor INTEGER_encode_uper$descriptor() {
        return INTEGER_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle INTEGER_encode_uper$handle() {
        return INTEGER_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment INTEGER_encode_uper$address() {
        return INTEGER_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment INTEGER_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = INTEGER_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("INTEGER_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class INTEGER_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("INTEGER_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t INTEGER_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor INTEGER_decode_aper$descriptor() {
        return INTEGER_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t INTEGER_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle INTEGER_decode_aper$handle() {
        return INTEGER_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t INTEGER_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment INTEGER_decode_aper$address() {
        return INTEGER_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t INTEGER_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment INTEGER_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = INTEGER_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("INTEGER_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class INTEGER_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("INTEGER_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor INTEGER_encode_aper$descriptor() {
        return INTEGER_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle INTEGER_encode_aper$handle() {
        return INTEGER_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment INTEGER_encode_aper$address() {
        return INTEGER_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t INTEGER_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment INTEGER_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = INTEGER_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("INTEGER_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class INTEGER_random_fill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_random_fill_result_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("INTEGER_random_fill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_random_fill_result_t INTEGER_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static FunctionDescriptor INTEGER_random_fill$descriptor() {
        return INTEGER_random_fill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_random_fill_result_t INTEGER_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static MethodHandle INTEGER_random_fill$handle() {
        return INTEGER_random_fill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_random_fill_result_t INTEGER_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static MemorySegment INTEGER_random_fill$address() {
        return INTEGER_random_fill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_random_fill_result_t INTEGER_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static MemorySegment INTEGER_random_fill(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = INTEGER_random_fill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("INTEGER_random_fill", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_INTEGER2imax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_INTEGER2imax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int asn_INTEGER2imax(const INTEGER_t *i, intmax_t *l)
     * }
     */
    public static FunctionDescriptor asn_INTEGER2imax$descriptor() {
        return asn_INTEGER2imax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int asn_INTEGER2imax(const INTEGER_t *i, intmax_t *l)
     * }
     */
    public static MethodHandle asn_INTEGER2imax$handle() {
        return asn_INTEGER2imax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int asn_INTEGER2imax(const INTEGER_t *i, intmax_t *l)
     * }
     */
    public static MemorySegment asn_INTEGER2imax$address() {
        return asn_INTEGER2imax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int asn_INTEGER2imax(const INTEGER_t *i, intmax_t *l)
     * }
     */
    public static int asn_INTEGER2imax(MemorySegment i, MemorySegment l) {
        var mh$ = asn_INTEGER2imax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_INTEGER2imax", i, l);
            }
            return (int)mh$.invokeExact(i, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_INTEGER2umax {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_INTEGER2umax");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int asn_INTEGER2umax(const INTEGER_t *i, uintmax_t *l)
     * }
     */
    public static FunctionDescriptor asn_INTEGER2umax$descriptor() {
        return asn_INTEGER2umax.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int asn_INTEGER2umax(const INTEGER_t *i, uintmax_t *l)
     * }
     */
    public static MethodHandle asn_INTEGER2umax$handle() {
        return asn_INTEGER2umax.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int asn_INTEGER2umax(const INTEGER_t *i, uintmax_t *l)
     * }
     */
    public static MemorySegment asn_INTEGER2umax$address() {
        return asn_INTEGER2umax.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int asn_INTEGER2umax(const INTEGER_t *i, uintmax_t *l)
     * }
     */
    public static int asn_INTEGER2umax(MemorySegment i, MemorySegment l) {
        var mh$ = asn_INTEGER2umax.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_INTEGER2umax", i, l);
            }
            return (int)mh$.invokeExact(i, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_imax2INTEGER {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_imax2INTEGER");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int asn_imax2INTEGER(INTEGER_t *i, intmax_t l)
     * }
     */
    public static FunctionDescriptor asn_imax2INTEGER$descriptor() {
        return asn_imax2INTEGER.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int asn_imax2INTEGER(INTEGER_t *i, intmax_t l)
     * }
     */
    public static MethodHandle asn_imax2INTEGER$handle() {
        return asn_imax2INTEGER.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int asn_imax2INTEGER(INTEGER_t *i, intmax_t l)
     * }
     */
    public static MemorySegment asn_imax2INTEGER$address() {
        return asn_imax2INTEGER.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int asn_imax2INTEGER(INTEGER_t *i, intmax_t l)
     * }
     */
    public static int asn_imax2INTEGER(MemorySegment i, long l) {
        var mh$ = asn_imax2INTEGER.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_imax2INTEGER", i, l);
            }
            return (int)mh$.invokeExact(i, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_umax2INTEGER {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_umax2INTEGER");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int asn_umax2INTEGER(INTEGER_t *i, uintmax_t l)
     * }
     */
    public static FunctionDescriptor asn_umax2INTEGER$descriptor() {
        return asn_umax2INTEGER.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int asn_umax2INTEGER(INTEGER_t *i, uintmax_t l)
     * }
     */
    public static MethodHandle asn_umax2INTEGER$handle() {
        return asn_umax2INTEGER.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int asn_umax2INTEGER(INTEGER_t *i, uintmax_t l)
     * }
     */
    public static MemorySegment asn_umax2INTEGER$address() {
        return asn_umax2INTEGER.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int asn_umax2INTEGER(INTEGER_t *i, uintmax_t l)
     * }
     */
    public static int asn_umax2INTEGER(MemorySegment i, long l) {
        var mh$ = asn_umax2INTEGER.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_umax2INTEGER", i, l);
            }
            return (int)mh$.invokeExact(i, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_INTEGER2long {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_INTEGER2long");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int asn_INTEGER2long(const INTEGER_t *i, long *l)
     * }
     */
    public static FunctionDescriptor asn_INTEGER2long$descriptor() {
        return asn_INTEGER2long.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int asn_INTEGER2long(const INTEGER_t *i, long *l)
     * }
     */
    public static MethodHandle asn_INTEGER2long$handle() {
        return asn_INTEGER2long.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int asn_INTEGER2long(const INTEGER_t *i, long *l)
     * }
     */
    public static MemorySegment asn_INTEGER2long$address() {
        return asn_INTEGER2long.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int asn_INTEGER2long(const INTEGER_t *i, long *l)
     * }
     */
    public static int asn_INTEGER2long(MemorySegment i, MemorySegment l) {
        var mh$ = asn_INTEGER2long.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_INTEGER2long", i, l);
            }
            return (int)mh$.invokeExact(i, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_INTEGER2ulong {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_INTEGER2ulong");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int asn_INTEGER2ulong(const INTEGER_t *i, unsigned long *l)
     * }
     */
    public static FunctionDescriptor asn_INTEGER2ulong$descriptor() {
        return asn_INTEGER2ulong.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int asn_INTEGER2ulong(const INTEGER_t *i, unsigned long *l)
     * }
     */
    public static MethodHandle asn_INTEGER2ulong$handle() {
        return asn_INTEGER2ulong.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int asn_INTEGER2ulong(const INTEGER_t *i, unsigned long *l)
     * }
     */
    public static MemorySegment asn_INTEGER2ulong$address() {
        return asn_INTEGER2ulong.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int asn_INTEGER2ulong(const INTEGER_t *i, unsigned long *l)
     * }
     */
    public static int asn_INTEGER2ulong(MemorySegment i, MemorySegment l) {
        var mh$ = asn_INTEGER2ulong.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_INTEGER2ulong", i, l);
            }
            return (int)mh$.invokeExact(i, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_long2INTEGER {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_long2INTEGER");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int asn_long2INTEGER(INTEGER_t *i, long l)
     * }
     */
    public static FunctionDescriptor asn_long2INTEGER$descriptor() {
        return asn_long2INTEGER.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int asn_long2INTEGER(INTEGER_t *i, long l)
     * }
     */
    public static MethodHandle asn_long2INTEGER$handle() {
        return asn_long2INTEGER.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int asn_long2INTEGER(INTEGER_t *i, long l)
     * }
     */
    public static MemorySegment asn_long2INTEGER$address() {
        return asn_long2INTEGER.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int asn_long2INTEGER(INTEGER_t *i, long l)
     * }
     */
    public static int asn_long2INTEGER(MemorySegment i, long l) {
        var mh$ = asn_long2INTEGER.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_long2INTEGER", i, l);
            }
            return (int)mh$.invokeExact(i, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_ulong2INTEGER {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_ulong2INTEGER");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int asn_ulong2INTEGER(INTEGER_t *i, unsigned long l)
     * }
     */
    public static FunctionDescriptor asn_ulong2INTEGER$descriptor() {
        return asn_ulong2INTEGER.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int asn_ulong2INTEGER(INTEGER_t *i, unsigned long l)
     * }
     */
    public static MethodHandle asn_ulong2INTEGER$handle() {
        return asn_ulong2INTEGER.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int asn_ulong2INTEGER(INTEGER_t *i, unsigned long l)
     * }
     */
    public static MemorySegment asn_ulong2INTEGER$address() {
        return asn_ulong2INTEGER.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int asn_ulong2INTEGER(INTEGER_t *i, unsigned long l)
     * }
     */
    public static int asn_ulong2INTEGER(MemorySegment i, long l) {
        var mh$ = asn_ulong2INTEGER.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_ulong2INTEGER", i, l);
            }
            return (int)mh$.invokeExact(i, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_INTEGER2int64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_INTEGER2int64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int asn_INTEGER2int64(const INTEGER_t *i, int64_t *l)
     * }
     */
    public static FunctionDescriptor asn_INTEGER2int64$descriptor() {
        return asn_INTEGER2int64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int asn_INTEGER2int64(const INTEGER_t *i, int64_t *l)
     * }
     */
    public static MethodHandle asn_INTEGER2int64$handle() {
        return asn_INTEGER2int64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int asn_INTEGER2int64(const INTEGER_t *i, int64_t *l)
     * }
     */
    public static MemorySegment asn_INTEGER2int64$address() {
        return asn_INTEGER2int64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int asn_INTEGER2int64(const INTEGER_t *i, int64_t *l)
     * }
     */
    public static int asn_INTEGER2int64(MemorySegment i, MemorySegment l) {
        var mh$ = asn_INTEGER2int64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_INTEGER2int64", i, l);
            }
            return (int)mh$.invokeExact(i, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_INTEGER2uint64 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_INTEGER2uint64");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int asn_INTEGER2uint64(const INTEGER_t *i, uint64_t *l)
     * }
     */
    public static FunctionDescriptor asn_INTEGER2uint64$descriptor() {
        return asn_INTEGER2uint64.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int asn_INTEGER2uint64(const INTEGER_t *i, uint64_t *l)
     * }
     */
    public static MethodHandle asn_INTEGER2uint64$handle() {
        return asn_INTEGER2uint64.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int asn_INTEGER2uint64(const INTEGER_t *i, uint64_t *l)
     * }
     */
    public static MemorySegment asn_INTEGER2uint64$address() {
        return asn_INTEGER2uint64.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int asn_INTEGER2uint64(const INTEGER_t *i, uint64_t *l)
     * }
     */
    public static int asn_INTEGER2uint64(MemorySegment i, MemorySegment l) {
        var mh$ = asn_INTEGER2uint64.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_INTEGER2uint64", i, l);
            }
            return (int)mh$.invokeExact(i, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_int642INTEGER {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_int642INTEGER");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int asn_int642INTEGER(INTEGER_t *i, int64_t l)
     * }
     */
    public static FunctionDescriptor asn_int642INTEGER$descriptor() {
        return asn_int642INTEGER.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int asn_int642INTEGER(INTEGER_t *i, int64_t l)
     * }
     */
    public static MethodHandle asn_int642INTEGER$handle() {
        return asn_int642INTEGER.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int asn_int642INTEGER(INTEGER_t *i, int64_t l)
     * }
     */
    public static MemorySegment asn_int642INTEGER$address() {
        return asn_int642INTEGER.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int asn_int642INTEGER(INTEGER_t *i, int64_t l)
     * }
     */
    public static int asn_int642INTEGER(MemorySegment i, long l) {
        var mh$ = asn_int642INTEGER.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_int642INTEGER", i, l);
            }
            return (int)mh$.invokeExact(i, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_uint642INTEGER {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_uint642INTEGER");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int asn_uint642INTEGER(INTEGER_t *i, uint64_t l)
     * }
     */
    public static FunctionDescriptor asn_uint642INTEGER$descriptor() {
        return asn_uint642INTEGER.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int asn_uint642INTEGER(INTEGER_t *i, uint64_t l)
     * }
     */
    public static MethodHandle asn_uint642INTEGER$handle() {
        return asn_uint642INTEGER.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int asn_uint642INTEGER(INTEGER_t *i, uint64_t l)
     * }
     */
    public static MemorySegment asn_uint642INTEGER$address() {
        return asn_uint642INTEGER.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int asn_uint642INTEGER(INTEGER_t *i, uint64_t l)
     * }
     */
    public static int asn_uint642INTEGER(MemorySegment i, long l) {
        var mh$ = asn_uint642INTEGER.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_uint642INTEGER", i, l);
            }
            return (int)mh$.invokeExact(i, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ASN_STRTOX_ERROR_RANGE = (int)-3L;
    /**
     * {@snippet lang=c :
     * enum asn_strtox_result_e.ASN_STRTOX_ERROR_RANGE = -3
     * }
     */
    public static int ASN_STRTOX_ERROR_RANGE() {
        return ASN_STRTOX_ERROR_RANGE;
    }
    private static final int ASN_STRTOX_ERROR_INVAL = (int)-2L;
    /**
     * {@snippet lang=c :
     * enum asn_strtox_result_e.ASN_STRTOX_ERROR_INVAL = -2
     * }
     */
    public static int ASN_STRTOX_ERROR_INVAL() {
        return ASN_STRTOX_ERROR_INVAL;
    }
    private static final int ASN_STRTOX_EXPECT_MORE = (int)-1L;
    /**
     * {@snippet lang=c :
     * enum asn_strtox_result_e.ASN_STRTOX_EXPECT_MORE = -1
     * }
     */
    public static int ASN_STRTOX_EXPECT_MORE() {
        return ASN_STRTOX_EXPECT_MORE;
    }
    private static final int ASN_STRTOX_OK = (int)0L;
    /**
     * {@snippet lang=c :
     * enum asn_strtox_result_e.ASN_STRTOX_OK = 0
     * }
     */
    public static int ASN_STRTOX_OK() {
        return ASN_STRTOX_OK;
    }
    private static final int ASN_STRTOX_EXTRA_DATA = (int)1L;
    /**
     * {@snippet lang=c :
     * enum asn_strtox_result_e.ASN_STRTOX_EXTRA_DATA = 1
     * }
     */
    public static int ASN_STRTOX_EXTRA_DATA() {
        return ASN_STRTOX_EXTRA_DATA;
    }

    private static class asn_strtol_lim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_strtol_lim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum asn_strtox_result_e asn_strtol_lim(const char *str, const char **end, long *l)
     * }
     */
    public static FunctionDescriptor asn_strtol_lim$descriptor() {
        return asn_strtol_lim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum asn_strtox_result_e asn_strtol_lim(const char *str, const char **end, long *l)
     * }
     */
    public static MethodHandle asn_strtol_lim$handle() {
        return asn_strtol_lim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum asn_strtox_result_e asn_strtol_lim(const char *str, const char **end, long *l)
     * }
     */
    public static MemorySegment asn_strtol_lim$address() {
        return asn_strtol_lim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum asn_strtox_result_e asn_strtol_lim(const char *str, const char **end, long *l)
     * }
     */
    public static int asn_strtol_lim(MemorySegment str, MemorySegment end, MemorySegment l) {
        var mh$ = asn_strtol_lim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_strtol_lim", str, end, l);
            }
            return (int)mh$.invokeExact(str, end, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_strtoul_lim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_strtoul_lim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum asn_strtox_result_e asn_strtoul_lim(const char *str, const char **end, unsigned long *l)
     * }
     */
    public static FunctionDescriptor asn_strtoul_lim$descriptor() {
        return asn_strtoul_lim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum asn_strtox_result_e asn_strtoul_lim(const char *str, const char **end, unsigned long *l)
     * }
     */
    public static MethodHandle asn_strtoul_lim$handle() {
        return asn_strtoul_lim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum asn_strtox_result_e asn_strtoul_lim(const char *str, const char **end, unsigned long *l)
     * }
     */
    public static MemorySegment asn_strtoul_lim$address() {
        return asn_strtoul_lim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum asn_strtox_result_e asn_strtoul_lim(const char *str, const char **end, unsigned long *l)
     * }
     */
    public static int asn_strtoul_lim(MemorySegment str, MemorySegment end, MemorySegment l) {
        var mh$ = asn_strtoul_lim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_strtoul_lim", str, end, l);
            }
            return (int)mh$.invokeExact(str, end, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_strtoimax_lim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_strtoimax_lim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum asn_strtox_result_e asn_strtoimax_lim(const char *str, const char **end, intmax_t *l)
     * }
     */
    public static FunctionDescriptor asn_strtoimax_lim$descriptor() {
        return asn_strtoimax_lim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum asn_strtox_result_e asn_strtoimax_lim(const char *str, const char **end, intmax_t *l)
     * }
     */
    public static MethodHandle asn_strtoimax_lim$handle() {
        return asn_strtoimax_lim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum asn_strtox_result_e asn_strtoimax_lim(const char *str, const char **end, intmax_t *l)
     * }
     */
    public static MemorySegment asn_strtoimax_lim$address() {
        return asn_strtoimax_lim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum asn_strtox_result_e asn_strtoimax_lim(const char *str, const char **end, intmax_t *l)
     * }
     */
    public static int asn_strtoimax_lim(MemorySegment str, MemorySegment end, MemorySegment l) {
        var mh$ = asn_strtoimax_lim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_strtoimax_lim", str, end, l);
            }
            return (int)mh$.invokeExact(str, end, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_strtoumax_lim {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_strtoumax_lim");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * enum asn_strtox_result_e asn_strtoumax_lim(const char *str, const char **end, uintmax_t *l)
     * }
     */
    public static FunctionDescriptor asn_strtoumax_lim$descriptor() {
        return asn_strtoumax_lim.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * enum asn_strtox_result_e asn_strtoumax_lim(const char *str, const char **end, uintmax_t *l)
     * }
     */
    public static MethodHandle asn_strtoumax_lim$handle() {
        return asn_strtoumax_lim.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * enum asn_strtox_result_e asn_strtoumax_lim(const char *str, const char **end, uintmax_t *l)
     * }
     */
    public static MemorySegment asn_strtoumax_lim$address() {
        return asn_strtoumax_lim.ADDR;
    }

    /**
     * {@snippet lang=c :
     * enum asn_strtox_result_e asn_strtoumax_lim(const char *str, const char **end, uintmax_t *l)
     * }
     */
    public static int asn_strtoumax_lim(MemorySegment str, MemorySegment end, MemorySegment l) {
        var mh$ = asn_strtoumax_lim.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_strtoumax_lim", str, end, l);
            }
            return (int)mh$.invokeExact(str, end, l);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class INTEGER_map_value2enum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("INTEGER_map_value2enum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const asn_INTEGER_enum_map_t *INTEGER_map_value2enum(const asn_INTEGER_specifics_t *specs, long value)
     * }
     */
    public static FunctionDescriptor INTEGER_map_value2enum$descriptor() {
        return INTEGER_map_value2enum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const asn_INTEGER_enum_map_t *INTEGER_map_value2enum(const asn_INTEGER_specifics_t *specs, long value)
     * }
     */
    public static MethodHandle INTEGER_map_value2enum$handle() {
        return INTEGER_map_value2enum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const asn_INTEGER_enum_map_t *INTEGER_map_value2enum(const asn_INTEGER_specifics_t *specs, long value)
     * }
     */
    public static MemorySegment INTEGER_map_value2enum$address() {
        return INTEGER_map_value2enum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const asn_INTEGER_enum_map_t *INTEGER_map_value2enum(const asn_INTEGER_specifics_t *specs, long value)
     * }
     */
    public static MemorySegment INTEGER_map_value2enum(MemorySegment specs, long value) {
        var mh$ = INTEGER_map_value2enum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("INTEGER_map_value2enum", specs, value);
            }
            return (MemorySegment)mh$.invokeExact(specs, value);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_NativeInteger$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_NativeInteger").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NativeInteger
     * }
     */
    public static GroupLayout asn_DEF_NativeInteger$layout() {
        return asn_DEF_NativeInteger$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NativeInteger
     * }
     */
    public static MemorySegment asn_DEF_NativeInteger() {
        return asn_DEF_NativeInteger$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NativeInteger
     * }
     */
    public static void asn_DEF_NativeInteger(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_NativeInteger$constants.SEGMENT, 0L, asn_DEF_NativeInteger$constants.LAYOUT.byteSize());
    }

    private static class asn_OP_NativeInteger$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_operation_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_OP_NativeInteger").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_NativeInteger
     * }
     */
    public static GroupLayout asn_OP_NativeInteger$layout() {
        return asn_OP_NativeInteger$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_NativeInteger
     * }
     */
    public static MemorySegment asn_OP_NativeInteger() {
        return asn_OP_NativeInteger$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_NativeInteger
     * }
     */
    public static void asn_OP_NativeInteger(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_OP_NativeInteger$constants.SEGMENT, 0L, asn_OP_NativeInteger$constants.LAYOUT.byteSize());
    }

    private static class NativeInteger_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeInteger_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NativeInteger_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor NativeInteger_free$descriptor() {
        return NativeInteger_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NativeInteger_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle NativeInteger_free$handle() {
        return NativeInteger_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NativeInteger_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment NativeInteger_free$address() {
        return NativeInteger_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NativeInteger_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void NativeInteger_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = NativeInteger_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeInteger_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeInteger_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeInteger_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int NativeInteger_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NativeInteger_print$descriptor() {
        return NativeInteger_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int NativeInteger_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NativeInteger_print$handle() {
        return NativeInteger_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int NativeInteger_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NativeInteger_print$address() {
        return NativeInteger_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int NativeInteger_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int NativeInteger_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NativeInteger_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeInteger_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeInteger_compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeInteger_compare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int NativeInteger_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static FunctionDescriptor NativeInteger_compare$descriptor() {
        return NativeInteger_compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int NativeInteger_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static MethodHandle NativeInteger_compare$handle() {
        return NativeInteger_compare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int NativeInteger_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static MemorySegment NativeInteger_compare$address() {
        return NativeInteger_compare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int NativeInteger_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static int NativeInteger_compare(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = NativeInteger_compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeInteger_compare", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeInteger_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeInteger_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int NativeInteger_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static FunctionDescriptor NativeInteger_copy$descriptor() {
        return NativeInteger_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int NativeInteger_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static MethodHandle NativeInteger_copy$handle() {
        return NativeInteger_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int NativeInteger_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static MemorySegment NativeInteger_copy$address() {
        return NativeInteger_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int NativeInteger_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static int NativeInteger_copy(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = NativeInteger_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeInteger_copy", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeInteger_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeInteger_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor NativeInteger_decode_ber$descriptor() {
        return NativeInteger_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle NativeInteger_decode_ber$handle() {
        return NativeInteger_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment NativeInteger_decode_ber$address() {
        return NativeInteger_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment NativeInteger_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = NativeInteger_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeInteger_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeInteger_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeInteger_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NativeInteger_encode_der$descriptor() {
        return NativeInteger_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NativeInteger_encode_der$handle() {
        return NativeInteger_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NativeInteger_encode_der$address() {
        return NativeInteger_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NativeInteger_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = NativeInteger_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeInteger_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeInteger_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeInteger_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor NativeInteger_decode_xer$descriptor() {
        return NativeInteger_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle NativeInteger_decode_xer$handle() {
        return NativeInteger_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment NativeInteger_decode_xer$address() {
        return NativeInteger_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment NativeInteger_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = NativeInteger_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeInteger_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeInteger_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeInteger_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NativeInteger_encode_xer$descriptor() {
        return NativeInteger_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NativeInteger_encode_xer$handle() {
        return NativeInteger_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NativeInteger_encode_xer$address() {
        return NativeInteger_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NativeInteger_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = NativeInteger_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeInteger_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeInteger_decode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeInteger_decode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor NativeInteger_decode_jer$descriptor() {
        return NativeInteger_decode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle NativeInteger_decode_jer$handle() {
        return NativeInteger_decode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment NativeInteger_decode_jer$address() {
        return NativeInteger_decode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment NativeInteger_decode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = NativeInteger_decode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeInteger_decode_jer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeInteger_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeInteger_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NativeInteger_encode_jer$descriptor() {
        return NativeInteger_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NativeInteger_encode_jer$handle() {
        return NativeInteger_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NativeInteger_encode_jer$address() {
        return NativeInteger_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NativeInteger_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = NativeInteger_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeInteger_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeInteger_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeInteger_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor NativeInteger_decode_oer$descriptor() {
        return NativeInteger_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle NativeInteger_decode_oer$handle() {
        return NativeInteger_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment NativeInteger_decode_oer$address() {
        return NativeInteger_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment NativeInteger_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = NativeInteger_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeInteger_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeInteger_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeInteger_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NativeInteger_encode_oer$descriptor() {
        return NativeInteger_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NativeInteger_encode_oer$handle() {
        return NativeInteger_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NativeInteger_encode_oer$address() {
        return NativeInteger_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NativeInteger_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NativeInteger_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeInteger_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeInteger_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeInteger_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor NativeInteger_decode_uper$descriptor() {
        return NativeInteger_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle NativeInteger_decode_uper$handle() {
        return NativeInteger_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NativeInteger_decode_uper$address() {
        return NativeInteger_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NativeInteger_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NativeInteger_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeInteger_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeInteger_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeInteger_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor NativeInteger_encode_uper$descriptor() {
        return NativeInteger_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle NativeInteger_encode_uper$handle() {
        return NativeInteger_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NativeInteger_encode_uper$address() {
        return NativeInteger_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NativeInteger_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = NativeInteger_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeInteger_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeInteger_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeInteger_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor NativeInteger_decode_aper$descriptor() {
        return NativeInteger_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle NativeInteger_decode_aper$handle() {
        return NativeInteger_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NativeInteger_decode_aper$address() {
        return NativeInteger_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NativeInteger_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NativeInteger_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NativeInteger_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeInteger_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeInteger_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeInteger_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor NativeInteger_encode_aper$descriptor() {
        return NativeInteger_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle NativeInteger_encode_aper$handle() {
        return NativeInteger_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NativeInteger_encode_aper$address() {
        return NativeInteger_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NativeInteger_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NativeInteger_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = NativeInteger_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeInteger_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeInteger_random_fill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_random_fill_result_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeInteger_random_fill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_random_fill_result_t NativeInteger_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static FunctionDescriptor NativeInteger_random_fill$descriptor() {
        return NativeInteger_random_fill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_random_fill_result_t NativeInteger_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static MethodHandle NativeInteger_random_fill$handle() {
        return NativeInteger_random_fill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_random_fill_result_t NativeInteger_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static MemorySegment NativeInteger_random_fill$address() {
        return NativeInteger_random_fill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_random_fill_result_t NativeInteger_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static MemorySegment NativeInteger_random_fill(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = NativeInteger_random_fill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeInteger_random_fill", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long DSRCmsgID_t
     * }
     */
    public static final OfLong DSRCmsgID_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_DSRCmsgID_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_DSRCmsgID_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DSRCmsgID_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_DSRCmsgID_constr_1$layout() {
        return asn_PER_type_DSRCmsgID_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DSRCmsgID_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_DSRCmsgID_constr_1() {
        return asn_PER_type_DSRCmsgID_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DSRCmsgID_constr_1
     * }
     */
    public static void asn_PER_type_DSRCmsgID_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_DSRCmsgID_constr_1$constants.SEGMENT, 0L, asn_PER_type_DSRCmsgID_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_DSRCmsgID$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_DSRCmsgID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DSRCmsgID
     * }
     */
    public static GroupLayout asn_DEF_DSRCmsgID$layout() {
        return asn_DEF_DSRCmsgID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DSRCmsgID
     * }
     */
    public static MemorySegment asn_DEF_DSRCmsgID() {
        return asn_DEF_DSRCmsgID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DSRCmsgID
     * }
     */
    public static void asn_DEF_DSRCmsgID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_DSRCmsgID$constants.SEGMENT, 0L, asn_DEF_DSRCmsgID$constants.LAYOUT.byteSize());
    }

    private static class DSRCmsgID_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSRCmsgID_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DSRCmsgID_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor DSRCmsgID_free$descriptor() {
        return DSRCmsgID_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DSRCmsgID_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle DSRCmsgID_free$handle() {
        return DSRCmsgID_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DSRCmsgID_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment DSRCmsgID_free$address() {
        return DSRCmsgID_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DSRCmsgID_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void DSRCmsgID_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = DSRCmsgID_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSRCmsgID_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSRCmsgID_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSRCmsgID_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DSRCmsgID_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DSRCmsgID_print$descriptor() {
        return DSRCmsgID_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DSRCmsgID_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DSRCmsgID_print$handle() {
        return DSRCmsgID_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DSRCmsgID_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DSRCmsgID_print$address() {
        return DSRCmsgID_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DSRCmsgID_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int DSRCmsgID_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DSRCmsgID_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSRCmsgID_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSRCmsgID_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSRCmsgID_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DSRCmsgID_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor DSRCmsgID_constraint$descriptor() {
        return DSRCmsgID_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DSRCmsgID_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle DSRCmsgID_constraint$handle() {
        return DSRCmsgID_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DSRCmsgID_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment DSRCmsgID_constraint$address() {
        return DSRCmsgID_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DSRCmsgID_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int DSRCmsgID_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DSRCmsgID_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSRCmsgID_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSRCmsgID_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSRCmsgID_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSRCmsgID_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor DSRCmsgID_decode_ber$descriptor() {
        return DSRCmsgID_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSRCmsgID_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle DSRCmsgID_decode_ber$handle() {
        return DSRCmsgID_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSRCmsgID_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DSRCmsgID_decode_ber$address() {
        return DSRCmsgID_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DSRCmsgID_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DSRCmsgID_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = DSRCmsgID_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSRCmsgID_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSRCmsgID_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSRCmsgID_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DSRCmsgID_encode_der$descriptor() {
        return DSRCmsgID_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DSRCmsgID_encode_der$handle() {
        return DSRCmsgID_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DSRCmsgID_encode_der$address() {
        return DSRCmsgID_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DSRCmsgID_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DSRCmsgID_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSRCmsgID_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSRCmsgID_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSRCmsgID_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSRCmsgID_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DSRCmsgID_decode_xer$descriptor() {
        return DSRCmsgID_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSRCmsgID_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle DSRCmsgID_decode_xer$handle() {
        return DSRCmsgID_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSRCmsgID_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DSRCmsgID_decode_xer$address() {
        return DSRCmsgID_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DSRCmsgID_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DSRCmsgID_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DSRCmsgID_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSRCmsgID_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSRCmsgID_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSRCmsgID_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DSRCmsgID_encode_xer$descriptor() {
        return DSRCmsgID_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DSRCmsgID_encode_xer$handle() {
        return DSRCmsgID_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DSRCmsgID_encode_xer$address() {
        return DSRCmsgID_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DSRCmsgID_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DSRCmsgID_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSRCmsgID_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSRCmsgID_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSRCmsgID_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DSRCmsgID_encode_jer$descriptor() {
        return DSRCmsgID_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DSRCmsgID_encode_jer$handle() {
        return DSRCmsgID_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DSRCmsgID_encode_jer$address() {
        return DSRCmsgID_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DSRCmsgID_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = DSRCmsgID_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSRCmsgID_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSRCmsgID_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSRCmsgID_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSRCmsgID_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DSRCmsgID_decode_oer$descriptor() {
        return DSRCmsgID_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSRCmsgID_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle DSRCmsgID_decode_oer$handle() {
        return DSRCmsgID_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSRCmsgID_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DSRCmsgID_decode_oer$address() {
        return DSRCmsgID_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DSRCmsgID_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DSRCmsgID_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DSRCmsgID_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSRCmsgID_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSRCmsgID_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSRCmsgID_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DSRCmsgID_encode_oer$descriptor() {
        return DSRCmsgID_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DSRCmsgID_encode_oer$handle() {
        return DSRCmsgID_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DSRCmsgID_encode_oer$address() {
        return DSRCmsgID_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DSRCmsgID_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DSRCmsgID_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSRCmsgID_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSRCmsgID_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSRCmsgID_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSRCmsgID_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DSRCmsgID_decode_uper$descriptor() {
        return DSRCmsgID_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSRCmsgID_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DSRCmsgID_decode_uper$handle() {
        return DSRCmsgID_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSRCmsgID_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DSRCmsgID_decode_uper$address() {
        return DSRCmsgID_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DSRCmsgID_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DSRCmsgID_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DSRCmsgID_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSRCmsgID_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSRCmsgID_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSRCmsgID_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DSRCmsgID_encode_uper$descriptor() {
        return DSRCmsgID_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DSRCmsgID_encode_uper$handle() {
        return DSRCmsgID_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DSRCmsgID_encode_uper$address() {
        return DSRCmsgID_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DSRCmsgID_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DSRCmsgID_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSRCmsgID_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSRCmsgID_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSRCmsgID_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSRCmsgID_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DSRCmsgID_decode_aper$descriptor() {
        return DSRCmsgID_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSRCmsgID_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DSRCmsgID_decode_aper$handle() {
        return DSRCmsgID_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSRCmsgID_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DSRCmsgID_decode_aper$address() {
        return DSRCmsgID_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DSRCmsgID_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DSRCmsgID_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DSRCmsgID_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSRCmsgID_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSRCmsgID_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSRCmsgID_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DSRCmsgID_encode_aper$descriptor() {
        return DSRCmsgID_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DSRCmsgID_encode_aper$handle() {
        return DSRCmsgID_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DSRCmsgID_encode_aper$address() {
        return DSRCmsgID_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DSRCmsgID_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DSRCmsgID_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DSRCmsgID_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSRCmsgID_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __assert_fail {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("__assert_fail");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __assert_fail(const char *__assertion, const char *__file, unsigned int __line, const char *__function)
     * }
     */
    public static FunctionDescriptor __assert_fail$descriptor() {
        return __assert_fail.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __assert_fail(const char *__assertion, const char *__file, unsigned int __line, const char *__function)
     * }
     */
    public static MethodHandle __assert_fail$handle() {
        return __assert_fail.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __assert_fail(const char *__assertion, const char *__file, unsigned int __line, const char *__function)
     * }
     */
    public static MemorySegment __assert_fail$address() {
        return __assert_fail.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __assert_fail(const char *__assertion, const char *__file, unsigned int __line, const char *__function)
     * }
     */
    public static void __assert_fail(MemorySegment __assertion, MemorySegment __file, int __line, MemorySegment __function) {
        var mh$ = __assert_fail.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__assert_fail", __assertion, __file, __line, __function);
            }
            mh$.invokeExact(__assertion, __file, __line, __function);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __assert_perror_fail {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("__assert_perror_fail");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __assert_perror_fail(int __errnum, const char *__file, unsigned int __line, const char *__function)
     * }
     */
    public static FunctionDescriptor __assert_perror_fail$descriptor() {
        return __assert_perror_fail.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __assert_perror_fail(int __errnum, const char *__file, unsigned int __line, const char *__function)
     * }
     */
    public static MethodHandle __assert_perror_fail$handle() {
        return __assert_perror_fail.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __assert_perror_fail(int __errnum, const char *__file, unsigned int __line, const char *__function)
     * }
     */
    public static MemorySegment __assert_perror_fail$address() {
        return __assert_perror_fail.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __assert_perror_fail(int __errnum, const char *__file, unsigned int __line, const char *__function)
     * }
     */
    public static void __assert_perror_fail(int __errnum, MemorySegment __file, int __line, MemorySegment __function) {
        var mh$ = __assert_perror_fail.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__assert_perror_fail", __errnum, __file, __line, __function);
            }
            mh$.invokeExact(__errnum, __file, __line, __function);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class __assert {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("__assert");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * extern void __assert(const char *__assertion, const char *__file, int __line)
     * }
     */
    public static FunctionDescriptor __assert$descriptor() {
        return __assert.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * extern void __assert(const char *__assertion, const char *__file, int __line)
     * }
     */
    public static MethodHandle __assert$handle() {
        return __assert.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * extern void __assert(const char *__assertion, const char *__file, int __line)
     * }
     */
    public static MemorySegment __assert$address() {
        return __assert.ADDR;
    }

    /**
     * {@snippet lang=c :
     * extern void __assert(const char *__assertion, const char *__file, int __line)
     * }
     */
    public static void __assert(MemorySegment __assertion, MemorySegment __file, int __line) {
        var mh$ = __assert.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("__assert", __assertion, __file, __line);
            }
            mh$.invokeExact(__assertion, __file, __line);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uper_get_length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("uper_get_length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t uper_get_length(asn_per_data_t *pd, int effective_bound_bits, size_t lower_bound, int *repeat)
     * }
     */
    public static FunctionDescriptor uper_get_length$descriptor() {
        return uper_get_length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t uper_get_length(asn_per_data_t *pd, int effective_bound_bits, size_t lower_bound, int *repeat)
     * }
     */
    public static MethodHandle uper_get_length$handle() {
        return uper_get_length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t uper_get_length(asn_per_data_t *pd, int effective_bound_bits, size_t lower_bound, int *repeat)
     * }
     */
    public static MemorySegment uper_get_length$address() {
        return uper_get_length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t uper_get_length(asn_per_data_t *pd, int effective_bound_bits, size_t lower_bound, int *repeat)
     * }
     */
    public static long uper_get_length(MemorySegment pd, int effective_bound_bits, long lower_bound, MemorySegment repeat) {
        var mh$ = uper_get_length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uper_get_length", pd, effective_bound_bits, lower_bound, repeat);
            }
            return (long)mh$.invokeExact(pd, effective_bound_bits, lower_bound, repeat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uper_get_nslength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("uper_get_nslength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t uper_get_nslength(asn_per_data_t *pd)
     * }
     */
    public static FunctionDescriptor uper_get_nslength$descriptor() {
        return uper_get_nslength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t uper_get_nslength(asn_per_data_t *pd)
     * }
     */
    public static MethodHandle uper_get_nslength$handle() {
        return uper_get_nslength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t uper_get_nslength(asn_per_data_t *pd)
     * }
     */
    public static MemorySegment uper_get_nslength$address() {
        return uper_get_nslength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t uper_get_nslength(asn_per_data_t *pd)
     * }
     */
    public static long uper_get_nslength(MemorySegment pd) {
        var mh$ = uper_get_nslength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uper_get_nslength", pd);
            }
            return (long)mh$.invokeExact(pd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uper_get_nsnnwn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("uper_get_nsnnwn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t uper_get_nsnnwn(asn_per_data_t *pd)
     * }
     */
    public static FunctionDescriptor uper_get_nsnnwn$descriptor() {
        return uper_get_nsnnwn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t uper_get_nsnnwn(asn_per_data_t *pd)
     * }
     */
    public static MethodHandle uper_get_nsnnwn$handle() {
        return uper_get_nsnnwn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t uper_get_nsnnwn(asn_per_data_t *pd)
     * }
     */
    public static MemorySegment uper_get_nsnnwn$address() {
        return uper_get_nsnnwn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t uper_get_nsnnwn(asn_per_data_t *pd)
     * }
     */
    public static long uper_get_nsnnwn(MemorySegment pd) {
        var mh$ = uper_get_nsnnwn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uper_get_nsnnwn", pd);
            }
            return (long)mh$.invokeExact(pd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uper_get_constrained_whole_number {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("uper_get_constrained_whole_number");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int uper_get_constrained_whole_number(asn_per_data_t *pd, uintmax_t *v, int nbits)
     * }
     */
    public static FunctionDescriptor uper_get_constrained_whole_number$descriptor() {
        return uper_get_constrained_whole_number.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int uper_get_constrained_whole_number(asn_per_data_t *pd, uintmax_t *v, int nbits)
     * }
     */
    public static MethodHandle uper_get_constrained_whole_number$handle() {
        return uper_get_constrained_whole_number.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int uper_get_constrained_whole_number(asn_per_data_t *pd, uintmax_t *v, int nbits)
     * }
     */
    public static MemorySegment uper_get_constrained_whole_number$address() {
        return uper_get_constrained_whole_number.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int uper_get_constrained_whole_number(asn_per_data_t *pd, uintmax_t *v, int nbits)
     * }
     */
    public static int uper_get_constrained_whole_number(MemorySegment pd, MemorySegment v, int nbits) {
        var mh$ = uper_get_constrained_whole_number.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uper_get_constrained_whole_number", pd, v, nbits);
            }
            return (int)mh$.invokeExact(pd, v, nbits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class per_long_range_rebase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("per_long_range_rebase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int per_long_range_rebase(long, intmax_t lb, intmax_t ub, unsigned long *output)
     * }
     */
    public static FunctionDescriptor per_long_range_rebase$descriptor() {
        return per_long_range_rebase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int per_long_range_rebase(long, intmax_t lb, intmax_t ub, unsigned long *output)
     * }
     */
    public static MethodHandle per_long_range_rebase$handle() {
        return per_long_range_rebase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int per_long_range_rebase(long, intmax_t lb, intmax_t ub, unsigned long *output)
     * }
     */
    public static MemorySegment per_long_range_rebase$address() {
        return per_long_range_rebase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int per_long_range_rebase(long, intmax_t lb, intmax_t ub, unsigned long *output)
     * }
     */
    public static int per_long_range_rebase(long x0, long lb, long ub, MemorySegment output) {
        var mh$ = per_long_range_rebase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("per_long_range_rebase", x0, lb, ub, output);
            }
            return (int)mh$.invokeExact(x0, lb, ub, output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class per_imax_range_rebase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("per_imax_range_rebase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int per_imax_range_rebase(intmax_t v, intmax_t lb, intmax_t ub, uintmax_t *output)
     * }
     */
    public static FunctionDescriptor per_imax_range_rebase$descriptor() {
        return per_imax_range_rebase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int per_imax_range_rebase(intmax_t v, intmax_t lb, intmax_t ub, uintmax_t *output)
     * }
     */
    public static MethodHandle per_imax_range_rebase$handle() {
        return per_imax_range_rebase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int per_imax_range_rebase(intmax_t v, intmax_t lb, intmax_t ub, uintmax_t *output)
     * }
     */
    public static MemorySegment per_imax_range_rebase$address() {
        return per_imax_range_rebase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int per_imax_range_rebase(intmax_t v, intmax_t lb, intmax_t ub, uintmax_t *output)
     * }
     */
    public static int per_imax_range_rebase(long v, long lb, long ub, MemorySegment output) {
        var mh$ = per_imax_range_rebase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("per_imax_range_rebase", v, lb, ub, output);
            }
            return (int)mh$.invokeExact(v, lb, ub, output);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class per_long_range_unrebase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("per_long_range_unrebase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int per_long_range_unrebase(unsigned long inp, intmax_t lb, intmax_t ub, long *outp)
     * }
     */
    public static FunctionDescriptor per_long_range_unrebase$descriptor() {
        return per_long_range_unrebase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int per_long_range_unrebase(unsigned long inp, intmax_t lb, intmax_t ub, long *outp)
     * }
     */
    public static MethodHandle per_long_range_unrebase$handle() {
        return per_long_range_unrebase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int per_long_range_unrebase(unsigned long inp, intmax_t lb, intmax_t ub, long *outp)
     * }
     */
    public static MemorySegment per_long_range_unrebase$address() {
        return per_long_range_unrebase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int per_long_range_unrebase(unsigned long inp, intmax_t lb, intmax_t ub, long *outp)
     * }
     */
    public static int per_long_range_unrebase(long inp, long lb, long ub, MemorySegment outp) {
        var mh$ = per_long_range_unrebase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("per_long_range_unrebase", inp, lb, ub, outp);
            }
            return (int)mh$.invokeExact(inp, lb, ub, outp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class per_imax_range_unrebase {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("per_imax_range_unrebase");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int per_imax_range_unrebase(uintmax_t inp, intmax_t lb, intmax_t ub, intmax_t *outp)
     * }
     */
    public static FunctionDescriptor per_imax_range_unrebase$descriptor() {
        return per_imax_range_unrebase.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int per_imax_range_unrebase(uintmax_t inp, intmax_t lb, intmax_t ub, intmax_t *outp)
     * }
     */
    public static MethodHandle per_imax_range_unrebase$handle() {
        return per_imax_range_unrebase.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int per_imax_range_unrebase(uintmax_t inp, intmax_t lb, intmax_t ub, intmax_t *outp)
     * }
     */
    public static MemorySegment per_imax_range_unrebase$address() {
        return per_imax_range_unrebase.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int per_imax_range_unrebase(uintmax_t inp, intmax_t lb, intmax_t ub, intmax_t *outp)
     * }
     */
    public static int per_imax_range_unrebase(long inp, long lb, long ub, MemorySegment outp) {
        var mh$ = per_imax_range_unrebase.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("per_imax_range_unrebase", inp, lb, ub, outp);
            }
            return (int)mh$.invokeExact(inp, lb, ub, outp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uper_put_constrained_whole_number_u {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("uper_put_constrained_whole_number_u");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int uper_put_constrained_whole_number_u(asn_per_outp_t *po, uintmax_t v, int nbits)
     * }
     */
    public static FunctionDescriptor uper_put_constrained_whole_number_u$descriptor() {
        return uper_put_constrained_whole_number_u.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int uper_put_constrained_whole_number_u(asn_per_outp_t *po, uintmax_t v, int nbits)
     * }
     */
    public static MethodHandle uper_put_constrained_whole_number_u$handle() {
        return uper_put_constrained_whole_number_u.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int uper_put_constrained_whole_number_u(asn_per_outp_t *po, uintmax_t v, int nbits)
     * }
     */
    public static MemorySegment uper_put_constrained_whole_number_u$address() {
        return uper_put_constrained_whole_number_u.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int uper_put_constrained_whole_number_u(asn_per_outp_t *po, uintmax_t v, int nbits)
     * }
     */
    public static int uper_put_constrained_whole_number_u(MemorySegment po, long v, int nbits) {
        var mh$ = uper_put_constrained_whole_number_u.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uper_put_constrained_whole_number_u", po, v, nbits);
            }
            return (int)mh$.invokeExact(po, v, nbits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uper_put_length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("uper_put_length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t uper_put_length(asn_per_outp_t *po, size_t whole_length, int *opt_need_eom)
     * }
     */
    public static FunctionDescriptor uper_put_length$descriptor() {
        return uper_put_length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t uper_put_length(asn_per_outp_t *po, size_t whole_length, int *opt_need_eom)
     * }
     */
    public static MethodHandle uper_put_length$handle() {
        return uper_put_length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t uper_put_length(asn_per_outp_t *po, size_t whole_length, int *opt_need_eom)
     * }
     */
    public static MemorySegment uper_put_length$address() {
        return uper_put_length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t uper_put_length(asn_per_outp_t *po, size_t whole_length, int *opt_need_eom)
     * }
     */
    public static long uper_put_length(MemorySegment po, long whole_length, MemorySegment opt_need_eom) {
        var mh$ = uper_put_length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uper_put_length", po, whole_length, opt_need_eom);
            }
            return (long)mh$.invokeExact(po, whole_length, opt_need_eom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uper_put_nslength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("uper_put_nslength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int uper_put_nslength(asn_per_outp_t *po, size_t length)
     * }
     */
    public static FunctionDescriptor uper_put_nslength$descriptor() {
        return uper_put_nslength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int uper_put_nslength(asn_per_outp_t *po, size_t length)
     * }
     */
    public static MethodHandle uper_put_nslength$handle() {
        return uper_put_nslength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int uper_put_nslength(asn_per_outp_t *po, size_t length)
     * }
     */
    public static MemorySegment uper_put_nslength$address() {
        return uper_put_nslength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int uper_put_nslength(asn_per_outp_t *po, size_t length)
     * }
     */
    public static int uper_put_nslength(MemorySegment po, long length) {
        var mh$ = uper_put_nslength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uper_put_nslength", po, length);
            }
            return (int)mh$.invokeExact(po, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uper_put_nsnnwn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("uper_put_nsnnwn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int uper_put_nsnnwn(asn_per_outp_t *po, int n)
     * }
     */
    public static FunctionDescriptor uper_put_nsnnwn$descriptor() {
        return uper_put_nsnnwn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int uper_put_nsnnwn(asn_per_outp_t *po, int n)
     * }
     */
    public static MethodHandle uper_put_nsnnwn$handle() {
        return uper_put_nsnnwn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int uper_put_nsnnwn(asn_per_outp_t *po, int n)
     * }
     */
    public static MemorySegment uper_put_nsnnwn$address() {
        return uper_put_nsnnwn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int uper_put_nsnnwn(asn_per_outp_t *po, int n)
     * }
     */
    public static int uper_put_nsnnwn(MemorySegment po, int n) {
        var mh$ = uper_put_nsnnwn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uper_put_nsnnwn", po, n);
            }
            return (int)mh$.invokeExact(po, n);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uper_decode_complete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("uper_decode_complete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t uper_decode_complete(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static FunctionDescriptor uper_decode_complete$descriptor() {
        return uper_decode_complete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t uper_decode_complete(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static MethodHandle uper_decode_complete$handle() {
        return uper_decode_complete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t uper_decode_complete(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static MemorySegment uper_decode_complete$address() {
        return uper_decode_complete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t uper_decode_complete(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static MemorySegment uper_decode_complete(SegmentAllocator allocator, MemorySegment opt_codec_ctx, MemorySegment type_descriptor, MemorySegment struct_ptr, MemorySegment buffer, long size) {
        var mh$ = uper_decode_complete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uper_decode_complete", allocator, opt_codec_ctx, type_descriptor, struct_ptr, buffer, size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, opt_codec_ctx, type_descriptor, struct_ptr, buffer, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uper_decode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("uper_decode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t uper_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size, int skip_bits, int unused_bits)
     * }
     */
    public static FunctionDescriptor uper_decode$descriptor() {
        return uper_decode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t uper_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size, int skip_bits, int unused_bits)
     * }
     */
    public static MethodHandle uper_decode$handle() {
        return uper_decode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t uper_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size, int skip_bits, int unused_bits)
     * }
     */
    public static MemorySegment uper_decode$address() {
        return uper_decode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t uper_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size, int skip_bits, int unused_bits)
     * }
     */
    public static MemorySegment uper_decode(SegmentAllocator allocator, MemorySegment opt_codec_ctx, MemorySegment type_descriptor, MemorySegment struct_ptr, MemorySegment buffer, long size, int skip_bits, int unused_bits) {
        var mh$ = uper_decode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uper_decode", allocator, opt_codec_ctx, type_descriptor, struct_ptr, buffer, size, skip_bits, unused_bits);
            }
            return (MemorySegment)mh$.invokeExact(allocator, opt_codec_ctx, type_descriptor, struct_ptr, buffer, size, skip_bits, unused_bits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uper_encode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("uper_encode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t uper_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_per_constraints_t *constraints, const void *struct_ptr, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static FunctionDescriptor uper_encode$descriptor() {
        return uper_encode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t uper_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_per_constraints_t *constraints, const void *struct_ptr, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static MethodHandle uper_encode$handle() {
        return uper_encode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t uper_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_per_constraints_t *constraints, const void *struct_ptr, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static MemorySegment uper_encode$address() {
        return uper_encode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t uper_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_per_constraints_t *constraints, const void *struct_ptr, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static MemorySegment uper_encode(SegmentAllocator allocator, MemorySegment type_descriptor, MemorySegment constraints, MemorySegment struct_ptr, MemorySegment consume_bytes_cb, MemorySegment app_key) {
        var mh$ = uper_encode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uper_encode", allocator, type_descriptor, constraints, struct_ptr, consume_bytes_cb, app_key);
            }
            return (MemorySegment)mh$.invokeExact(allocator, type_descriptor, constraints, struct_ptr, consume_bytes_cb, app_key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uper_encode_to_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("uper_encode_to_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t uper_encode_to_buffer(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_per_constraints_t *constraints, const void *struct_ptr, void *buffer, size_t buffer_size)
     * }
     */
    public static FunctionDescriptor uper_encode_to_buffer$descriptor() {
        return uper_encode_to_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t uper_encode_to_buffer(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_per_constraints_t *constraints, const void *struct_ptr, void *buffer, size_t buffer_size)
     * }
     */
    public static MethodHandle uper_encode_to_buffer$handle() {
        return uper_encode_to_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t uper_encode_to_buffer(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_per_constraints_t *constraints, const void *struct_ptr, void *buffer, size_t buffer_size)
     * }
     */
    public static MemorySegment uper_encode_to_buffer$address() {
        return uper_encode_to_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t uper_encode_to_buffer(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_per_constraints_t *constraints, const void *struct_ptr, void *buffer, size_t buffer_size)
     * }
     */
    public static MemorySegment uper_encode_to_buffer(SegmentAllocator allocator, MemorySegment type_descriptor, MemorySegment constraints, MemorySegment struct_ptr, MemorySegment buffer, long buffer_size) {
        var mh$ = uper_encode_to_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uper_encode_to_buffer", allocator, type_descriptor, constraints, struct_ptr, buffer, buffer_size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, type_descriptor, constraints, struct_ptr, buffer, buffer_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class uper_encode_to_new_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("uper_encode_to_new_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t uper_encode_to_new_buffer(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_per_constraints_t *constraints, const void *struct_ptr, void **buffer_r)
     * }
     */
    public static FunctionDescriptor uper_encode_to_new_buffer$descriptor() {
        return uper_encode_to_new_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t uper_encode_to_new_buffer(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_per_constraints_t *constraints, const void *struct_ptr, void **buffer_r)
     * }
     */
    public static MethodHandle uper_encode_to_new_buffer$handle() {
        return uper_encode_to_new_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t uper_encode_to_new_buffer(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_per_constraints_t *constraints, const void *struct_ptr, void **buffer_r)
     * }
     */
    public static MemorySegment uper_encode_to_new_buffer$address() {
        return uper_encode_to_new_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t uper_encode_to_new_buffer(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_per_constraints_t *constraints, const void *struct_ptr, void **buffer_r)
     * }
     */
    public static long uper_encode_to_new_buffer(MemorySegment type_descriptor, MemorySegment constraints, MemorySegment struct_ptr, MemorySegment buffer_r) {
        var mh$ = uper_encode_to_new_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("uper_encode_to_new_buffer", type_descriptor, constraints, struct_ptr, buffer_r);
            }
            return (long)mh$.invokeExact(type_descriptor, constraints, struct_ptr, buffer_r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aper_get_length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("aper_get_length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t aper_get_length(asn_per_data_t *pd, ssize_t lb, ssize_t ub, int effective_bound_bits, int *repeat)
     * }
     */
    public static FunctionDescriptor aper_get_length$descriptor() {
        return aper_get_length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t aper_get_length(asn_per_data_t *pd, ssize_t lb, ssize_t ub, int effective_bound_bits, int *repeat)
     * }
     */
    public static MethodHandle aper_get_length$handle() {
        return aper_get_length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t aper_get_length(asn_per_data_t *pd, ssize_t lb, ssize_t ub, int effective_bound_bits, int *repeat)
     * }
     */
    public static MemorySegment aper_get_length$address() {
        return aper_get_length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t aper_get_length(asn_per_data_t *pd, ssize_t lb, ssize_t ub, int effective_bound_bits, int *repeat)
     * }
     */
    public static long aper_get_length(MemorySegment pd, long lb, long ub, int effective_bound_bits, MemorySegment repeat) {
        var mh$ = aper_get_length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aper_get_length", pd, lb, ub, effective_bound_bits, repeat);
            }
            return (long)mh$.invokeExact(pd, lb, ub, effective_bound_bits, repeat);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aper_get_nslength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("aper_get_nslength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t aper_get_nslength(asn_per_data_t *pd)
     * }
     */
    public static FunctionDescriptor aper_get_nslength$descriptor() {
        return aper_get_nslength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t aper_get_nslength(asn_per_data_t *pd)
     * }
     */
    public static MethodHandle aper_get_nslength$handle() {
        return aper_get_nslength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t aper_get_nslength(asn_per_data_t *pd)
     * }
     */
    public static MemorySegment aper_get_nslength$address() {
        return aper_get_nslength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t aper_get_nslength(asn_per_data_t *pd)
     * }
     */
    public static long aper_get_nslength(MemorySegment pd) {
        var mh$ = aper_get_nslength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aper_get_nslength", pd);
            }
            return (long)mh$.invokeExact(pd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aper_get_nsnnwn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("aper_get_nsnnwn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t aper_get_nsnnwn(asn_per_data_t *pd)
     * }
     */
    public static FunctionDescriptor aper_get_nsnnwn$descriptor() {
        return aper_get_nsnnwn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t aper_get_nsnnwn(asn_per_data_t *pd)
     * }
     */
    public static MethodHandle aper_get_nsnnwn$handle() {
        return aper_get_nsnnwn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t aper_get_nsnnwn(asn_per_data_t *pd)
     * }
     */
    public static MemorySegment aper_get_nsnnwn$address() {
        return aper_get_nsnnwn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t aper_get_nsnnwn(asn_per_data_t *pd)
     * }
     */
    public static long aper_get_nsnnwn(MemorySegment pd) {
        var mh$ = aper_get_nsnnwn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aper_get_nsnnwn", pd);
            }
            return (long)mh$.invokeExact(pd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aper_get_constrained_whole_number {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("aper_get_constrained_whole_number");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * long aper_get_constrained_whole_number(asn_per_data_t *po, long lb, long ub)
     * }
     */
    public static FunctionDescriptor aper_get_constrained_whole_number$descriptor() {
        return aper_get_constrained_whole_number.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * long aper_get_constrained_whole_number(asn_per_data_t *po, long lb, long ub)
     * }
     */
    public static MethodHandle aper_get_constrained_whole_number$handle() {
        return aper_get_constrained_whole_number.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * long aper_get_constrained_whole_number(asn_per_data_t *po, long lb, long ub)
     * }
     */
    public static MemorySegment aper_get_constrained_whole_number$address() {
        return aper_get_constrained_whole_number.ADDR;
    }

    /**
     * {@snippet lang=c :
     * long aper_get_constrained_whole_number(asn_per_data_t *po, long lb, long ub)
     * }
     */
    public static long aper_get_constrained_whole_number(MemorySegment po, long lb, long ub) {
        var mh$ = aper_get_constrained_whole_number.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aper_get_constrained_whole_number", po, lb, ub);
            }
            return (long)mh$.invokeExact(po, lb, ub);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aper_put_length {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("aper_put_length");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t aper_put_length(asn_per_outp_t *po, ssize_t lb, ssize_t ub, size_t n, int *opt_need_eom)
     * }
     */
    public static FunctionDescriptor aper_put_length$descriptor() {
        return aper_put_length.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t aper_put_length(asn_per_outp_t *po, ssize_t lb, ssize_t ub, size_t n, int *opt_need_eom)
     * }
     */
    public static MethodHandle aper_put_length$handle() {
        return aper_put_length.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t aper_put_length(asn_per_outp_t *po, ssize_t lb, ssize_t ub, size_t n, int *opt_need_eom)
     * }
     */
    public static MemorySegment aper_put_length$address() {
        return aper_put_length.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t aper_put_length(asn_per_outp_t *po, ssize_t lb, ssize_t ub, size_t n, int *opt_need_eom)
     * }
     */
    public static long aper_put_length(MemorySegment po, long lb, long ub, long n, MemorySegment opt_need_eom) {
        var mh$ = aper_put_length.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aper_put_length", po, lb, ub, n, opt_need_eom);
            }
            return (long)mh$.invokeExact(po, lb, ub, n, opt_need_eom);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aper_put_align {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("aper_put_align");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int aper_put_align(asn_per_outp_t *po)
     * }
     */
    public static FunctionDescriptor aper_put_align$descriptor() {
        return aper_put_align.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int aper_put_align(asn_per_outp_t *po)
     * }
     */
    public static MethodHandle aper_put_align$handle() {
        return aper_put_align.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int aper_put_align(asn_per_outp_t *po)
     * }
     */
    public static MemorySegment aper_put_align$address() {
        return aper_put_align.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int aper_put_align(asn_per_outp_t *po)
     * }
     */
    public static int aper_put_align(MemorySegment po) {
        var mh$ = aper_put_align.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aper_put_align", po);
            }
            return (int)mh$.invokeExact(po);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aper_get_align {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("aper_get_align");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int32_t aper_get_align(asn_per_data_t *pd)
     * }
     */
    public static FunctionDescriptor aper_get_align$descriptor() {
        return aper_get_align.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int32_t aper_get_align(asn_per_data_t *pd)
     * }
     */
    public static MethodHandle aper_get_align$handle() {
        return aper_get_align.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int32_t aper_get_align(asn_per_data_t *pd)
     * }
     */
    public static MemorySegment aper_get_align$address() {
        return aper_get_align.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int32_t aper_get_align(asn_per_data_t *pd)
     * }
     */
    public static int aper_get_align(MemorySegment pd) {
        var mh$ = aper_get_align.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aper_get_align", pd);
            }
            return (int)mh$.invokeExact(pd);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aper_put_nslength {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("aper_put_nslength");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int aper_put_nslength(asn_per_outp_t *po, size_t length)
     * }
     */
    public static FunctionDescriptor aper_put_nslength$descriptor() {
        return aper_put_nslength.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int aper_put_nslength(asn_per_outp_t *po, size_t length)
     * }
     */
    public static MethodHandle aper_put_nslength$handle() {
        return aper_put_nslength.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int aper_put_nslength(asn_per_outp_t *po, size_t length)
     * }
     */
    public static MemorySegment aper_put_nslength$address() {
        return aper_put_nslength.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int aper_put_nslength(asn_per_outp_t *po, size_t length)
     * }
     */
    public static int aper_put_nslength(MemorySegment po, long length) {
        var mh$ = aper_put_nslength.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aper_put_nslength", po, length);
            }
            return (int)mh$.invokeExact(po, length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aper_put_nsnnwn {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("aper_put_nsnnwn");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int aper_put_nsnnwn(asn_per_outp_t *po, int number)
     * }
     */
    public static FunctionDescriptor aper_put_nsnnwn$descriptor() {
        return aper_put_nsnnwn.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int aper_put_nsnnwn(asn_per_outp_t *po, int number)
     * }
     */
    public static MethodHandle aper_put_nsnnwn$handle() {
        return aper_put_nsnnwn.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int aper_put_nsnnwn(asn_per_outp_t *po, int number)
     * }
     */
    public static MemorySegment aper_put_nsnnwn$address() {
        return aper_put_nsnnwn.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int aper_put_nsnnwn(asn_per_outp_t *po, int number)
     * }
     */
    public static int aper_put_nsnnwn(MemorySegment po, int number) {
        var mh$ = aper_put_nsnnwn.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aper_put_nsnnwn", po, number);
            }
            return (int)mh$.invokeExact(po, number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aper_put_constrained_whole_number {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("aper_put_constrained_whole_number");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int aper_put_constrained_whole_number(asn_per_outp_t *po, long lb, long ub, long number)
     * }
     */
    public static FunctionDescriptor aper_put_constrained_whole_number$descriptor() {
        return aper_put_constrained_whole_number.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int aper_put_constrained_whole_number(asn_per_outp_t *po, long lb, long ub, long number)
     * }
     */
    public static MethodHandle aper_put_constrained_whole_number$handle() {
        return aper_put_constrained_whole_number.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int aper_put_constrained_whole_number(asn_per_outp_t *po, long lb, long ub, long number)
     * }
     */
    public static MemorySegment aper_put_constrained_whole_number$address() {
        return aper_put_constrained_whole_number.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int aper_put_constrained_whole_number(asn_per_outp_t *po, long lb, long ub, long number)
     * }
     */
    public static int aper_put_constrained_whole_number(MemorySegment po, long lb, long ub, long number) {
        var mh$ = aper_put_constrained_whole_number.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aper_put_constrained_whole_number", po, lb, ub, number);
            }
            return (int)mh$.invokeExact(po, lb, ub, number);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aper_decode_complete {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("aper_decode_complete");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t aper_decode_complete(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static FunctionDescriptor aper_decode_complete$descriptor() {
        return aper_decode_complete.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t aper_decode_complete(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static MethodHandle aper_decode_complete$handle() {
        return aper_decode_complete.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t aper_decode_complete(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static MemorySegment aper_decode_complete$address() {
        return aper_decode_complete.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t aper_decode_complete(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size)
     * }
     */
    public static MemorySegment aper_decode_complete(SegmentAllocator allocator, MemorySegment opt_codec_ctx, MemorySegment type_descriptor, MemorySegment struct_ptr, MemorySegment buffer, long size) {
        var mh$ = aper_decode_complete.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aper_decode_complete", allocator, opt_codec_ctx, type_descriptor, struct_ptr, buffer, size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, opt_codec_ctx, type_descriptor, struct_ptr, buffer, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aper_decode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("aper_decode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t aper_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size, int skip_bits, int unused_bits)
     * }
     */
    public static FunctionDescriptor aper_decode$descriptor() {
        return aper_decode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t aper_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size, int skip_bits, int unused_bits)
     * }
     */
    public static MethodHandle aper_decode$handle() {
        return aper_decode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t aper_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size, int skip_bits, int unused_bits)
     * }
     */
    public static MemorySegment aper_decode$address() {
        return aper_decode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t aper_decode(const struct asn_codec_ctx_s *opt_codec_ctx, const struct asn_TYPE_descriptor_s *type_descriptor, void **struct_ptr, const void *buffer, size_t size, int skip_bits, int unused_bits)
     * }
     */
    public static MemorySegment aper_decode(SegmentAllocator allocator, MemorySegment opt_codec_ctx, MemorySegment type_descriptor, MemorySegment struct_ptr, MemorySegment buffer, long size, int skip_bits, int unused_bits) {
        var mh$ = aper_decode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aper_decode", allocator, opt_codec_ctx, type_descriptor, struct_ptr, buffer, size, skip_bits, unused_bits);
            }
            return (MemorySegment)mh$.invokeExact(allocator, opt_codec_ctx, type_descriptor, struct_ptr, buffer, size, skip_bits, unused_bits);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aper_encode {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("aper_encode");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t aper_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_per_constraints_t *constraints, const void *struct_ptr, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static FunctionDescriptor aper_encode$descriptor() {
        return aper_encode.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t aper_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_per_constraints_t *constraints, const void *struct_ptr, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static MethodHandle aper_encode$handle() {
        return aper_encode.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t aper_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_per_constraints_t *constraints, const void *struct_ptr, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static MemorySegment aper_encode$address() {
        return aper_encode.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t aper_encode(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_per_constraints_t *constraints, const void *struct_ptr, asn_app_consume_bytes_f *consume_bytes_cb, void *app_key)
     * }
     */
    public static MemorySegment aper_encode(SegmentAllocator allocator, MemorySegment type_descriptor, MemorySegment constraints, MemorySegment struct_ptr, MemorySegment consume_bytes_cb, MemorySegment app_key) {
        var mh$ = aper_encode.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aper_encode", allocator, type_descriptor, constraints, struct_ptr, consume_bytes_cb, app_key);
            }
            return (MemorySegment)mh$.invokeExact(allocator, type_descriptor, constraints, struct_ptr, consume_bytes_cb, app_key);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aper_encode_to_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("aper_encode_to_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t aper_encode_to_buffer(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_per_constraints_t *constraints, const void *struct_ptr, void *buffer, size_t buffer_size)
     * }
     */
    public static FunctionDescriptor aper_encode_to_buffer$descriptor() {
        return aper_encode_to_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t aper_encode_to_buffer(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_per_constraints_t *constraints, const void *struct_ptr, void *buffer, size_t buffer_size)
     * }
     */
    public static MethodHandle aper_encode_to_buffer$handle() {
        return aper_encode_to_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t aper_encode_to_buffer(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_per_constraints_t *constraints, const void *struct_ptr, void *buffer, size_t buffer_size)
     * }
     */
    public static MemorySegment aper_encode_to_buffer$address() {
        return aper_encode_to_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t aper_encode_to_buffer(const struct asn_TYPE_descriptor_s *type_descriptor, const asn_per_constraints_t *constraints, const void *struct_ptr, void *buffer, size_t buffer_size)
     * }
     */
    public static MemorySegment aper_encode_to_buffer(SegmentAllocator allocator, MemorySegment type_descriptor, MemorySegment constraints, MemorySegment struct_ptr, MemorySegment buffer, long buffer_size) {
        var mh$ = aper_encode_to_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aper_encode_to_buffer", allocator, type_descriptor, constraints, struct_ptr, buffer, buffer_size);
            }
            return (MemorySegment)mh$.invokeExact(allocator, type_descriptor, constraints, struct_ptr, buffer, buffer_size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class aper_encode_to_new_buffer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("aper_encode_to_new_buffer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ssize_t aper_encode_to_new_buffer(const struct asn_TYPE_descriptor_s *td, const asn_per_constraints_t *constraints, const void *sptr, void **buffer_r)
     * }
     */
    public static FunctionDescriptor aper_encode_to_new_buffer$descriptor() {
        return aper_encode_to_new_buffer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ssize_t aper_encode_to_new_buffer(const struct asn_TYPE_descriptor_s *td, const asn_per_constraints_t *constraints, const void *sptr, void **buffer_r)
     * }
     */
    public static MethodHandle aper_encode_to_new_buffer$handle() {
        return aper_encode_to_new_buffer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ssize_t aper_encode_to_new_buffer(const struct asn_TYPE_descriptor_s *td, const asn_per_constraints_t *constraints, const void *sptr, void **buffer_r)
     * }
     */
    public static MemorySegment aper_encode_to_new_buffer$address() {
        return aper_encode_to_new_buffer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ssize_t aper_encode_to_new_buffer(const struct asn_TYPE_descriptor_s *td, const asn_per_constraints_t *constraints, const void *sptr, void **buffer_r)
     * }
     */
    public static long aper_encode_to_new_buffer(MemorySegment td, MemorySegment constraints, MemorySegment sptr, MemorySegment buffer_r) {
        var mh$ = aper_encode_to_new_buffer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("aper_encode_to_new_buffer", td, constraints, sptr, buffer_r);
            }
            return (long)mh$.invokeExact(td, constraints, sptr, buffer_r);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class get_asn1c_environment_version {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT    );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("get_asn1c_environment_version");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int get_asn1c_environment_version()
     * }
     */
    public static FunctionDescriptor get_asn1c_environment_version$descriptor() {
        return get_asn1c_environment_version.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int get_asn1c_environment_version()
     * }
     */
    public static MethodHandle get_asn1c_environment_version$handle() {
        return get_asn1c_environment_version.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int get_asn1c_environment_version()
     * }
     */
    public static MemorySegment get_asn1c_environment_version$address() {
        return get_asn1c_environment_version.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int get_asn1c_environment_version()
     * }
     */
    public static int get_asn1c_environment_version() {
        var mh$ = get_asn1c_environment_version.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("get_asn1c_environment_version");
            }
            return (int)mh$.invokeExact();
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Variadic invoker class for:
     * {@snippet lang=c :
     * ssize_t asn__format_to_callback(int (*callback)(const void *, size_t, void *), void *key, const char *fmt, ...)
     * }
     */
    public static class asn__format_to_callback {
        private static final FunctionDescriptor BASE_DESC = FunctionDescriptor.of(
                MessageFrame_h.C_LONG,
                MessageFrame_h.C_POINTER,
                MessageFrame_h.C_POINTER,
                MessageFrame_h.C_POINTER
            );
        private static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn__format_to_callback");

        private final MethodHandle handle;
        private final FunctionDescriptor descriptor;
        private final MethodHandle spreader;

        private asn__format_to_callback(MethodHandle handle, FunctionDescriptor descriptor, MethodHandle spreader) {
            this.handle = handle;
            this.descriptor = descriptor;
            this.spreader = spreader;
        }

        /**
         * Variadic invoker factory for:
         * {@snippet lang=c :
         * ssize_t asn__format_to_callback(int (*callback)(const void *, size_t, void *), void *key, const char *fmt, ...)
         * }
         */
        public static asn__format_to_callback makeInvoker(MemoryLayout... layouts) {
            FunctionDescriptor desc$ = BASE_DESC.appendArgumentLayouts(layouts);
            Linker.Option fva$ = Linker.Option.firstVariadicArg(BASE_DESC.argumentLayouts().size());
            var mh$ = Linker.nativeLinker().downcallHandle(ADDR, desc$, fva$);
            var spreader$ = mh$.asSpreader(Object[].class, layouts.length);
            return new asn__format_to_callback(mh$, desc$, spreader$);
        }

        /**
         * {@return the address}
         */
        public static MemorySegment address() {
            return ADDR;
        }

        /**
         * {@return the specialized method handle}
         */
        public MethodHandle handle() {
            return handle;
        }

        /**
         * {@return the specialized descriptor}
         */
        public FunctionDescriptor descriptor() {
            return descriptor;
        }

        public long apply(MemorySegment callback, MemorySegment key, MemorySegment fmt, Object... x3) {
            try {
                if (TRACE_DOWNCALLS) {
                    traceDowncall("asn__format_to_callback", callback, key, fmt, x3);
                }
                return (long) spreader.invokeExact(callback, key, fmt, x3);
            } catch(IllegalArgumentException | ClassCastException ex$)  {
                throw ex$; // rethrow IAE from passing wrong number/type of args
            } catch (Throwable ex$) {
               throw new AssertionError("should not reach here", ex$);
            }
        }
    }

    private static class asn_DEF_OCTET_STRING$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_OCTET_STRING").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_OCTET_STRING
     * }
     */
    public static GroupLayout asn_DEF_OCTET_STRING$layout() {
        return asn_DEF_OCTET_STRING$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_OCTET_STRING
     * }
     */
    public static MemorySegment asn_DEF_OCTET_STRING() {
        return asn_DEF_OCTET_STRING$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_OCTET_STRING
     * }
     */
    public static void asn_DEF_OCTET_STRING(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_OCTET_STRING$constants.SEGMENT, 0L, asn_DEF_OCTET_STRING$constants.LAYOUT.byteSize());
    }

    private static class asn_OP_OCTET_STRING$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_operation_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_OP_OCTET_STRING").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_OCTET_STRING
     * }
     */
    public static GroupLayout asn_OP_OCTET_STRING$layout() {
        return asn_OP_OCTET_STRING$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_OCTET_STRING
     * }
     */
    public static MemorySegment asn_OP_OCTET_STRING() {
        return asn_OP_OCTET_STRING$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_OCTET_STRING
     * }
     */
    public static void asn_OP_OCTET_STRING(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_OP_OCTET_STRING$constants.SEGMENT, 0L, asn_OP_OCTET_STRING$constants.LAYOUT.byteSize());
    }

    private static class OCTET_STRING_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void OCTET_STRING_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_free$descriptor() {
        return OCTET_STRING_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void OCTET_STRING_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle OCTET_STRING_free$handle() {
        return OCTET_STRING_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void OCTET_STRING_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment OCTET_STRING_free$address() {
        return OCTET_STRING_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void OCTET_STRING_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void OCTET_STRING_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = OCTET_STRING_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int OCTET_STRING_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_print$descriptor() {
        return OCTET_STRING_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int OCTET_STRING_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OCTET_STRING_print$handle() {
        return OCTET_STRING_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int OCTET_STRING_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OCTET_STRING_print$address() {
        return OCTET_STRING_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int OCTET_STRING_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int OCTET_STRING_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = OCTET_STRING_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_print_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_print_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int OCTET_STRING_print_utf8(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_print_utf8$descriptor() {
        return OCTET_STRING_print_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int OCTET_STRING_print_utf8(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OCTET_STRING_print_utf8$handle() {
        return OCTET_STRING_print_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int OCTET_STRING_print_utf8(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OCTET_STRING_print_utf8$address() {
        return OCTET_STRING_print_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int OCTET_STRING_print_utf8(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int OCTET_STRING_print_utf8(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = OCTET_STRING_print_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_print_utf8", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_compare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int OCTET_STRING_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_compare$descriptor() {
        return OCTET_STRING_compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int OCTET_STRING_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static MethodHandle OCTET_STRING_compare$handle() {
        return OCTET_STRING_compare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int OCTET_STRING_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static MemorySegment OCTET_STRING_compare$address() {
        return OCTET_STRING_compare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int OCTET_STRING_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static int OCTET_STRING_compare(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = OCTET_STRING_compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_compare", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int OCTET_STRING_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_copy$descriptor() {
        return OCTET_STRING_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int OCTET_STRING_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static MethodHandle OCTET_STRING_copy$handle() {
        return OCTET_STRING_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int OCTET_STRING_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static MemorySegment OCTET_STRING_copy$address() {
        return OCTET_STRING_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int OCTET_STRING_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static int OCTET_STRING_copy(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = OCTET_STRING_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_copy", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_decode_ber$descriptor() {
        return OCTET_STRING_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle OCTET_STRING_decode_ber$handle() {
        return OCTET_STRING_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment OCTET_STRING_decode_ber$address() {
        return OCTET_STRING_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment OCTET_STRING_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = OCTET_STRING_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_encode_der$descriptor() {
        return OCTET_STRING_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OCTET_STRING_encode_der$handle() {
        return OCTET_STRING_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OCTET_STRING_encode_der$address() {
        return OCTET_STRING_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OCTET_STRING_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = OCTET_STRING_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_decode_xer_hex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_decode_xer_hex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_xer_hex(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_decode_xer_hex$descriptor() {
        return OCTET_STRING_decode_xer_hex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_xer_hex(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle OCTET_STRING_decode_xer_hex$handle() {
        return OCTET_STRING_decode_xer_hex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_xer_hex(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment OCTET_STRING_decode_xer_hex$address() {
        return OCTET_STRING_decode_xer_hex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_xer_hex(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment OCTET_STRING_decode_xer_hex(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = OCTET_STRING_decode_xer_hex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_decode_xer_hex", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_decode_xer_binary {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_decode_xer_binary");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_xer_binary(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_decode_xer_binary$descriptor() {
        return OCTET_STRING_decode_xer_binary.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_xer_binary(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle OCTET_STRING_decode_xer_binary$handle() {
        return OCTET_STRING_decode_xer_binary.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_xer_binary(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment OCTET_STRING_decode_xer_binary$address() {
        return OCTET_STRING_decode_xer_binary.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_xer_binary(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment OCTET_STRING_decode_xer_binary(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = OCTET_STRING_decode_xer_binary.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_decode_xer_binary", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_decode_xer_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_decode_xer_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_xer_utf8(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_decode_xer_utf8$descriptor() {
        return OCTET_STRING_decode_xer_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_xer_utf8(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle OCTET_STRING_decode_xer_utf8$handle() {
        return OCTET_STRING_decode_xer_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_xer_utf8(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment OCTET_STRING_decode_xer_utf8$address() {
        return OCTET_STRING_decode_xer_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_xer_utf8(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment OCTET_STRING_decode_xer_utf8(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = OCTET_STRING_decode_xer_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_decode_xer_utf8", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_encode_xer$descriptor() {
        return OCTET_STRING_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OCTET_STRING_encode_xer$handle() {
        return OCTET_STRING_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OCTET_STRING_encode_xer$address() {
        return OCTET_STRING_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OCTET_STRING_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = OCTET_STRING_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_encode_xer_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_encode_xer_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_xer_utf8(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_encode_xer_utf8$descriptor() {
        return OCTET_STRING_encode_xer_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_xer_utf8(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OCTET_STRING_encode_xer_utf8$handle() {
        return OCTET_STRING_encode_xer_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_xer_utf8(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OCTET_STRING_encode_xer_utf8$address() {
        return OCTET_STRING_encode_xer_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_xer_utf8(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OCTET_STRING_encode_xer_utf8(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = OCTET_STRING_encode_xer_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_encode_xer_utf8", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_decode_jer_hex {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_decode_jer_hex");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_jer_hex(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_decode_jer_hex$descriptor() {
        return OCTET_STRING_decode_jer_hex.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_jer_hex(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle OCTET_STRING_decode_jer_hex$handle() {
        return OCTET_STRING_decode_jer_hex.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_jer_hex(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment OCTET_STRING_decode_jer_hex$address() {
        return OCTET_STRING_decode_jer_hex.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_jer_hex(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment OCTET_STRING_decode_jer_hex(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = OCTET_STRING_decode_jer_hex.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_decode_jer_hex", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_decode_jer_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_decode_jer_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_jer_utf8(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_decode_jer_utf8$descriptor() {
        return OCTET_STRING_decode_jer_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_jer_utf8(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle OCTET_STRING_decode_jer_utf8$handle() {
        return OCTET_STRING_decode_jer_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_jer_utf8(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment OCTET_STRING_decode_jer_utf8$address() {
        return OCTET_STRING_decode_jer_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_jer_utf8(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment OCTET_STRING_decode_jer_utf8(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = OCTET_STRING_decode_jer_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_decode_jer_utf8", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_encode_jer$descriptor() {
        return OCTET_STRING_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OCTET_STRING_encode_jer$handle() {
        return OCTET_STRING_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OCTET_STRING_encode_jer$address() {
        return OCTET_STRING_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OCTET_STRING_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = OCTET_STRING_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_encode_jer_utf8 {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_encode_jer_utf8");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_jer_utf8(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_encode_jer_utf8$descriptor() {
        return OCTET_STRING_encode_jer_utf8.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_jer_utf8(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OCTET_STRING_encode_jer_utf8$handle() {
        return OCTET_STRING_encode_jer_utf8.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_jer_utf8(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OCTET_STRING_encode_jer_utf8$address() {
        return OCTET_STRING_encode_jer_utf8.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_jer_utf8(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OCTET_STRING_encode_jer_utf8(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = OCTET_STRING_encode_jer_utf8.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_encode_jer_utf8", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_decode_oer$descriptor() {
        return OCTET_STRING_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle OCTET_STRING_decode_oer$handle() {
        return OCTET_STRING_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment OCTET_STRING_decode_oer$address() {
        return OCTET_STRING_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment OCTET_STRING_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = OCTET_STRING_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_encode_oer$descriptor() {
        return OCTET_STRING_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OCTET_STRING_encode_oer$handle() {
        return OCTET_STRING_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OCTET_STRING_encode_oer$address() {
        return OCTET_STRING_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OCTET_STRING_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = OCTET_STRING_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_decode_uper$descriptor() {
        return OCTET_STRING_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle OCTET_STRING_decode_uper$handle() {
        return OCTET_STRING_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment OCTET_STRING_decode_uper$address() {
        return OCTET_STRING_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment OCTET_STRING_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = OCTET_STRING_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_encode_uper$descriptor() {
        return OCTET_STRING_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle OCTET_STRING_encode_uper$handle() {
        return OCTET_STRING_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment OCTET_STRING_encode_uper$address() {
        return OCTET_STRING_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment OCTET_STRING_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = OCTET_STRING_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_decode_aper$descriptor() {
        return OCTET_STRING_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle OCTET_STRING_decode_aper$handle() {
        return OCTET_STRING_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment OCTET_STRING_decode_aper$address() {
        return OCTET_STRING_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OCTET_STRING_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment OCTET_STRING_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = OCTET_STRING_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_encode_aper$descriptor() {
        return OCTET_STRING_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle OCTET_STRING_encode_aper$handle() {
        return OCTET_STRING_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment OCTET_STRING_encode_aper$address() {
        return OCTET_STRING_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OCTET_STRING_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment OCTET_STRING_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = OCTET_STRING_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_random_fill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_random_fill_result_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_random_fill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_random_fill_result_t OCTET_STRING_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_random_fill$descriptor() {
        return OCTET_STRING_random_fill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_random_fill_result_t OCTET_STRING_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static MethodHandle OCTET_STRING_random_fill$handle() {
        return OCTET_STRING_random_fill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_random_fill_result_t OCTET_STRING_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static MemorySegment OCTET_STRING_random_fill$address() {
        return OCTET_STRING_random_fill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_random_fill_result_t OCTET_STRING_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static MemorySegment OCTET_STRING_random_fill(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = OCTET_STRING_random_fill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_random_fill", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_per_get_characters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_per_get_characters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int OCTET_STRING_per_get_characters(asn_per_data_t *po, uint8_t *buf, size_t units, unsigned int bpc, unsigned int unit_bits, long lb, long ub, const asn_per_constraints_t *pc)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_per_get_characters$descriptor() {
        return OCTET_STRING_per_get_characters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int OCTET_STRING_per_get_characters(asn_per_data_t *po, uint8_t *buf, size_t units, unsigned int bpc, unsigned int unit_bits, long lb, long ub, const asn_per_constraints_t *pc)
     * }
     */
    public static MethodHandle OCTET_STRING_per_get_characters$handle() {
        return OCTET_STRING_per_get_characters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int OCTET_STRING_per_get_characters(asn_per_data_t *po, uint8_t *buf, size_t units, unsigned int bpc, unsigned int unit_bits, long lb, long ub, const asn_per_constraints_t *pc)
     * }
     */
    public static MemorySegment OCTET_STRING_per_get_characters$address() {
        return OCTET_STRING_per_get_characters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int OCTET_STRING_per_get_characters(asn_per_data_t *po, uint8_t *buf, size_t units, unsigned int bpc, unsigned int unit_bits, long lb, long ub, const asn_per_constraints_t *pc)
     * }
     */
    public static int OCTET_STRING_per_get_characters(MemorySegment po, MemorySegment buf, long units, int bpc, int unit_bits, long lb, long ub, MemorySegment pc) {
        var mh$ = OCTET_STRING_per_get_characters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_per_get_characters", po, buf, units, bpc, unit_bits, lb, ub, pc);
            }
            return (int)mh$.invokeExact(po, buf, units, bpc, unit_bits, lb, ub, pc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_per_put_characters {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_per_put_characters");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int OCTET_STRING_per_put_characters(asn_per_outp_t *po, const uint8_t *buf, size_t units, unsigned int bpc, unsigned int unit_bits, long lb, long ub, const asn_per_constraints_t *pc)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_per_put_characters$descriptor() {
        return OCTET_STRING_per_put_characters.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int OCTET_STRING_per_put_characters(asn_per_outp_t *po, const uint8_t *buf, size_t units, unsigned int bpc, unsigned int unit_bits, long lb, long ub, const asn_per_constraints_t *pc)
     * }
     */
    public static MethodHandle OCTET_STRING_per_put_characters$handle() {
        return OCTET_STRING_per_put_characters.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int OCTET_STRING_per_put_characters(asn_per_outp_t *po, const uint8_t *buf, size_t units, unsigned int bpc, unsigned int unit_bits, long lb, long ub, const asn_per_constraints_t *pc)
     * }
     */
    public static MemorySegment OCTET_STRING_per_put_characters$address() {
        return OCTET_STRING_per_put_characters.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int OCTET_STRING_per_put_characters(asn_per_outp_t *po, const uint8_t *buf, size_t units, unsigned int bpc, unsigned int unit_bits, long lb, long ub, const asn_per_constraints_t *pc)
     * }
     */
    public static int OCTET_STRING_per_put_characters(MemorySegment po, MemorySegment buf, long units, int bpc, int unit_bits, long lb, long ub, MemorySegment pc) {
        var mh$ = OCTET_STRING_per_put_characters.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_per_put_characters", po, buf, units, bpc, unit_bits, lb, ub, pc);
            }
            return (int)mh$.invokeExact(po, buf, units, bpc, unit_bits, lb, ub, pc);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_fromBuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_fromBuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int OCTET_STRING_fromBuf(OCTET_STRING_t *s, const char *str, int size)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_fromBuf$descriptor() {
        return OCTET_STRING_fromBuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int OCTET_STRING_fromBuf(OCTET_STRING_t *s, const char *str, int size)
     * }
     */
    public static MethodHandle OCTET_STRING_fromBuf$handle() {
        return OCTET_STRING_fromBuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int OCTET_STRING_fromBuf(OCTET_STRING_t *s, const char *str, int size)
     * }
     */
    public static MemorySegment OCTET_STRING_fromBuf$address() {
        return OCTET_STRING_fromBuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int OCTET_STRING_fromBuf(OCTET_STRING_t *s, const char *str, int size)
     * }
     */
    public static int OCTET_STRING_fromBuf(MemorySegment s, MemorySegment str, int size) {
        var mh$ = OCTET_STRING_fromBuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_fromBuf", s, str, size);
            }
            return (int)mh$.invokeExact(s, str, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OCTET_STRING_new_fromBuf {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_new_fromBuf");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * OCTET_STRING_t *OCTET_STRING_new_fromBuf(const asn_TYPE_descriptor_t *td, const char *str, int size)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_new_fromBuf$descriptor() {
        return OCTET_STRING_new_fromBuf.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * OCTET_STRING_t *OCTET_STRING_new_fromBuf(const asn_TYPE_descriptor_t *td, const char *str, int size)
     * }
     */
    public static MethodHandle OCTET_STRING_new_fromBuf$handle() {
        return OCTET_STRING_new_fromBuf.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * OCTET_STRING_t *OCTET_STRING_new_fromBuf(const asn_TYPE_descriptor_t *td, const char *str, int size)
     * }
     */
    public static MemorySegment OCTET_STRING_new_fromBuf$address() {
        return OCTET_STRING_new_fromBuf.ADDR;
    }

    /**
     * {@snippet lang=c :
     * OCTET_STRING_t *OCTET_STRING_new_fromBuf(const asn_TYPE_descriptor_t *td, const char *str, int size)
     * }
     */
    public static MemorySegment OCTET_STRING_new_fromBuf(MemorySegment td, MemorySegment str, int size) {
        var mh$ = OCTET_STRING_new_fromBuf.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_new_fromBuf", td, str, size);
            }
            return (MemorySegment)mh$.invokeExact(td, str, size);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ASN_OSUBV_ANY = (int)0L;
    /**
     * {@snippet lang=c :
     * enum asn_OS_Subvariant.ASN_OSUBV_ANY = 0
     * }
     */
    public static int ASN_OSUBV_ANY() {
        return ASN_OSUBV_ANY;
    }
    private static final int ASN_OSUBV_BIT = (int)1L;
    /**
     * {@snippet lang=c :
     * enum asn_OS_Subvariant.ASN_OSUBV_BIT = 1
     * }
     */
    public static int ASN_OSUBV_BIT() {
        return ASN_OSUBV_BIT;
    }
    private static final int ASN_OSUBV_STR = (int)2L;
    /**
     * {@snippet lang=c :
     * enum asn_OS_Subvariant.ASN_OSUBV_STR = 2
     * }
     */
    public static int ASN_OSUBV_STR() {
        return ASN_OSUBV_STR;
    }
    private static final int ASN_OSUBV_U16 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum asn_OS_Subvariant.ASN_OSUBV_U16 = 3
     * }
     */
    public static int ASN_OSUBV_U16() {
        return ASN_OSUBV_U16;
    }
    private static final int ASN_OSUBV_U32 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum asn_OS_Subvariant.ASN_OSUBV_U32 = 4
     * }
     */
    public static int ASN_OSUBV_U32() {
        return ASN_OSUBV_U32;
    }

    private static class asn_SPC_OCTET_STRING_specs$constants {
        public static final GroupLayout LAYOUT = asn_OCTET_STRING_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_OCTET_STRING_specs").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_OCTET_STRING_specifics_t asn_SPC_OCTET_STRING_specs
     * }
     */
    public static GroupLayout asn_SPC_OCTET_STRING_specs$layout() {
        return asn_SPC_OCTET_STRING_specs$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_OCTET_STRING_specifics_t asn_SPC_OCTET_STRING_specs
     * }
     */
    public static MemorySegment asn_SPC_OCTET_STRING_specs() {
        return asn_SPC_OCTET_STRING_specs$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_OCTET_STRING_specifics_t asn_SPC_OCTET_STRING_specs
     * }
     */
    public static void asn_SPC_OCTET_STRING_specs(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_OCTET_STRING_specs$constants.SEGMENT, 0L, asn_SPC_OCTET_STRING_specs$constants.LAYOUT.byteSize());
    }

    private static class OCTET_STRING_random_length_constrained {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OCTET_STRING_random_length_constrained");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * size_t OCTET_STRING_random_length_constrained(const asn_TYPE_descriptor_t *, const asn_encoding_constraints_t *, size_t max_length)
     * }
     */
    public static FunctionDescriptor OCTET_STRING_random_length_constrained$descriptor() {
        return OCTET_STRING_random_length_constrained.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * size_t OCTET_STRING_random_length_constrained(const asn_TYPE_descriptor_t *, const asn_encoding_constraints_t *, size_t max_length)
     * }
     */
    public static MethodHandle OCTET_STRING_random_length_constrained$handle() {
        return OCTET_STRING_random_length_constrained.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * size_t OCTET_STRING_random_length_constrained(const asn_TYPE_descriptor_t *, const asn_encoding_constraints_t *, size_t max_length)
     * }
     */
    public static MemorySegment OCTET_STRING_random_length_constrained$address() {
        return OCTET_STRING_random_length_constrained.ADDR;
    }

    /**
     * {@snippet lang=c :
     * size_t OCTET_STRING_random_length_constrained(const asn_TYPE_descriptor_t *, const asn_encoding_constraints_t *, size_t max_length)
     * }
     */
    public static long OCTET_STRING_random_length_constrained(MemorySegment x0, MemorySegment x1, long max_length) {
        var mh$ = OCTET_STRING_random_length_constrained.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OCTET_STRING_random_length_constrained", x0, x1, max_length);
            }
            return (long)mh$.invokeExact(x0, x1, max_length);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_ANY$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_ANY").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ANY
     * }
     */
    public static GroupLayout asn_DEF_ANY$layout() {
        return asn_DEF_ANY$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ANY
     * }
     */
    public static MemorySegment asn_DEF_ANY() {
        return asn_DEF_ANY$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ANY
     * }
     */
    public static void asn_DEF_ANY(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_ANY$constants.SEGMENT, 0L, asn_DEF_ANY$constants.LAYOUT.byteSize());
    }

    private static class asn_OP_ANY$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_operation_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_OP_ANY").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_ANY
     * }
     */
    public static GroupLayout asn_OP_ANY$layout() {
        return asn_OP_ANY$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_ANY
     * }
     */
    public static MemorySegment asn_OP_ANY() {
        return asn_OP_ANY$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_ANY
     * }
     */
    public static void asn_OP_ANY(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_OP_ANY$constants.SEGMENT, 0L, asn_OP_ANY$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_ANY_specs$constants {
        public static final GroupLayout LAYOUT = asn_OCTET_STRING_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_ANY_specs").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_OCTET_STRING_specifics_t asn_SPC_ANY_specs
     * }
     */
    public static GroupLayout asn_SPC_ANY_specs$layout() {
        return asn_SPC_ANY_specs$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_OCTET_STRING_specifics_t asn_SPC_ANY_specs
     * }
     */
    public static MemorySegment asn_SPC_ANY_specs() {
        return asn_SPC_ANY_specs$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_OCTET_STRING_specifics_t asn_SPC_ANY_specs
     * }
     */
    public static void asn_SPC_ANY_specs(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_ANY_specs$constants.SEGMENT, 0L, asn_SPC_ANY_specs$constants.LAYOUT.byteSize());
    }

    private static class ANY_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ANY_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ANY_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ANY_encode_xer$descriptor() {
        return ANY_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ANY_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ANY_encode_xer$handle() {
        return ANY_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ANY_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ANY_encode_xer$address() {
        return ANY_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ANY_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ANY_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ANY_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ANY_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ANY_decode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ANY_decode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ANY_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor ANY_decode_jer$descriptor() {
        return ANY_decode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ANY_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle ANY_decode_jer$handle() {
        return ANY_decode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ANY_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ANY_decode_jer$address() {
        return ANY_decode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ANY_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ANY_decode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = ANY_decode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ANY_decode_jer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ANY_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ANY_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ANY_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ANY_encode_jer$descriptor() {
        return ANY_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ANY_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ANY_encode_jer$handle() {
        return ANY_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ANY_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ANY_encode_jer$address() {
        return ANY_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ANY_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ANY_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = ANY_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ANY_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ANY_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ANY_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ANY_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor ANY_decode_uper$descriptor() {
        return ANY_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ANY_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle ANY_decode_uper$handle() {
        return ANY_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ANY_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ANY_decode_uper$address() {
        return ANY_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ANY_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ANY_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ANY_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ANY_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ANY_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ANY_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ANY_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor ANY_encode_uper$descriptor() {
        return ANY_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ANY_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle ANY_encode_uper$handle() {
        return ANY_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ANY_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ANY_encode_uper$address() {
        return ANY_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ANY_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ANY_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ANY_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ANY_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ANY_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ANY_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ANY_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor ANY_decode_aper$descriptor() {
        return ANY_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ANY_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle ANY_decode_aper$handle() {
        return ANY_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ANY_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ANY_decode_aper$address() {
        return ANY_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ANY_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ANY_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ANY_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ANY_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ANY_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ANY_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ANY_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor ANY_encode_aper$descriptor() {
        return ANY_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ANY_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle ANY_encode_aper$handle() {
        return ANY_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ANY_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ANY_encode_aper$address() {
        return ANY_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ANY_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ANY_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ANY_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ANY_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ANY_fromType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ANY_fromType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ANY_fromType(ANY_t *, asn_TYPE_descriptor_t *td, void *struct_ptr)
     * }
     */
    public static FunctionDescriptor ANY_fromType$descriptor() {
        return ANY_fromType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ANY_fromType(ANY_t *, asn_TYPE_descriptor_t *td, void *struct_ptr)
     * }
     */
    public static MethodHandle ANY_fromType$handle() {
        return ANY_fromType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ANY_fromType(ANY_t *, asn_TYPE_descriptor_t *td, void *struct_ptr)
     * }
     */
    public static MemorySegment ANY_fromType$address() {
        return ANY_fromType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ANY_fromType(ANY_t *, asn_TYPE_descriptor_t *td, void *struct_ptr)
     * }
     */
    public static int ANY_fromType(MemorySegment x0, MemorySegment td, MemorySegment struct_ptr) {
        var mh$ = ANY_fromType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ANY_fromType", x0, td, struct_ptr);
            }
            return (int)mh$.invokeExact(x0, td, struct_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ANY_new_fromType {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ANY_new_fromType");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ANY_t *ANY_new_fromType(asn_TYPE_descriptor_t *td, void *struct_ptr)
     * }
     */
    public static FunctionDescriptor ANY_new_fromType$descriptor() {
        return ANY_new_fromType.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ANY_t *ANY_new_fromType(asn_TYPE_descriptor_t *td, void *struct_ptr)
     * }
     */
    public static MethodHandle ANY_new_fromType$handle() {
        return ANY_new_fromType.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ANY_t *ANY_new_fromType(asn_TYPE_descriptor_t *td, void *struct_ptr)
     * }
     */
    public static MemorySegment ANY_new_fromType$address() {
        return ANY_new_fromType.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ANY_t *ANY_new_fromType(asn_TYPE_descriptor_t *td, void *struct_ptr)
     * }
     */
    public static MemorySegment ANY_new_fromType(MemorySegment td, MemorySegment struct_ptr) {
        var mh$ = ANY_new_fromType.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ANY_new_fromType", td, struct_ptr);
            }
            return (MemorySegment)mh$.invokeExact(td, struct_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ANY_fromType_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ANY_fromType_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ANY_fromType_aper(ANY_t *st, asn_TYPE_descriptor_t *td, void *sptr)
     * }
     */
    public static FunctionDescriptor ANY_fromType_aper$descriptor() {
        return ANY_fromType_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ANY_fromType_aper(ANY_t *st, asn_TYPE_descriptor_t *td, void *sptr)
     * }
     */
    public static MethodHandle ANY_fromType_aper$handle() {
        return ANY_fromType_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ANY_fromType_aper(ANY_t *st, asn_TYPE_descriptor_t *td, void *sptr)
     * }
     */
    public static MemorySegment ANY_fromType_aper$address() {
        return ANY_fromType_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ANY_fromType_aper(ANY_t *st, asn_TYPE_descriptor_t *td, void *sptr)
     * }
     */
    public static int ANY_fromType_aper(MemorySegment st, MemorySegment td, MemorySegment sptr) {
        var mh$ = ANY_fromType_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ANY_fromType_aper", st, td, sptr);
            }
            return (int)mh$.invokeExact(st, td, sptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ANY_new_fromType_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ANY_new_fromType_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * ANY_t *ANY_new_fromType_aper(asn_TYPE_descriptor_t *td, void *sptr)
     * }
     */
    public static FunctionDescriptor ANY_new_fromType_aper$descriptor() {
        return ANY_new_fromType_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * ANY_t *ANY_new_fromType_aper(asn_TYPE_descriptor_t *td, void *sptr)
     * }
     */
    public static MethodHandle ANY_new_fromType_aper$handle() {
        return ANY_new_fromType_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * ANY_t *ANY_new_fromType_aper(asn_TYPE_descriptor_t *td, void *sptr)
     * }
     */
    public static MemorySegment ANY_new_fromType_aper$address() {
        return ANY_new_fromType_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * ANY_t *ANY_new_fromType_aper(asn_TYPE_descriptor_t *td, void *sptr)
     * }
     */
    public static MemorySegment ANY_new_fromType_aper(MemorySegment td, MemorySegment sptr) {
        var mh$ = ANY_new_fromType_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ANY_new_fromType_aper", td, sptr);
            }
            return (MemorySegment)mh$.invokeExact(td, sptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ANY_to_type {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ANY_to_type");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ANY_to_type(ANY_t *, asn_TYPE_descriptor_t *td, void **struct_ptr)
     * }
     */
    public static FunctionDescriptor ANY_to_type$descriptor() {
        return ANY_to_type.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ANY_to_type(ANY_t *, asn_TYPE_descriptor_t *td, void **struct_ptr)
     * }
     */
    public static MethodHandle ANY_to_type$handle() {
        return ANY_to_type.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ANY_to_type(ANY_t *, asn_TYPE_descriptor_t *td, void **struct_ptr)
     * }
     */
    public static MemorySegment ANY_to_type$address() {
        return ANY_to_type.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ANY_to_type(ANY_t *, asn_TYPE_descriptor_t *td, void **struct_ptr)
     * }
     */
    public static int ANY_to_type(MemorySegment x0, MemorySegment td, MemorySegment struct_ptr) {
        var mh$ = ANY_to_type.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ANY_to_type", x0, td, struct_ptr);
            }
            return (int)mh$.invokeExact(x0, td, struct_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ANY_to_type_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ANY_to_type_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ANY_to_type_aper(ANY_t *, asn_TYPE_descriptor_t *td, void **struct_ptr)
     * }
     */
    public static FunctionDescriptor ANY_to_type_aper$descriptor() {
        return ANY_to_type_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ANY_to_type_aper(ANY_t *, asn_TYPE_descriptor_t *td, void **struct_ptr)
     * }
     */
    public static MethodHandle ANY_to_type_aper$handle() {
        return ANY_to_type_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ANY_to_type_aper(ANY_t *, asn_TYPE_descriptor_t *td, void **struct_ptr)
     * }
     */
    public static MemorySegment ANY_to_type_aper$address() {
        return ANY_to_type_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ANY_to_type_aper(ANY_t *, asn_TYPE_descriptor_t *td, void **struct_ptr)
     * }
     */
    public static int ANY_to_type_aper(MemorySegment x0, MemorySegment td, MemorySegment struct_ptr) {
        var mh$ = ANY_to_type_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ANY_to_type_aper", x0, td, struct_ptr);
            }
            return (int)mh$.invokeExact(x0, td, struct_ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int aioc__undefined = (int)0L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.aioc__undefined = 0
     * }
     */
    public static int aioc__undefined() {
        return aioc__undefined;
    }
    private static final int aioc__value = (int)1L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.aioc__value = 1
     * }
     */
    public static int aioc__value() {
        return aioc__value;
    }
    private static final int aioc__type = (int)2L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.aioc__type = 2
     * }
     */
    public static int aioc__type() {
        return aioc__type;
    }
    private static final int aioc__open_type = (int)3L;
    /**
     * {@snippet lang=c :
     * enum <anonymous>.aioc__open_type = 3
     * }
     */
    public static int aioc__open_type() {
        return aioc__open_type;
    }
    /**
     * {@snippet lang=c :
     * typedef long Common_MsgCount_t
     * }
     */
    public static final OfLong Common_MsgCount_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_Common_MsgCount_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_Common_MsgCount_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Common_MsgCount_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_Common_MsgCount_constr_1$layout() {
        return asn_PER_type_Common_MsgCount_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Common_MsgCount_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_Common_MsgCount_constr_1() {
        return asn_PER_type_Common_MsgCount_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Common_MsgCount_constr_1
     * }
     */
    public static void asn_PER_type_Common_MsgCount_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_Common_MsgCount_constr_1$constants.SEGMENT, 0L, asn_PER_type_Common_MsgCount_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_Common_MsgCount$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_Common_MsgCount").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Common_MsgCount
     * }
     */
    public static GroupLayout asn_DEF_Common_MsgCount$layout() {
        return asn_DEF_Common_MsgCount$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Common_MsgCount
     * }
     */
    public static MemorySegment asn_DEF_Common_MsgCount() {
        return asn_DEF_Common_MsgCount$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Common_MsgCount
     * }
     */
    public static void asn_DEF_Common_MsgCount(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_Common_MsgCount$constants.SEGMENT, 0L, asn_DEF_Common_MsgCount$constants.LAYOUT.byteSize());
    }

    private static class Common_MsgCount_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_MsgCount_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Common_MsgCount_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor Common_MsgCount_free$descriptor() {
        return Common_MsgCount_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Common_MsgCount_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle Common_MsgCount_free$handle() {
        return Common_MsgCount_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Common_MsgCount_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment Common_MsgCount_free$address() {
        return Common_MsgCount_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Common_MsgCount_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void Common_MsgCount_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = Common_MsgCount_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_MsgCount_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_MsgCount_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_MsgCount_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Common_MsgCount_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_MsgCount_print$descriptor() {
        return Common_MsgCount_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Common_MsgCount_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Common_MsgCount_print$handle() {
        return Common_MsgCount_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Common_MsgCount_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_MsgCount_print$address() {
        return Common_MsgCount_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Common_MsgCount_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int Common_MsgCount_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Common_MsgCount_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_MsgCount_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_MsgCount_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_MsgCount_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Common_MsgCount_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_MsgCount_constraint$descriptor() {
        return Common_MsgCount_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Common_MsgCount_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle Common_MsgCount_constraint$handle() {
        return Common_MsgCount_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Common_MsgCount_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment Common_MsgCount_constraint$address() {
        return Common_MsgCount_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Common_MsgCount_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int Common_MsgCount_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Common_MsgCount_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_MsgCount_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_MsgCount_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_MsgCount_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_MsgCount_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor Common_MsgCount_decode_ber$descriptor() {
        return Common_MsgCount_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_MsgCount_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle Common_MsgCount_decode_ber$handle() {
        return Common_MsgCount_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_MsgCount_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Common_MsgCount_decode_ber$address() {
        return Common_MsgCount_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Common_MsgCount_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Common_MsgCount_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = Common_MsgCount_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_MsgCount_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_MsgCount_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_MsgCount_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_MsgCount_encode_der$descriptor() {
        return Common_MsgCount_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Common_MsgCount_encode_der$handle() {
        return Common_MsgCount_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_MsgCount_encode_der$address() {
        return Common_MsgCount_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_MsgCount_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Common_MsgCount_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_MsgCount_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_MsgCount_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_MsgCount_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_MsgCount_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Common_MsgCount_decode_xer$descriptor() {
        return Common_MsgCount_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_MsgCount_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle Common_MsgCount_decode_xer$handle() {
        return Common_MsgCount_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_MsgCount_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Common_MsgCount_decode_xer$address() {
        return Common_MsgCount_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Common_MsgCount_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Common_MsgCount_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Common_MsgCount_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_MsgCount_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_MsgCount_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_MsgCount_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_MsgCount_encode_xer$descriptor() {
        return Common_MsgCount_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Common_MsgCount_encode_xer$handle() {
        return Common_MsgCount_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_MsgCount_encode_xer$address() {
        return Common_MsgCount_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_MsgCount_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Common_MsgCount_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_MsgCount_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_MsgCount_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_MsgCount_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_MsgCount_encode_jer$descriptor() {
        return Common_MsgCount_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Common_MsgCount_encode_jer$handle() {
        return Common_MsgCount_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_MsgCount_encode_jer$address() {
        return Common_MsgCount_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_MsgCount_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = Common_MsgCount_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_MsgCount_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_MsgCount_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_MsgCount_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_MsgCount_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Common_MsgCount_decode_oer$descriptor() {
        return Common_MsgCount_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_MsgCount_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle Common_MsgCount_decode_oer$handle() {
        return Common_MsgCount_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_MsgCount_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Common_MsgCount_decode_oer$address() {
        return Common_MsgCount_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Common_MsgCount_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Common_MsgCount_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Common_MsgCount_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_MsgCount_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_MsgCount_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_MsgCount_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_MsgCount_encode_oer$descriptor() {
        return Common_MsgCount_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Common_MsgCount_encode_oer$handle() {
        return Common_MsgCount_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_MsgCount_encode_oer$address() {
        return Common_MsgCount_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_MsgCount_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Common_MsgCount_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_MsgCount_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_MsgCount_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_MsgCount_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_MsgCount_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Common_MsgCount_decode_uper$descriptor() {
        return Common_MsgCount_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_MsgCount_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Common_MsgCount_decode_uper$handle() {
        return Common_MsgCount_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_MsgCount_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Common_MsgCount_decode_uper$address() {
        return Common_MsgCount_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Common_MsgCount_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Common_MsgCount_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Common_MsgCount_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_MsgCount_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_MsgCount_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_MsgCount_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Common_MsgCount_encode_uper$descriptor() {
        return Common_MsgCount_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Common_MsgCount_encode_uper$handle() {
        return Common_MsgCount_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Common_MsgCount_encode_uper$address() {
        return Common_MsgCount_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Common_MsgCount_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Common_MsgCount_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_MsgCount_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_MsgCount_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_MsgCount_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_MsgCount_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Common_MsgCount_decode_aper$descriptor() {
        return Common_MsgCount_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_MsgCount_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Common_MsgCount_decode_aper$handle() {
        return Common_MsgCount_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_MsgCount_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Common_MsgCount_decode_aper$address() {
        return Common_MsgCount_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Common_MsgCount_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Common_MsgCount_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Common_MsgCount_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_MsgCount_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_MsgCount_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_MsgCount_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Common_MsgCount_encode_aper$descriptor() {
        return Common_MsgCount_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Common_MsgCount_encode_aper$handle() {
        return Common_MsgCount_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Common_MsgCount_encode_aper$address() {
        return Common_MsgCount_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_MsgCount_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Common_MsgCount_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Common_MsgCount_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_MsgCount_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_PER_type_TemporaryID_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_TemporaryID_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TemporaryID_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_TemporaryID_constr_1$layout() {
        return asn_PER_type_TemporaryID_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TemporaryID_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_TemporaryID_constr_1() {
        return asn_PER_type_TemporaryID_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TemporaryID_constr_1
     * }
     */
    public static void asn_PER_type_TemporaryID_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_TemporaryID_constr_1$constants.SEGMENT, 0L, asn_PER_type_TemporaryID_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_TemporaryID$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_TemporaryID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TemporaryID
     * }
     */
    public static GroupLayout asn_DEF_TemporaryID$layout() {
        return asn_DEF_TemporaryID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TemporaryID
     * }
     */
    public static MemorySegment asn_DEF_TemporaryID() {
        return asn_DEF_TemporaryID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TemporaryID
     * }
     */
    public static void asn_DEF_TemporaryID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_TemporaryID$constants.SEGMENT, 0L, asn_DEF_TemporaryID$constants.LAYOUT.byteSize());
    }

    private static class TemporaryID_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TemporaryID_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void TemporaryID_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor TemporaryID_free$descriptor() {
        return TemporaryID_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void TemporaryID_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle TemporaryID_free$handle() {
        return TemporaryID_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void TemporaryID_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment TemporaryID_free$address() {
        return TemporaryID_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void TemporaryID_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void TemporaryID_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = TemporaryID_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TemporaryID_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TemporaryID_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TemporaryID_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TemporaryID_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TemporaryID_print$descriptor() {
        return TemporaryID_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TemporaryID_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TemporaryID_print$handle() {
        return TemporaryID_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TemporaryID_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TemporaryID_print$address() {
        return TemporaryID_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TemporaryID_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int TemporaryID_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TemporaryID_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TemporaryID_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TemporaryID_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TemporaryID_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TemporaryID_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor TemporaryID_constraint$descriptor() {
        return TemporaryID_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TemporaryID_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle TemporaryID_constraint$handle() {
        return TemporaryID_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TemporaryID_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment TemporaryID_constraint$address() {
        return TemporaryID_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TemporaryID_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int TemporaryID_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TemporaryID_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TemporaryID_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TemporaryID_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TemporaryID_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TemporaryID_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor TemporaryID_decode_ber$descriptor() {
        return TemporaryID_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TemporaryID_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle TemporaryID_decode_ber$handle() {
        return TemporaryID_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TemporaryID_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment TemporaryID_decode_ber$address() {
        return TemporaryID_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TemporaryID_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment TemporaryID_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = TemporaryID_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TemporaryID_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TemporaryID_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TemporaryID_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TemporaryID_encode_der$descriptor() {
        return TemporaryID_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TemporaryID_encode_der$handle() {
        return TemporaryID_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TemporaryID_encode_der$address() {
        return TemporaryID_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TemporaryID_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = TemporaryID_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TemporaryID_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TemporaryID_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TemporaryID_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TemporaryID_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor TemporaryID_decode_xer$descriptor() {
        return TemporaryID_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TemporaryID_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle TemporaryID_decode_xer$handle() {
        return TemporaryID_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TemporaryID_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment TemporaryID_decode_xer$address() {
        return TemporaryID_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TemporaryID_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment TemporaryID_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = TemporaryID_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TemporaryID_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TemporaryID_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TemporaryID_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TemporaryID_encode_xer$descriptor() {
        return TemporaryID_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TemporaryID_encode_xer$handle() {
        return TemporaryID_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TemporaryID_encode_xer$address() {
        return TemporaryID_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TemporaryID_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = TemporaryID_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TemporaryID_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TemporaryID_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TemporaryID_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TemporaryID_encode_jer$descriptor() {
        return TemporaryID_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TemporaryID_encode_jer$handle() {
        return TemporaryID_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TemporaryID_encode_jer$address() {
        return TemporaryID_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TemporaryID_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = TemporaryID_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TemporaryID_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TemporaryID_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TemporaryID_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TemporaryID_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor TemporaryID_decode_oer$descriptor() {
        return TemporaryID_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TemporaryID_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle TemporaryID_decode_oer$handle() {
        return TemporaryID_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TemporaryID_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment TemporaryID_decode_oer$address() {
        return TemporaryID_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TemporaryID_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment TemporaryID_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = TemporaryID_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TemporaryID_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TemporaryID_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TemporaryID_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TemporaryID_encode_oer$descriptor() {
        return TemporaryID_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TemporaryID_encode_oer$handle() {
        return TemporaryID_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TemporaryID_encode_oer$address() {
        return TemporaryID_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TemporaryID_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TemporaryID_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TemporaryID_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TemporaryID_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TemporaryID_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TemporaryID_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor TemporaryID_decode_uper$descriptor() {
        return TemporaryID_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TemporaryID_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle TemporaryID_decode_uper$handle() {
        return TemporaryID_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TemporaryID_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TemporaryID_decode_uper$address() {
        return TemporaryID_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TemporaryID_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TemporaryID_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TemporaryID_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TemporaryID_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TemporaryID_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TemporaryID_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor TemporaryID_encode_uper$descriptor() {
        return TemporaryID_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle TemporaryID_encode_uper$handle() {
        return TemporaryID_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TemporaryID_encode_uper$address() {
        return TemporaryID_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TemporaryID_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TemporaryID_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TemporaryID_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TemporaryID_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TemporaryID_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TemporaryID_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor TemporaryID_decode_aper$descriptor() {
        return TemporaryID_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TemporaryID_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle TemporaryID_decode_aper$handle() {
        return TemporaryID_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TemporaryID_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TemporaryID_decode_aper$address() {
        return TemporaryID_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TemporaryID_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TemporaryID_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TemporaryID_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TemporaryID_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TemporaryID_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TemporaryID_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor TemporaryID_encode_aper$descriptor() {
        return TemporaryID_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle TemporaryID_encode_aper$handle() {
        return TemporaryID_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TemporaryID_encode_aper$address() {
        return TemporaryID_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TemporaryID_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TemporaryID_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TemporaryID_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TemporaryID_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long DSecond_t
     * }
     */
    public static final OfLong DSecond_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_DSecond_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_DSecond_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DSecond_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_DSecond_constr_1$layout() {
        return asn_PER_type_DSecond_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DSecond_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_DSecond_constr_1() {
        return asn_PER_type_DSecond_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DSecond_constr_1
     * }
     */
    public static void asn_PER_type_DSecond_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_DSecond_constr_1$constants.SEGMENT, 0L, asn_PER_type_DSecond_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_DSecond$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_DSecond").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DSecond
     * }
     */
    public static GroupLayout asn_DEF_DSecond$layout() {
        return asn_DEF_DSecond$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DSecond
     * }
     */
    public static MemorySegment asn_DEF_DSecond() {
        return asn_DEF_DSecond$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DSecond
     * }
     */
    public static void asn_DEF_DSecond(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_DSecond$constants.SEGMENT, 0L, asn_DEF_DSecond$constants.LAYOUT.byteSize());
    }

    private static class DSecond_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSecond_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DSecond_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor DSecond_free$descriptor() {
        return DSecond_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DSecond_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle DSecond_free$handle() {
        return DSecond_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DSecond_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment DSecond_free$address() {
        return DSecond_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DSecond_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void DSecond_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = DSecond_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSecond_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSecond_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSecond_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DSecond_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DSecond_print$descriptor() {
        return DSecond_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DSecond_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DSecond_print$handle() {
        return DSecond_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DSecond_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DSecond_print$address() {
        return DSecond_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DSecond_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int DSecond_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DSecond_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSecond_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSecond_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSecond_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DSecond_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor DSecond_constraint$descriptor() {
        return DSecond_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DSecond_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle DSecond_constraint$handle() {
        return DSecond_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DSecond_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment DSecond_constraint$address() {
        return DSecond_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DSecond_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int DSecond_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DSecond_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSecond_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSecond_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSecond_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSecond_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor DSecond_decode_ber$descriptor() {
        return DSecond_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSecond_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle DSecond_decode_ber$handle() {
        return DSecond_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSecond_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DSecond_decode_ber$address() {
        return DSecond_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DSecond_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DSecond_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = DSecond_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSecond_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSecond_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSecond_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DSecond_encode_der$descriptor() {
        return DSecond_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DSecond_encode_der$handle() {
        return DSecond_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DSecond_encode_der$address() {
        return DSecond_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DSecond_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DSecond_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSecond_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSecond_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSecond_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSecond_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DSecond_decode_xer$descriptor() {
        return DSecond_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSecond_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle DSecond_decode_xer$handle() {
        return DSecond_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSecond_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DSecond_decode_xer$address() {
        return DSecond_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DSecond_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DSecond_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DSecond_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSecond_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSecond_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSecond_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DSecond_encode_xer$descriptor() {
        return DSecond_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DSecond_encode_xer$handle() {
        return DSecond_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DSecond_encode_xer$address() {
        return DSecond_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DSecond_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DSecond_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSecond_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSecond_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSecond_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DSecond_encode_jer$descriptor() {
        return DSecond_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DSecond_encode_jer$handle() {
        return DSecond_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DSecond_encode_jer$address() {
        return DSecond_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DSecond_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = DSecond_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSecond_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSecond_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSecond_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSecond_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DSecond_decode_oer$descriptor() {
        return DSecond_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSecond_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle DSecond_decode_oer$handle() {
        return DSecond_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSecond_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DSecond_decode_oer$address() {
        return DSecond_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DSecond_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DSecond_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DSecond_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSecond_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

