// Generated by jextract

package j2735_2024_MessageFrame;

import java.lang.invoke.*;
import java.lang.foreign.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class MessageFrame_h_4 extends MessageFrame_h_5 {

    MessageFrame_h_4() {
        // Should not be called directly
    }

    private static class OffsetLL_B16_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B16_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B16_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B16_encode_oer$descriptor() {
        return OffsetLL_B16_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B16_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OffsetLL_B16_encode_oer$handle() {
        return OffsetLL_B16_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B16_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B16_encode_oer$address() {
        return OffsetLL_B16_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B16_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B16_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = OffsetLL_B16_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B16_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B16_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B16_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B16_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B16_decode_uper$descriptor() {
        return OffsetLL_B16_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B16_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle OffsetLL_B16_decode_uper$handle() {
        return OffsetLL_B16_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B16_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment OffsetLL_B16_decode_uper$address() {
        return OffsetLL_B16_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B16_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment OffsetLL_B16_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = OffsetLL_B16_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B16_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B16_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B16_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B16_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B16_encode_uper$descriptor() {
        return OffsetLL_B16_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B16_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle OffsetLL_B16_encode_uper$handle() {
        return OffsetLL_B16_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B16_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment OffsetLL_B16_encode_uper$address() {
        return OffsetLL_B16_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B16_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment OffsetLL_B16_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = OffsetLL_B16_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B16_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B16_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B16_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B16_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B16_decode_aper$descriptor() {
        return OffsetLL_B16_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B16_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle OffsetLL_B16_decode_aper$handle() {
        return OffsetLL_B16_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B16_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment OffsetLL_B16_decode_aper$address() {
        return OffsetLL_B16_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B16_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment OffsetLL_B16_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = OffsetLL_B16_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B16_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B16_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B16_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B16_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B16_encode_aper$descriptor() {
        return OffsetLL_B16_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B16_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle OffsetLL_B16_encode_aper$handle() {
        return OffsetLL_B16_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B16_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment OffsetLL_B16_encode_aper$address() {
        return OffsetLL_B16_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B16_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment OffsetLL_B16_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = OffsetLL_B16_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B16_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_Node_LL_32B$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_Node_LL_32B").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Node_LL_32B
     * }
     */
    public static GroupLayout asn_DEF_Node_LL_32B$layout() {
        return asn_DEF_Node_LL_32B$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Node_LL_32B
     * }
     */
    public static MemorySegment asn_DEF_Node_LL_32B() {
        return asn_DEF_Node_LL_32B$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Node_LL_32B
     * }
     */
    public static void asn_DEF_Node_LL_32B(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_Node_LL_32B$constants.SEGMENT, 0L, asn_DEF_Node_LL_32B$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_Node_LL_32B_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_Node_LL_32B_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Node_LL_32B_specs_1
     * }
     */
    public static GroupLayout asn_SPC_Node_LL_32B_specs_1$layout() {
        return asn_SPC_Node_LL_32B_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Node_LL_32B_specs_1
     * }
     */
    public static MemorySegment asn_SPC_Node_LL_32B_specs_1() {
        return asn_SPC_Node_LL_32B_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Node_LL_32B_specs_1
     * }
     */
    public static void asn_SPC_Node_LL_32B_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_Node_LL_32B_specs_1$constants.SEGMENT, 0L, asn_SPC_Node_LL_32B_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_Node_LL_32B_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_Node_LL_32B_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_32B_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_Node_LL_32B_1$layout() {
        return asn_MBR_Node_LL_32B_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_32B_1[2]
     * }
     */
    public static long[] asn_MBR_Node_LL_32B_1$dimensions() {
        return asn_MBR_Node_LL_32B_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_32B_1[2]
     * }
     */
    public static MemorySegment asn_MBR_Node_LL_32B_1() {
        return asn_MBR_Node_LL_32B_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_32B_1[2]
     * }
     */
    public static void asn_MBR_Node_LL_32B_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_Node_LL_32B_1$constants.SEGMENT, 0L, asn_MBR_Node_LL_32B_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_32B_1[2]
     * }
     */
    public static MemorySegment asn_MBR_Node_LL_32B_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_Node_LL_32B_1$constants.HANDLE.invokeExact(asn_MBR_Node_LL_32B_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_32B_1[2]
     * }
     */
    public static void asn_MBR_Node_LL_32B_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_Node_LL_32B_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_Node_LL_36B$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_Node_LL_36B").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Node_LL_36B
     * }
     */
    public static GroupLayout asn_DEF_Node_LL_36B$layout() {
        return asn_DEF_Node_LL_36B$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Node_LL_36B
     * }
     */
    public static MemorySegment asn_DEF_Node_LL_36B() {
        return asn_DEF_Node_LL_36B$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Node_LL_36B
     * }
     */
    public static void asn_DEF_Node_LL_36B(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_Node_LL_36B$constants.SEGMENT, 0L, asn_DEF_Node_LL_36B$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_Node_LL_36B_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_Node_LL_36B_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Node_LL_36B_specs_1
     * }
     */
    public static GroupLayout asn_SPC_Node_LL_36B_specs_1$layout() {
        return asn_SPC_Node_LL_36B_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Node_LL_36B_specs_1
     * }
     */
    public static MemorySegment asn_SPC_Node_LL_36B_specs_1() {
        return asn_SPC_Node_LL_36B_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Node_LL_36B_specs_1
     * }
     */
    public static void asn_SPC_Node_LL_36B_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_Node_LL_36B_specs_1$constants.SEGMENT, 0L, asn_SPC_Node_LL_36B_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_Node_LL_36B_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_Node_LL_36B_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_36B_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_Node_LL_36B_1$layout() {
        return asn_MBR_Node_LL_36B_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_36B_1[2]
     * }
     */
    public static long[] asn_MBR_Node_LL_36B_1$dimensions() {
        return asn_MBR_Node_LL_36B_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_36B_1[2]
     * }
     */
    public static MemorySegment asn_MBR_Node_LL_36B_1() {
        return asn_MBR_Node_LL_36B_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_36B_1[2]
     * }
     */
    public static void asn_MBR_Node_LL_36B_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_Node_LL_36B_1$constants.SEGMENT, 0L, asn_MBR_Node_LL_36B_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_36B_1[2]
     * }
     */
    public static MemorySegment asn_MBR_Node_LL_36B_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_Node_LL_36B_1$constants.HANDLE.invokeExact(asn_MBR_Node_LL_36B_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_36B_1[2]
     * }
     */
    public static void asn_MBR_Node_LL_36B_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_Node_LL_36B_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef long OffsetLL_B22_t
     * }
     */
    public static final OfLong OffsetLL_B22_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_OffsetLL_B22_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_OffsetLL_B22_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_OffsetLL_B22_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_OffsetLL_B22_constr_1$layout() {
        return asn_PER_type_OffsetLL_B22_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_OffsetLL_B22_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_OffsetLL_B22_constr_1() {
        return asn_PER_type_OffsetLL_B22_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_OffsetLL_B22_constr_1
     * }
     */
    public static void asn_PER_type_OffsetLL_B22_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_OffsetLL_B22_constr_1$constants.SEGMENT, 0L, asn_PER_type_OffsetLL_B22_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_OffsetLL_B22$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_OffsetLL_B22").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_OffsetLL_B22
     * }
     */
    public static GroupLayout asn_DEF_OffsetLL_B22$layout() {
        return asn_DEF_OffsetLL_B22$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_OffsetLL_B22
     * }
     */
    public static MemorySegment asn_DEF_OffsetLL_B22() {
        return asn_DEF_OffsetLL_B22$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_OffsetLL_B22
     * }
     */
    public static void asn_DEF_OffsetLL_B22(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_OffsetLL_B22$constants.SEGMENT, 0L, asn_DEF_OffsetLL_B22$constants.LAYOUT.byteSize());
    }

    private static class OffsetLL_B22_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B22_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void OffsetLL_B22_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor OffsetLL_B22_free$descriptor() {
        return OffsetLL_B22_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void OffsetLL_B22_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle OffsetLL_B22_free$handle() {
        return OffsetLL_B22_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void OffsetLL_B22_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment OffsetLL_B22_free$address() {
        return OffsetLL_B22_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void OffsetLL_B22_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void OffsetLL_B22_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = OffsetLL_B22_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B22_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B22_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B22_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int OffsetLL_B22_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B22_print$descriptor() {
        return OffsetLL_B22_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int OffsetLL_B22_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OffsetLL_B22_print$handle() {
        return OffsetLL_B22_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int OffsetLL_B22_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B22_print$address() {
        return OffsetLL_B22_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int OffsetLL_B22_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int OffsetLL_B22_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = OffsetLL_B22_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B22_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B22_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B22_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int OffsetLL_B22_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B22_constraint$descriptor() {
        return OffsetLL_B22_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int OffsetLL_B22_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle OffsetLL_B22_constraint$handle() {
        return OffsetLL_B22_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int OffsetLL_B22_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B22_constraint$address() {
        return OffsetLL_B22_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int OffsetLL_B22_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int OffsetLL_B22_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = OffsetLL_B22_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B22_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B22_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B22_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B22_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor OffsetLL_B22_decode_ber$descriptor() {
        return OffsetLL_B22_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B22_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle OffsetLL_B22_decode_ber$handle() {
        return OffsetLL_B22_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B22_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment OffsetLL_B22_decode_ber$address() {
        return OffsetLL_B22_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B22_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment OffsetLL_B22_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = OffsetLL_B22_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B22_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B22_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B22_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B22_encode_der$descriptor() {
        return OffsetLL_B22_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OffsetLL_B22_encode_der$handle() {
        return OffsetLL_B22_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B22_encode_der$address() {
        return OffsetLL_B22_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B22_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = OffsetLL_B22_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B22_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B22_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B22_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B22_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor OffsetLL_B22_decode_xer$descriptor() {
        return OffsetLL_B22_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B22_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle OffsetLL_B22_decode_xer$handle() {
        return OffsetLL_B22_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B22_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment OffsetLL_B22_decode_xer$address() {
        return OffsetLL_B22_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B22_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment OffsetLL_B22_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = OffsetLL_B22_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B22_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B22_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B22_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B22_encode_xer$descriptor() {
        return OffsetLL_B22_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OffsetLL_B22_encode_xer$handle() {
        return OffsetLL_B22_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B22_encode_xer$address() {
        return OffsetLL_B22_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B22_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = OffsetLL_B22_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B22_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B22_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B22_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B22_encode_jer$descriptor() {
        return OffsetLL_B22_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OffsetLL_B22_encode_jer$handle() {
        return OffsetLL_B22_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B22_encode_jer$address() {
        return OffsetLL_B22_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B22_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = OffsetLL_B22_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B22_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B22_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B22_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B22_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor OffsetLL_B22_decode_oer$descriptor() {
        return OffsetLL_B22_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B22_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle OffsetLL_B22_decode_oer$handle() {
        return OffsetLL_B22_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B22_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment OffsetLL_B22_decode_oer$address() {
        return OffsetLL_B22_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B22_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment OffsetLL_B22_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = OffsetLL_B22_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B22_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B22_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B22_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B22_encode_oer$descriptor() {
        return OffsetLL_B22_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OffsetLL_B22_encode_oer$handle() {
        return OffsetLL_B22_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B22_encode_oer$address() {
        return OffsetLL_B22_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B22_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = OffsetLL_B22_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B22_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B22_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B22_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B22_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B22_decode_uper$descriptor() {
        return OffsetLL_B22_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B22_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle OffsetLL_B22_decode_uper$handle() {
        return OffsetLL_B22_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B22_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment OffsetLL_B22_decode_uper$address() {
        return OffsetLL_B22_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B22_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment OffsetLL_B22_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = OffsetLL_B22_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B22_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B22_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B22_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B22_encode_uper$descriptor() {
        return OffsetLL_B22_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle OffsetLL_B22_encode_uper$handle() {
        return OffsetLL_B22_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment OffsetLL_B22_encode_uper$address() {
        return OffsetLL_B22_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment OffsetLL_B22_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = OffsetLL_B22_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B22_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B22_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B22_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B22_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B22_decode_aper$descriptor() {
        return OffsetLL_B22_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B22_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle OffsetLL_B22_decode_aper$handle() {
        return OffsetLL_B22_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B22_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment OffsetLL_B22_decode_aper$address() {
        return OffsetLL_B22_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B22_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment OffsetLL_B22_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = OffsetLL_B22_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B22_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B22_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B22_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B22_encode_aper$descriptor() {
        return OffsetLL_B22_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle OffsetLL_B22_encode_aper$handle() {
        return OffsetLL_B22_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment OffsetLL_B22_encode_aper$address() {
        return OffsetLL_B22_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B22_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment OffsetLL_B22_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = OffsetLL_B22_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B22_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_Node_LL_44B$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_Node_LL_44B").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Node_LL_44B
     * }
     */
    public static GroupLayout asn_DEF_Node_LL_44B$layout() {
        return asn_DEF_Node_LL_44B$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Node_LL_44B
     * }
     */
    public static MemorySegment asn_DEF_Node_LL_44B() {
        return asn_DEF_Node_LL_44B$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Node_LL_44B
     * }
     */
    public static void asn_DEF_Node_LL_44B(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_Node_LL_44B$constants.SEGMENT, 0L, asn_DEF_Node_LL_44B$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_Node_LL_44B_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_Node_LL_44B_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Node_LL_44B_specs_1
     * }
     */
    public static GroupLayout asn_SPC_Node_LL_44B_specs_1$layout() {
        return asn_SPC_Node_LL_44B_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Node_LL_44B_specs_1
     * }
     */
    public static MemorySegment asn_SPC_Node_LL_44B_specs_1() {
        return asn_SPC_Node_LL_44B_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Node_LL_44B_specs_1
     * }
     */
    public static void asn_SPC_Node_LL_44B_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_Node_LL_44B_specs_1$constants.SEGMENT, 0L, asn_SPC_Node_LL_44B_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_Node_LL_44B_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_Node_LL_44B_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_44B_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_Node_LL_44B_1$layout() {
        return asn_MBR_Node_LL_44B_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_44B_1[2]
     * }
     */
    public static long[] asn_MBR_Node_LL_44B_1$dimensions() {
        return asn_MBR_Node_LL_44B_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_44B_1[2]
     * }
     */
    public static MemorySegment asn_MBR_Node_LL_44B_1() {
        return asn_MBR_Node_LL_44B_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_44B_1[2]
     * }
     */
    public static void asn_MBR_Node_LL_44B_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_Node_LL_44B_1$constants.SEGMENT, 0L, asn_MBR_Node_LL_44B_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_44B_1[2]
     * }
     */
    public static MemorySegment asn_MBR_Node_LL_44B_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_Node_LL_44B_1$constants.HANDLE.invokeExact(asn_MBR_Node_LL_44B_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_44B_1[2]
     * }
     */
    public static void asn_MBR_Node_LL_44B_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_Node_LL_44B_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef long OffsetLL_B24_t
     * }
     */
    public static final OfLong OffsetLL_B24_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_OffsetLL_B24_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_OffsetLL_B24_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_OffsetLL_B24_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_OffsetLL_B24_constr_1$layout() {
        return asn_PER_type_OffsetLL_B24_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_OffsetLL_B24_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_OffsetLL_B24_constr_1() {
        return asn_PER_type_OffsetLL_B24_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_OffsetLL_B24_constr_1
     * }
     */
    public static void asn_PER_type_OffsetLL_B24_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_OffsetLL_B24_constr_1$constants.SEGMENT, 0L, asn_PER_type_OffsetLL_B24_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_OffsetLL_B24$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_OffsetLL_B24").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_OffsetLL_B24
     * }
     */
    public static GroupLayout asn_DEF_OffsetLL_B24$layout() {
        return asn_DEF_OffsetLL_B24$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_OffsetLL_B24
     * }
     */
    public static MemorySegment asn_DEF_OffsetLL_B24() {
        return asn_DEF_OffsetLL_B24$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_OffsetLL_B24
     * }
     */
    public static void asn_DEF_OffsetLL_B24(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_OffsetLL_B24$constants.SEGMENT, 0L, asn_DEF_OffsetLL_B24$constants.LAYOUT.byteSize());
    }

    private static class OffsetLL_B24_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B24_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void OffsetLL_B24_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor OffsetLL_B24_free$descriptor() {
        return OffsetLL_B24_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void OffsetLL_B24_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle OffsetLL_B24_free$handle() {
        return OffsetLL_B24_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void OffsetLL_B24_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment OffsetLL_B24_free$address() {
        return OffsetLL_B24_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void OffsetLL_B24_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void OffsetLL_B24_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = OffsetLL_B24_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B24_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B24_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B24_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int OffsetLL_B24_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B24_print$descriptor() {
        return OffsetLL_B24_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int OffsetLL_B24_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OffsetLL_B24_print$handle() {
        return OffsetLL_B24_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int OffsetLL_B24_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B24_print$address() {
        return OffsetLL_B24_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int OffsetLL_B24_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int OffsetLL_B24_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = OffsetLL_B24_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B24_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B24_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B24_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int OffsetLL_B24_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B24_constraint$descriptor() {
        return OffsetLL_B24_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int OffsetLL_B24_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle OffsetLL_B24_constraint$handle() {
        return OffsetLL_B24_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int OffsetLL_B24_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B24_constraint$address() {
        return OffsetLL_B24_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int OffsetLL_B24_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int OffsetLL_B24_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = OffsetLL_B24_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B24_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B24_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B24_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B24_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor OffsetLL_B24_decode_ber$descriptor() {
        return OffsetLL_B24_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B24_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle OffsetLL_B24_decode_ber$handle() {
        return OffsetLL_B24_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B24_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment OffsetLL_B24_decode_ber$address() {
        return OffsetLL_B24_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B24_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment OffsetLL_B24_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = OffsetLL_B24_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B24_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B24_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B24_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B24_encode_der$descriptor() {
        return OffsetLL_B24_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OffsetLL_B24_encode_der$handle() {
        return OffsetLL_B24_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B24_encode_der$address() {
        return OffsetLL_B24_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B24_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = OffsetLL_B24_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B24_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B24_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B24_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B24_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor OffsetLL_B24_decode_xer$descriptor() {
        return OffsetLL_B24_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B24_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle OffsetLL_B24_decode_xer$handle() {
        return OffsetLL_B24_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B24_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment OffsetLL_B24_decode_xer$address() {
        return OffsetLL_B24_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B24_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment OffsetLL_B24_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = OffsetLL_B24_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B24_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B24_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B24_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B24_encode_xer$descriptor() {
        return OffsetLL_B24_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OffsetLL_B24_encode_xer$handle() {
        return OffsetLL_B24_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B24_encode_xer$address() {
        return OffsetLL_B24_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B24_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = OffsetLL_B24_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B24_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B24_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B24_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B24_encode_jer$descriptor() {
        return OffsetLL_B24_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OffsetLL_B24_encode_jer$handle() {
        return OffsetLL_B24_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B24_encode_jer$address() {
        return OffsetLL_B24_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B24_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = OffsetLL_B24_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B24_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B24_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B24_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B24_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor OffsetLL_B24_decode_oer$descriptor() {
        return OffsetLL_B24_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B24_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle OffsetLL_B24_decode_oer$handle() {
        return OffsetLL_B24_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B24_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment OffsetLL_B24_decode_oer$address() {
        return OffsetLL_B24_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B24_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment OffsetLL_B24_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = OffsetLL_B24_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B24_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B24_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B24_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B24_encode_oer$descriptor() {
        return OffsetLL_B24_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OffsetLL_B24_encode_oer$handle() {
        return OffsetLL_B24_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B24_encode_oer$address() {
        return OffsetLL_B24_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B24_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = OffsetLL_B24_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B24_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B24_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B24_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B24_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B24_decode_uper$descriptor() {
        return OffsetLL_B24_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B24_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle OffsetLL_B24_decode_uper$handle() {
        return OffsetLL_B24_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B24_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment OffsetLL_B24_decode_uper$address() {
        return OffsetLL_B24_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B24_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment OffsetLL_B24_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = OffsetLL_B24_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B24_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B24_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B24_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B24_encode_uper$descriptor() {
        return OffsetLL_B24_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle OffsetLL_B24_encode_uper$handle() {
        return OffsetLL_B24_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment OffsetLL_B24_encode_uper$address() {
        return OffsetLL_B24_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment OffsetLL_B24_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = OffsetLL_B24_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B24_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B24_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B24_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B24_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B24_decode_aper$descriptor() {
        return OffsetLL_B24_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B24_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle OffsetLL_B24_decode_aper$handle() {
        return OffsetLL_B24_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B24_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment OffsetLL_B24_decode_aper$address() {
        return OffsetLL_B24_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B24_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment OffsetLL_B24_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = OffsetLL_B24_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B24_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B24_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B24_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B24_encode_aper$descriptor() {
        return OffsetLL_B24_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle OffsetLL_B24_encode_aper$handle() {
        return OffsetLL_B24_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment OffsetLL_B24_encode_aper$address() {
        return OffsetLL_B24_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B24_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment OffsetLL_B24_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = OffsetLL_B24_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B24_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_Node_LL_48B$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_Node_LL_48B").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Node_LL_48B
     * }
     */
    public static GroupLayout asn_DEF_Node_LL_48B$layout() {
        return asn_DEF_Node_LL_48B$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Node_LL_48B
     * }
     */
    public static MemorySegment asn_DEF_Node_LL_48B() {
        return asn_DEF_Node_LL_48B$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Node_LL_48B
     * }
     */
    public static void asn_DEF_Node_LL_48B(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_Node_LL_48B$constants.SEGMENT, 0L, asn_DEF_Node_LL_48B$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_Node_LL_48B_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_Node_LL_48B_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Node_LL_48B_specs_1
     * }
     */
    public static GroupLayout asn_SPC_Node_LL_48B_specs_1$layout() {
        return asn_SPC_Node_LL_48B_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Node_LL_48B_specs_1
     * }
     */
    public static MemorySegment asn_SPC_Node_LL_48B_specs_1() {
        return asn_SPC_Node_LL_48B_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Node_LL_48B_specs_1
     * }
     */
    public static void asn_SPC_Node_LL_48B_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_Node_LL_48B_specs_1$constants.SEGMENT, 0L, asn_SPC_Node_LL_48B_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_Node_LL_48B_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_Node_LL_48B_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_48B_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_Node_LL_48B_1$layout() {
        return asn_MBR_Node_LL_48B_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_48B_1[2]
     * }
     */
    public static long[] asn_MBR_Node_LL_48B_1$dimensions() {
        return asn_MBR_Node_LL_48B_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_48B_1[2]
     * }
     */
    public static MemorySegment asn_MBR_Node_LL_48B_1() {
        return asn_MBR_Node_LL_48B_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_48B_1[2]
     * }
     */
    public static void asn_MBR_Node_LL_48B_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_Node_LL_48B_1$constants.SEGMENT, 0L, asn_MBR_Node_LL_48B_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_48B_1[2]
     * }
     */
    public static MemorySegment asn_MBR_Node_LL_48B_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_Node_LL_48B_1$constants.HANDLE.invokeExact(asn_MBR_Node_LL_48B_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Node_LL_48B_1[2]
     * }
     */
    public static void asn_MBR_Node_LL_48B_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_Node_LL_48B_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    private static final int NodeOffsetPointLL_PR_NOTHING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum NodeOffsetPointLL_PR.NodeOffsetPointLL_PR_NOTHING = 0
     * }
     */
    public static int NodeOffsetPointLL_PR_NOTHING() {
        return NodeOffsetPointLL_PR_NOTHING;
    }
    private static final int NodeOffsetPointLL_PR_node_LL1 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum NodeOffsetPointLL_PR.NodeOffsetPointLL_PR_node_LL1 = 1
     * }
     */
    public static int NodeOffsetPointLL_PR_node_LL1() {
        return NodeOffsetPointLL_PR_node_LL1;
    }
    private static final int NodeOffsetPointLL_PR_node_LL2 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum NodeOffsetPointLL_PR.NodeOffsetPointLL_PR_node_LL2 = 2
     * }
     */
    public static int NodeOffsetPointLL_PR_node_LL2() {
        return NodeOffsetPointLL_PR_node_LL2;
    }
    private static final int NodeOffsetPointLL_PR_node_LL3 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum NodeOffsetPointLL_PR.NodeOffsetPointLL_PR_node_LL3 = 3
     * }
     */
    public static int NodeOffsetPointLL_PR_node_LL3() {
        return NodeOffsetPointLL_PR_node_LL3;
    }
    private static final int NodeOffsetPointLL_PR_node_LL4 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum NodeOffsetPointLL_PR.NodeOffsetPointLL_PR_node_LL4 = 4
     * }
     */
    public static int NodeOffsetPointLL_PR_node_LL4() {
        return NodeOffsetPointLL_PR_node_LL4;
    }
    private static final int NodeOffsetPointLL_PR_node_LL5 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum NodeOffsetPointLL_PR.NodeOffsetPointLL_PR_node_LL5 = 5
     * }
     */
    public static int NodeOffsetPointLL_PR_node_LL5() {
        return NodeOffsetPointLL_PR_node_LL5;
    }
    private static final int NodeOffsetPointLL_PR_node_LL6 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum NodeOffsetPointLL_PR.NodeOffsetPointLL_PR_node_LL6 = 6
     * }
     */
    public static int NodeOffsetPointLL_PR_node_LL6() {
        return NodeOffsetPointLL_PR_node_LL6;
    }
    private static final int NodeOffsetPointLL_PR_node_LatLon = (int)7L;
    /**
     * {@snippet lang=c :
     * enum NodeOffsetPointLL_PR.NodeOffsetPointLL_PR_node_LatLon = 7
     * }
     */
    public static int NodeOffsetPointLL_PR_node_LatLon() {
        return NodeOffsetPointLL_PR_node_LatLon;
    }
    private static final int NodeOffsetPointLL_PR_regional = (int)8L;
    /**
     * {@snippet lang=c :
     * enum NodeOffsetPointLL_PR.NodeOffsetPointLL_PR_regional = 8
     * }
     */
    public static int NodeOffsetPointLL_PR_regional() {
        return NodeOffsetPointLL_PR_regional;
    }

    private static class asn_DEF_NodeOffsetPointLL$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_NodeOffsetPointLL").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NodeOffsetPointLL
     * }
     */
    public static GroupLayout asn_DEF_NodeOffsetPointLL$layout() {
        return asn_DEF_NodeOffsetPointLL$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NodeOffsetPointLL
     * }
     */
    public static MemorySegment asn_DEF_NodeOffsetPointLL() {
        return asn_DEF_NodeOffsetPointLL$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NodeOffsetPointLL
     * }
     */
    public static void asn_DEF_NodeOffsetPointLL(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_NodeOffsetPointLL$constants.SEGMENT, 0L, asn_DEF_NodeOffsetPointLL$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_NodeOffsetPointLL_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_CHOICE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_NodeOffsetPointLL_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_NodeOffsetPointLL_specs_1
     * }
     */
    public static GroupLayout asn_SPC_NodeOffsetPointLL_specs_1$layout() {
        return asn_SPC_NodeOffsetPointLL_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_NodeOffsetPointLL_specs_1
     * }
     */
    public static MemorySegment asn_SPC_NodeOffsetPointLL_specs_1() {
        return asn_SPC_NodeOffsetPointLL_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_NodeOffsetPointLL_specs_1
     * }
     */
    public static void asn_SPC_NodeOffsetPointLL_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_NodeOffsetPointLL_specs_1$constants.SEGMENT, 0L, asn_SPC_NodeOffsetPointLL_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_NodeOffsetPointLL_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(8, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_NodeOffsetPointLL_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 8 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeOffsetPointLL_1[8]
     * }
     */
    public static SequenceLayout asn_MBR_NodeOffsetPointLL_1$layout() {
        return asn_MBR_NodeOffsetPointLL_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeOffsetPointLL_1[8]
     * }
     */
    public static long[] asn_MBR_NodeOffsetPointLL_1$dimensions() {
        return asn_MBR_NodeOffsetPointLL_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeOffsetPointLL_1[8]
     * }
     */
    public static MemorySegment asn_MBR_NodeOffsetPointLL_1() {
        return asn_MBR_NodeOffsetPointLL_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeOffsetPointLL_1[8]
     * }
     */
    public static void asn_MBR_NodeOffsetPointLL_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_NodeOffsetPointLL_1$constants.SEGMENT, 0L, asn_MBR_NodeOffsetPointLL_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeOffsetPointLL_1[8]
     * }
     */
    public static MemorySegment asn_MBR_NodeOffsetPointLL_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_NodeOffsetPointLL_1$constants.HANDLE.invokeExact(asn_MBR_NodeOffsetPointLL_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeOffsetPointLL_1[8]
     * }
     */
    public static void asn_MBR_NodeOffsetPointLL_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_NodeOffsetPointLL_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_NodeOffsetPointLL_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_NodeOffsetPointLL_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NodeOffsetPointLL_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_NodeOffsetPointLL_constr_1$layout() {
        return asn_PER_type_NodeOffsetPointLL_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NodeOffsetPointLL_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_NodeOffsetPointLL_constr_1() {
        return asn_PER_type_NodeOffsetPointLL_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NodeOffsetPointLL_constr_1
     * }
     */
    public static void asn_PER_type_NodeOffsetPointLL_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_NodeOffsetPointLL_constr_1$constants.SEGMENT, 0L, asn_PER_type_NodeOffsetPointLL_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_NodeLL$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_NodeLL").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NodeLL
     * }
     */
    public static GroupLayout asn_DEF_NodeLL$layout() {
        return asn_DEF_NodeLL$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NodeLL
     * }
     */
    public static MemorySegment asn_DEF_NodeLL() {
        return asn_DEF_NodeLL$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NodeLL
     * }
     */
    public static void asn_DEF_NodeLL(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_NodeLL$constants.SEGMENT, 0L, asn_DEF_NodeLL$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_NodeLL_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_NodeLL_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_NodeLL_specs_1
     * }
     */
    public static GroupLayout asn_SPC_NodeLL_specs_1$layout() {
        return asn_SPC_NodeLL_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_NodeLL_specs_1
     * }
     */
    public static MemorySegment asn_SPC_NodeLL_specs_1() {
        return asn_SPC_NodeLL_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_NodeLL_specs_1
     * }
     */
    public static void asn_SPC_NodeLL_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_NodeLL_specs_1$constants.SEGMENT, 0L, asn_SPC_NodeLL_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_NodeLL_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_NodeLL_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeLL_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_NodeLL_1$layout() {
        return asn_MBR_NodeLL_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeLL_1[2]
     * }
     */
    public static long[] asn_MBR_NodeLL_1$dimensions() {
        return asn_MBR_NodeLL_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeLL_1[2]
     * }
     */
    public static MemorySegment asn_MBR_NodeLL_1() {
        return asn_MBR_NodeLL_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeLL_1[2]
     * }
     */
    public static void asn_MBR_NodeLL_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_NodeLL_1$constants.SEGMENT, 0L, asn_MBR_NodeLL_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeLL_1[2]
     * }
     */
    public static MemorySegment asn_MBR_NodeLL_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_NodeLL_1$constants.HANDLE.invokeExact(asn_MBR_NodeLL_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeLL_1[2]
     * }
     */
    public static void asn_MBR_NodeLL_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_NodeLL_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_NodeAttributeSetLL$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_NodeAttributeSetLL").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NodeAttributeSetLL
     * }
     */
    public static GroupLayout asn_DEF_NodeAttributeSetLL$layout() {
        return asn_DEF_NodeAttributeSetLL$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NodeAttributeSetLL
     * }
     */
    public static MemorySegment asn_DEF_NodeAttributeSetLL() {
        return asn_DEF_NodeAttributeSetLL$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NodeAttributeSetLL
     * }
     */
    public static void asn_DEF_NodeAttributeSetLL(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_NodeAttributeSetLL$constants.SEGMENT, 0L, asn_DEF_NodeAttributeSetLL$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_NodeAttributeSetLL_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_NodeAttributeSetLL_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_NodeAttributeSetLL_specs_1
     * }
     */
    public static GroupLayout asn_SPC_NodeAttributeSetLL_specs_1$layout() {
        return asn_SPC_NodeAttributeSetLL_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_NodeAttributeSetLL_specs_1
     * }
     */
    public static MemorySegment asn_SPC_NodeAttributeSetLL_specs_1() {
        return asn_SPC_NodeAttributeSetLL_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_NodeAttributeSetLL_specs_1
     * }
     */
    public static void asn_SPC_NodeAttributeSetLL_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_NodeAttributeSetLL_specs_1$constants.SEGMENT, 0L, asn_SPC_NodeAttributeSetLL_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_NodeAttributeSetLL_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(7, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_NodeAttributeSetLL_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 7 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeAttributeSetLL_1[7]
     * }
     */
    public static SequenceLayout asn_MBR_NodeAttributeSetLL_1$layout() {
        return asn_MBR_NodeAttributeSetLL_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeAttributeSetLL_1[7]
     * }
     */
    public static long[] asn_MBR_NodeAttributeSetLL_1$dimensions() {
        return asn_MBR_NodeAttributeSetLL_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeAttributeSetLL_1[7]
     * }
     */
    public static MemorySegment asn_MBR_NodeAttributeSetLL_1() {
        return asn_MBR_NodeAttributeSetLL_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeAttributeSetLL_1[7]
     * }
     */
    public static void asn_MBR_NodeAttributeSetLL_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_NodeAttributeSetLL_1$constants.SEGMENT, 0L, asn_MBR_NodeAttributeSetLL_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeAttributeSetLL_1[7]
     * }
     */
    public static MemorySegment asn_MBR_NodeAttributeSetLL_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_NodeAttributeSetLL_1$constants.HANDLE.invokeExact(asn_MBR_NodeAttributeSetLL_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeAttributeSetLL_1[7]
     * }
     */
    public static void asn_MBR_NodeAttributeSetLL_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_NodeAttributeSetLL_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    private static final int NodeAttributeLL_reserved = (int)0L;
    /**
     * {@snippet lang=c :
     * enum NodeAttributeLL.NodeAttributeLL_reserved = 0
     * }
     */
    public static int NodeAttributeLL_reserved() {
        return NodeAttributeLL_reserved;
    }
    private static final int NodeAttributeLL_stopLine = (int)1L;
    /**
     * {@snippet lang=c :
     * enum NodeAttributeLL.NodeAttributeLL_stopLine = 1
     * }
     */
    public static int NodeAttributeLL_stopLine() {
        return NodeAttributeLL_stopLine;
    }
    private static final int NodeAttributeLL_roundedCapStyleA = (int)2L;
    /**
     * {@snippet lang=c :
     * enum NodeAttributeLL.NodeAttributeLL_roundedCapStyleA = 2
     * }
     */
    public static int NodeAttributeLL_roundedCapStyleA() {
        return NodeAttributeLL_roundedCapStyleA;
    }
    private static final int NodeAttributeLL_roundedCapStyleB = (int)3L;
    /**
     * {@snippet lang=c :
     * enum NodeAttributeLL.NodeAttributeLL_roundedCapStyleB = 3
     * }
     */
    public static int NodeAttributeLL_roundedCapStyleB() {
        return NodeAttributeLL_roundedCapStyleB;
    }
    private static final int NodeAttributeLL_mergePoint = (int)4L;
    /**
     * {@snippet lang=c :
     * enum NodeAttributeLL.NodeAttributeLL_mergePoint = 4
     * }
     */
    public static int NodeAttributeLL_mergePoint() {
        return NodeAttributeLL_mergePoint;
    }
    private static final int NodeAttributeLL_divergePoint = (int)5L;
    /**
     * {@snippet lang=c :
     * enum NodeAttributeLL.NodeAttributeLL_divergePoint = 5
     * }
     */
    public static int NodeAttributeLL_divergePoint() {
        return NodeAttributeLL_divergePoint;
    }
    private static final int NodeAttributeLL_downstreamStopLine = (int)6L;
    /**
     * {@snippet lang=c :
     * enum NodeAttributeLL.NodeAttributeLL_downstreamStopLine = 6
     * }
     */
    public static int NodeAttributeLL_downstreamStopLine() {
        return NodeAttributeLL_downstreamStopLine;
    }
    private static final int NodeAttributeLL_downstreamStartNode = (int)7L;
    /**
     * {@snippet lang=c :
     * enum NodeAttributeLL.NodeAttributeLL_downstreamStartNode = 7
     * }
     */
    public static int NodeAttributeLL_downstreamStartNode() {
        return NodeAttributeLL_downstreamStartNode;
    }
    private static final int NodeAttributeLL_closedToTraffic = (int)8L;
    /**
     * {@snippet lang=c :
     * enum NodeAttributeLL.NodeAttributeLL_closedToTraffic = 8
     * }
     */
    public static int NodeAttributeLL_closedToTraffic() {
        return NodeAttributeLL_closedToTraffic;
    }
    private static final int NodeAttributeLL_safeIsland = (int)9L;
    /**
     * {@snippet lang=c :
     * enum NodeAttributeLL.NodeAttributeLL_safeIsland = 9
     * }
     */
    public static int NodeAttributeLL_safeIsland() {
        return NodeAttributeLL_safeIsland;
    }
    private static final int NodeAttributeLL_curbPresentAtStepOff = (int)10L;
    /**
     * {@snippet lang=c :
     * enum NodeAttributeLL.NodeAttributeLL_curbPresentAtStepOff = 10
     * }
     */
    public static int NodeAttributeLL_curbPresentAtStepOff() {
        return NodeAttributeLL_curbPresentAtStepOff;
    }
    private static final int NodeAttributeLL_hydrantPresent = (int)11L;
    /**
     * {@snippet lang=c :
     * enum NodeAttributeLL.NodeAttributeLL_hydrantPresent = 11
     * }
     */
    public static int NodeAttributeLL_hydrantPresent() {
        return NodeAttributeLL_hydrantPresent;
    }
    /**
     * {@snippet lang=c :
     * typedef long NodeAttributeLL_t
     * }
     */
    public static final OfLong NodeAttributeLL_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_NodeAttributeLL_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_NodeAttributeLL_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NodeAttributeLL_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_NodeAttributeLL_constr_1$layout() {
        return asn_PER_type_NodeAttributeLL_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NodeAttributeLL_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_NodeAttributeLL_constr_1() {
        return asn_PER_type_NodeAttributeLL_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NodeAttributeLL_constr_1
     * }
     */
    public static void asn_PER_type_NodeAttributeLL_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_NodeAttributeLL_constr_1$constants.SEGMENT, 0L, asn_PER_type_NodeAttributeLL_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_NodeAttributeLL$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_NodeAttributeLL").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NodeAttributeLL
     * }
     */
    public static GroupLayout asn_DEF_NodeAttributeLL$layout() {
        return asn_DEF_NodeAttributeLL$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NodeAttributeLL
     * }
     */
    public static MemorySegment asn_DEF_NodeAttributeLL() {
        return asn_DEF_NodeAttributeLL$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NodeAttributeLL
     * }
     */
    public static void asn_DEF_NodeAttributeLL(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_NodeAttributeLL$constants.SEGMENT, 0L, asn_DEF_NodeAttributeLL$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_NodeAttributeLL_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_NodeAttributeLL_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_NodeAttributeLL_specs_1
     * }
     */
    public static GroupLayout asn_SPC_NodeAttributeLL_specs_1$layout() {
        return asn_SPC_NodeAttributeLL_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_NodeAttributeLL_specs_1
     * }
     */
    public static MemorySegment asn_SPC_NodeAttributeLL_specs_1() {
        return asn_SPC_NodeAttributeLL_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_NodeAttributeLL_specs_1
     * }
     */
    public static void asn_SPC_NodeAttributeLL_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_NodeAttributeLL_specs_1$constants.SEGMENT, 0L, asn_SPC_NodeAttributeLL_specs_1$constants.LAYOUT.byteSize());
    }

    private static class NodeAttributeLL_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NodeAttributeLL_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NodeAttributeLL_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor NodeAttributeLL_free$descriptor() {
        return NodeAttributeLL_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NodeAttributeLL_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle NodeAttributeLL_free$handle() {
        return NodeAttributeLL_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NodeAttributeLL_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment NodeAttributeLL_free$address() {
        return NodeAttributeLL_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NodeAttributeLL_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void NodeAttributeLL_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = NodeAttributeLL_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NodeAttributeLL_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NodeAttributeLL_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NodeAttributeLL_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int NodeAttributeLL_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NodeAttributeLL_print$descriptor() {
        return NodeAttributeLL_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int NodeAttributeLL_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NodeAttributeLL_print$handle() {
        return NodeAttributeLL_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int NodeAttributeLL_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NodeAttributeLL_print$address() {
        return NodeAttributeLL_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int NodeAttributeLL_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int NodeAttributeLL_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NodeAttributeLL_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NodeAttributeLL_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NodeAttributeLL_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NodeAttributeLL_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int NodeAttributeLL_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor NodeAttributeLL_constraint$descriptor() {
        return NodeAttributeLL_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int NodeAttributeLL_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle NodeAttributeLL_constraint$handle() {
        return NodeAttributeLL_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int NodeAttributeLL_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment NodeAttributeLL_constraint$address() {
        return NodeAttributeLL_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int NodeAttributeLL_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int NodeAttributeLL_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = NodeAttributeLL_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NodeAttributeLL_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NodeAttributeLL_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NodeAttributeLL_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NodeAttributeLL_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor NodeAttributeLL_decode_ber$descriptor() {
        return NodeAttributeLL_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NodeAttributeLL_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle NodeAttributeLL_decode_ber$handle() {
        return NodeAttributeLL_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NodeAttributeLL_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment NodeAttributeLL_decode_ber$address() {
        return NodeAttributeLL_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NodeAttributeLL_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment NodeAttributeLL_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = NodeAttributeLL_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NodeAttributeLL_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NodeAttributeLL_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NodeAttributeLL_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NodeAttributeLL_encode_der$descriptor() {
        return NodeAttributeLL_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NodeAttributeLL_encode_der$handle() {
        return NodeAttributeLL_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NodeAttributeLL_encode_der$address() {
        return NodeAttributeLL_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NodeAttributeLL_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = NodeAttributeLL_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NodeAttributeLL_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NodeAttributeLL_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NodeAttributeLL_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NodeAttributeLL_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor NodeAttributeLL_decode_xer$descriptor() {
        return NodeAttributeLL_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NodeAttributeLL_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle NodeAttributeLL_decode_xer$handle() {
        return NodeAttributeLL_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NodeAttributeLL_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment NodeAttributeLL_decode_xer$address() {
        return NodeAttributeLL_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NodeAttributeLL_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment NodeAttributeLL_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = NodeAttributeLL_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NodeAttributeLL_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NodeAttributeLL_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NodeAttributeLL_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NodeAttributeLL_encode_xer$descriptor() {
        return NodeAttributeLL_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NodeAttributeLL_encode_xer$handle() {
        return NodeAttributeLL_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NodeAttributeLL_encode_xer$address() {
        return NodeAttributeLL_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NodeAttributeLL_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = NodeAttributeLL_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NodeAttributeLL_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NodeAttributeLL_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NodeAttributeLL_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NodeAttributeLL_encode_jer$descriptor() {
        return NodeAttributeLL_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NodeAttributeLL_encode_jer$handle() {
        return NodeAttributeLL_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NodeAttributeLL_encode_jer$address() {
        return NodeAttributeLL_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NodeAttributeLL_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = NodeAttributeLL_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NodeAttributeLL_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NodeAttributeLL_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NodeAttributeLL_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NodeAttributeLL_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor NodeAttributeLL_decode_oer$descriptor() {
        return NodeAttributeLL_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NodeAttributeLL_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle NodeAttributeLL_decode_oer$handle() {
        return NodeAttributeLL_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NodeAttributeLL_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment NodeAttributeLL_decode_oer$address() {
        return NodeAttributeLL_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NodeAttributeLL_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment NodeAttributeLL_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = NodeAttributeLL_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NodeAttributeLL_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NodeAttributeLL_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NodeAttributeLL_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NodeAttributeLL_encode_oer$descriptor() {
        return NodeAttributeLL_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NodeAttributeLL_encode_oer$handle() {
        return NodeAttributeLL_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NodeAttributeLL_encode_oer$address() {
        return NodeAttributeLL_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NodeAttributeLL_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NodeAttributeLL_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NodeAttributeLL_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NodeAttributeLL_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NodeAttributeLL_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NodeAttributeLL_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor NodeAttributeLL_decode_uper$descriptor() {
        return NodeAttributeLL_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NodeAttributeLL_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle NodeAttributeLL_decode_uper$handle() {
        return NodeAttributeLL_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NodeAttributeLL_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NodeAttributeLL_decode_uper$address() {
        return NodeAttributeLL_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NodeAttributeLL_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NodeAttributeLL_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NodeAttributeLL_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NodeAttributeLL_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NodeAttributeLL_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NodeAttributeLL_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor NodeAttributeLL_encode_uper$descriptor() {
        return NodeAttributeLL_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle NodeAttributeLL_encode_uper$handle() {
        return NodeAttributeLL_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NodeAttributeLL_encode_uper$address() {
        return NodeAttributeLL_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NodeAttributeLL_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = NodeAttributeLL_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NodeAttributeLL_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NodeAttributeLL_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NodeAttributeLL_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NodeAttributeLL_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor NodeAttributeLL_decode_aper$descriptor() {
        return NodeAttributeLL_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NodeAttributeLL_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle NodeAttributeLL_decode_aper$handle() {
        return NodeAttributeLL_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NodeAttributeLL_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NodeAttributeLL_decode_aper$address() {
        return NodeAttributeLL_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NodeAttributeLL_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NodeAttributeLL_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NodeAttributeLL_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NodeAttributeLL_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NodeAttributeLL_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NodeAttributeLL_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor NodeAttributeLL_encode_aper$descriptor() {
        return NodeAttributeLL_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle NodeAttributeLL_encode_aper$handle() {
        return NodeAttributeLL_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NodeAttributeLL_encode_aper$address() {
        return NodeAttributeLL_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NodeAttributeLL_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NodeAttributeLL_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = NodeAttributeLL_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NodeAttributeLL_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_NodeAttributeLLList$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_NodeAttributeLLList").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NodeAttributeLLList
     * }
     */
    public static GroupLayout asn_DEF_NodeAttributeLLList$layout() {
        return asn_DEF_NodeAttributeLLList$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NodeAttributeLLList
     * }
     */
    public static MemorySegment asn_DEF_NodeAttributeLLList() {
        return asn_DEF_NodeAttributeLLList$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NodeAttributeLLList
     * }
     */
    public static void asn_DEF_NodeAttributeLLList(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_NodeAttributeLLList$constants.SEGMENT, 0L, asn_DEF_NodeAttributeLLList$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_NodeAttributeLLList_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SET_OF_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_NodeAttributeLLList_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_NodeAttributeLLList_specs_1
     * }
     */
    public static GroupLayout asn_SPC_NodeAttributeLLList_specs_1$layout() {
        return asn_SPC_NodeAttributeLLList_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_NodeAttributeLLList_specs_1
     * }
     */
    public static MemorySegment asn_SPC_NodeAttributeLLList_specs_1() {
        return asn_SPC_NodeAttributeLLList_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_NodeAttributeLLList_specs_1
     * }
     */
    public static void asn_SPC_NodeAttributeLLList_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_NodeAttributeLLList_specs_1$constants.SEGMENT, 0L, asn_SPC_NodeAttributeLLList_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_NodeAttributeLLList_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(1, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_NodeAttributeLLList_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 1 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeAttributeLLList_1[1]
     * }
     */
    public static SequenceLayout asn_MBR_NodeAttributeLLList_1$layout() {
        return asn_MBR_NodeAttributeLLList_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeAttributeLLList_1[1]
     * }
     */
    public static long[] asn_MBR_NodeAttributeLLList_1$dimensions() {
        return asn_MBR_NodeAttributeLLList_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeAttributeLLList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_NodeAttributeLLList_1() {
        return asn_MBR_NodeAttributeLLList_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeAttributeLLList_1[1]
     * }
     */
    public static void asn_MBR_NodeAttributeLLList_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_NodeAttributeLLList_1$constants.SEGMENT, 0L, asn_MBR_NodeAttributeLLList_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeAttributeLLList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_NodeAttributeLLList_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_NodeAttributeLLList_1$constants.HANDLE.invokeExact(asn_MBR_NodeAttributeLLList_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeAttributeLLList_1[1]
     * }
     */
    public static void asn_MBR_NodeAttributeLLList_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_NodeAttributeLLList_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_NodeAttributeLLList_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_NodeAttributeLLList_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NodeAttributeLLList_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_NodeAttributeLLList_constr_1$layout() {
        return asn_PER_type_NodeAttributeLLList_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NodeAttributeLLList_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_NodeAttributeLLList_constr_1() {
        return asn_PER_type_NodeAttributeLLList_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NodeAttributeLLList_constr_1
     * }
     */
    public static void asn_PER_type_NodeAttributeLLList_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_NodeAttributeLLList_constr_1$constants.SEGMENT, 0L, asn_PER_type_NodeAttributeLLList_constr_1$constants.LAYOUT.byteSize());
    }
    private static final int SegmentAttributeLL_reserved = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_reserved = 0
     * }
     */
    public static int SegmentAttributeLL_reserved() {
        return SegmentAttributeLL_reserved;
    }
    private static final int SegmentAttributeLL_doNotBlock = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_doNotBlock = 1
     * }
     */
    public static int SegmentAttributeLL_doNotBlock() {
        return SegmentAttributeLL_doNotBlock;
    }
    private static final int SegmentAttributeLL_whiteLine = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_whiteLine = 2
     * }
     */
    public static int SegmentAttributeLL_whiteLine() {
        return SegmentAttributeLL_whiteLine;
    }
    private static final int SegmentAttributeLL_mergingLaneLeft = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_mergingLaneLeft = 3
     * }
     */
    public static int SegmentAttributeLL_mergingLaneLeft() {
        return SegmentAttributeLL_mergingLaneLeft;
    }
    private static final int SegmentAttributeLL_mergingLaneRight = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_mergingLaneRight = 4
     * }
     */
    public static int SegmentAttributeLL_mergingLaneRight() {
        return SegmentAttributeLL_mergingLaneRight;
    }
    private static final int SegmentAttributeLL_curbOnLeft = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_curbOnLeft = 5
     * }
     */
    public static int SegmentAttributeLL_curbOnLeft() {
        return SegmentAttributeLL_curbOnLeft;
    }
    private static final int SegmentAttributeLL_curbOnRight = (int)6L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_curbOnRight = 6
     * }
     */
    public static int SegmentAttributeLL_curbOnRight() {
        return SegmentAttributeLL_curbOnRight;
    }
    private static final int SegmentAttributeLL_loadingzoneOnLeft = (int)7L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_loadingzoneOnLeft = 7
     * }
     */
    public static int SegmentAttributeLL_loadingzoneOnLeft() {
        return SegmentAttributeLL_loadingzoneOnLeft;
    }
    private static final int SegmentAttributeLL_loadingzoneOnRight = (int)8L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_loadingzoneOnRight = 8
     * }
     */
    public static int SegmentAttributeLL_loadingzoneOnRight() {
        return SegmentAttributeLL_loadingzoneOnRight;
    }
    private static final int SegmentAttributeLL_turnOutPointOnLeft = (int)9L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_turnOutPointOnLeft = 9
     * }
     */
    public static int SegmentAttributeLL_turnOutPointOnLeft() {
        return SegmentAttributeLL_turnOutPointOnLeft;
    }
    private static final int SegmentAttributeLL_turnOutPointOnRight = (int)10L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_turnOutPointOnRight = 10
     * }
     */
    public static int SegmentAttributeLL_turnOutPointOnRight() {
        return SegmentAttributeLL_turnOutPointOnRight;
    }
    private static final int SegmentAttributeLL_adjacentParkingOnLeft = (int)11L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_adjacentParkingOnLeft = 11
     * }
     */
    public static int SegmentAttributeLL_adjacentParkingOnLeft() {
        return SegmentAttributeLL_adjacentParkingOnLeft;
    }
    private static final int SegmentAttributeLL_adjacentParkingOnRight = (int)12L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_adjacentParkingOnRight = 12
     * }
     */
    public static int SegmentAttributeLL_adjacentParkingOnRight() {
        return SegmentAttributeLL_adjacentParkingOnRight;
    }
    private static final int SegmentAttributeLL_adjacentBikeLaneOnLeft = (int)13L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_adjacentBikeLaneOnLeft = 13
     * }
     */
    public static int SegmentAttributeLL_adjacentBikeLaneOnLeft() {
        return SegmentAttributeLL_adjacentBikeLaneOnLeft;
    }
    private static final int SegmentAttributeLL_adjacentBikeLaneOnRight = (int)14L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_adjacentBikeLaneOnRight = 14
     * }
     */
    public static int SegmentAttributeLL_adjacentBikeLaneOnRight() {
        return SegmentAttributeLL_adjacentBikeLaneOnRight;
    }
    private static final int SegmentAttributeLL_sharedBikeLane = (int)15L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_sharedBikeLane = 15
     * }
     */
    public static int SegmentAttributeLL_sharedBikeLane() {
        return SegmentAttributeLL_sharedBikeLane;
    }
    private static final int SegmentAttributeLL_bikeBoxInFront = (int)16L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_bikeBoxInFront = 16
     * }
     */
    public static int SegmentAttributeLL_bikeBoxInFront() {
        return SegmentAttributeLL_bikeBoxInFront;
    }
    private static final int SegmentAttributeLL_transitStopOnLeft = (int)17L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_transitStopOnLeft = 17
     * }
     */
    public static int SegmentAttributeLL_transitStopOnLeft() {
        return SegmentAttributeLL_transitStopOnLeft;
    }
    private static final int SegmentAttributeLL_transitStopOnRight = (int)18L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_transitStopOnRight = 18
     * }
     */
    public static int SegmentAttributeLL_transitStopOnRight() {
        return SegmentAttributeLL_transitStopOnRight;
    }
    private static final int SegmentAttributeLL_transitStopInLane = (int)19L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_transitStopInLane = 19
     * }
     */
    public static int SegmentAttributeLL_transitStopInLane() {
        return SegmentAttributeLL_transitStopInLane;
    }
    private static final int SegmentAttributeLL_sharedWithTrackedVehicle = (int)20L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_sharedWithTrackedVehicle = 20
     * }
     */
    public static int SegmentAttributeLL_sharedWithTrackedVehicle() {
        return SegmentAttributeLL_sharedWithTrackedVehicle;
    }
    private static final int SegmentAttributeLL_safeIsland = (int)21L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_safeIsland = 21
     * }
     */
    public static int SegmentAttributeLL_safeIsland() {
        return SegmentAttributeLL_safeIsland;
    }
    private static final int SegmentAttributeLL_lowCurbsPresent = (int)22L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_lowCurbsPresent = 22
     * }
     */
    public static int SegmentAttributeLL_lowCurbsPresent() {
        return SegmentAttributeLL_lowCurbsPresent;
    }
    private static final int SegmentAttributeLL_rumbleStripPresent = (int)23L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_rumbleStripPresent = 23
     * }
     */
    public static int SegmentAttributeLL_rumbleStripPresent() {
        return SegmentAttributeLL_rumbleStripPresent;
    }
    private static final int SegmentAttributeLL_audibleSignalingPresent = (int)24L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_audibleSignalingPresent = 24
     * }
     */
    public static int SegmentAttributeLL_audibleSignalingPresent() {
        return SegmentAttributeLL_audibleSignalingPresent;
    }
    private static final int SegmentAttributeLL_adaptiveTimingPresent = (int)25L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_adaptiveTimingPresent = 25
     * }
     */
    public static int SegmentAttributeLL_adaptiveTimingPresent() {
        return SegmentAttributeLL_adaptiveTimingPresent;
    }
    private static final int SegmentAttributeLL_rfSignalRequestPresent = (int)26L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_rfSignalRequestPresent = 26
     * }
     */
    public static int SegmentAttributeLL_rfSignalRequestPresent() {
        return SegmentAttributeLL_rfSignalRequestPresent;
    }
    private static final int SegmentAttributeLL_partialCurbIntrusion = (int)27L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_partialCurbIntrusion = 27
     * }
     */
    public static int SegmentAttributeLL_partialCurbIntrusion() {
        return SegmentAttributeLL_partialCurbIntrusion;
    }
    private static final int SegmentAttributeLL_taperToLeft = (int)28L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_taperToLeft = 28
     * }
     */
    public static int SegmentAttributeLL_taperToLeft() {
        return SegmentAttributeLL_taperToLeft;
    }
    private static final int SegmentAttributeLL_taperToRight = (int)29L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_taperToRight = 29
     * }
     */
    public static int SegmentAttributeLL_taperToRight() {
        return SegmentAttributeLL_taperToRight;
    }
    private static final int SegmentAttributeLL_taperToCenterLine = (int)30L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_taperToCenterLine = 30
     * }
     */
    public static int SegmentAttributeLL_taperToCenterLine() {
        return SegmentAttributeLL_taperToCenterLine;
    }
    private static final int SegmentAttributeLL_parallelParking = (int)31L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_parallelParking = 31
     * }
     */
    public static int SegmentAttributeLL_parallelParking() {
        return SegmentAttributeLL_parallelParking;
    }
    private static final int SegmentAttributeLL_headInParking = (int)32L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_headInParking = 32
     * }
     */
    public static int SegmentAttributeLL_headInParking() {
        return SegmentAttributeLL_headInParking;
    }
    private static final int SegmentAttributeLL_freeParking = (int)33L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_freeParking = 33
     * }
     */
    public static int SegmentAttributeLL_freeParking() {
        return SegmentAttributeLL_freeParking;
    }
    private static final int SegmentAttributeLL_timeRestrictionsOnParking = (int)34L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_timeRestrictionsOnParking = 34
     * }
     */
    public static int SegmentAttributeLL_timeRestrictionsOnParking() {
        return SegmentAttributeLL_timeRestrictionsOnParking;
    }
    private static final int SegmentAttributeLL_costToPark = (int)35L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_costToPark = 35
     * }
     */
    public static int SegmentAttributeLL_costToPark() {
        return SegmentAttributeLL_costToPark;
    }
    private static final int SegmentAttributeLL_midBlockCurbPresent = (int)36L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_midBlockCurbPresent = 36
     * }
     */
    public static int SegmentAttributeLL_midBlockCurbPresent() {
        return SegmentAttributeLL_midBlockCurbPresent;
    }
    private static final int SegmentAttributeLL_unEvenPavementPresent = (int)37L;
    /**
     * {@snippet lang=c :
     * enum SegmentAttributeLL.SegmentAttributeLL_unEvenPavementPresent = 37
     * }
     */
    public static int SegmentAttributeLL_unEvenPavementPresent() {
        return SegmentAttributeLL_unEvenPavementPresent;
    }
    /**
     * {@snippet lang=c :
     * typedef long SegmentAttributeLL_t
     * }
     */
    public static final OfLong SegmentAttributeLL_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_SegmentAttributeLL_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_SegmentAttributeLL_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SegmentAttributeLL_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_SegmentAttributeLL_constr_1$layout() {
        return asn_PER_type_SegmentAttributeLL_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SegmentAttributeLL_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_SegmentAttributeLL_constr_1() {
        return asn_PER_type_SegmentAttributeLL_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SegmentAttributeLL_constr_1
     * }
     */
    public static void asn_PER_type_SegmentAttributeLL_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_SegmentAttributeLL_constr_1$constants.SEGMENT, 0L, asn_PER_type_SegmentAttributeLL_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_SegmentAttributeLL$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_SegmentAttributeLL").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SegmentAttributeLL
     * }
     */
    public static GroupLayout asn_DEF_SegmentAttributeLL$layout() {
        return asn_DEF_SegmentAttributeLL$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SegmentAttributeLL
     * }
     */
    public static MemorySegment asn_DEF_SegmentAttributeLL() {
        return asn_DEF_SegmentAttributeLL$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SegmentAttributeLL
     * }
     */
    public static void asn_DEF_SegmentAttributeLL(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_SegmentAttributeLL$constants.SEGMENT, 0L, asn_DEF_SegmentAttributeLL$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_SegmentAttributeLL_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_SegmentAttributeLL_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_SegmentAttributeLL_specs_1
     * }
     */
    public static GroupLayout asn_SPC_SegmentAttributeLL_specs_1$layout() {
        return asn_SPC_SegmentAttributeLL_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_SegmentAttributeLL_specs_1
     * }
     */
    public static MemorySegment asn_SPC_SegmentAttributeLL_specs_1() {
        return asn_SPC_SegmentAttributeLL_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_SegmentAttributeLL_specs_1
     * }
     */
    public static void asn_SPC_SegmentAttributeLL_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_SegmentAttributeLL_specs_1$constants.SEGMENT, 0L, asn_SPC_SegmentAttributeLL_specs_1$constants.LAYOUT.byteSize());
    }

    private static class SegmentAttributeLL_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SegmentAttributeLL_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SegmentAttributeLL_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor SegmentAttributeLL_free$descriptor() {
        return SegmentAttributeLL_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SegmentAttributeLL_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle SegmentAttributeLL_free$handle() {
        return SegmentAttributeLL_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SegmentAttributeLL_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment SegmentAttributeLL_free$address() {
        return SegmentAttributeLL_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SegmentAttributeLL_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void SegmentAttributeLL_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = SegmentAttributeLL_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SegmentAttributeLL_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SegmentAttributeLL_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SegmentAttributeLL_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SegmentAttributeLL_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SegmentAttributeLL_print$descriptor() {
        return SegmentAttributeLL_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SegmentAttributeLL_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SegmentAttributeLL_print$handle() {
        return SegmentAttributeLL_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SegmentAttributeLL_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SegmentAttributeLL_print$address() {
        return SegmentAttributeLL_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SegmentAttributeLL_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int SegmentAttributeLL_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SegmentAttributeLL_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SegmentAttributeLL_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SegmentAttributeLL_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SegmentAttributeLL_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SegmentAttributeLL_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor SegmentAttributeLL_constraint$descriptor() {
        return SegmentAttributeLL_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SegmentAttributeLL_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle SegmentAttributeLL_constraint$handle() {
        return SegmentAttributeLL_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SegmentAttributeLL_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment SegmentAttributeLL_constraint$address() {
        return SegmentAttributeLL_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SegmentAttributeLL_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int SegmentAttributeLL_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SegmentAttributeLL_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SegmentAttributeLL_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SegmentAttributeLL_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SegmentAttributeLL_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SegmentAttributeLL_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor SegmentAttributeLL_decode_ber$descriptor() {
        return SegmentAttributeLL_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SegmentAttributeLL_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle SegmentAttributeLL_decode_ber$handle() {
        return SegmentAttributeLL_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SegmentAttributeLL_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SegmentAttributeLL_decode_ber$address() {
        return SegmentAttributeLL_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SegmentAttributeLL_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SegmentAttributeLL_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = SegmentAttributeLL_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SegmentAttributeLL_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SegmentAttributeLL_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SegmentAttributeLL_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SegmentAttributeLL_encode_der$descriptor() {
        return SegmentAttributeLL_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SegmentAttributeLL_encode_der$handle() {
        return SegmentAttributeLL_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SegmentAttributeLL_encode_der$address() {
        return SegmentAttributeLL_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SegmentAttributeLL_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SegmentAttributeLL_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SegmentAttributeLL_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SegmentAttributeLL_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SegmentAttributeLL_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SegmentAttributeLL_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SegmentAttributeLL_decode_xer$descriptor() {
        return SegmentAttributeLL_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SegmentAttributeLL_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle SegmentAttributeLL_decode_xer$handle() {
        return SegmentAttributeLL_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SegmentAttributeLL_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SegmentAttributeLL_decode_xer$address() {
        return SegmentAttributeLL_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SegmentAttributeLL_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SegmentAttributeLL_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SegmentAttributeLL_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SegmentAttributeLL_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SegmentAttributeLL_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SegmentAttributeLL_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SegmentAttributeLL_encode_xer$descriptor() {
        return SegmentAttributeLL_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SegmentAttributeLL_encode_xer$handle() {
        return SegmentAttributeLL_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SegmentAttributeLL_encode_xer$address() {
        return SegmentAttributeLL_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SegmentAttributeLL_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SegmentAttributeLL_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SegmentAttributeLL_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SegmentAttributeLL_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SegmentAttributeLL_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SegmentAttributeLL_encode_jer$descriptor() {
        return SegmentAttributeLL_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SegmentAttributeLL_encode_jer$handle() {
        return SegmentAttributeLL_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SegmentAttributeLL_encode_jer$address() {
        return SegmentAttributeLL_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SegmentAttributeLL_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = SegmentAttributeLL_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SegmentAttributeLL_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SegmentAttributeLL_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SegmentAttributeLL_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SegmentAttributeLL_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SegmentAttributeLL_decode_oer$descriptor() {
        return SegmentAttributeLL_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SegmentAttributeLL_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle SegmentAttributeLL_decode_oer$handle() {
        return SegmentAttributeLL_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SegmentAttributeLL_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SegmentAttributeLL_decode_oer$address() {
        return SegmentAttributeLL_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SegmentAttributeLL_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SegmentAttributeLL_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SegmentAttributeLL_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SegmentAttributeLL_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SegmentAttributeLL_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SegmentAttributeLL_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SegmentAttributeLL_encode_oer$descriptor() {
        return SegmentAttributeLL_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SegmentAttributeLL_encode_oer$handle() {
        return SegmentAttributeLL_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SegmentAttributeLL_encode_oer$address() {
        return SegmentAttributeLL_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SegmentAttributeLL_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SegmentAttributeLL_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SegmentAttributeLL_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SegmentAttributeLL_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SegmentAttributeLL_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SegmentAttributeLL_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SegmentAttributeLL_decode_uper$descriptor() {
        return SegmentAttributeLL_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SegmentAttributeLL_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SegmentAttributeLL_decode_uper$handle() {
        return SegmentAttributeLL_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SegmentAttributeLL_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SegmentAttributeLL_decode_uper$address() {
        return SegmentAttributeLL_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SegmentAttributeLL_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SegmentAttributeLL_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SegmentAttributeLL_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SegmentAttributeLL_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SegmentAttributeLL_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SegmentAttributeLL_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SegmentAttributeLL_encode_uper$descriptor() {
        return SegmentAttributeLL_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SegmentAttributeLL_encode_uper$handle() {
        return SegmentAttributeLL_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SegmentAttributeLL_encode_uper$address() {
        return SegmentAttributeLL_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SegmentAttributeLL_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SegmentAttributeLL_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SegmentAttributeLL_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SegmentAttributeLL_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SegmentAttributeLL_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SegmentAttributeLL_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SegmentAttributeLL_decode_aper$descriptor() {
        return SegmentAttributeLL_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SegmentAttributeLL_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SegmentAttributeLL_decode_aper$handle() {
        return SegmentAttributeLL_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SegmentAttributeLL_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SegmentAttributeLL_decode_aper$address() {
        return SegmentAttributeLL_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SegmentAttributeLL_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SegmentAttributeLL_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SegmentAttributeLL_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SegmentAttributeLL_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SegmentAttributeLL_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SegmentAttributeLL_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SegmentAttributeLL_encode_aper$descriptor() {
        return SegmentAttributeLL_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SegmentAttributeLL_encode_aper$handle() {
        return SegmentAttributeLL_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SegmentAttributeLL_encode_aper$address() {
        return SegmentAttributeLL_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SegmentAttributeLL_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SegmentAttributeLL_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SegmentAttributeLL_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SegmentAttributeLL_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_SegmentAttributeLLList$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_SegmentAttributeLLList").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SegmentAttributeLLList
     * }
     */
    public static GroupLayout asn_DEF_SegmentAttributeLLList$layout() {
        return asn_DEF_SegmentAttributeLLList$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SegmentAttributeLLList
     * }
     */
    public static MemorySegment asn_DEF_SegmentAttributeLLList() {
        return asn_DEF_SegmentAttributeLLList$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SegmentAttributeLLList
     * }
     */
    public static void asn_DEF_SegmentAttributeLLList(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_SegmentAttributeLLList$constants.SEGMENT, 0L, asn_DEF_SegmentAttributeLLList$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_SegmentAttributeLLList_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SET_OF_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_SegmentAttributeLLList_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_SegmentAttributeLLList_specs_1
     * }
     */
    public static GroupLayout asn_SPC_SegmentAttributeLLList_specs_1$layout() {
        return asn_SPC_SegmentAttributeLLList_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_SegmentAttributeLLList_specs_1
     * }
     */
    public static MemorySegment asn_SPC_SegmentAttributeLLList_specs_1() {
        return asn_SPC_SegmentAttributeLLList_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_SegmentAttributeLLList_specs_1
     * }
     */
    public static void asn_SPC_SegmentAttributeLLList_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_SegmentAttributeLLList_specs_1$constants.SEGMENT, 0L, asn_SPC_SegmentAttributeLLList_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_SegmentAttributeLLList_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(1, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_SegmentAttributeLLList_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 1 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SegmentAttributeLLList_1[1]
     * }
     */
    public static SequenceLayout asn_MBR_SegmentAttributeLLList_1$layout() {
        return asn_MBR_SegmentAttributeLLList_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SegmentAttributeLLList_1[1]
     * }
     */
    public static long[] asn_MBR_SegmentAttributeLLList_1$dimensions() {
        return asn_MBR_SegmentAttributeLLList_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SegmentAttributeLLList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_SegmentAttributeLLList_1() {
        return asn_MBR_SegmentAttributeLLList_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SegmentAttributeLLList_1[1]
     * }
     */
    public static void asn_MBR_SegmentAttributeLLList_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_SegmentAttributeLLList_1$constants.SEGMENT, 0L, asn_MBR_SegmentAttributeLLList_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SegmentAttributeLLList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_SegmentAttributeLLList_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_SegmentAttributeLLList_1$constants.HANDLE.invokeExact(asn_MBR_SegmentAttributeLLList_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SegmentAttributeLLList_1[1]
     * }
     */
    public static void asn_MBR_SegmentAttributeLLList_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_SegmentAttributeLLList_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_SegmentAttributeLLList_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_SegmentAttributeLLList_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SegmentAttributeLLList_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_SegmentAttributeLLList_constr_1$layout() {
        return asn_PER_type_SegmentAttributeLLList_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SegmentAttributeLLList_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_SegmentAttributeLLList_constr_1() {
        return asn_PER_type_SegmentAttributeLLList_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SegmentAttributeLLList_constr_1
     * }
     */
    public static void asn_PER_type_SegmentAttributeLLList_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_SegmentAttributeLLList_constr_1$constants.SEGMENT, 0L, asn_PER_type_SegmentAttributeLLList_constr_1$constants.LAYOUT.byteSize());
    }
    private static final int NodeListLL_PR_NOTHING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum NodeListLL_PR.NodeListLL_PR_NOTHING = 0
     * }
     */
    public static int NodeListLL_PR_NOTHING() {
        return NodeListLL_PR_NOTHING;
    }
    private static final int NodeListLL_PR_nodes = (int)1L;
    /**
     * {@snippet lang=c :
     * enum NodeListLL_PR.NodeListLL_PR_nodes = 1
     * }
     */
    public static int NodeListLL_PR_nodes() {
        return NodeListLL_PR_nodes;
    }

    private static class asn_DEF_NodeListLL$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_NodeListLL").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NodeListLL
     * }
     */
    public static GroupLayout asn_DEF_NodeListLL$layout() {
        return asn_DEF_NodeListLL$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NodeListLL
     * }
     */
    public static MemorySegment asn_DEF_NodeListLL() {
        return asn_DEF_NodeListLL$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NodeListLL
     * }
     */
    public static void asn_DEF_NodeListLL(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_NodeListLL$constants.SEGMENT, 0L, asn_DEF_NodeListLL$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_NodeListLL_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_CHOICE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_NodeListLL_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_NodeListLL_specs_1
     * }
     */
    public static GroupLayout asn_SPC_NodeListLL_specs_1$layout() {
        return asn_SPC_NodeListLL_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_NodeListLL_specs_1
     * }
     */
    public static MemorySegment asn_SPC_NodeListLL_specs_1() {
        return asn_SPC_NodeListLL_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_NodeListLL_specs_1
     * }
     */
    public static void asn_SPC_NodeListLL_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_NodeListLL_specs_1$constants.SEGMENT, 0L, asn_SPC_NodeListLL_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_NodeListLL_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(1, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_NodeListLL_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 1 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeListLL_1[1]
     * }
     */
    public static SequenceLayout asn_MBR_NodeListLL_1$layout() {
        return asn_MBR_NodeListLL_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeListLL_1[1]
     * }
     */
    public static long[] asn_MBR_NodeListLL_1$dimensions() {
        return asn_MBR_NodeListLL_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeListLL_1[1]
     * }
     */
    public static MemorySegment asn_MBR_NodeListLL_1() {
        return asn_MBR_NodeListLL_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeListLL_1[1]
     * }
     */
    public static void asn_MBR_NodeListLL_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_NodeListLL_1$constants.SEGMENT, 0L, asn_MBR_NodeListLL_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeListLL_1[1]
     * }
     */
    public static MemorySegment asn_MBR_NodeListLL_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_NodeListLL_1$constants.HANDLE.invokeExact(asn_MBR_NodeListLL_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodeListLL_1[1]
     * }
     */
    public static void asn_MBR_NodeListLL_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_NodeListLL_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_NodeListLL_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_NodeListLL_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NodeListLL_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_NodeListLL_constr_1$layout() {
        return asn_PER_type_NodeListLL_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NodeListLL_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_NodeListLL_constr_1() {
        return asn_PER_type_NodeListLL_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NodeListLL_constr_1
     * }
     */
    public static void asn_PER_type_NodeListLL_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_NodeListLL_constr_1$constants.SEGMENT, 0L, asn_PER_type_NodeListLL_constr_1$constants.LAYOUT.byteSize());
    }
    private static final int OffsetSystem__offset_PR_NOTHING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum OffsetSystem__offset_PR.OffsetSystem__offset_PR_NOTHING = 0
     * }
     */
    public static int OffsetSystem__offset_PR_NOTHING() {
        return OffsetSystem__offset_PR_NOTHING;
    }
    private static final int OffsetSystem__offset_PR_xy = (int)1L;
    /**
     * {@snippet lang=c :
     * enum OffsetSystem__offset_PR.OffsetSystem__offset_PR_xy = 1
     * }
     */
    public static int OffsetSystem__offset_PR_xy() {
        return OffsetSystem__offset_PR_xy;
    }
    private static final int OffsetSystem__offset_PR_ll = (int)2L;
    /**
     * {@snippet lang=c :
     * enum OffsetSystem__offset_PR.OffsetSystem__offset_PR_ll = 2
     * }
     */
    public static int OffsetSystem__offset_PR_ll() {
        return OffsetSystem__offset_PR_ll;
    }

    private static class asn_DEF_OffsetSystem$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_OffsetSystem").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_OffsetSystem
     * }
     */
    public static GroupLayout asn_DEF_OffsetSystem$layout() {
        return asn_DEF_OffsetSystem$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_OffsetSystem
     * }
     */
    public static MemorySegment asn_DEF_OffsetSystem() {
        return asn_DEF_OffsetSystem$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_OffsetSystem
     * }
     */
    public static void asn_DEF_OffsetSystem(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_OffsetSystem$constants.SEGMENT, 0L, asn_DEF_OffsetSystem$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_OffsetSystem_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_OffsetSystem_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_OffsetSystem_specs_1
     * }
     */
    public static GroupLayout asn_SPC_OffsetSystem_specs_1$layout() {
        return asn_SPC_OffsetSystem_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_OffsetSystem_specs_1
     * }
     */
    public static MemorySegment asn_SPC_OffsetSystem_specs_1() {
        return asn_SPC_OffsetSystem_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_OffsetSystem_specs_1
     * }
     */
    public static void asn_SPC_OffsetSystem_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_OffsetSystem_specs_1$constants.SEGMENT, 0L, asn_SPC_OffsetSystem_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_OffsetSystem_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_OffsetSystem_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_OffsetSystem_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_OffsetSystem_1$layout() {
        return asn_MBR_OffsetSystem_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_OffsetSystem_1[2]
     * }
     */
    public static long[] asn_MBR_OffsetSystem_1$dimensions() {
        return asn_MBR_OffsetSystem_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_OffsetSystem_1[2]
     * }
     */
    public static MemorySegment asn_MBR_OffsetSystem_1() {
        return asn_MBR_OffsetSystem_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_OffsetSystem_1[2]
     * }
     */
    public static void asn_MBR_OffsetSystem_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_OffsetSystem_1$constants.SEGMENT, 0L, asn_MBR_OffsetSystem_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_OffsetSystem_1[2]
     * }
     */
    public static MemorySegment asn_MBR_OffsetSystem_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_OffsetSystem_1$constants.HANDLE.invokeExact(asn_MBR_OffsetSystem_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_OffsetSystem_1[2]
     * }
     */
    public static void asn_MBR_OffsetSystem_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_OffsetSystem_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef long Radius_B12_t
     * }
     */
    public static final OfLong Radius_B12_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_Radius_B12_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_Radius_B12_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Radius_B12_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_Radius_B12_constr_1$layout() {
        return asn_PER_type_Radius_B12_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Radius_B12_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_Radius_B12_constr_1() {
        return asn_PER_type_Radius_B12_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Radius_B12_constr_1
     * }
     */
    public static void asn_PER_type_Radius_B12_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_Radius_B12_constr_1$constants.SEGMENT, 0L, asn_PER_type_Radius_B12_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_Radius_B12$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_Radius_B12").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Radius_B12
     * }
     */
    public static GroupLayout asn_DEF_Radius_B12$layout() {
        return asn_DEF_Radius_B12$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Radius_B12
     * }
     */
    public static MemorySegment asn_DEF_Radius_B12() {
        return asn_DEF_Radius_B12$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Radius_B12
     * }
     */
    public static void asn_DEF_Radius_B12(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_Radius_B12$constants.SEGMENT, 0L, asn_DEF_Radius_B12$constants.LAYOUT.byteSize());
    }

    private static class Radius_B12_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_B12_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Radius_B12_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor Radius_B12_free$descriptor() {
        return Radius_B12_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Radius_B12_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle Radius_B12_free$handle() {
        return Radius_B12_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Radius_B12_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment Radius_B12_free$address() {
        return Radius_B12_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Radius_B12_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void Radius_B12_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = Radius_B12_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_B12_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_B12_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_B12_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Radius_B12_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Radius_B12_print$descriptor() {
        return Radius_B12_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Radius_B12_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Radius_B12_print$handle() {
        return Radius_B12_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Radius_B12_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Radius_B12_print$address() {
        return Radius_B12_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Radius_B12_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int Radius_B12_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Radius_B12_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_B12_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_B12_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_B12_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Radius_B12_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor Radius_B12_constraint$descriptor() {
        return Radius_B12_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Radius_B12_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle Radius_B12_constraint$handle() {
        return Radius_B12_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Radius_B12_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment Radius_B12_constraint$address() {
        return Radius_B12_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Radius_B12_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int Radius_B12_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Radius_B12_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_B12_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_B12_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_B12_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_B12_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor Radius_B12_decode_ber$descriptor() {
        return Radius_B12_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_B12_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle Radius_B12_decode_ber$handle() {
        return Radius_B12_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_B12_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Radius_B12_decode_ber$address() {
        return Radius_B12_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_B12_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Radius_B12_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = Radius_B12_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_B12_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_B12_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_B12_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Radius_B12_encode_der$descriptor() {
        return Radius_B12_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Radius_B12_encode_der$handle() {
        return Radius_B12_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Radius_B12_encode_der$address() {
        return Radius_B12_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Radius_B12_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Radius_B12_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_B12_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_B12_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_B12_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_B12_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Radius_B12_decode_xer$descriptor() {
        return Radius_B12_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_B12_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle Radius_B12_decode_xer$handle() {
        return Radius_B12_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_B12_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Radius_B12_decode_xer$address() {
        return Radius_B12_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_B12_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Radius_B12_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Radius_B12_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_B12_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_B12_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_B12_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Radius_B12_encode_xer$descriptor() {
        return Radius_B12_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Radius_B12_encode_xer$handle() {
        return Radius_B12_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Radius_B12_encode_xer$address() {
        return Radius_B12_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Radius_B12_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Radius_B12_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_B12_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_B12_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_B12_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Radius_B12_encode_jer$descriptor() {
        return Radius_B12_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Radius_B12_encode_jer$handle() {
        return Radius_B12_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Radius_B12_encode_jer$address() {
        return Radius_B12_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Radius_B12_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = Radius_B12_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_B12_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_B12_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_B12_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_B12_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Radius_B12_decode_oer$descriptor() {
        return Radius_B12_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_B12_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle Radius_B12_decode_oer$handle() {
        return Radius_B12_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_B12_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Radius_B12_decode_oer$address() {
        return Radius_B12_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_B12_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Radius_B12_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Radius_B12_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_B12_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_B12_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_B12_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Radius_B12_encode_oer$descriptor() {
        return Radius_B12_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Radius_B12_encode_oer$handle() {
        return Radius_B12_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Radius_B12_encode_oer$address() {
        return Radius_B12_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Radius_B12_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Radius_B12_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_B12_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_B12_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_B12_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_B12_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Radius_B12_decode_uper$descriptor() {
        return Radius_B12_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_B12_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Radius_B12_decode_uper$handle() {
        return Radius_B12_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_B12_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Radius_B12_decode_uper$address() {
        return Radius_B12_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_B12_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Radius_B12_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Radius_B12_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_B12_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_B12_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_B12_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Radius_B12_encode_uper$descriptor() {
        return Radius_B12_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Radius_B12_encode_uper$handle() {
        return Radius_B12_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Radius_B12_encode_uper$address() {
        return Radius_B12_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Radius_B12_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Radius_B12_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_B12_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_B12_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_B12_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_B12_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Radius_B12_decode_aper$descriptor() {
        return Radius_B12_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_B12_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Radius_B12_decode_aper$handle() {
        return Radius_B12_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_B12_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Radius_B12_decode_aper$address() {
        return Radius_B12_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_B12_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Radius_B12_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Radius_B12_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_B12_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_B12_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_B12_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Radius_B12_encode_aper$descriptor() {
        return Radius_B12_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Radius_B12_encode_aper$handle() {
        return Radius_B12_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Radius_B12_encode_aper$address() {
        return Radius_B12_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_B12_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Radius_B12_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Radius_B12_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_B12_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int DistanceUnits_centimeter = (int)0L;
    /**
     * {@snippet lang=c :
     * enum DistanceUnits.DistanceUnits_centimeter = 0
     * }
     */
    public static int DistanceUnits_centimeter() {
        return DistanceUnits_centimeter;
    }
    private static final int DistanceUnits_cm2_5 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum DistanceUnits.DistanceUnits_cm2_5 = 1
     * }
     */
    public static int DistanceUnits_cm2_5() {
        return DistanceUnits_cm2_5;
    }
    private static final int DistanceUnits_decimeter = (int)2L;
    /**
     * {@snippet lang=c :
     * enum DistanceUnits.DistanceUnits_decimeter = 2
     * }
     */
    public static int DistanceUnits_decimeter() {
        return DistanceUnits_decimeter;
    }
    private static final int DistanceUnits_meter = (int)3L;
    /**
     * {@snippet lang=c :
     * enum DistanceUnits.DistanceUnits_meter = 3
     * }
     */
    public static int DistanceUnits_meter() {
        return DistanceUnits_meter;
    }
    private static final int DistanceUnits_kilometer = (int)4L;
    /**
     * {@snippet lang=c :
     * enum DistanceUnits.DistanceUnits_kilometer = 4
     * }
     */
    public static int DistanceUnits_kilometer() {
        return DistanceUnits_kilometer;
    }
    private static final int DistanceUnits_foot = (int)5L;
    /**
     * {@snippet lang=c :
     * enum DistanceUnits.DistanceUnits_foot = 5
     * }
     */
    public static int DistanceUnits_foot() {
        return DistanceUnits_foot;
    }
    private static final int DistanceUnits_yard = (int)6L;
    /**
     * {@snippet lang=c :
     * enum DistanceUnits.DistanceUnits_yard = 6
     * }
     */
    public static int DistanceUnits_yard() {
        return DistanceUnits_yard;
    }
    private static final int DistanceUnits_mile = (int)7L;
    /**
     * {@snippet lang=c :
     * enum DistanceUnits.DistanceUnits_mile = 7
     * }
     */
    public static int DistanceUnits_mile() {
        return DistanceUnits_mile;
    }
    /**
     * {@snippet lang=c :
     * typedef long DistanceUnits_t
     * }
     */
    public static final OfLong DistanceUnits_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_DistanceUnits_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_DistanceUnits_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DistanceUnits_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_DistanceUnits_constr_1$layout() {
        return asn_PER_type_DistanceUnits_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DistanceUnits_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_DistanceUnits_constr_1() {
        return asn_PER_type_DistanceUnits_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DistanceUnits_constr_1
     * }
     */
    public static void asn_PER_type_DistanceUnits_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_DistanceUnits_constr_1$constants.SEGMENT, 0L, asn_PER_type_DistanceUnits_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_DistanceUnits$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_DistanceUnits").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DistanceUnits
     * }
     */
    public static GroupLayout asn_DEF_DistanceUnits$layout() {
        return asn_DEF_DistanceUnits$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DistanceUnits
     * }
     */
    public static MemorySegment asn_DEF_DistanceUnits() {
        return asn_DEF_DistanceUnits$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DistanceUnits
     * }
     */
    public static void asn_DEF_DistanceUnits(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_DistanceUnits$constants.SEGMENT, 0L, asn_DEF_DistanceUnits$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_DistanceUnits_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_DistanceUnits_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_DistanceUnits_specs_1
     * }
     */
    public static GroupLayout asn_SPC_DistanceUnits_specs_1$layout() {
        return asn_SPC_DistanceUnits_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_DistanceUnits_specs_1
     * }
     */
    public static MemorySegment asn_SPC_DistanceUnits_specs_1() {
        return asn_SPC_DistanceUnits_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_DistanceUnits_specs_1
     * }
     */
    public static void asn_SPC_DistanceUnits_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_DistanceUnits_specs_1$constants.SEGMENT, 0L, asn_SPC_DistanceUnits_specs_1$constants.LAYOUT.byteSize());
    }

    private static class DistanceUnits_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DistanceUnits_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DistanceUnits_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor DistanceUnits_free$descriptor() {
        return DistanceUnits_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DistanceUnits_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle DistanceUnits_free$handle() {
        return DistanceUnits_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DistanceUnits_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment DistanceUnits_free$address() {
        return DistanceUnits_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DistanceUnits_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void DistanceUnits_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = DistanceUnits_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DistanceUnits_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DistanceUnits_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DistanceUnits_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DistanceUnits_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DistanceUnits_print$descriptor() {
        return DistanceUnits_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DistanceUnits_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DistanceUnits_print$handle() {
        return DistanceUnits_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DistanceUnits_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DistanceUnits_print$address() {
        return DistanceUnits_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DistanceUnits_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int DistanceUnits_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DistanceUnits_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DistanceUnits_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DistanceUnits_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DistanceUnits_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DistanceUnits_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor DistanceUnits_constraint$descriptor() {
        return DistanceUnits_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DistanceUnits_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle DistanceUnits_constraint$handle() {
        return DistanceUnits_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DistanceUnits_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment DistanceUnits_constraint$address() {
        return DistanceUnits_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DistanceUnits_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int DistanceUnits_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DistanceUnits_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DistanceUnits_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DistanceUnits_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DistanceUnits_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DistanceUnits_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor DistanceUnits_decode_ber$descriptor() {
        return DistanceUnits_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DistanceUnits_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle DistanceUnits_decode_ber$handle() {
        return DistanceUnits_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DistanceUnits_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DistanceUnits_decode_ber$address() {
        return DistanceUnits_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DistanceUnits_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DistanceUnits_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = DistanceUnits_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DistanceUnits_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DistanceUnits_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DistanceUnits_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DistanceUnits_encode_der$descriptor() {
        return DistanceUnits_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DistanceUnits_encode_der$handle() {
        return DistanceUnits_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DistanceUnits_encode_der$address() {
        return DistanceUnits_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DistanceUnits_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DistanceUnits_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DistanceUnits_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DistanceUnits_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DistanceUnits_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DistanceUnits_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DistanceUnits_decode_xer$descriptor() {
        return DistanceUnits_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DistanceUnits_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle DistanceUnits_decode_xer$handle() {
        return DistanceUnits_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DistanceUnits_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DistanceUnits_decode_xer$address() {
        return DistanceUnits_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DistanceUnits_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DistanceUnits_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DistanceUnits_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DistanceUnits_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DistanceUnits_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DistanceUnits_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DistanceUnits_encode_xer$descriptor() {
        return DistanceUnits_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DistanceUnits_encode_xer$handle() {
        return DistanceUnits_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DistanceUnits_encode_xer$address() {
        return DistanceUnits_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DistanceUnits_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DistanceUnits_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DistanceUnits_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DistanceUnits_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DistanceUnits_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DistanceUnits_encode_jer$descriptor() {
        return DistanceUnits_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DistanceUnits_encode_jer$handle() {
        return DistanceUnits_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DistanceUnits_encode_jer$address() {
        return DistanceUnits_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DistanceUnits_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = DistanceUnits_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DistanceUnits_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DistanceUnits_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DistanceUnits_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DistanceUnits_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DistanceUnits_decode_oer$descriptor() {
        return DistanceUnits_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DistanceUnits_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle DistanceUnits_decode_oer$handle() {
        return DistanceUnits_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DistanceUnits_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DistanceUnits_decode_oer$address() {
        return DistanceUnits_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DistanceUnits_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DistanceUnits_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DistanceUnits_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DistanceUnits_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DistanceUnits_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DistanceUnits_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DistanceUnits_encode_oer$descriptor() {
        return DistanceUnits_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DistanceUnits_encode_oer$handle() {
        return DistanceUnits_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DistanceUnits_encode_oer$address() {
        return DistanceUnits_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DistanceUnits_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DistanceUnits_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DistanceUnits_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DistanceUnits_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DistanceUnits_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DistanceUnits_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DistanceUnits_decode_uper$descriptor() {
        return DistanceUnits_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DistanceUnits_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DistanceUnits_decode_uper$handle() {
        return DistanceUnits_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DistanceUnits_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DistanceUnits_decode_uper$address() {
        return DistanceUnits_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DistanceUnits_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DistanceUnits_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DistanceUnits_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DistanceUnits_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DistanceUnits_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DistanceUnits_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DistanceUnits_encode_uper$descriptor() {
        return DistanceUnits_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DistanceUnits_encode_uper$handle() {
        return DistanceUnits_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DistanceUnits_encode_uper$address() {
        return DistanceUnits_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DistanceUnits_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DistanceUnits_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DistanceUnits_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DistanceUnits_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DistanceUnits_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DistanceUnits_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DistanceUnits_decode_aper$descriptor() {
        return DistanceUnits_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DistanceUnits_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DistanceUnits_decode_aper$handle() {
        return DistanceUnits_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DistanceUnits_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DistanceUnits_decode_aper$address() {
        return DistanceUnits_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DistanceUnits_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DistanceUnits_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DistanceUnits_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DistanceUnits_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DistanceUnits_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DistanceUnits_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DistanceUnits_encode_aper$descriptor() {
        return DistanceUnits_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DistanceUnits_encode_aper$handle() {
        return DistanceUnits_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DistanceUnits_encode_aper$address() {
        return DistanceUnits_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DistanceUnits_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DistanceUnits_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DistanceUnits_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DistanceUnits_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_Circle$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_Circle").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Circle
     * }
     */
    public static GroupLayout asn_DEF_Circle$layout() {
        return asn_DEF_Circle$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Circle
     * }
     */
    public static MemorySegment asn_DEF_Circle() {
        return asn_DEF_Circle$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Circle
     * }
     */
    public static void asn_DEF_Circle(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_Circle$constants.SEGMENT, 0L, asn_DEF_Circle$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_Circle_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_Circle_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Circle_specs_1
     * }
     */
    public static GroupLayout asn_SPC_Circle_specs_1$layout() {
        return asn_SPC_Circle_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Circle_specs_1
     * }
     */
    public static MemorySegment asn_SPC_Circle_specs_1() {
        return asn_SPC_Circle_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Circle_specs_1
     * }
     */
    public static void asn_SPC_Circle_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_Circle_specs_1$constants.SEGMENT, 0L, asn_SPC_Circle_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_Circle_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(3, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_Circle_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 3 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Circle_1[3]
     * }
     */
    public static SequenceLayout asn_MBR_Circle_1$layout() {
        return asn_MBR_Circle_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Circle_1[3]
     * }
     */
    public static long[] asn_MBR_Circle_1$dimensions() {
        return asn_MBR_Circle_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Circle_1[3]
     * }
     */
    public static MemorySegment asn_MBR_Circle_1() {
        return asn_MBR_Circle_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Circle_1[3]
     * }
     */
    public static void asn_MBR_Circle_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_Circle_1$constants.SEGMENT, 0L, asn_MBR_Circle_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Circle_1[3]
     * }
     */
    public static MemorySegment asn_MBR_Circle_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_Circle_1$constants.HANDLE.invokeExact(asn_MBR_Circle_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Circle_1[3]
     * }
     */
    public static void asn_MBR_Circle_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_Circle_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_GeometricProjection$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_GeometricProjection").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_GeometricProjection
     * }
     */
    public static GroupLayout asn_DEF_GeometricProjection$layout() {
        return asn_DEF_GeometricProjection$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_GeometricProjection
     * }
     */
    public static MemorySegment asn_DEF_GeometricProjection() {
        return asn_DEF_GeometricProjection$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_GeometricProjection
     * }
     */
    public static void asn_DEF_GeometricProjection(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_GeometricProjection$constants.SEGMENT, 0L, asn_DEF_GeometricProjection$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_GeometricProjection_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_GeometricProjection_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_GeometricProjection_specs_1
     * }
     */
    public static GroupLayout asn_SPC_GeometricProjection_specs_1$layout() {
        return asn_SPC_GeometricProjection_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_GeometricProjection_specs_1
     * }
     */
    public static MemorySegment asn_SPC_GeometricProjection_specs_1() {
        return asn_SPC_GeometricProjection_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_GeometricProjection_specs_1
     * }
     */
    public static void asn_SPC_GeometricProjection_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_GeometricProjection_specs_1$constants.SEGMENT, 0L, asn_SPC_GeometricProjection_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_GeometricProjection_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(5, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_GeometricProjection_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 5 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_GeometricProjection_1[5]
     * }
     */
    public static SequenceLayout asn_MBR_GeometricProjection_1$layout() {
        return asn_MBR_GeometricProjection_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_GeometricProjection_1[5]
     * }
     */
    public static long[] asn_MBR_GeometricProjection_1$dimensions() {
        return asn_MBR_GeometricProjection_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_GeometricProjection_1[5]
     * }
     */
    public static MemorySegment asn_MBR_GeometricProjection_1() {
        return asn_MBR_GeometricProjection_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_GeometricProjection_1[5]
     * }
     */
    public static void asn_MBR_GeometricProjection_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_GeometricProjection_1$constants.SEGMENT, 0L, asn_MBR_GeometricProjection_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_GeometricProjection_1[5]
     * }
     */
    public static MemorySegment asn_MBR_GeometricProjection_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_GeometricProjection_1$constants.HANDLE.invokeExact(asn_MBR_GeometricProjection_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_GeometricProjection_1[5]
     * }
     */
    public static void asn_MBR_GeometricProjection_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_GeometricProjection_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_ShapePointSet$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_ShapePointSet").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ShapePointSet
     * }
     */
    public static GroupLayout asn_DEF_ShapePointSet$layout() {
        return asn_DEF_ShapePointSet$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ShapePointSet
     * }
     */
    public static MemorySegment asn_DEF_ShapePointSet() {
        return asn_DEF_ShapePointSet$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ShapePointSet
     * }
     */
    public static void asn_DEF_ShapePointSet(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_ShapePointSet$constants.SEGMENT, 0L, asn_DEF_ShapePointSet$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_ShapePointSet_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_ShapePointSet_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_ShapePointSet_specs_1
     * }
     */
    public static GroupLayout asn_SPC_ShapePointSet_specs_1$layout() {
        return asn_SPC_ShapePointSet_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_ShapePointSet_specs_1
     * }
     */
    public static MemorySegment asn_SPC_ShapePointSet_specs_1() {
        return asn_SPC_ShapePointSet_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_ShapePointSet_specs_1
     * }
     */
    public static void asn_SPC_ShapePointSet_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_ShapePointSet_specs_1$constants.SEGMENT, 0L, asn_SPC_ShapePointSet_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_ShapePointSet_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(4, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_ShapePointSet_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 4 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ShapePointSet_1[4]
     * }
     */
    public static SequenceLayout asn_MBR_ShapePointSet_1$layout() {
        return asn_MBR_ShapePointSet_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ShapePointSet_1[4]
     * }
     */
    public static long[] asn_MBR_ShapePointSet_1$dimensions() {
        return asn_MBR_ShapePointSet_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ShapePointSet_1[4]
     * }
     */
    public static MemorySegment asn_MBR_ShapePointSet_1() {
        return asn_MBR_ShapePointSet_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ShapePointSet_1[4]
     * }
     */
    public static void asn_MBR_ShapePointSet_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_ShapePointSet_1$constants.SEGMENT, 0L, asn_MBR_ShapePointSet_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ShapePointSet_1[4]
     * }
     */
    public static MemorySegment asn_MBR_ShapePointSet_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_ShapePointSet_1$constants.HANDLE.invokeExact(asn_MBR_ShapePointSet_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ShapePointSet_1[4]
     * }
     */
    public static void asn_MBR_ShapePointSet_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_ShapePointSet_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_RegionList$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_RegionList").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RegionList
     * }
     */
    public static GroupLayout asn_DEF_RegionList$layout() {
        return asn_DEF_RegionList$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RegionList
     * }
     */
    public static MemorySegment asn_DEF_RegionList() {
        return asn_DEF_RegionList$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RegionList
     * }
     */
    public static void asn_DEF_RegionList(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_RegionList$constants.SEGMENT, 0L, asn_DEF_RegionList$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_RegionList_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SET_OF_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_RegionList_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_RegionList_specs_1
     * }
     */
    public static GroupLayout asn_SPC_RegionList_specs_1$layout() {
        return asn_SPC_RegionList_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_RegionList_specs_1
     * }
     */
    public static MemorySegment asn_SPC_RegionList_specs_1() {
        return asn_SPC_RegionList_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_RegionList_specs_1
     * }
     */
    public static void asn_SPC_RegionList_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_RegionList_specs_1$constants.SEGMENT, 0L, asn_SPC_RegionList_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_RegionList_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(1, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_RegionList_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 1 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionList_1[1]
     * }
     */
    public static SequenceLayout asn_MBR_RegionList_1$layout() {
        return asn_MBR_RegionList_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionList_1[1]
     * }
     */
    public static long[] asn_MBR_RegionList_1$dimensions() {
        return asn_MBR_RegionList_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_RegionList_1() {
        return asn_MBR_RegionList_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionList_1[1]
     * }
     */
    public static void asn_MBR_RegionList_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RegionList_1$constants.SEGMENT, 0L, asn_MBR_RegionList_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_RegionList_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_RegionList_1$constants.HANDLE.invokeExact(asn_MBR_RegionList_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionList_1[1]
     * }
     */
    public static void asn_MBR_RegionList_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RegionList_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_RegionList_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_RegionList_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RegionList_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_RegionList_constr_1$layout() {
        return asn_PER_type_RegionList_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RegionList_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_RegionList_constr_1() {
        return asn_PER_type_RegionList_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RegionList_constr_1
     * }
     */
    public static void asn_PER_type_RegionList_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_RegionList_constr_1$constants.SEGMENT, 0L, asn_PER_type_RegionList_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_RegionOffsets$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_RegionOffsets").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RegionOffsets
     * }
     */
    public static GroupLayout asn_DEF_RegionOffsets$layout() {
        return asn_DEF_RegionOffsets$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RegionOffsets
     * }
     */
    public static MemorySegment asn_DEF_RegionOffsets() {
        return asn_DEF_RegionOffsets$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RegionOffsets
     * }
     */
    public static void asn_DEF_RegionOffsets(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_RegionOffsets$constants.SEGMENT, 0L, asn_DEF_RegionOffsets$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_RegionOffsets_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_RegionOffsets_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RegionOffsets_specs_1
     * }
     */
    public static GroupLayout asn_SPC_RegionOffsets_specs_1$layout() {
        return asn_SPC_RegionOffsets_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RegionOffsets_specs_1
     * }
     */
    public static MemorySegment asn_SPC_RegionOffsets_specs_1() {
        return asn_SPC_RegionOffsets_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RegionOffsets_specs_1
     * }
     */
    public static void asn_SPC_RegionOffsets_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_RegionOffsets_specs_1$constants.SEGMENT, 0L, asn_SPC_RegionOffsets_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_RegionOffsets_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(3, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_RegionOffsets_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 3 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionOffsets_1[3]
     * }
     */
    public static SequenceLayout asn_MBR_RegionOffsets_1$layout() {
        return asn_MBR_RegionOffsets_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionOffsets_1[3]
     * }
     */
    public static long[] asn_MBR_RegionOffsets_1$dimensions() {
        return asn_MBR_RegionOffsets_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionOffsets_1[3]
     * }
     */
    public static MemorySegment asn_MBR_RegionOffsets_1() {
        return asn_MBR_RegionOffsets_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionOffsets_1[3]
     * }
     */
    public static void asn_MBR_RegionOffsets_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RegionOffsets_1$constants.SEGMENT, 0L, asn_MBR_RegionOffsets_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionOffsets_1[3]
     * }
     */
    public static MemorySegment asn_MBR_RegionOffsets_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_RegionOffsets_1$constants.HANDLE.invokeExact(asn_MBR_RegionOffsets_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionOffsets_1[3]
     * }
     */
    public static void asn_MBR_RegionOffsets_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RegionOffsets_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_RegionPointSet$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_RegionPointSet").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RegionPointSet
     * }
     */
    public static GroupLayout asn_DEF_RegionPointSet$layout() {
        return asn_DEF_RegionPointSet$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RegionPointSet
     * }
     */
    public static MemorySegment asn_DEF_RegionPointSet() {
        return asn_DEF_RegionPointSet$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RegionPointSet
     * }
     */
    public static void asn_DEF_RegionPointSet(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_RegionPointSet$constants.SEGMENT, 0L, asn_DEF_RegionPointSet$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_RegionPointSet_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_RegionPointSet_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RegionPointSet_specs_1
     * }
     */
    public static GroupLayout asn_SPC_RegionPointSet_specs_1$layout() {
        return asn_SPC_RegionPointSet_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RegionPointSet_specs_1
     * }
     */
    public static MemorySegment asn_SPC_RegionPointSet_specs_1() {
        return asn_SPC_RegionPointSet_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RegionPointSet_specs_1
     * }
     */
    public static void asn_SPC_RegionPointSet_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_RegionPointSet_specs_1$constants.SEGMENT, 0L, asn_SPC_RegionPointSet_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_RegionPointSet_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(3, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_RegionPointSet_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 3 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionPointSet_1[3]
     * }
     */
    public static SequenceLayout asn_MBR_RegionPointSet_1$layout() {
        return asn_MBR_RegionPointSet_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionPointSet_1[3]
     * }
     */
    public static long[] asn_MBR_RegionPointSet_1$dimensions() {
        return asn_MBR_RegionPointSet_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionPointSet_1[3]
     * }
     */
    public static MemorySegment asn_MBR_RegionPointSet_1() {
        return asn_MBR_RegionPointSet_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionPointSet_1[3]
     * }
     */
    public static void asn_MBR_RegionPointSet_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RegionPointSet_1$constants.SEGMENT, 0L, asn_MBR_RegionPointSet_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionPointSet_1[3]
     * }
     */
    public static MemorySegment asn_MBR_RegionPointSet_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_RegionPointSet_1$constants.HANDLE.invokeExact(asn_MBR_RegionPointSet_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionPointSet_1[3]
     * }
     */
    public static void asn_MBR_RegionPointSet_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RegionPointSet_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    private static final int ValidRegion__area_PR_NOTHING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ValidRegion__area_PR.ValidRegion__area_PR_NOTHING = 0
     * }
     */
    public static int ValidRegion__area_PR_NOTHING() {
        return ValidRegion__area_PR_NOTHING;
    }
    private static final int ValidRegion__area_PR_shapePointSet = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ValidRegion__area_PR.ValidRegion__area_PR_shapePointSet = 1
     * }
     */
    public static int ValidRegion__area_PR_shapePointSet() {
        return ValidRegion__area_PR_shapePointSet;
    }
    private static final int ValidRegion__area_PR_circle = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ValidRegion__area_PR.ValidRegion__area_PR_circle = 2
     * }
     */
    public static int ValidRegion__area_PR_circle() {
        return ValidRegion__area_PR_circle;
    }
    private static final int ValidRegion__area_PR_regionPointSet = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ValidRegion__area_PR.ValidRegion__area_PR_regionPointSet = 3
     * }
     */
    public static int ValidRegion__area_PR_regionPointSet() {
        return ValidRegion__area_PR_regionPointSet;
    }

    private static class asn_DEF_ValidRegion$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_ValidRegion").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ValidRegion
     * }
     */
    public static GroupLayout asn_DEF_ValidRegion$layout() {
        return asn_DEF_ValidRegion$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ValidRegion
     * }
     */
    public static MemorySegment asn_DEF_ValidRegion() {
        return asn_DEF_ValidRegion$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ValidRegion
     * }
     */
    public static void asn_DEF_ValidRegion(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_ValidRegion$constants.SEGMENT, 0L, asn_DEF_ValidRegion$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_ValidRegion_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_ValidRegion_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_ValidRegion_specs_1
     * }
     */
    public static GroupLayout asn_SPC_ValidRegion_specs_1$layout() {
        return asn_SPC_ValidRegion_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_ValidRegion_specs_1
     * }
     */
    public static MemorySegment asn_SPC_ValidRegion_specs_1() {
        return asn_SPC_ValidRegion_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_ValidRegion_specs_1
     * }
     */
    public static void asn_SPC_ValidRegion_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_ValidRegion_specs_1$constants.SEGMENT, 0L, asn_SPC_ValidRegion_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_ValidRegion_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(3, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_ValidRegion_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 3 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ValidRegion_1[3]
     * }
     */
    public static SequenceLayout asn_MBR_ValidRegion_1$layout() {
        return asn_MBR_ValidRegion_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ValidRegion_1[3]
     * }
     */
    public static long[] asn_MBR_ValidRegion_1$dimensions() {
        return asn_MBR_ValidRegion_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ValidRegion_1[3]
     * }
     */
    public static MemorySegment asn_MBR_ValidRegion_1() {
        return asn_MBR_ValidRegion_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ValidRegion_1[3]
     * }
     */
    public static void asn_MBR_ValidRegion_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_ValidRegion_1$constants.SEGMENT, 0L, asn_MBR_ValidRegion_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ValidRegion_1[3]
     * }
     */
    public static MemorySegment asn_MBR_ValidRegion_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_ValidRegion_1$constants.HANDLE.invokeExact(asn_MBR_ValidRegion_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ValidRegion_1[3]
     * }
     */
    public static void asn_MBR_ValidRegion_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_ValidRegion_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    private static final int GeographicalPath__description_PR_NOTHING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum GeographicalPath__description_PR.GeographicalPath__description_PR_NOTHING = 0
     * }
     */
    public static int GeographicalPath__description_PR_NOTHING() {
        return GeographicalPath__description_PR_NOTHING;
    }
    private static final int GeographicalPath__description_PR_path = (int)1L;
    /**
     * {@snippet lang=c :
     * enum GeographicalPath__description_PR.GeographicalPath__description_PR_path = 1
     * }
     */
    public static int GeographicalPath__description_PR_path() {
        return GeographicalPath__description_PR_path;
    }
    private static final int GeographicalPath__description_PR_geometry = (int)2L;
    /**
     * {@snippet lang=c :
     * enum GeographicalPath__description_PR.GeographicalPath__description_PR_geometry = 2
     * }
     */
    public static int GeographicalPath__description_PR_geometry() {
        return GeographicalPath__description_PR_geometry;
    }
    private static final int GeographicalPath__description_PR_oldRegion = (int)3L;
    /**
     * {@snippet lang=c :
     * enum GeographicalPath__description_PR.GeographicalPath__description_PR_oldRegion = 3
     * }
     */
    public static int GeographicalPath__description_PR_oldRegion() {
        return GeographicalPath__description_PR_oldRegion;
    }

    private static class asn_DEF_GeographicalPath$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_GeographicalPath").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_GeographicalPath
     * }
     */
    public static GroupLayout asn_DEF_GeographicalPath$layout() {
        return asn_DEF_GeographicalPath$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_GeographicalPath
     * }
     */
    public static MemorySegment asn_DEF_GeographicalPath() {
        return asn_DEF_GeographicalPath$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_GeographicalPath
     * }
     */
    public static void asn_DEF_GeographicalPath(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_GeographicalPath$constants.SEGMENT, 0L, asn_DEF_GeographicalPath$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_GeographicalPath_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_GeographicalPath_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_GeographicalPath_specs_1
     * }
     */
    public static GroupLayout asn_SPC_GeographicalPath_specs_1$layout() {
        return asn_SPC_GeographicalPath_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_GeographicalPath_specs_1
     * }
     */
    public static MemorySegment asn_SPC_GeographicalPath_specs_1() {
        return asn_SPC_GeographicalPath_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_GeographicalPath_specs_1
     * }
     */
    public static void asn_SPC_GeographicalPath_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_GeographicalPath_specs_1$constants.SEGMENT, 0L, asn_SPC_GeographicalPath_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_GeographicalPath_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(9, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_GeographicalPath_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 9 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_GeographicalPath_1[9]
     * }
     */
    public static SequenceLayout asn_MBR_GeographicalPath_1$layout() {
        return asn_MBR_GeographicalPath_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_GeographicalPath_1[9]
     * }
     */
    public static long[] asn_MBR_GeographicalPath_1$dimensions() {
        return asn_MBR_GeographicalPath_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_GeographicalPath_1[9]
     * }
     */
    public static MemorySegment asn_MBR_GeographicalPath_1() {
        return asn_MBR_GeographicalPath_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_GeographicalPath_1[9]
     * }
     */
    public static void asn_MBR_GeographicalPath_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_GeographicalPath_1$constants.SEGMENT, 0L, asn_MBR_GeographicalPath_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_GeographicalPath_1[9]
     * }
     */
    public static MemorySegment asn_MBR_GeographicalPath_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_GeographicalPath_1$constants.HANDLE.invokeExact(asn_MBR_GeographicalPath_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_GeographicalPath_1[9]
     * }
     */
    public static void asn_MBR_GeographicalPath_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_GeographicalPath_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_TravelerInformation$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_TravelerInformation").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TravelerInformation
     * }
     */
    public static GroupLayout asn_DEF_TravelerInformation$layout() {
        return asn_DEF_TravelerInformation$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TravelerInformation
     * }
     */
    public static MemorySegment asn_DEF_TravelerInformation() {
        return asn_DEF_TravelerInformation$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TravelerInformation
     * }
     */
    public static void asn_DEF_TravelerInformation(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_TravelerInformation$constants.SEGMENT, 0L, asn_DEF_TravelerInformation$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_TravelerInformation_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_TravelerInformation_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_TravelerInformation_specs_1
     * }
     */
    public static GroupLayout asn_SPC_TravelerInformation_specs_1$layout() {
        return asn_SPC_TravelerInformation_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_TravelerInformation_specs_1
     * }
     */
    public static MemorySegment asn_SPC_TravelerInformation_specs_1() {
        return asn_SPC_TravelerInformation_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_TravelerInformation_specs_1
     * }
     */
    public static void asn_SPC_TravelerInformation_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_TravelerInformation_specs_1$constants.SEGMENT, 0L, asn_SPC_TravelerInformation_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_TravelerInformation_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(6, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_TravelerInformation_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 6 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TravelerInformation_1[6]
     * }
     */
    public static SequenceLayout asn_MBR_TravelerInformation_1$layout() {
        return asn_MBR_TravelerInformation_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TravelerInformation_1[6]
     * }
     */
    public static long[] asn_MBR_TravelerInformation_1$dimensions() {
        return asn_MBR_TravelerInformation_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TravelerInformation_1[6]
     * }
     */
    public static MemorySegment asn_MBR_TravelerInformation_1() {
        return asn_MBR_TravelerInformation_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TravelerInformation_1[6]
     * }
     */
    public static void asn_MBR_TravelerInformation_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_TravelerInformation_1$constants.SEGMENT, 0L, asn_MBR_TravelerInformation_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TravelerInformation_1[6]
     * }
     */
    public static MemorySegment asn_MBR_TravelerInformation_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_TravelerInformation_1$constants.HANDLE.invokeExact(asn_MBR_TravelerInformation_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TravelerInformation_1[6]
     * }
     */
    public static void asn_MBR_TravelerInformation_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_TravelerInformation_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    private static final int PersonalDeviceUserType_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum PersonalDeviceUserType.PersonalDeviceUserType_unavailable = 0
     * }
     */
    public static int PersonalDeviceUserType_unavailable() {
        return PersonalDeviceUserType_unavailable;
    }
    private static final int PersonalDeviceUserType_aPEDESTRIAN = (int)1L;
    /**
     * {@snippet lang=c :
     * enum PersonalDeviceUserType.PersonalDeviceUserType_aPEDESTRIAN = 1
     * }
     */
    public static int PersonalDeviceUserType_aPEDESTRIAN() {
        return PersonalDeviceUserType_aPEDESTRIAN;
    }
    private static final int PersonalDeviceUserType_aPEDALCYCLIST = (int)2L;
    /**
     * {@snippet lang=c :
     * enum PersonalDeviceUserType.PersonalDeviceUserType_aPEDALCYCLIST = 2
     * }
     */
    public static int PersonalDeviceUserType_aPEDALCYCLIST() {
        return PersonalDeviceUserType_aPEDALCYCLIST;
    }
    private static final int PersonalDeviceUserType_aPUBLICSAFETYWORKER = (int)3L;
    /**
     * {@snippet lang=c :
     * enum PersonalDeviceUserType.PersonalDeviceUserType_aPUBLICSAFETYWORKER = 3
     * }
     */
    public static int PersonalDeviceUserType_aPUBLICSAFETYWORKER() {
        return PersonalDeviceUserType_aPUBLICSAFETYWORKER;
    }
    private static final int PersonalDeviceUserType_anANIMAL = (int)4L;
    /**
     * {@snippet lang=c :
     * enum PersonalDeviceUserType.PersonalDeviceUserType_anANIMAL = 4
     * }
     */
    public static int PersonalDeviceUserType_anANIMAL() {
        return PersonalDeviceUserType_anANIMAL;
    }
    /**
     * {@snippet lang=c :
     * typedef long PersonalDeviceUserType_t
     * }
     */
    public static final OfLong PersonalDeviceUserType_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_PersonalDeviceUserType_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_PersonalDeviceUserType_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PersonalDeviceUserType_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_PersonalDeviceUserType_constr_1$layout() {
        return asn_PER_type_PersonalDeviceUserType_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PersonalDeviceUserType_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_PersonalDeviceUserType_constr_1() {
        return asn_PER_type_PersonalDeviceUserType_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PersonalDeviceUserType_constr_1
     * }
     */
    public static void asn_PER_type_PersonalDeviceUserType_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_PersonalDeviceUserType_constr_1$constants.SEGMENT, 0L, asn_PER_type_PersonalDeviceUserType_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_PersonalDeviceUserType$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_PersonalDeviceUserType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PersonalDeviceUserType
     * }
     */
    public static GroupLayout asn_DEF_PersonalDeviceUserType$layout() {
        return asn_DEF_PersonalDeviceUserType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PersonalDeviceUserType
     * }
     */
    public static MemorySegment asn_DEF_PersonalDeviceUserType() {
        return asn_DEF_PersonalDeviceUserType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PersonalDeviceUserType
     * }
     */
    public static void asn_DEF_PersonalDeviceUserType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_PersonalDeviceUserType$constants.SEGMENT, 0L, asn_DEF_PersonalDeviceUserType$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_PersonalDeviceUserType_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_PersonalDeviceUserType_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_PersonalDeviceUserType_specs_1
     * }
     */
    public static GroupLayout asn_SPC_PersonalDeviceUserType_specs_1$layout() {
        return asn_SPC_PersonalDeviceUserType_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_PersonalDeviceUserType_specs_1
     * }
     */
    public static MemorySegment asn_SPC_PersonalDeviceUserType_specs_1() {
        return asn_SPC_PersonalDeviceUserType_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_PersonalDeviceUserType_specs_1
     * }
     */
    public static void asn_SPC_PersonalDeviceUserType_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_PersonalDeviceUserType_specs_1$constants.SEGMENT, 0L, asn_SPC_PersonalDeviceUserType_specs_1$constants.LAYOUT.byteSize());
    }

    private static class PersonalDeviceUserType_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUserType_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PersonalDeviceUserType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUserType_free$descriptor() {
        return PersonalDeviceUserType_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PersonalDeviceUserType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle PersonalDeviceUserType_free$handle() {
        return PersonalDeviceUserType_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PersonalDeviceUserType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_free$address() {
        return PersonalDeviceUserType_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PersonalDeviceUserType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void PersonalDeviceUserType_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PersonalDeviceUserType_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUserType_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUserType_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUserType_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PersonalDeviceUserType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUserType_print$descriptor() {
        return PersonalDeviceUserType_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PersonalDeviceUserType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalDeviceUserType_print$handle() {
        return PersonalDeviceUserType_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PersonalDeviceUserType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_print$address() {
        return PersonalDeviceUserType_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PersonalDeviceUserType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int PersonalDeviceUserType_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalDeviceUserType_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUserType_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUserType_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUserType_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PersonalDeviceUserType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUserType_constraint$descriptor() {
        return PersonalDeviceUserType_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PersonalDeviceUserType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle PersonalDeviceUserType_constraint$handle() {
        return PersonalDeviceUserType_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PersonalDeviceUserType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_constraint$address() {
        return PersonalDeviceUserType_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PersonalDeviceUserType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int PersonalDeviceUserType_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PersonalDeviceUserType_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUserType_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUserType_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUserType_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUserType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUserType_decode_ber$descriptor() {
        return PersonalDeviceUserType_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUserType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle PersonalDeviceUserType_decode_ber$handle() {
        return PersonalDeviceUserType_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUserType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_decode_ber$address() {
        return PersonalDeviceUserType_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUserType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = PersonalDeviceUserType_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUserType_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUserType_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUserType_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUserType_encode_der$descriptor() {
        return PersonalDeviceUserType_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalDeviceUserType_encode_der$handle() {
        return PersonalDeviceUserType_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_encode_der$address() {
        return PersonalDeviceUserType_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PersonalDeviceUserType_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUserType_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUserType_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUserType_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUserType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUserType_decode_xer$descriptor() {
        return PersonalDeviceUserType_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUserType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle PersonalDeviceUserType_decode_xer$handle() {
        return PersonalDeviceUserType_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUserType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_decode_xer$address() {
        return PersonalDeviceUserType_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUserType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = PersonalDeviceUserType_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUserType_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUserType_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUserType_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUserType_encode_xer$descriptor() {
        return PersonalDeviceUserType_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalDeviceUserType_encode_xer$handle() {
        return PersonalDeviceUserType_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_encode_xer$address() {
        return PersonalDeviceUserType_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PersonalDeviceUserType_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUserType_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUserType_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUserType_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUserType_encode_jer$descriptor() {
        return PersonalDeviceUserType_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalDeviceUserType_encode_jer$handle() {
        return PersonalDeviceUserType_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_encode_jer$address() {
        return PersonalDeviceUserType_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = PersonalDeviceUserType_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUserType_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUserType_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUserType_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUserType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUserType_decode_oer$descriptor() {
        return PersonalDeviceUserType_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUserType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle PersonalDeviceUserType_decode_oer$handle() {
        return PersonalDeviceUserType_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUserType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_decode_oer$address() {
        return PersonalDeviceUserType_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUserType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = PersonalDeviceUserType_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUserType_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUserType_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUserType_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUserType_encode_oer$descriptor() {
        return PersonalDeviceUserType_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalDeviceUserType_encode_oer$handle() {
        return PersonalDeviceUserType_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_encode_oer$address() {
        return PersonalDeviceUserType_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalDeviceUserType_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUserType_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUserType_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUserType_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUserType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUserType_decode_uper$descriptor() {
        return PersonalDeviceUserType_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUserType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle PersonalDeviceUserType_decode_uper$handle() {
        return PersonalDeviceUserType_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUserType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_decode_uper$address() {
        return PersonalDeviceUserType_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUserType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalDeviceUserType_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUserType_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUserType_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUserType_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUserType_encode_uper$descriptor() {
        return PersonalDeviceUserType_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle PersonalDeviceUserType_encode_uper$handle() {
        return PersonalDeviceUserType_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_encode_uper$address() {
        return PersonalDeviceUserType_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PersonalDeviceUserType_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUserType_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUserType_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUserType_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUserType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUserType_decode_aper$descriptor() {
        return PersonalDeviceUserType_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUserType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle PersonalDeviceUserType_decode_aper$handle() {
        return PersonalDeviceUserType_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUserType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_decode_aper$address() {
        return PersonalDeviceUserType_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUserType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalDeviceUserType_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUserType_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUserType_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUserType_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUserType_encode_aper$descriptor() {
        return PersonalDeviceUserType_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle PersonalDeviceUserType_encode_aper$handle() {
        return PersonalDeviceUserType_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_encode_aper$address() {
        return PersonalDeviceUserType_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUserType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalDeviceUserType_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PersonalDeviceUserType_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUserType_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PersonalDeviceUsageState_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum PersonalDeviceUsageState.PersonalDeviceUsageState_unavailable = 0
     * }
     */
    public static int PersonalDeviceUsageState_unavailable() {
        return PersonalDeviceUsageState_unavailable;
    }
    private static final int PersonalDeviceUsageState_other = (int)1L;
    /**
     * {@snippet lang=c :
     * enum PersonalDeviceUsageState.PersonalDeviceUsageState_other = 1
     * }
     */
    public static int PersonalDeviceUsageState_other() {
        return PersonalDeviceUsageState_other;
    }
    private static final int PersonalDeviceUsageState_idle = (int)2L;
    /**
     * {@snippet lang=c :
     * enum PersonalDeviceUsageState.PersonalDeviceUsageState_idle = 2
     * }
     */
    public static int PersonalDeviceUsageState_idle() {
        return PersonalDeviceUsageState_idle;
    }
    private static final int PersonalDeviceUsageState_listeningToAudio = (int)3L;
    /**
     * {@snippet lang=c :
     * enum PersonalDeviceUsageState.PersonalDeviceUsageState_listeningToAudio = 3
     * }
     */
    public static int PersonalDeviceUsageState_listeningToAudio() {
        return PersonalDeviceUsageState_listeningToAudio;
    }
    private static final int PersonalDeviceUsageState_typing = (int)4L;
    /**
     * {@snippet lang=c :
     * enum PersonalDeviceUsageState.PersonalDeviceUsageState_typing = 4
     * }
     */
    public static int PersonalDeviceUsageState_typing() {
        return PersonalDeviceUsageState_typing;
    }
    private static final int PersonalDeviceUsageState_calling = (int)5L;
    /**
     * {@snippet lang=c :
     * enum PersonalDeviceUsageState.PersonalDeviceUsageState_calling = 5
     * }
     */
    public static int PersonalDeviceUsageState_calling() {
        return PersonalDeviceUsageState_calling;
    }
    private static final int PersonalDeviceUsageState_playingGames = (int)6L;
    /**
     * {@snippet lang=c :
     * enum PersonalDeviceUsageState.PersonalDeviceUsageState_playingGames = 6
     * }
     */
    public static int PersonalDeviceUsageState_playingGames() {
        return PersonalDeviceUsageState_playingGames;
    }
    private static final int PersonalDeviceUsageState_reading = (int)7L;
    /**
     * {@snippet lang=c :
     * enum PersonalDeviceUsageState.PersonalDeviceUsageState_reading = 7
     * }
     */
    public static int PersonalDeviceUsageState_reading() {
        return PersonalDeviceUsageState_reading;
    }
    private static final int PersonalDeviceUsageState_viewing = (int)8L;
    /**
     * {@snippet lang=c :
     * enum PersonalDeviceUsageState.PersonalDeviceUsageState_viewing = 8
     * }
     */
    public static int PersonalDeviceUsageState_viewing() {
        return PersonalDeviceUsageState_viewing;
    }

    private static class asn_PER_type_PersonalDeviceUsageState_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_PersonalDeviceUsageState_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PersonalDeviceUsageState_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_PersonalDeviceUsageState_constr_1$layout() {
        return asn_PER_type_PersonalDeviceUsageState_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PersonalDeviceUsageState_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_PersonalDeviceUsageState_constr_1() {
        return asn_PER_type_PersonalDeviceUsageState_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PersonalDeviceUsageState_constr_1
     * }
     */
    public static void asn_PER_type_PersonalDeviceUsageState_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_PersonalDeviceUsageState_constr_1$constants.SEGMENT, 0L, asn_PER_type_PersonalDeviceUsageState_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_PersonalDeviceUsageState$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_PersonalDeviceUsageState").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PersonalDeviceUsageState
     * }
     */
    public static GroupLayout asn_DEF_PersonalDeviceUsageState$layout() {
        return asn_DEF_PersonalDeviceUsageState$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PersonalDeviceUsageState
     * }
     */
    public static MemorySegment asn_DEF_PersonalDeviceUsageState() {
        return asn_DEF_PersonalDeviceUsageState$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PersonalDeviceUsageState
     * }
     */
    public static void asn_DEF_PersonalDeviceUsageState(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_PersonalDeviceUsageState$constants.SEGMENT, 0L, asn_DEF_PersonalDeviceUsageState$constants.LAYOUT.byteSize());
    }

    private static class PersonalDeviceUsageState_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUsageState_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PersonalDeviceUsageState_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUsageState_free$descriptor() {
        return PersonalDeviceUsageState_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PersonalDeviceUsageState_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle PersonalDeviceUsageState_free$handle() {
        return PersonalDeviceUsageState_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PersonalDeviceUsageState_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_free$address() {
        return PersonalDeviceUsageState_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PersonalDeviceUsageState_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void PersonalDeviceUsageState_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PersonalDeviceUsageState_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUsageState_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUsageState_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUsageState_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PersonalDeviceUsageState_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUsageState_print$descriptor() {
        return PersonalDeviceUsageState_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PersonalDeviceUsageState_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalDeviceUsageState_print$handle() {
        return PersonalDeviceUsageState_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PersonalDeviceUsageState_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_print$address() {
        return PersonalDeviceUsageState_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PersonalDeviceUsageState_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int PersonalDeviceUsageState_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalDeviceUsageState_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUsageState_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUsageState_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUsageState_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PersonalDeviceUsageState_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUsageState_constraint$descriptor() {
        return PersonalDeviceUsageState_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PersonalDeviceUsageState_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle PersonalDeviceUsageState_constraint$handle() {
        return PersonalDeviceUsageState_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PersonalDeviceUsageState_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_constraint$address() {
        return PersonalDeviceUsageState_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PersonalDeviceUsageState_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int PersonalDeviceUsageState_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PersonalDeviceUsageState_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUsageState_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUsageState_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUsageState_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUsageState_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUsageState_decode_ber$descriptor() {
        return PersonalDeviceUsageState_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUsageState_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle PersonalDeviceUsageState_decode_ber$handle() {
        return PersonalDeviceUsageState_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUsageState_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_decode_ber$address() {
        return PersonalDeviceUsageState_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUsageState_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = PersonalDeviceUsageState_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUsageState_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUsageState_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUsageState_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUsageState_encode_der$descriptor() {
        return PersonalDeviceUsageState_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalDeviceUsageState_encode_der$handle() {
        return PersonalDeviceUsageState_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_encode_der$address() {
        return PersonalDeviceUsageState_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PersonalDeviceUsageState_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUsageState_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUsageState_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUsageState_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUsageState_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUsageState_decode_xer$descriptor() {
        return PersonalDeviceUsageState_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUsageState_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle PersonalDeviceUsageState_decode_xer$handle() {
        return PersonalDeviceUsageState_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUsageState_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_decode_xer$address() {
        return PersonalDeviceUsageState_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUsageState_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = PersonalDeviceUsageState_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUsageState_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUsageState_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUsageState_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUsageState_encode_xer$descriptor() {
        return PersonalDeviceUsageState_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalDeviceUsageState_encode_xer$handle() {
        return PersonalDeviceUsageState_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_encode_xer$address() {
        return PersonalDeviceUsageState_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PersonalDeviceUsageState_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUsageState_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUsageState_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUsageState_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUsageState_encode_jer$descriptor() {
        return PersonalDeviceUsageState_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalDeviceUsageState_encode_jer$handle() {
        return PersonalDeviceUsageState_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_encode_jer$address() {
        return PersonalDeviceUsageState_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = PersonalDeviceUsageState_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUsageState_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUsageState_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUsageState_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUsageState_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUsageState_decode_oer$descriptor() {
        return PersonalDeviceUsageState_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUsageState_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle PersonalDeviceUsageState_decode_oer$handle() {
        return PersonalDeviceUsageState_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUsageState_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_decode_oer$address() {
        return PersonalDeviceUsageState_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUsageState_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = PersonalDeviceUsageState_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUsageState_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUsageState_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUsageState_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUsageState_encode_oer$descriptor() {
        return PersonalDeviceUsageState_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalDeviceUsageState_encode_oer$handle() {
        return PersonalDeviceUsageState_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_encode_oer$address() {
        return PersonalDeviceUsageState_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalDeviceUsageState_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUsageState_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUsageState_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUsageState_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUsageState_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUsageState_decode_uper$descriptor() {
        return PersonalDeviceUsageState_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUsageState_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle PersonalDeviceUsageState_decode_uper$handle() {
        return PersonalDeviceUsageState_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUsageState_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_decode_uper$address() {
        return PersonalDeviceUsageState_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUsageState_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalDeviceUsageState_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUsageState_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUsageState_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUsageState_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUsageState_encode_uper$descriptor() {
        return PersonalDeviceUsageState_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle PersonalDeviceUsageState_encode_uper$handle() {
        return PersonalDeviceUsageState_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_encode_uper$address() {
        return PersonalDeviceUsageState_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PersonalDeviceUsageState_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUsageState_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUsageState_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUsageState_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUsageState_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUsageState_decode_aper$descriptor() {
        return PersonalDeviceUsageState_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUsageState_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle PersonalDeviceUsageState_decode_aper$handle() {
        return PersonalDeviceUsageState_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUsageState_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_decode_aper$address() {
        return PersonalDeviceUsageState_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalDeviceUsageState_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalDeviceUsageState_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUsageState_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalDeviceUsageState_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalDeviceUsageState_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor PersonalDeviceUsageState_encode_aper$descriptor() {
        return PersonalDeviceUsageState_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle PersonalDeviceUsageState_encode_aper$handle() {
        return PersonalDeviceUsageState_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_encode_aper$address() {
        return PersonalDeviceUsageState_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalDeviceUsageState_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalDeviceUsageState_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PersonalDeviceUsageState_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalDeviceUsageState_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef BOOLEAN_t PersonalCrossingRequest_t
     * }
     */
    public static final OfInt PersonalCrossingRequest_t = MessageFrame_h.C_INT;

    private static class asn_DEF_PersonalCrossingRequest$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_PersonalCrossingRequest").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PersonalCrossingRequest
     * }
     */
    public static GroupLayout asn_DEF_PersonalCrossingRequest$layout() {
        return asn_DEF_PersonalCrossingRequest$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PersonalCrossingRequest
     * }
     */
    public static MemorySegment asn_DEF_PersonalCrossingRequest() {
        return asn_DEF_PersonalCrossingRequest$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PersonalCrossingRequest
     * }
     */
    public static void asn_DEF_PersonalCrossingRequest(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_PersonalCrossingRequest$constants.SEGMENT, 0L, asn_DEF_PersonalCrossingRequest$constants.LAYOUT.byteSize());
    }

    private static class PersonalCrossingRequest_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingRequest_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PersonalCrossingRequest_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor PersonalCrossingRequest_free$descriptor() {
        return PersonalCrossingRequest_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PersonalCrossingRequest_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle PersonalCrossingRequest_free$handle() {
        return PersonalCrossingRequest_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PersonalCrossingRequest_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_free$address() {
        return PersonalCrossingRequest_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PersonalCrossingRequest_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void PersonalCrossingRequest_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PersonalCrossingRequest_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingRequest_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingRequest_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingRequest_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PersonalCrossingRequest_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalCrossingRequest_print$descriptor() {
        return PersonalCrossingRequest_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PersonalCrossingRequest_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalCrossingRequest_print$handle() {
        return PersonalCrossingRequest_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PersonalCrossingRequest_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_print$address() {
        return PersonalCrossingRequest_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PersonalCrossingRequest_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int PersonalCrossingRequest_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalCrossingRequest_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingRequest_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingRequest_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingRequest_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PersonalCrossingRequest_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalCrossingRequest_constraint$descriptor() {
        return PersonalCrossingRequest_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PersonalCrossingRequest_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle PersonalCrossingRequest_constraint$handle() {
        return PersonalCrossingRequest_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PersonalCrossingRequest_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_constraint$address() {
        return PersonalCrossingRequest_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PersonalCrossingRequest_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int PersonalCrossingRequest_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PersonalCrossingRequest_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingRequest_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingRequest_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingRequest_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingRequest_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor PersonalCrossingRequest_decode_ber$descriptor() {
        return PersonalCrossingRequest_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingRequest_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle PersonalCrossingRequest_decode_ber$handle() {
        return PersonalCrossingRequest_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingRequest_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_decode_ber$address() {
        return PersonalCrossingRequest_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingRequest_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = PersonalCrossingRequest_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingRequest_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingRequest_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingRequest_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalCrossingRequest_encode_der$descriptor() {
        return PersonalCrossingRequest_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalCrossingRequest_encode_der$handle() {
        return PersonalCrossingRequest_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_encode_der$address() {
        return PersonalCrossingRequest_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PersonalCrossingRequest_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingRequest_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingRequest_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingRequest_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingRequest_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor PersonalCrossingRequest_decode_xer$descriptor() {
        return PersonalCrossingRequest_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingRequest_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle PersonalCrossingRequest_decode_xer$handle() {
        return PersonalCrossingRequest_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingRequest_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_decode_xer$address() {
        return PersonalCrossingRequest_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingRequest_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = PersonalCrossingRequest_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingRequest_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingRequest_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingRequest_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalCrossingRequest_encode_xer$descriptor() {
        return PersonalCrossingRequest_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalCrossingRequest_encode_xer$handle() {
        return PersonalCrossingRequest_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_encode_xer$address() {
        return PersonalCrossingRequest_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PersonalCrossingRequest_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingRequest_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingRequest_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingRequest_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalCrossingRequest_encode_jer$descriptor() {
        return PersonalCrossingRequest_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalCrossingRequest_encode_jer$handle() {
        return PersonalCrossingRequest_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_encode_jer$address() {
        return PersonalCrossingRequest_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = PersonalCrossingRequest_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingRequest_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingRequest_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingRequest_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingRequest_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor PersonalCrossingRequest_decode_oer$descriptor() {
        return PersonalCrossingRequest_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingRequest_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle PersonalCrossingRequest_decode_oer$handle() {
        return PersonalCrossingRequest_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingRequest_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_decode_oer$address() {
        return PersonalCrossingRequest_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingRequest_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = PersonalCrossingRequest_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingRequest_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingRequest_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingRequest_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalCrossingRequest_encode_oer$descriptor() {
        return PersonalCrossingRequest_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalCrossingRequest_encode_oer$handle() {
        return PersonalCrossingRequest_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_encode_oer$address() {
        return PersonalCrossingRequest_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalCrossingRequest_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingRequest_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingRequest_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingRequest_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingRequest_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor PersonalCrossingRequest_decode_uper$descriptor() {
        return PersonalCrossingRequest_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingRequest_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle PersonalCrossingRequest_decode_uper$handle() {
        return PersonalCrossingRequest_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingRequest_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_decode_uper$address() {
        return PersonalCrossingRequest_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingRequest_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalCrossingRequest_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingRequest_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingRequest_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingRequest_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor PersonalCrossingRequest_encode_uper$descriptor() {
        return PersonalCrossingRequest_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle PersonalCrossingRequest_encode_uper$handle() {
        return PersonalCrossingRequest_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_encode_uper$address() {
        return PersonalCrossingRequest_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PersonalCrossingRequest_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingRequest_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingRequest_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingRequest_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingRequest_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor PersonalCrossingRequest_decode_aper$descriptor() {
        return PersonalCrossingRequest_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingRequest_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle PersonalCrossingRequest_decode_aper$handle() {
        return PersonalCrossingRequest_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingRequest_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_decode_aper$address() {
        return PersonalCrossingRequest_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingRequest_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalCrossingRequest_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingRequest_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingRequest_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingRequest_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor PersonalCrossingRequest_encode_aper$descriptor() {
        return PersonalCrossingRequest_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle PersonalCrossingRequest_encode_aper$handle() {
        return PersonalCrossingRequest_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_encode_aper$address() {
        return PersonalCrossingRequest_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingRequest_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalCrossingRequest_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PersonalCrossingRequest_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingRequest_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef BOOLEAN_t PersonalCrossingInProgress_t
     * }
     */
    public static final OfInt PersonalCrossingInProgress_t = MessageFrame_h.C_INT;

    private static class asn_DEF_PersonalCrossingInProgress$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_PersonalCrossingInProgress").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PersonalCrossingInProgress
     * }
     */
    public static GroupLayout asn_DEF_PersonalCrossingInProgress$layout() {
        return asn_DEF_PersonalCrossingInProgress$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PersonalCrossingInProgress
     * }
     */
    public static MemorySegment asn_DEF_PersonalCrossingInProgress() {
        return asn_DEF_PersonalCrossingInProgress$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PersonalCrossingInProgress
     * }
     */
    public static void asn_DEF_PersonalCrossingInProgress(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_PersonalCrossingInProgress$constants.SEGMENT, 0L, asn_DEF_PersonalCrossingInProgress$constants.LAYOUT.byteSize());
    }

    private static class PersonalCrossingInProgress_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingInProgress_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PersonalCrossingInProgress_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor PersonalCrossingInProgress_free$descriptor() {
        return PersonalCrossingInProgress_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PersonalCrossingInProgress_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle PersonalCrossingInProgress_free$handle() {
        return PersonalCrossingInProgress_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PersonalCrossingInProgress_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_free$address() {
        return PersonalCrossingInProgress_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PersonalCrossingInProgress_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void PersonalCrossingInProgress_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PersonalCrossingInProgress_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingInProgress_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingInProgress_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingInProgress_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PersonalCrossingInProgress_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalCrossingInProgress_print$descriptor() {
        return PersonalCrossingInProgress_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PersonalCrossingInProgress_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalCrossingInProgress_print$handle() {
        return PersonalCrossingInProgress_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PersonalCrossingInProgress_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_print$address() {
        return PersonalCrossingInProgress_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PersonalCrossingInProgress_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int PersonalCrossingInProgress_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalCrossingInProgress_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingInProgress_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingInProgress_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingInProgress_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PersonalCrossingInProgress_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalCrossingInProgress_constraint$descriptor() {
        return PersonalCrossingInProgress_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PersonalCrossingInProgress_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle PersonalCrossingInProgress_constraint$handle() {
        return PersonalCrossingInProgress_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PersonalCrossingInProgress_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_constraint$address() {
        return PersonalCrossingInProgress_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PersonalCrossingInProgress_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int PersonalCrossingInProgress_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PersonalCrossingInProgress_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingInProgress_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingInProgress_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingInProgress_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingInProgress_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor PersonalCrossingInProgress_decode_ber$descriptor() {
        return PersonalCrossingInProgress_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingInProgress_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle PersonalCrossingInProgress_decode_ber$handle() {
        return PersonalCrossingInProgress_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingInProgress_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_decode_ber$address() {
        return PersonalCrossingInProgress_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingInProgress_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = PersonalCrossingInProgress_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingInProgress_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingInProgress_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingInProgress_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalCrossingInProgress_encode_der$descriptor() {
        return PersonalCrossingInProgress_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalCrossingInProgress_encode_der$handle() {
        return PersonalCrossingInProgress_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_encode_der$address() {
        return PersonalCrossingInProgress_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PersonalCrossingInProgress_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingInProgress_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingInProgress_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingInProgress_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingInProgress_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor PersonalCrossingInProgress_decode_xer$descriptor() {
        return PersonalCrossingInProgress_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingInProgress_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle PersonalCrossingInProgress_decode_xer$handle() {
        return PersonalCrossingInProgress_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingInProgress_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_decode_xer$address() {
        return PersonalCrossingInProgress_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingInProgress_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = PersonalCrossingInProgress_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingInProgress_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingInProgress_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingInProgress_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalCrossingInProgress_encode_xer$descriptor() {
        return PersonalCrossingInProgress_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalCrossingInProgress_encode_xer$handle() {
        return PersonalCrossingInProgress_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_encode_xer$address() {
        return PersonalCrossingInProgress_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PersonalCrossingInProgress_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingInProgress_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingInProgress_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingInProgress_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalCrossingInProgress_encode_jer$descriptor() {
        return PersonalCrossingInProgress_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalCrossingInProgress_encode_jer$handle() {
        return PersonalCrossingInProgress_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_encode_jer$address() {
        return PersonalCrossingInProgress_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = PersonalCrossingInProgress_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingInProgress_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingInProgress_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingInProgress_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingInProgress_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor PersonalCrossingInProgress_decode_oer$descriptor() {
        return PersonalCrossingInProgress_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingInProgress_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle PersonalCrossingInProgress_decode_oer$handle() {
        return PersonalCrossingInProgress_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingInProgress_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_decode_oer$address() {
        return PersonalCrossingInProgress_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingInProgress_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = PersonalCrossingInProgress_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingInProgress_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingInProgress_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingInProgress_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalCrossingInProgress_encode_oer$descriptor() {
        return PersonalCrossingInProgress_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalCrossingInProgress_encode_oer$handle() {
        return PersonalCrossingInProgress_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_encode_oer$address() {
        return PersonalCrossingInProgress_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalCrossingInProgress_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingInProgress_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingInProgress_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingInProgress_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingInProgress_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor PersonalCrossingInProgress_decode_uper$descriptor() {
        return PersonalCrossingInProgress_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingInProgress_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle PersonalCrossingInProgress_decode_uper$handle() {
        return PersonalCrossingInProgress_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingInProgress_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_decode_uper$address() {
        return PersonalCrossingInProgress_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingInProgress_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalCrossingInProgress_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingInProgress_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingInProgress_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingInProgress_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor PersonalCrossingInProgress_encode_uper$descriptor() {
        return PersonalCrossingInProgress_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle PersonalCrossingInProgress_encode_uper$handle() {
        return PersonalCrossingInProgress_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_encode_uper$address() {
        return PersonalCrossingInProgress_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PersonalCrossingInProgress_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingInProgress_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingInProgress_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingInProgress_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingInProgress_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor PersonalCrossingInProgress_decode_aper$descriptor() {
        return PersonalCrossingInProgress_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingInProgress_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle PersonalCrossingInProgress_decode_aper$handle() {
        return PersonalCrossingInProgress_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingInProgress_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_decode_aper$address() {
        return PersonalCrossingInProgress_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalCrossingInProgress_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalCrossingInProgress_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingInProgress_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalCrossingInProgress_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalCrossingInProgress_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor PersonalCrossingInProgress_encode_aper$descriptor() {
        return PersonalCrossingInProgress_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle PersonalCrossingInProgress_encode_aper$handle() {
        return PersonalCrossingInProgress_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_encode_aper$address() {
        return PersonalCrossingInProgress_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalCrossingInProgress_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalCrossingInProgress_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PersonalCrossingInProgress_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalCrossingInProgress_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int NumberOfParticipantsInCluster_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum NumberOfParticipantsInCluster.NumberOfParticipantsInCluster_unavailable = 0
     * }
     */
    public static int NumberOfParticipantsInCluster_unavailable() {
        return NumberOfParticipantsInCluster_unavailable;
    }
    private static final int NumberOfParticipantsInCluster_small = (int)1L;
    /**
     * {@snippet lang=c :
     * enum NumberOfParticipantsInCluster.NumberOfParticipantsInCluster_small = 1
     * }
     */
    public static int NumberOfParticipantsInCluster_small() {
        return NumberOfParticipantsInCluster_small;
    }
    private static final int NumberOfParticipantsInCluster_medium = (int)2L;
    /**
     * {@snippet lang=c :
     * enum NumberOfParticipantsInCluster.NumberOfParticipantsInCluster_medium = 2
     * }
     */
    public static int NumberOfParticipantsInCluster_medium() {
        return NumberOfParticipantsInCluster_medium;
    }
    private static final int NumberOfParticipantsInCluster_large = (int)3L;
    /**
     * {@snippet lang=c :
     * enum NumberOfParticipantsInCluster.NumberOfParticipantsInCluster_large = 3
     * }
     */
    public static int NumberOfParticipantsInCluster_large() {
        return NumberOfParticipantsInCluster_large;
    }
    /**
     * {@snippet lang=c :
     * typedef long NumberOfParticipantsInCluster_t
     * }
     */
    public static final OfLong NumberOfParticipantsInCluster_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_NumberOfParticipantsInCluster_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_NumberOfParticipantsInCluster_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NumberOfParticipantsInCluster_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_NumberOfParticipantsInCluster_constr_1$layout() {
        return asn_PER_type_NumberOfParticipantsInCluster_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NumberOfParticipantsInCluster_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_NumberOfParticipantsInCluster_constr_1() {
        return asn_PER_type_NumberOfParticipantsInCluster_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NumberOfParticipantsInCluster_constr_1
     * }
     */
    public static void asn_PER_type_NumberOfParticipantsInCluster_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_NumberOfParticipantsInCluster_constr_1$constants.SEGMENT, 0L, asn_PER_type_NumberOfParticipantsInCluster_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_NumberOfParticipantsInCluster$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_NumberOfParticipantsInCluster").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NumberOfParticipantsInCluster
     * }
     */
    public static GroupLayout asn_DEF_NumberOfParticipantsInCluster$layout() {
        return asn_DEF_NumberOfParticipantsInCluster$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NumberOfParticipantsInCluster
     * }
     */
    public static MemorySegment asn_DEF_NumberOfParticipantsInCluster() {
        return asn_DEF_NumberOfParticipantsInCluster$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NumberOfParticipantsInCluster
     * }
     */
    public static void asn_DEF_NumberOfParticipantsInCluster(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_NumberOfParticipantsInCluster$constants.SEGMENT, 0L, asn_DEF_NumberOfParticipantsInCluster$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_NumberOfParticipantsInCluster_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_NumberOfParticipantsInCluster_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_NumberOfParticipantsInCluster_specs_1
     * }
     */
    public static GroupLayout asn_SPC_NumberOfParticipantsInCluster_specs_1$layout() {
        return asn_SPC_NumberOfParticipantsInCluster_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_NumberOfParticipantsInCluster_specs_1
     * }
     */
    public static MemorySegment asn_SPC_NumberOfParticipantsInCluster_specs_1() {
        return asn_SPC_NumberOfParticipantsInCluster_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_NumberOfParticipantsInCluster_specs_1
     * }
     */
    public static void asn_SPC_NumberOfParticipantsInCluster_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_NumberOfParticipantsInCluster_specs_1$constants.SEGMENT, 0L, asn_SPC_NumberOfParticipantsInCluster_specs_1$constants.LAYOUT.byteSize());
    }

    private static class NumberOfParticipantsInCluster_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NumberOfParticipantsInCluster_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NumberOfParticipantsInCluster_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor NumberOfParticipantsInCluster_free$descriptor() {
        return NumberOfParticipantsInCluster_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NumberOfParticipantsInCluster_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle NumberOfParticipantsInCluster_free$handle() {
        return NumberOfParticipantsInCluster_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NumberOfParticipantsInCluster_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_free$address() {
        return NumberOfParticipantsInCluster_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NumberOfParticipantsInCluster_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void NumberOfParticipantsInCluster_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = NumberOfParticipantsInCluster_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NumberOfParticipantsInCluster_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NumberOfParticipantsInCluster_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NumberOfParticipantsInCluster_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int NumberOfParticipantsInCluster_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NumberOfParticipantsInCluster_print$descriptor() {
        return NumberOfParticipantsInCluster_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int NumberOfParticipantsInCluster_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NumberOfParticipantsInCluster_print$handle() {
        return NumberOfParticipantsInCluster_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int NumberOfParticipantsInCluster_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_print$address() {
        return NumberOfParticipantsInCluster_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int NumberOfParticipantsInCluster_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int NumberOfParticipantsInCluster_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NumberOfParticipantsInCluster_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NumberOfParticipantsInCluster_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NumberOfParticipantsInCluster_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NumberOfParticipantsInCluster_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int NumberOfParticipantsInCluster_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor NumberOfParticipantsInCluster_constraint$descriptor() {
        return NumberOfParticipantsInCluster_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int NumberOfParticipantsInCluster_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle NumberOfParticipantsInCluster_constraint$handle() {
        return NumberOfParticipantsInCluster_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int NumberOfParticipantsInCluster_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_constraint$address() {
        return NumberOfParticipantsInCluster_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int NumberOfParticipantsInCluster_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int NumberOfParticipantsInCluster_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = NumberOfParticipantsInCluster_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NumberOfParticipantsInCluster_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NumberOfParticipantsInCluster_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NumberOfParticipantsInCluster_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NumberOfParticipantsInCluster_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor NumberOfParticipantsInCluster_decode_ber$descriptor() {
        return NumberOfParticipantsInCluster_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NumberOfParticipantsInCluster_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle NumberOfParticipantsInCluster_decode_ber$handle() {
        return NumberOfParticipantsInCluster_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NumberOfParticipantsInCluster_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_decode_ber$address() {
        return NumberOfParticipantsInCluster_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NumberOfParticipantsInCluster_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = NumberOfParticipantsInCluster_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NumberOfParticipantsInCluster_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NumberOfParticipantsInCluster_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NumberOfParticipantsInCluster_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NumberOfParticipantsInCluster_encode_der$descriptor() {
        return NumberOfParticipantsInCluster_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NumberOfParticipantsInCluster_encode_der$handle() {
        return NumberOfParticipantsInCluster_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_encode_der$address() {
        return NumberOfParticipantsInCluster_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = NumberOfParticipantsInCluster_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NumberOfParticipantsInCluster_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NumberOfParticipantsInCluster_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NumberOfParticipantsInCluster_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NumberOfParticipantsInCluster_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor NumberOfParticipantsInCluster_decode_xer$descriptor() {
        return NumberOfParticipantsInCluster_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NumberOfParticipantsInCluster_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle NumberOfParticipantsInCluster_decode_xer$handle() {
        return NumberOfParticipantsInCluster_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NumberOfParticipantsInCluster_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_decode_xer$address() {
        return NumberOfParticipantsInCluster_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NumberOfParticipantsInCluster_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = NumberOfParticipantsInCluster_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NumberOfParticipantsInCluster_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NumberOfParticipantsInCluster_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NumberOfParticipantsInCluster_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NumberOfParticipantsInCluster_encode_xer$descriptor() {
        return NumberOfParticipantsInCluster_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NumberOfParticipantsInCluster_encode_xer$handle() {
        return NumberOfParticipantsInCluster_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_encode_xer$address() {
        return NumberOfParticipantsInCluster_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = NumberOfParticipantsInCluster_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NumberOfParticipantsInCluster_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NumberOfParticipantsInCluster_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NumberOfParticipantsInCluster_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NumberOfParticipantsInCluster_encode_jer$descriptor() {
        return NumberOfParticipantsInCluster_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NumberOfParticipantsInCluster_encode_jer$handle() {
        return NumberOfParticipantsInCluster_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_encode_jer$address() {
        return NumberOfParticipantsInCluster_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = NumberOfParticipantsInCluster_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NumberOfParticipantsInCluster_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NumberOfParticipantsInCluster_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NumberOfParticipantsInCluster_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NumberOfParticipantsInCluster_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor NumberOfParticipantsInCluster_decode_oer$descriptor() {
        return NumberOfParticipantsInCluster_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NumberOfParticipantsInCluster_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle NumberOfParticipantsInCluster_decode_oer$handle() {
        return NumberOfParticipantsInCluster_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NumberOfParticipantsInCluster_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_decode_oer$address() {
        return NumberOfParticipantsInCluster_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NumberOfParticipantsInCluster_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = NumberOfParticipantsInCluster_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NumberOfParticipantsInCluster_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NumberOfParticipantsInCluster_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NumberOfParticipantsInCluster_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NumberOfParticipantsInCluster_encode_oer$descriptor() {
        return NumberOfParticipantsInCluster_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NumberOfParticipantsInCluster_encode_oer$handle() {
        return NumberOfParticipantsInCluster_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_encode_oer$address() {
        return NumberOfParticipantsInCluster_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NumberOfParticipantsInCluster_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NumberOfParticipantsInCluster_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NumberOfParticipantsInCluster_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NumberOfParticipantsInCluster_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NumberOfParticipantsInCluster_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor NumberOfParticipantsInCluster_decode_uper$descriptor() {
        return NumberOfParticipantsInCluster_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NumberOfParticipantsInCluster_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle NumberOfParticipantsInCluster_decode_uper$handle() {
        return NumberOfParticipantsInCluster_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NumberOfParticipantsInCluster_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_decode_uper$address() {
        return NumberOfParticipantsInCluster_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NumberOfParticipantsInCluster_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NumberOfParticipantsInCluster_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NumberOfParticipantsInCluster_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NumberOfParticipantsInCluster_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NumberOfParticipantsInCluster_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor NumberOfParticipantsInCluster_encode_uper$descriptor() {
        return NumberOfParticipantsInCluster_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle NumberOfParticipantsInCluster_encode_uper$handle() {
        return NumberOfParticipantsInCluster_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_encode_uper$address() {
        return NumberOfParticipantsInCluster_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = NumberOfParticipantsInCluster_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NumberOfParticipantsInCluster_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NumberOfParticipantsInCluster_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NumberOfParticipantsInCluster_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NumberOfParticipantsInCluster_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor NumberOfParticipantsInCluster_decode_aper$descriptor() {
        return NumberOfParticipantsInCluster_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NumberOfParticipantsInCluster_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle NumberOfParticipantsInCluster_decode_aper$handle() {
        return NumberOfParticipantsInCluster_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NumberOfParticipantsInCluster_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_decode_aper$address() {
        return NumberOfParticipantsInCluster_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NumberOfParticipantsInCluster_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NumberOfParticipantsInCluster_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NumberOfParticipantsInCluster_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NumberOfParticipantsInCluster_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NumberOfParticipantsInCluster_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor NumberOfParticipantsInCluster_encode_aper$descriptor() {
        return NumberOfParticipantsInCluster_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle NumberOfParticipantsInCluster_encode_aper$handle() {
        return NumberOfParticipantsInCluster_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_encode_aper$address() {
        return NumberOfParticipantsInCluster_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NumberOfParticipantsInCluster_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NumberOfParticipantsInCluster_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = NumberOfParticipantsInCluster_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NumberOfParticipantsInCluster_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long PersonalClusterRadius_t
     * }
     */
    public static final OfLong PersonalClusterRadius_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_PersonalClusterRadius_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_PersonalClusterRadius_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PersonalClusterRadius_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_PersonalClusterRadius_constr_1$layout() {
        return asn_PER_type_PersonalClusterRadius_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PersonalClusterRadius_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_PersonalClusterRadius_constr_1() {
        return asn_PER_type_PersonalClusterRadius_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PersonalClusterRadius_constr_1
     * }
     */
    public static void asn_PER_type_PersonalClusterRadius_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_PersonalClusterRadius_constr_1$constants.SEGMENT, 0L, asn_PER_type_PersonalClusterRadius_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_PersonalClusterRadius$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_PersonalClusterRadius").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PersonalClusterRadius
     * }
     */
    public static GroupLayout asn_DEF_PersonalClusterRadius$layout() {
        return asn_DEF_PersonalClusterRadius$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PersonalClusterRadius
     * }
     */
    public static MemorySegment asn_DEF_PersonalClusterRadius() {
        return asn_DEF_PersonalClusterRadius$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PersonalClusterRadius
     * }
     */
    public static void asn_DEF_PersonalClusterRadius(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_PersonalClusterRadius$constants.SEGMENT, 0L, asn_DEF_PersonalClusterRadius$constants.LAYOUT.byteSize());
    }

    private static class PersonalClusterRadius_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalClusterRadius_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PersonalClusterRadius_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor PersonalClusterRadius_free$descriptor() {
        return PersonalClusterRadius_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PersonalClusterRadius_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle PersonalClusterRadius_free$handle() {
        return PersonalClusterRadius_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PersonalClusterRadius_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment PersonalClusterRadius_free$address() {
        return PersonalClusterRadius_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PersonalClusterRadius_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void PersonalClusterRadius_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PersonalClusterRadius_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalClusterRadius_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalClusterRadius_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalClusterRadius_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PersonalClusterRadius_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalClusterRadius_print$descriptor() {
        return PersonalClusterRadius_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PersonalClusterRadius_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalClusterRadius_print$handle() {
        return PersonalClusterRadius_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PersonalClusterRadius_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalClusterRadius_print$address() {
        return PersonalClusterRadius_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PersonalClusterRadius_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int PersonalClusterRadius_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalClusterRadius_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalClusterRadius_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalClusterRadius_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalClusterRadius_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PersonalClusterRadius_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalClusterRadius_constraint$descriptor() {
        return PersonalClusterRadius_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PersonalClusterRadius_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle PersonalClusterRadius_constraint$handle() {
        return PersonalClusterRadius_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PersonalClusterRadius_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment PersonalClusterRadius_constraint$address() {
        return PersonalClusterRadius_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PersonalClusterRadius_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int PersonalClusterRadius_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PersonalClusterRadius_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalClusterRadius_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalClusterRadius_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalClusterRadius_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalClusterRadius_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor PersonalClusterRadius_decode_ber$descriptor() {
        return PersonalClusterRadius_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalClusterRadius_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle PersonalClusterRadius_decode_ber$handle() {
        return PersonalClusterRadius_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalClusterRadius_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment PersonalClusterRadius_decode_ber$address() {
        return PersonalClusterRadius_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalClusterRadius_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment PersonalClusterRadius_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = PersonalClusterRadius_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalClusterRadius_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalClusterRadius_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalClusterRadius_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalClusterRadius_encode_der$descriptor() {
        return PersonalClusterRadius_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalClusterRadius_encode_der$handle() {
        return PersonalClusterRadius_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalClusterRadius_encode_der$address() {
        return PersonalClusterRadius_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalClusterRadius_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PersonalClusterRadius_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalClusterRadius_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalClusterRadius_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalClusterRadius_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalClusterRadius_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor PersonalClusterRadius_decode_xer$descriptor() {
        return PersonalClusterRadius_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalClusterRadius_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle PersonalClusterRadius_decode_xer$handle() {
        return PersonalClusterRadius_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalClusterRadius_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalClusterRadius_decode_xer$address() {
        return PersonalClusterRadius_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalClusterRadius_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalClusterRadius_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = PersonalClusterRadius_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalClusterRadius_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalClusterRadius_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalClusterRadius_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalClusterRadius_encode_xer$descriptor() {
        return PersonalClusterRadius_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalClusterRadius_encode_xer$handle() {
        return PersonalClusterRadius_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalClusterRadius_encode_xer$address() {
        return PersonalClusterRadius_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalClusterRadius_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PersonalClusterRadius_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalClusterRadius_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalClusterRadius_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalClusterRadius_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalClusterRadius_encode_jer$descriptor() {
        return PersonalClusterRadius_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalClusterRadius_encode_jer$handle() {
        return PersonalClusterRadius_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalClusterRadius_encode_jer$address() {
        return PersonalClusterRadius_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalClusterRadius_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = PersonalClusterRadius_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalClusterRadius_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalClusterRadius_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalClusterRadius_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalClusterRadius_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor PersonalClusterRadius_decode_oer$descriptor() {
        return PersonalClusterRadius_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalClusterRadius_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle PersonalClusterRadius_decode_oer$handle() {
        return PersonalClusterRadius_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalClusterRadius_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalClusterRadius_decode_oer$address() {
        return PersonalClusterRadius_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalClusterRadius_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalClusterRadius_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = PersonalClusterRadius_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalClusterRadius_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalClusterRadius_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalClusterRadius_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalClusterRadius_encode_oer$descriptor() {
        return PersonalClusterRadius_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalClusterRadius_encode_oer$handle() {
        return PersonalClusterRadius_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalClusterRadius_encode_oer$address() {
        return PersonalClusterRadius_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalClusterRadius_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalClusterRadius_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalClusterRadius_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalClusterRadius_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalClusterRadius_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalClusterRadius_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor PersonalClusterRadius_decode_uper$descriptor() {
        return PersonalClusterRadius_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalClusterRadius_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle PersonalClusterRadius_decode_uper$handle() {
        return PersonalClusterRadius_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalClusterRadius_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalClusterRadius_decode_uper$address() {
        return PersonalClusterRadius_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalClusterRadius_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalClusterRadius_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalClusterRadius_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalClusterRadius_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalClusterRadius_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalClusterRadius_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor PersonalClusterRadius_encode_uper$descriptor() {
        return PersonalClusterRadius_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle PersonalClusterRadius_encode_uper$handle() {
        return PersonalClusterRadius_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalClusterRadius_encode_uper$address() {
        return PersonalClusterRadius_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalClusterRadius_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PersonalClusterRadius_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalClusterRadius_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalClusterRadius_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalClusterRadius_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalClusterRadius_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor PersonalClusterRadius_decode_aper$descriptor() {
        return PersonalClusterRadius_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalClusterRadius_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle PersonalClusterRadius_decode_aper$handle() {
        return PersonalClusterRadius_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalClusterRadius_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalClusterRadius_decode_aper$address() {
        return PersonalClusterRadius_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalClusterRadius_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalClusterRadius_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalClusterRadius_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalClusterRadius_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalClusterRadius_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalClusterRadius_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor PersonalClusterRadius_encode_aper$descriptor() {
        return PersonalClusterRadius_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle PersonalClusterRadius_encode_aper$handle() {
        return PersonalClusterRadius_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalClusterRadius_encode_aper$address() {
        return PersonalClusterRadius_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalClusterRadius_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalClusterRadius_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PersonalClusterRadius_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalClusterRadius_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PublicSafetyEventResponderWorkerType_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum PublicSafetyEventResponderWorkerType.PublicSafetyEventResponderWorkerType_unavailable = 0
     * }
     */
    public static int PublicSafetyEventResponderWorkerType_unavailable() {
        return PublicSafetyEventResponderWorkerType_unavailable;
    }
    private static final int PublicSafetyEventResponderWorkerType_towOperater = (int)1L;
    /**
     * {@snippet lang=c :
     * enum PublicSafetyEventResponderWorkerType.PublicSafetyEventResponderWorkerType_towOperater = 1
     * }
     */
    public static int PublicSafetyEventResponderWorkerType_towOperater() {
        return PublicSafetyEventResponderWorkerType_towOperater;
    }
    private static final int PublicSafetyEventResponderWorkerType_fireAndEMSWorker = (int)2L;
    /**
     * {@snippet lang=c :
     * enum PublicSafetyEventResponderWorkerType.PublicSafetyEventResponderWorkerType_fireAndEMSWorker = 2
     * }
     */
    public static int PublicSafetyEventResponderWorkerType_fireAndEMSWorker() {
        return PublicSafetyEventResponderWorkerType_fireAndEMSWorker;
    }
    private static final int PublicSafetyEventResponderWorkerType_aDOTWorker = (int)3L;
    /**
     * {@snippet lang=c :
     * enum PublicSafetyEventResponderWorkerType.PublicSafetyEventResponderWorkerType_aDOTWorker = 3
     * }
     */
    public static int PublicSafetyEventResponderWorkerType_aDOTWorker() {
        return PublicSafetyEventResponderWorkerType_aDOTWorker;
    }
    private static final int PublicSafetyEventResponderWorkerType_lawEnforcement = (int)4L;
    /**
     * {@snippet lang=c :
     * enum PublicSafetyEventResponderWorkerType.PublicSafetyEventResponderWorkerType_lawEnforcement = 4
     * }
     */
    public static int PublicSafetyEventResponderWorkerType_lawEnforcement() {
        return PublicSafetyEventResponderWorkerType_lawEnforcement;
    }
    private static final int PublicSafetyEventResponderWorkerType_hazmatResponder = (int)5L;
    /**
     * {@snippet lang=c :
     * enum PublicSafetyEventResponderWorkerType.PublicSafetyEventResponderWorkerType_hazmatResponder = 5
     * }
     */
    public static int PublicSafetyEventResponderWorkerType_hazmatResponder() {
        return PublicSafetyEventResponderWorkerType_hazmatResponder;
    }
    private static final int PublicSafetyEventResponderWorkerType_animalControlWorker = (int)6L;
    /**
     * {@snippet lang=c :
     * enum PublicSafetyEventResponderWorkerType.PublicSafetyEventResponderWorkerType_animalControlWorker = 6
     * }
     */
    public static int PublicSafetyEventResponderWorkerType_animalControlWorker() {
        return PublicSafetyEventResponderWorkerType_animalControlWorker;
    }
    private static final int PublicSafetyEventResponderWorkerType_otherPersonnel = (int)7L;
    /**
     * {@snippet lang=c :
     * enum PublicSafetyEventResponderWorkerType.PublicSafetyEventResponderWorkerType_otherPersonnel = 7
     * }
     */
    public static int PublicSafetyEventResponderWorkerType_otherPersonnel() {
        return PublicSafetyEventResponderWorkerType_otherPersonnel;
    }
    /**
     * {@snippet lang=c :
     * typedef long PublicSafetyEventResponderWorkerType_t
     * }
     */
    public static final OfLong PublicSafetyEventResponderWorkerType_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_PublicSafetyEventResponderWorkerType_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_PublicSafetyEventResponderWorkerType_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PublicSafetyEventResponderWorkerType_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_PublicSafetyEventResponderWorkerType_constr_1$layout() {
        return asn_PER_type_PublicSafetyEventResponderWorkerType_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PublicSafetyEventResponderWorkerType_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_PublicSafetyEventResponderWorkerType_constr_1() {
        return asn_PER_type_PublicSafetyEventResponderWorkerType_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PublicSafetyEventResponderWorkerType_constr_1
     * }
     */
    public static void asn_PER_type_PublicSafetyEventResponderWorkerType_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_PublicSafetyEventResponderWorkerType_constr_1$constants.SEGMENT, 0L, asn_PER_type_PublicSafetyEventResponderWorkerType_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_PublicSafetyEventResponderWorkerType$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_PublicSafetyEventResponderWorkerType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PublicSafetyEventResponderWorkerType
     * }
     */
    public static GroupLayout asn_DEF_PublicSafetyEventResponderWorkerType$layout() {
        return asn_DEF_PublicSafetyEventResponderWorkerType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PublicSafetyEventResponderWorkerType
     * }
     */
    public static MemorySegment asn_DEF_PublicSafetyEventResponderWorkerType() {
        return asn_DEF_PublicSafetyEventResponderWorkerType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PublicSafetyEventResponderWorkerType
     * }
     */
    public static void asn_DEF_PublicSafetyEventResponderWorkerType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_PublicSafetyEventResponderWorkerType$constants.SEGMENT, 0L, asn_DEF_PublicSafetyEventResponderWorkerType$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_PublicSafetyEventResponderWorkerType_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_PublicSafetyEventResponderWorkerType_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_PublicSafetyEventResponderWorkerType_specs_1
     * }
     */
    public static GroupLayout asn_SPC_PublicSafetyEventResponderWorkerType_specs_1$layout() {
        return asn_SPC_PublicSafetyEventResponderWorkerType_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_PublicSafetyEventResponderWorkerType_specs_1
     * }
     */
    public static MemorySegment asn_SPC_PublicSafetyEventResponderWorkerType_specs_1() {
        return asn_SPC_PublicSafetyEventResponderWorkerType_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_PublicSafetyEventResponderWorkerType_specs_1
     * }
     */
    public static void asn_SPC_PublicSafetyEventResponderWorkerType_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_PublicSafetyEventResponderWorkerType_specs_1$constants.SEGMENT, 0L, asn_SPC_PublicSafetyEventResponderWorkerType_specs_1$constants.LAYOUT.byteSize());
    }

    private static class PublicSafetyEventResponderWorkerType_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyEventResponderWorkerType_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PublicSafetyEventResponderWorkerType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor PublicSafetyEventResponderWorkerType_free$descriptor() {
        return PublicSafetyEventResponderWorkerType_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PublicSafetyEventResponderWorkerType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle PublicSafetyEventResponderWorkerType_free$handle() {
        return PublicSafetyEventResponderWorkerType_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PublicSafetyEventResponderWorkerType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_free$address() {
        return PublicSafetyEventResponderWorkerType_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PublicSafetyEventResponderWorkerType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void PublicSafetyEventResponderWorkerType_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PublicSafetyEventResponderWorkerType_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyEventResponderWorkerType_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyEventResponderWorkerType_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyEventResponderWorkerType_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PublicSafetyEventResponderWorkerType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PublicSafetyEventResponderWorkerType_print$descriptor() {
        return PublicSafetyEventResponderWorkerType_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PublicSafetyEventResponderWorkerType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PublicSafetyEventResponderWorkerType_print$handle() {
        return PublicSafetyEventResponderWorkerType_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PublicSafetyEventResponderWorkerType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_print$address() {
        return PublicSafetyEventResponderWorkerType_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PublicSafetyEventResponderWorkerType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int PublicSafetyEventResponderWorkerType_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PublicSafetyEventResponderWorkerType_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyEventResponderWorkerType_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyEventResponderWorkerType_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyEventResponderWorkerType_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PublicSafetyEventResponderWorkerType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor PublicSafetyEventResponderWorkerType_constraint$descriptor() {
        return PublicSafetyEventResponderWorkerType_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PublicSafetyEventResponderWorkerType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle PublicSafetyEventResponderWorkerType_constraint$handle() {
        return PublicSafetyEventResponderWorkerType_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PublicSafetyEventResponderWorkerType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_constraint$address() {
        return PublicSafetyEventResponderWorkerType_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PublicSafetyEventResponderWorkerType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int PublicSafetyEventResponderWorkerType_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PublicSafetyEventResponderWorkerType_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyEventResponderWorkerType_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyEventResponderWorkerType_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyEventResponderWorkerType_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyEventResponderWorkerType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor PublicSafetyEventResponderWorkerType_decode_ber$descriptor() {
        return PublicSafetyEventResponderWorkerType_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyEventResponderWorkerType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle PublicSafetyEventResponderWorkerType_decode_ber$handle() {
        return PublicSafetyEventResponderWorkerType_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyEventResponderWorkerType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_decode_ber$address() {
        return PublicSafetyEventResponderWorkerType_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyEventResponderWorkerType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = PublicSafetyEventResponderWorkerType_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyEventResponderWorkerType_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyEventResponderWorkerType_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyEventResponderWorkerType_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PublicSafetyEventResponderWorkerType_encode_der$descriptor() {
        return PublicSafetyEventResponderWorkerType_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PublicSafetyEventResponderWorkerType_encode_der$handle() {
        return PublicSafetyEventResponderWorkerType_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_encode_der$address() {
        return PublicSafetyEventResponderWorkerType_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PublicSafetyEventResponderWorkerType_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyEventResponderWorkerType_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyEventResponderWorkerType_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyEventResponderWorkerType_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyEventResponderWorkerType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor PublicSafetyEventResponderWorkerType_decode_xer$descriptor() {
        return PublicSafetyEventResponderWorkerType_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyEventResponderWorkerType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle PublicSafetyEventResponderWorkerType_decode_xer$handle() {
        return PublicSafetyEventResponderWorkerType_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyEventResponderWorkerType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_decode_xer$address() {
        return PublicSafetyEventResponderWorkerType_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyEventResponderWorkerType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = PublicSafetyEventResponderWorkerType_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyEventResponderWorkerType_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyEventResponderWorkerType_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyEventResponderWorkerType_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PublicSafetyEventResponderWorkerType_encode_xer$descriptor() {
        return PublicSafetyEventResponderWorkerType_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PublicSafetyEventResponderWorkerType_encode_xer$handle() {
        return PublicSafetyEventResponderWorkerType_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_encode_xer$address() {
        return PublicSafetyEventResponderWorkerType_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PublicSafetyEventResponderWorkerType_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyEventResponderWorkerType_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyEventResponderWorkerType_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyEventResponderWorkerType_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PublicSafetyEventResponderWorkerType_encode_jer$descriptor() {
        return PublicSafetyEventResponderWorkerType_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PublicSafetyEventResponderWorkerType_encode_jer$handle() {
        return PublicSafetyEventResponderWorkerType_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_encode_jer$address() {
        return PublicSafetyEventResponderWorkerType_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = PublicSafetyEventResponderWorkerType_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyEventResponderWorkerType_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyEventResponderWorkerType_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyEventResponderWorkerType_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyEventResponderWorkerType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor PublicSafetyEventResponderWorkerType_decode_oer$descriptor() {
        return PublicSafetyEventResponderWorkerType_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyEventResponderWorkerType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle PublicSafetyEventResponderWorkerType_decode_oer$handle() {
        return PublicSafetyEventResponderWorkerType_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyEventResponderWorkerType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_decode_oer$address() {
        return PublicSafetyEventResponderWorkerType_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyEventResponderWorkerType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = PublicSafetyEventResponderWorkerType_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyEventResponderWorkerType_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyEventResponderWorkerType_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyEventResponderWorkerType_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PublicSafetyEventResponderWorkerType_encode_oer$descriptor() {
        return PublicSafetyEventResponderWorkerType_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PublicSafetyEventResponderWorkerType_encode_oer$handle() {
        return PublicSafetyEventResponderWorkerType_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_encode_oer$address() {
        return PublicSafetyEventResponderWorkerType_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PublicSafetyEventResponderWorkerType_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyEventResponderWorkerType_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyEventResponderWorkerType_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyEventResponderWorkerType_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyEventResponderWorkerType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor PublicSafetyEventResponderWorkerType_decode_uper$descriptor() {
        return PublicSafetyEventResponderWorkerType_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyEventResponderWorkerType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle PublicSafetyEventResponderWorkerType_decode_uper$handle() {
        return PublicSafetyEventResponderWorkerType_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyEventResponderWorkerType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_decode_uper$address() {
        return PublicSafetyEventResponderWorkerType_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyEventResponderWorkerType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PublicSafetyEventResponderWorkerType_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyEventResponderWorkerType_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyEventResponderWorkerType_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyEventResponderWorkerType_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor PublicSafetyEventResponderWorkerType_encode_uper$descriptor() {
        return PublicSafetyEventResponderWorkerType_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle PublicSafetyEventResponderWorkerType_encode_uper$handle() {
        return PublicSafetyEventResponderWorkerType_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_encode_uper$address() {
        return PublicSafetyEventResponderWorkerType_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PublicSafetyEventResponderWorkerType_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyEventResponderWorkerType_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyEventResponderWorkerType_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyEventResponderWorkerType_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyEventResponderWorkerType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor PublicSafetyEventResponderWorkerType_decode_aper$descriptor() {
        return PublicSafetyEventResponderWorkerType_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyEventResponderWorkerType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle PublicSafetyEventResponderWorkerType_decode_aper$handle() {
        return PublicSafetyEventResponderWorkerType_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyEventResponderWorkerType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_decode_aper$address() {
        return PublicSafetyEventResponderWorkerType_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyEventResponderWorkerType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PublicSafetyEventResponderWorkerType_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyEventResponderWorkerType_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyEventResponderWorkerType_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyEventResponderWorkerType_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor PublicSafetyEventResponderWorkerType_encode_aper$descriptor() {
        return PublicSafetyEventResponderWorkerType_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle PublicSafetyEventResponderWorkerType_encode_aper$handle() {
        return PublicSafetyEventResponderWorkerType_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_encode_aper$address() {
        return PublicSafetyEventResponderWorkerType_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyEventResponderWorkerType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PublicSafetyEventResponderWorkerType_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PublicSafetyEventResponderWorkerType_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyEventResponderWorkerType_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PublicSafetyAndRoadWorkerActivity_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum PublicSafetyAndRoadWorkerActivity.PublicSafetyAndRoadWorkerActivity_unavailable = 0
     * }
     */
    public static int PublicSafetyAndRoadWorkerActivity_unavailable() {
        return PublicSafetyAndRoadWorkerActivity_unavailable;
    }
    private static final int PublicSafetyAndRoadWorkerActivity_workingOnRoad = (int)1L;
    /**
     * {@snippet lang=c :
     * enum PublicSafetyAndRoadWorkerActivity.PublicSafetyAndRoadWorkerActivity_workingOnRoad = 1
     * }
     */
    public static int PublicSafetyAndRoadWorkerActivity_workingOnRoad() {
        return PublicSafetyAndRoadWorkerActivity_workingOnRoad;
    }
    private static final int PublicSafetyAndRoadWorkerActivity_settingUpClosures = (int)2L;
    /**
     * {@snippet lang=c :
     * enum PublicSafetyAndRoadWorkerActivity.PublicSafetyAndRoadWorkerActivity_settingUpClosures = 2
     * }
     */
    public static int PublicSafetyAndRoadWorkerActivity_settingUpClosures() {
        return PublicSafetyAndRoadWorkerActivity_settingUpClosures;
    }
    private static final int PublicSafetyAndRoadWorkerActivity_respondingToEvents = (int)3L;
    /**
     * {@snippet lang=c :
     * enum PublicSafetyAndRoadWorkerActivity.PublicSafetyAndRoadWorkerActivity_respondingToEvents = 3
     * }
     */
    public static int PublicSafetyAndRoadWorkerActivity_respondingToEvents() {
        return PublicSafetyAndRoadWorkerActivity_respondingToEvents;
    }
    private static final int PublicSafetyAndRoadWorkerActivity_directingTraffic = (int)4L;
    /**
     * {@snippet lang=c :
     * enum PublicSafetyAndRoadWorkerActivity.PublicSafetyAndRoadWorkerActivity_directingTraffic = 4
     * }
     */
    public static int PublicSafetyAndRoadWorkerActivity_directingTraffic() {
        return PublicSafetyAndRoadWorkerActivity_directingTraffic;
    }
    private static final int PublicSafetyAndRoadWorkerActivity_otherActivities = (int)5L;
    /**
     * {@snippet lang=c :
     * enum PublicSafetyAndRoadWorkerActivity.PublicSafetyAndRoadWorkerActivity_otherActivities = 5
     * }
     */
    public static int PublicSafetyAndRoadWorkerActivity_otherActivities() {
        return PublicSafetyAndRoadWorkerActivity_otherActivities;
    }

    private static class asn_PER_type_PublicSafetyAndRoadWorkerActivity_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_PublicSafetyAndRoadWorkerActivity_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PublicSafetyAndRoadWorkerActivity_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_PublicSafetyAndRoadWorkerActivity_constr_1$layout() {
        return asn_PER_type_PublicSafetyAndRoadWorkerActivity_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PublicSafetyAndRoadWorkerActivity_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_PublicSafetyAndRoadWorkerActivity_constr_1() {
        return asn_PER_type_PublicSafetyAndRoadWorkerActivity_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PublicSafetyAndRoadWorkerActivity_constr_1
     * }
     */
    public static void asn_PER_type_PublicSafetyAndRoadWorkerActivity_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_PublicSafetyAndRoadWorkerActivity_constr_1$constants.SEGMENT, 0L, asn_PER_type_PublicSafetyAndRoadWorkerActivity_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_PublicSafetyAndRoadWorkerActivity$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_PublicSafetyAndRoadWorkerActivity").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PublicSafetyAndRoadWorkerActivity
     * }
     */
    public static GroupLayout asn_DEF_PublicSafetyAndRoadWorkerActivity$layout() {
        return asn_DEF_PublicSafetyAndRoadWorkerActivity$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PublicSafetyAndRoadWorkerActivity
     * }
     */
    public static MemorySegment asn_DEF_PublicSafetyAndRoadWorkerActivity() {
        return asn_DEF_PublicSafetyAndRoadWorkerActivity$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PublicSafetyAndRoadWorkerActivity
     * }
     */
    public static void asn_DEF_PublicSafetyAndRoadWorkerActivity(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_PublicSafetyAndRoadWorkerActivity$constants.SEGMENT, 0L, asn_DEF_PublicSafetyAndRoadWorkerActivity$constants.LAYOUT.byteSize());
    }

    private static class PublicSafetyAndRoadWorkerActivity_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyAndRoadWorkerActivity_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PublicSafetyAndRoadWorkerActivity_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor PublicSafetyAndRoadWorkerActivity_free$descriptor() {
        return PublicSafetyAndRoadWorkerActivity_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PublicSafetyAndRoadWorkerActivity_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle PublicSafetyAndRoadWorkerActivity_free$handle() {
        return PublicSafetyAndRoadWorkerActivity_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PublicSafetyAndRoadWorkerActivity_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_free$address() {
        return PublicSafetyAndRoadWorkerActivity_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PublicSafetyAndRoadWorkerActivity_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void PublicSafetyAndRoadWorkerActivity_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PublicSafetyAndRoadWorkerActivity_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyAndRoadWorkerActivity_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyAndRoadWorkerActivity_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyAndRoadWorkerActivity_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PublicSafetyAndRoadWorkerActivity_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PublicSafetyAndRoadWorkerActivity_print$descriptor() {
        return PublicSafetyAndRoadWorkerActivity_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PublicSafetyAndRoadWorkerActivity_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PublicSafetyAndRoadWorkerActivity_print$handle() {
        return PublicSafetyAndRoadWorkerActivity_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PublicSafetyAndRoadWorkerActivity_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_print$address() {
        return PublicSafetyAndRoadWorkerActivity_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PublicSafetyAndRoadWorkerActivity_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int PublicSafetyAndRoadWorkerActivity_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PublicSafetyAndRoadWorkerActivity_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyAndRoadWorkerActivity_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyAndRoadWorkerActivity_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyAndRoadWorkerActivity_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PublicSafetyAndRoadWorkerActivity_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor PublicSafetyAndRoadWorkerActivity_constraint$descriptor() {
        return PublicSafetyAndRoadWorkerActivity_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PublicSafetyAndRoadWorkerActivity_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle PublicSafetyAndRoadWorkerActivity_constraint$handle() {
        return PublicSafetyAndRoadWorkerActivity_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PublicSafetyAndRoadWorkerActivity_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_constraint$address() {
        return PublicSafetyAndRoadWorkerActivity_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PublicSafetyAndRoadWorkerActivity_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int PublicSafetyAndRoadWorkerActivity_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PublicSafetyAndRoadWorkerActivity_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyAndRoadWorkerActivity_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyAndRoadWorkerActivity_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyAndRoadWorkerActivity_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyAndRoadWorkerActivity_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor PublicSafetyAndRoadWorkerActivity_decode_ber$descriptor() {
        return PublicSafetyAndRoadWorkerActivity_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyAndRoadWorkerActivity_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle PublicSafetyAndRoadWorkerActivity_decode_ber$handle() {
        return PublicSafetyAndRoadWorkerActivity_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyAndRoadWorkerActivity_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_decode_ber$address() {
        return PublicSafetyAndRoadWorkerActivity_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyAndRoadWorkerActivity_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = PublicSafetyAndRoadWorkerActivity_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyAndRoadWorkerActivity_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyAndRoadWorkerActivity_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyAndRoadWorkerActivity_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PublicSafetyAndRoadWorkerActivity_encode_der$descriptor() {
        return PublicSafetyAndRoadWorkerActivity_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PublicSafetyAndRoadWorkerActivity_encode_der$handle() {
        return PublicSafetyAndRoadWorkerActivity_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_encode_der$address() {
        return PublicSafetyAndRoadWorkerActivity_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PublicSafetyAndRoadWorkerActivity_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyAndRoadWorkerActivity_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyAndRoadWorkerActivity_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyAndRoadWorkerActivity_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyAndRoadWorkerActivity_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor PublicSafetyAndRoadWorkerActivity_decode_xer$descriptor() {
        return PublicSafetyAndRoadWorkerActivity_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyAndRoadWorkerActivity_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle PublicSafetyAndRoadWorkerActivity_decode_xer$handle() {
        return PublicSafetyAndRoadWorkerActivity_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyAndRoadWorkerActivity_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_decode_xer$address() {
        return PublicSafetyAndRoadWorkerActivity_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyAndRoadWorkerActivity_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = PublicSafetyAndRoadWorkerActivity_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyAndRoadWorkerActivity_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyAndRoadWorkerActivity_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyAndRoadWorkerActivity_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PublicSafetyAndRoadWorkerActivity_encode_xer$descriptor() {
        return PublicSafetyAndRoadWorkerActivity_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PublicSafetyAndRoadWorkerActivity_encode_xer$handle() {
        return PublicSafetyAndRoadWorkerActivity_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_encode_xer$address() {
        return PublicSafetyAndRoadWorkerActivity_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PublicSafetyAndRoadWorkerActivity_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyAndRoadWorkerActivity_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyAndRoadWorkerActivity_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyAndRoadWorkerActivity_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PublicSafetyAndRoadWorkerActivity_encode_jer$descriptor() {
        return PublicSafetyAndRoadWorkerActivity_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PublicSafetyAndRoadWorkerActivity_encode_jer$handle() {
        return PublicSafetyAndRoadWorkerActivity_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_encode_jer$address() {
        return PublicSafetyAndRoadWorkerActivity_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = PublicSafetyAndRoadWorkerActivity_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyAndRoadWorkerActivity_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyAndRoadWorkerActivity_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyAndRoadWorkerActivity_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyAndRoadWorkerActivity_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor PublicSafetyAndRoadWorkerActivity_decode_oer$descriptor() {
        return PublicSafetyAndRoadWorkerActivity_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyAndRoadWorkerActivity_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle PublicSafetyAndRoadWorkerActivity_decode_oer$handle() {
        return PublicSafetyAndRoadWorkerActivity_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyAndRoadWorkerActivity_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_decode_oer$address() {
        return PublicSafetyAndRoadWorkerActivity_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyAndRoadWorkerActivity_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = PublicSafetyAndRoadWorkerActivity_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyAndRoadWorkerActivity_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyAndRoadWorkerActivity_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyAndRoadWorkerActivity_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PublicSafetyAndRoadWorkerActivity_encode_oer$descriptor() {
        return PublicSafetyAndRoadWorkerActivity_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PublicSafetyAndRoadWorkerActivity_encode_oer$handle() {
        return PublicSafetyAndRoadWorkerActivity_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_encode_oer$address() {
        return PublicSafetyAndRoadWorkerActivity_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PublicSafetyAndRoadWorkerActivity_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyAndRoadWorkerActivity_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyAndRoadWorkerActivity_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyAndRoadWorkerActivity_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyAndRoadWorkerActivity_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor PublicSafetyAndRoadWorkerActivity_decode_uper$descriptor() {
        return PublicSafetyAndRoadWorkerActivity_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyAndRoadWorkerActivity_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle PublicSafetyAndRoadWorkerActivity_decode_uper$handle() {
        return PublicSafetyAndRoadWorkerActivity_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyAndRoadWorkerActivity_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_decode_uper$address() {
        return PublicSafetyAndRoadWorkerActivity_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyAndRoadWorkerActivity_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PublicSafetyAndRoadWorkerActivity_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyAndRoadWorkerActivity_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyAndRoadWorkerActivity_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyAndRoadWorkerActivity_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor PublicSafetyAndRoadWorkerActivity_encode_uper$descriptor() {
        return PublicSafetyAndRoadWorkerActivity_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle PublicSafetyAndRoadWorkerActivity_encode_uper$handle() {
        return PublicSafetyAndRoadWorkerActivity_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_encode_uper$address() {
        return PublicSafetyAndRoadWorkerActivity_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PublicSafetyAndRoadWorkerActivity_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyAndRoadWorkerActivity_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyAndRoadWorkerActivity_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyAndRoadWorkerActivity_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyAndRoadWorkerActivity_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor PublicSafetyAndRoadWorkerActivity_decode_aper$descriptor() {
        return PublicSafetyAndRoadWorkerActivity_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyAndRoadWorkerActivity_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle PublicSafetyAndRoadWorkerActivity_decode_aper$handle() {
        return PublicSafetyAndRoadWorkerActivity_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyAndRoadWorkerActivity_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_decode_aper$address() {
        return PublicSafetyAndRoadWorkerActivity_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyAndRoadWorkerActivity_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PublicSafetyAndRoadWorkerActivity_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyAndRoadWorkerActivity_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyAndRoadWorkerActivity_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyAndRoadWorkerActivity_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor PublicSafetyAndRoadWorkerActivity_encode_aper$descriptor() {
        return PublicSafetyAndRoadWorkerActivity_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle PublicSafetyAndRoadWorkerActivity_encode_aper$handle() {
        return PublicSafetyAndRoadWorkerActivity_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_encode_aper$address() {
        return PublicSafetyAndRoadWorkerActivity_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyAndRoadWorkerActivity_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PublicSafetyAndRoadWorkerActivity_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PublicSafetyAndRoadWorkerActivity_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyAndRoadWorkerActivity_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PublicSafetyDirectingTrafficSubType_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum PublicSafetyDirectingTrafficSubType.PublicSafetyDirectingTrafficSubType_unavailable = 0
     * }
     */
    public static int PublicSafetyDirectingTrafficSubType_unavailable() {
        return PublicSafetyDirectingTrafficSubType_unavailable;
    }
    private static final int PublicSafetyDirectingTrafficSubType_policeAndTrafficOfficers = (int)1L;
    /**
     * {@snippet lang=c :
     * enum PublicSafetyDirectingTrafficSubType.PublicSafetyDirectingTrafficSubType_policeAndTrafficOfficers = 1
     * }
     */
    public static int PublicSafetyDirectingTrafficSubType_policeAndTrafficOfficers() {
        return PublicSafetyDirectingTrafficSubType_policeAndTrafficOfficers;
    }
    private static final int PublicSafetyDirectingTrafficSubType_trafficControlPersons = (int)2L;
    /**
     * {@snippet lang=c :
     * enum PublicSafetyDirectingTrafficSubType.PublicSafetyDirectingTrafficSubType_trafficControlPersons = 2
     * }
     */
    public static int PublicSafetyDirectingTrafficSubType_trafficControlPersons() {
        return PublicSafetyDirectingTrafficSubType_trafficControlPersons;
    }
    private static final int PublicSafetyDirectingTrafficSubType_railroadCrossingGuards = (int)3L;
    /**
     * {@snippet lang=c :
     * enum PublicSafetyDirectingTrafficSubType.PublicSafetyDirectingTrafficSubType_railroadCrossingGuards = 3
     * }
     */
    public static int PublicSafetyDirectingTrafficSubType_railroadCrossingGuards() {
        return PublicSafetyDirectingTrafficSubType_railroadCrossingGuards;
    }
    private static final int PublicSafetyDirectingTrafficSubType_civilDefenseNationalGuardMilitaryPolice = (int)4L;
    /**
     * {@snippet lang=c :
     * enum PublicSafetyDirectingTrafficSubType.PublicSafetyDirectingTrafficSubType_civilDefenseNationalGuardMilitaryPolice = 4
     * }
     */
    public static int PublicSafetyDirectingTrafficSubType_civilDefenseNationalGuardMilitaryPolice() {
        return PublicSafetyDirectingTrafficSubType_civilDefenseNationalGuardMilitaryPolice;
    }
    private static final int PublicSafetyDirectingTrafficSubType_emergencyOrganizationPersonnel = (int)5L;
    /**
     * {@snippet lang=c :
     * enum PublicSafetyDirectingTrafficSubType.PublicSafetyDirectingTrafficSubType_emergencyOrganizationPersonnel = 5
     * }
     */
    public static int PublicSafetyDirectingTrafficSubType_emergencyOrganizationPersonnel() {
        return PublicSafetyDirectingTrafficSubType_emergencyOrganizationPersonnel;
    }
    private static final int PublicSafetyDirectingTrafficSubType_highwayServiceVehiclePersonnel = (int)6L;
    /**
     * {@snippet lang=c :
     * enum PublicSafetyDirectingTrafficSubType.PublicSafetyDirectingTrafficSubType_highwayServiceVehiclePersonnel = 6
     * }
     */
    public static int PublicSafetyDirectingTrafficSubType_highwayServiceVehiclePersonnel() {
        return PublicSafetyDirectingTrafficSubType_highwayServiceVehiclePersonnel;
    }

    private static class asn_PER_type_PublicSafetyDirectingTrafficSubType_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_PublicSafetyDirectingTrafficSubType_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PublicSafetyDirectingTrafficSubType_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_PublicSafetyDirectingTrafficSubType_constr_1$layout() {
        return asn_PER_type_PublicSafetyDirectingTrafficSubType_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PublicSafetyDirectingTrafficSubType_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_PublicSafetyDirectingTrafficSubType_constr_1() {
        return asn_PER_type_PublicSafetyDirectingTrafficSubType_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PublicSafetyDirectingTrafficSubType_constr_1
     * }
     */
    public static void asn_PER_type_PublicSafetyDirectingTrafficSubType_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_PublicSafetyDirectingTrafficSubType_constr_1$constants.SEGMENT, 0L, asn_PER_type_PublicSafetyDirectingTrafficSubType_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_PublicSafetyDirectingTrafficSubType$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_PublicSafetyDirectingTrafficSubType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PublicSafetyDirectingTrafficSubType
     * }
     */
    public static GroupLayout asn_DEF_PublicSafetyDirectingTrafficSubType$layout() {
        return asn_DEF_PublicSafetyDirectingTrafficSubType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PublicSafetyDirectingTrafficSubType
     * }
     */
    public static MemorySegment asn_DEF_PublicSafetyDirectingTrafficSubType() {
        return asn_DEF_PublicSafetyDirectingTrafficSubType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PublicSafetyDirectingTrafficSubType
     * }
     */
    public static void asn_DEF_PublicSafetyDirectingTrafficSubType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_PublicSafetyDirectingTrafficSubType$constants.SEGMENT, 0L, asn_DEF_PublicSafetyDirectingTrafficSubType$constants.LAYOUT.byteSize());
    }

    private static class PublicSafetyDirectingTrafficSubType_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyDirectingTrafficSubType_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PublicSafetyDirectingTrafficSubType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor PublicSafetyDirectingTrafficSubType_free$descriptor() {
        return PublicSafetyDirectingTrafficSubType_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PublicSafetyDirectingTrafficSubType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle PublicSafetyDirectingTrafficSubType_free$handle() {
        return PublicSafetyDirectingTrafficSubType_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PublicSafetyDirectingTrafficSubType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_free$address() {
        return PublicSafetyDirectingTrafficSubType_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PublicSafetyDirectingTrafficSubType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void PublicSafetyDirectingTrafficSubType_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PublicSafetyDirectingTrafficSubType_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyDirectingTrafficSubType_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyDirectingTrafficSubType_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyDirectingTrafficSubType_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PublicSafetyDirectingTrafficSubType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PublicSafetyDirectingTrafficSubType_print$descriptor() {
        return PublicSafetyDirectingTrafficSubType_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PublicSafetyDirectingTrafficSubType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PublicSafetyDirectingTrafficSubType_print$handle() {
        return PublicSafetyDirectingTrafficSubType_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PublicSafetyDirectingTrafficSubType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_print$address() {
        return PublicSafetyDirectingTrafficSubType_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PublicSafetyDirectingTrafficSubType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int PublicSafetyDirectingTrafficSubType_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PublicSafetyDirectingTrafficSubType_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyDirectingTrafficSubType_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyDirectingTrafficSubType_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyDirectingTrafficSubType_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PublicSafetyDirectingTrafficSubType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor PublicSafetyDirectingTrafficSubType_constraint$descriptor() {
        return PublicSafetyDirectingTrafficSubType_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PublicSafetyDirectingTrafficSubType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle PublicSafetyDirectingTrafficSubType_constraint$handle() {
        return PublicSafetyDirectingTrafficSubType_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PublicSafetyDirectingTrafficSubType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_constraint$address() {
        return PublicSafetyDirectingTrafficSubType_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PublicSafetyDirectingTrafficSubType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int PublicSafetyDirectingTrafficSubType_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PublicSafetyDirectingTrafficSubType_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyDirectingTrafficSubType_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyDirectingTrafficSubType_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyDirectingTrafficSubType_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyDirectingTrafficSubType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor PublicSafetyDirectingTrafficSubType_decode_ber$descriptor() {
        return PublicSafetyDirectingTrafficSubType_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyDirectingTrafficSubType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle PublicSafetyDirectingTrafficSubType_decode_ber$handle() {
        return PublicSafetyDirectingTrafficSubType_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyDirectingTrafficSubType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_decode_ber$address() {
        return PublicSafetyDirectingTrafficSubType_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyDirectingTrafficSubType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = PublicSafetyDirectingTrafficSubType_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyDirectingTrafficSubType_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyDirectingTrafficSubType_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyDirectingTrafficSubType_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PublicSafetyDirectingTrafficSubType_encode_der$descriptor() {
        return PublicSafetyDirectingTrafficSubType_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PublicSafetyDirectingTrafficSubType_encode_der$handle() {
        return PublicSafetyDirectingTrafficSubType_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_encode_der$address() {
        return PublicSafetyDirectingTrafficSubType_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PublicSafetyDirectingTrafficSubType_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyDirectingTrafficSubType_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyDirectingTrafficSubType_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyDirectingTrafficSubType_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyDirectingTrafficSubType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor PublicSafetyDirectingTrafficSubType_decode_xer$descriptor() {
        return PublicSafetyDirectingTrafficSubType_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyDirectingTrafficSubType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle PublicSafetyDirectingTrafficSubType_decode_xer$handle() {
        return PublicSafetyDirectingTrafficSubType_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyDirectingTrafficSubType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_decode_xer$address() {
        return PublicSafetyDirectingTrafficSubType_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyDirectingTrafficSubType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = PublicSafetyDirectingTrafficSubType_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyDirectingTrafficSubType_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyDirectingTrafficSubType_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyDirectingTrafficSubType_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PublicSafetyDirectingTrafficSubType_encode_xer$descriptor() {
        return PublicSafetyDirectingTrafficSubType_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PublicSafetyDirectingTrafficSubType_encode_xer$handle() {
        return PublicSafetyDirectingTrafficSubType_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_encode_xer$address() {
        return PublicSafetyDirectingTrafficSubType_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PublicSafetyDirectingTrafficSubType_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyDirectingTrafficSubType_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyDirectingTrafficSubType_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyDirectingTrafficSubType_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PublicSafetyDirectingTrafficSubType_encode_jer$descriptor() {
        return PublicSafetyDirectingTrafficSubType_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PublicSafetyDirectingTrafficSubType_encode_jer$handle() {
        return PublicSafetyDirectingTrafficSubType_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_encode_jer$address() {
        return PublicSafetyDirectingTrafficSubType_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = PublicSafetyDirectingTrafficSubType_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyDirectingTrafficSubType_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyDirectingTrafficSubType_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyDirectingTrafficSubType_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyDirectingTrafficSubType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor PublicSafetyDirectingTrafficSubType_decode_oer$descriptor() {
        return PublicSafetyDirectingTrafficSubType_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyDirectingTrafficSubType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle PublicSafetyDirectingTrafficSubType_decode_oer$handle() {
        return PublicSafetyDirectingTrafficSubType_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyDirectingTrafficSubType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_decode_oer$address() {
        return PublicSafetyDirectingTrafficSubType_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyDirectingTrafficSubType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = PublicSafetyDirectingTrafficSubType_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyDirectingTrafficSubType_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyDirectingTrafficSubType_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyDirectingTrafficSubType_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PublicSafetyDirectingTrafficSubType_encode_oer$descriptor() {
        return PublicSafetyDirectingTrafficSubType_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PublicSafetyDirectingTrafficSubType_encode_oer$handle() {
        return PublicSafetyDirectingTrafficSubType_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_encode_oer$address() {
        return PublicSafetyDirectingTrafficSubType_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PublicSafetyDirectingTrafficSubType_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyDirectingTrafficSubType_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyDirectingTrafficSubType_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyDirectingTrafficSubType_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyDirectingTrafficSubType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor PublicSafetyDirectingTrafficSubType_decode_uper$descriptor() {
        return PublicSafetyDirectingTrafficSubType_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyDirectingTrafficSubType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle PublicSafetyDirectingTrafficSubType_decode_uper$handle() {
        return PublicSafetyDirectingTrafficSubType_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyDirectingTrafficSubType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_decode_uper$address() {
        return PublicSafetyDirectingTrafficSubType_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyDirectingTrafficSubType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PublicSafetyDirectingTrafficSubType_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyDirectingTrafficSubType_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyDirectingTrafficSubType_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyDirectingTrafficSubType_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor PublicSafetyDirectingTrafficSubType_encode_uper$descriptor() {
        return PublicSafetyDirectingTrafficSubType_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle PublicSafetyDirectingTrafficSubType_encode_uper$handle() {
        return PublicSafetyDirectingTrafficSubType_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_encode_uper$address() {
        return PublicSafetyDirectingTrafficSubType_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PublicSafetyDirectingTrafficSubType_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyDirectingTrafficSubType_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyDirectingTrafficSubType_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyDirectingTrafficSubType_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyDirectingTrafficSubType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor PublicSafetyDirectingTrafficSubType_decode_aper$descriptor() {
        return PublicSafetyDirectingTrafficSubType_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyDirectingTrafficSubType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle PublicSafetyDirectingTrafficSubType_decode_aper$handle() {
        return PublicSafetyDirectingTrafficSubType_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyDirectingTrafficSubType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_decode_aper$address() {
        return PublicSafetyDirectingTrafficSubType_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PublicSafetyDirectingTrafficSubType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PublicSafetyDirectingTrafficSubType_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyDirectingTrafficSubType_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PublicSafetyDirectingTrafficSubType_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PublicSafetyDirectingTrafficSubType_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor PublicSafetyDirectingTrafficSubType_encode_aper$descriptor() {
        return PublicSafetyDirectingTrafficSubType_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle PublicSafetyDirectingTrafficSubType_encode_aper$handle() {
        return PublicSafetyDirectingTrafficSubType_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_encode_aper$address() {
        return PublicSafetyDirectingTrafficSubType_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PublicSafetyDirectingTrafficSubType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PublicSafetyDirectingTrafficSubType_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PublicSafetyDirectingTrafficSubType_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PublicSafetyDirectingTrafficSubType_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PersonalAssistive_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum PersonalAssistive.PersonalAssistive_unavailable = 0
     * }
     */
    public static int PersonalAssistive_unavailable() {
        return PersonalAssistive_unavailable;
    }
    private static final int PersonalAssistive_otherType = (int)1L;
    /**
     * {@snippet lang=c :
     * enum PersonalAssistive.PersonalAssistive_otherType = 1
     * }
     */
    public static int PersonalAssistive_otherType() {
        return PersonalAssistive_otherType;
    }
    private static final int PersonalAssistive_vision = (int)2L;
    /**
     * {@snippet lang=c :
     * enum PersonalAssistive.PersonalAssistive_vision = 2
     * }
     */
    public static int PersonalAssistive_vision() {
        return PersonalAssistive_vision;
    }
    private static final int PersonalAssistive_hearing = (int)3L;
    /**
     * {@snippet lang=c :
     * enum PersonalAssistive.PersonalAssistive_hearing = 3
     * }
     */
    public static int PersonalAssistive_hearing() {
        return PersonalAssistive_hearing;
    }
    private static final int PersonalAssistive_movement = (int)4L;
    /**
     * {@snippet lang=c :
     * enum PersonalAssistive.PersonalAssistive_movement = 4
     * }
     */
    public static int PersonalAssistive_movement() {
        return PersonalAssistive_movement;
    }
    private static final int PersonalAssistive_cognition = (int)5L;
    /**
     * {@snippet lang=c :
     * enum PersonalAssistive.PersonalAssistive_cognition = 5
     * }
     */
    public static int PersonalAssistive_cognition() {
        return PersonalAssistive_cognition;
    }

    private static class asn_PER_type_PersonalAssistive_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_PersonalAssistive_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PersonalAssistive_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_PersonalAssistive_constr_1$layout() {
        return asn_PER_type_PersonalAssistive_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PersonalAssistive_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_PersonalAssistive_constr_1() {
        return asn_PER_type_PersonalAssistive_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PersonalAssistive_constr_1
     * }
     */
    public static void asn_PER_type_PersonalAssistive_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_PersonalAssistive_constr_1$constants.SEGMENT, 0L, asn_PER_type_PersonalAssistive_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_PersonalAssistive$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_PersonalAssistive").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PersonalAssistive
     * }
     */
    public static GroupLayout asn_DEF_PersonalAssistive$layout() {
        return asn_DEF_PersonalAssistive$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PersonalAssistive
     * }
     */
    public static MemorySegment asn_DEF_PersonalAssistive() {
        return asn_DEF_PersonalAssistive$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PersonalAssistive
     * }
     */
    public static void asn_DEF_PersonalAssistive(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_PersonalAssistive$constants.SEGMENT, 0L, asn_DEF_PersonalAssistive$constants.LAYOUT.byteSize());
    }

    private static class PersonalAssistive_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalAssistive_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PersonalAssistive_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor PersonalAssistive_free$descriptor() {
        return PersonalAssistive_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PersonalAssistive_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle PersonalAssistive_free$handle() {
        return PersonalAssistive_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PersonalAssistive_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment PersonalAssistive_free$address() {
        return PersonalAssistive_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PersonalAssistive_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void PersonalAssistive_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PersonalAssistive_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalAssistive_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalAssistive_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalAssistive_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PersonalAssistive_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalAssistive_print$descriptor() {
        return PersonalAssistive_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PersonalAssistive_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalAssistive_print$handle() {
        return PersonalAssistive_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PersonalAssistive_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalAssistive_print$address() {
        return PersonalAssistive_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PersonalAssistive_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int PersonalAssistive_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalAssistive_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalAssistive_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalAssistive_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalAssistive_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PersonalAssistive_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalAssistive_constraint$descriptor() {
        return PersonalAssistive_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PersonalAssistive_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle PersonalAssistive_constraint$handle() {
        return PersonalAssistive_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PersonalAssistive_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment PersonalAssistive_constraint$address() {
        return PersonalAssistive_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PersonalAssistive_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int PersonalAssistive_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PersonalAssistive_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalAssistive_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalAssistive_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalAssistive_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalAssistive_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor PersonalAssistive_decode_ber$descriptor() {
        return PersonalAssistive_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalAssistive_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle PersonalAssistive_decode_ber$handle() {
        return PersonalAssistive_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalAssistive_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment PersonalAssistive_decode_ber$address() {
        return PersonalAssistive_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalAssistive_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment PersonalAssistive_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = PersonalAssistive_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalAssistive_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalAssistive_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalAssistive_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalAssistive_encode_der$descriptor() {
        return PersonalAssistive_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalAssistive_encode_der$handle() {
        return PersonalAssistive_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalAssistive_encode_der$address() {
        return PersonalAssistive_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalAssistive_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PersonalAssistive_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalAssistive_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalAssistive_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalAssistive_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalAssistive_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor PersonalAssistive_decode_xer$descriptor() {
        return PersonalAssistive_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalAssistive_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle PersonalAssistive_decode_xer$handle() {
        return PersonalAssistive_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalAssistive_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalAssistive_decode_xer$address() {
        return PersonalAssistive_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalAssistive_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalAssistive_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = PersonalAssistive_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalAssistive_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalAssistive_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalAssistive_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalAssistive_encode_xer$descriptor() {
        return PersonalAssistive_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalAssistive_encode_xer$handle() {
        return PersonalAssistive_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalAssistive_encode_xer$address() {
        return PersonalAssistive_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalAssistive_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PersonalAssistive_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalAssistive_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalAssistive_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalAssistive_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalAssistive_encode_jer$descriptor() {
        return PersonalAssistive_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalAssistive_encode_jer$handle() {
        return PersonalAssistive_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalAssistive_encode_jer$address() {
        return PersonalAssistive_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalAssistive_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = PersonalAssistive_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalAssistive_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalAssistive_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalAssistive_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalAssistive_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor PersonalAssistive_decode_oer$descriptor() {
        return PersonalAssistive_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalAssistive_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle PersonalAssistive_decode_oer$handle() {
        return PersonalAssistive_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalAssistive_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalAssistive_decode_oer$address() {
        return PersonalAssistive_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalAssistive_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment PersonalAssistive_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = PersonalAssistive_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalAssistive_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalAssistive_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalAssistive_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PersonalAssistive_encode_oer$descriptor() {
        return PersonalAssistive_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PersonalAssistive_encode_oer$handle() {
        return PersonalAssistive_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalAssistive_encode_oer$address() {
        return PersonalAssistive_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PersonalAssistive_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalAssistive_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalAssistive_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalAssistive_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalAssistive_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalAssistive_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor PersonalAssistive_decode_uper$descriptor() {
        return PersonalAssistive_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalAssistive_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle PersonalAssistive_decode_uper$handle() {
        return PersonalAssistive_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalAssistive_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalAssistive_decode_uper$address() {
        return PersonalAssistive_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalAssistive_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalAssistive_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalAssistive_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalAssistive_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalAssistive_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalAssistive_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor PersonalAssistive_encode_uper$descriptor() {
        return PersonalAssistive_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle PersonalAssistive_encode_uper$handle() {
        return PersonalAssistive_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalAssistive_encode_uper$address() {
        return PersonalAssistive_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalAssistive_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PersonalAssistive_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalAssistive_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalAssistive_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalAssistive_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalAssistive_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor PersonalAssistive_decode_aper$descriptor() {
        return PersonalAssistive_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalAssistive_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle PersonalAssistive_decode_aper$handle() {
        return PersonalAssistive_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalAssistive_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalAssistive_decode_aper$address() {
        return PersonalAssistive_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PersonalAssistive_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PersonalAssistive_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PersonalAssistive_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalAssistive_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PersonalAssistive_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PersonalAssistive_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor PersonalAssistive_encode_aper$descriptor() {
        return PersonalAssistive_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle PersonalAssistive_encode_aper$handle() {
        return PersonalAssistive_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalAssistive_encode_aper$address() {
        return PersonalAssistive_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PersonalAssistive_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PersonalAssistive_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PersonalAssistive_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PersonalAssistive_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int UserSizeAndBehaviour_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum UserSizeAndBehaviour.UserSizeAndBehaviour_unavailable = 0
     * }
     */
    public static int UserSizeAndBehaviour_unavailable() {
        return UserSizeAndBehaviour_unavailable;
    }
    private static final int UserSizeAndBehaviour_smallStature = (int)1L;
    /**
     * {@snippet lang=c :
     * enum UserSizeAndBehaviour.UserSizeAndBehaviour_smallStature = 1
     * }
     */
    public static int UserSizeAndBehaviour_smallStature() {
        return UserSizeAndBehaviour_smallStature;
    }
    private static final int UserSizeAndBehaviour_largeStature = (int)2L;
    /**
     * {@snippet lang=c :
     * enum UserSizeAndBehaviour.UserSizeAndBehaviour_largeStature = 2
     * }
     */
    public static int UserSizeAndBehaviour_largeStature() {
        return UserSizeAndBehaviour_largeStature;
    }
    private static final int UserSizeAndBehaviour_erraticMoving = (int)3L;
    /**
     * {@snippet lang=c :
     * enum UserSizeAndBehaviour.UserSizeAndBehaviour_erraticMoving = 3
     * }
     */
    public static int UserSizeAndBehaviour_erraticMoving() {
        return UserSizeAndBehaviour_erraticMoving;
    }
    private static final int UserSizeAndBehaviour_slowMoving = (int)4L;
    /**
     * {@snippet lang=c :
     * enum UserSizeAndBehaviour.UserSizeAndBehaviour_slowMoving = 4
     * }
     */
    public static int UserSizeAndBehaviour_slowMoving() {
        return UserSizeAndBehaviour_slowMoving;
    }

    private static class asn_PER_type_UserSizeAndBehaviour_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_UserSizeAndBehaviour_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_UserSizeAndBehaviour_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_UserSizeAndBehaviour_constr_1$layout() {
        return asn_PER_type_UserSizeAndBehaviour_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_UserSizeAndBehaviour_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_UserSizeAndBehaviour_constr_1() {
        return asn_PER_type_UserSizeAndBehaviour_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_UserSizeAndBehaviour_constr_1
     * }
     */
    public static void asn_PER_type_UserSizeAndBehaviour_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_UserSizeAndBehaviour_constr_1$constants.SEGMENT, 0L, asn_PER_type_UserSizeAndBehaviour_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_UserSizeAndBehaviour$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_UserSizeAndBehaviour").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_UserSizeAndBehaviour
     * }
     */
    public static GroupLayout asn_DEF_UserSizeAndBehaviour$layout() {
        return asn_DEF_UserSizeAndBehaviour$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_UserSizeAndBehaviour
     * }
     */
    public static MemorySegment asn_DEF_UserSizeAndBehaviour() {
        return asn_DEF_UserSizeAndBehaviour$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_UserSizeAndBehaviour
     * }
     */
    public static void asn_DEF_UserSizeAndBehaviour(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_UserSizeAndBehaviour$constants.SEGMENT, 0L, asn_DEF_UserSizeAndBehaviour$constants.LAYOUT.byteSize());
    }

    private static class UserSizeAndBehaviour_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("UserSizeAndBehaviour_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void UserSizeAndBehaviour_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor UserSizeAndBehaviour_free$descriptor() {
        return UserSizeAndBehaviour_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void UserSizeAndBehaviour_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle UserSizeAndBehaviour_free$handle() {
        return UserSizeAndBehaviour_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void UserSizeAndBehaviour_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_free$address() {
        return UserSizeAndBehaviour_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void UserSizeAndBehaviour_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void UserSizeAndBehaviour_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = UserSizeAndBehaviour_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UserSizeAndBehaviour_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UserSizeAndBehaviour_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("UserSizeAndBehaviour_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int UserSizeAndBehaviour_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor UserSizeAndBehaviour_print$descriptor() {
        return UserSizeAndBehaviour_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int UserSizeAndBehaviour_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle UserSizeAndBehaviour_print$handle() {
        return UserSizeAndBehaviour_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int UserSizeAndBehaviour_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_print$address() {
        return UserSizeAndBehaviour_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int UserSizeAndBehaviour_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int UserSizeAndBehaviour_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = UserSizeAndBehaviour_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UserSizeAndBehaviour_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UserSizeAndBehaviour_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("UserSizeAndBehaviour_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int UserSizeAndBehaviour_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor UserSizeAndBehaviour_constraint$descriptor() {
        return UserSizeAndBehaviour_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int UserSizeAndBehaviour_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle UserSizeAndBehaviour_constraint$handle() {
        return UserSizeAndBehaviour_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int UserSizeAndBehaviour_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_constraint$address() {
        return UserSizeAndBehaviour_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int UserSizeAndBehaviour_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int UserSizeAndBehaviour_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = UserSizeAndBehaviour_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UserSizeAndBehaviour_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UserSizeAndBehaviour_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("UserSizeAndBehaviour_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t UserSizeAndBehaviour_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor UserSizeAndBehaviour_decode_ber$descriptor() {
        return UserSizeAndBehaviour_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t UserSizeAndBehaviour_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle UserSizeAndBehaviour_decode_ber$handle() {
        return UserSizeAndBehaviour_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t UserSizeAndBehaviour_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_decode_ber$address() {
        return UserSizeAndBehaviour_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t UserSizeAndBehaviour_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = UserSizeAndBehaviour_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UserSizeAndBehaviour_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UserSizeAndBehaviour_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("UserSizeAndBehaviour_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor UserSizeAndBehaviour_encode_der$descriptor() {
        return UserSizeAndBehaviour_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle UserSizeAndBehaviour_encode_der$handle() {
        return UserSizeAndBehaviour_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_encode_der$address() {
        return UserSizeAndBehaviour_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = UserSizeAndBehaviour_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UserSizeAndBehaviour_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UserSizeAndBehaviour_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("UserSizeAndBehaviour_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t UserSizeAndBehaviour_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor UserSizeAndBehaviour_decode_xer$descriptor() {
        return UserSizeAndBehaviour_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t UserSizeAndBehaviour_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle UserSizeAndBehaviour_decode_xer$handle() {
        return UserSizeAndBehaviour_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t UserSizeAndBehaviour_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_decode_xer$address() {
        return UserSizeAndBehaviour_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t UserSizeAndBehaviour_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = UserSizeAndBehaviour_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UserSizeAndBehaviour_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UserSizeAndBehaviour_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("UserSizeAndBehaviour_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor UserSizeAndBehaviour_encode_xer$descriptor() {
        return UserSizeAndBehaviour_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle UserSizeAndBehaviour_encode_xer$handle() {
        return UserSizeAndBehaviour_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_encode_xer$address() {
        return UserSizeAndBehaviour_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = UserSizeAndBehaviour_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UserSizeAndBehaviour_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UserSizeAndBehaviour_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("UserSizeAndBehaviour_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor UserSizeAndBehaviour_encode_jer$descriptor() {
        return UserSizeAndBehaviour_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle UserSizeAndBehaviour_encode_jer$handle() {
        return UserSizeAndBehaviour_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_encode_jer$address() {
        return UserSizeAndBehaviour_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = UserSizeAndBehaviour_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UserSizeAndBehaviour_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UserSizeAndBehaviour_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("UserSizeAndBehaviour_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t UserSizeAndBehaviour_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor UserSizeAndBehaviour_decode_oer$descriptor() {
        return UserSizeAndBehaviour_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t UserSizeAndBehaviour_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle UserSizeAndBehaviour_decode_oer$handle() {
        return UserSizeAndBehaviour_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t UserSizeAndBehaviour_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_decode_oer$address() {
        return UserSizeAndBehaviour_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t UserSizeAndBehaviour_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = UserSizeAndBehaviour_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UserSizeAndBehaviour_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UserSizeAndBehaviour_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("UserSizeAndBehaviour_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor UserSizeAndBehaviour_encode_oer$descriptor() {
        return UserSizeAndBehaviour_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle UserSizeAndBehaviour_encode_oer$handle() {
        return UserSizeAndBehaviour_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_encode_oer$address() {
        return UserSizeAndBehaviour_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = UserSizeAndBehaviour_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UserSizeAndBehaviour_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UserSizeAndBehaviour_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("UserSizeAndBehaviour_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t UserSizeAndBehaviour_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor UserSizeAndBehaviour_decode_uper$descriptor() {
        return UserSizeAndBehaviour_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t UserSizeAndBehaviour_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle UserSizeAndBehaviour_decode_uper$handle() {
        return UserSizeAndBehaviour_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t UserSizeAndBehaviour_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_decode_uper$address() {
        return UserSizeAndBehaviour_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t UserSizeAndBehaviour_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = UserSizeAndBehaviour_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UserSizeAndBehaviour_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UserSizeAndBehaviour_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("UserSizeAndBehaviour_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor UserSizeAndBehaviour_encode_uper$descriptor() {
        return UserSizeAndBehaviour_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle UserSizeAndBehaviour_encode_uper$handle() {
        return UserSizeAndBehaviour_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_encode_uper$address() {
        return UserSizeAndBehaviour_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = UserSizeAndBehaviour_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UserSizeAndBehaviour_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UserSizeAndBehaviour_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("UserSizeAndBehaviour_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t UserSizeAndBehaviour_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor UserSizeAndBehaviour_decode_aper$descriptor() {
        return UserSizeAndBehaviour_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t UserSizeAndBehaviour_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle UserSizeAndBehaviour_decode_aper$handle() {
        return UserSizeAndBehaviour_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t UserSizeAndBehaviour_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_decode_aper$address() {
        return UserSizeAndBehaviour_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t UserSizeAndBehaviour_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = UserSizeAndBehaviour_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UserSizeAndBehaviour_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class UserSizeAndBehaviour_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("UserSizeAndBehaviour_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor UserSizeAndBehaviour_encode_aper$descriptor() {
        return UserSizeAndBehaviour_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle UserSizeAndBehaviour_encode_aper$handle() {
        return UserSizeAndBehaviour_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_encode_aper$address() {
        return UserSizeAndBehaviour_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t UserSizeAndBehaviour_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment UserSizeAndBehaviour_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = UserSizeAndBehaviour_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("UserSizeAndBehaviour_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int Attachment_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum Attachment.Attachment_unavailable = 0
     * }
     */
    public static int Attachment_unavailable() {
        return Attachment_unavailable;
    }
    private static final int Attachment_stroller = (int)1L;
    /**
     * {@snippet lang=c :
     * enum Attachment.Attachment_stroller = 1
     * }
     */
    public static int Attachment_stroller() {
        return Attachment_stroller;
    }
    private static final int Attachment_bicycleTrailer = (int)2L;
    /**
     * {@snippet lang=c :
     * enum Attachment.Attachment_bicycleTrailer = 2
     * }
     */
    public static int Attachment_bicycleTrailer() {
        return Attachment_bicycleTrailer;
    }
    private static final int Attachment_cart = (int)3L;
    /**
     * {@snippet lang=c :
     * enum Attachment.Attachment_cart = 3
     * }
     */
    public static int Attachment_cart() {
        return Attachment_cart;
    }
    private static final int Attachment_wheelchair = (int)4L;
    /**
     * {@snippet lang=c :
     * enum Attachment.Attachment_wheelchair = 4
     * }
     */
    public static int Attachment_wheelchair() {
        return Attachment_wheelchair;
    }
    private static final int Attachment_otherWalkAssistAttachments = (int)5L;
    /**
     * {@snippet lang=c :
     * enum Attachment.Attachment_otherWalkAssistAttachments = 5
     * }
     */
    public static int Attachment_otherWalkAssistAttachments() {
        return Attachment_otherWalkAssistAttachments;
    }
    private static final int Attachment_pet = (int)6L;
    /**
     * {@snippet lang=c :
     * enum Attachment.Attachment_pet = 6
     * }
     */
    public static int Attachment_pet() {
        return Attachment_pet;
    }
    /**
     * {@snippet lang=c :
     * typedef long Attachment_t
     * }
     */
    public static final OfLong Attachment_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_Attachment_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_Attachment_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Attachment_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_Attachment_constr_1$layout() {
        return asn_PER_type_Attachment_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Attachment_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_Attachment_constr_1() {
        return asn_PER_type_Attachment_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Attachment_constr_1
     * }
     */
    public static void asn_PER_type_Attachment_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_Attachment_constr_1$constants.SEGMENT, 0L, asn_PER_type_Attachment_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_Attachment$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_Attachment").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Attachment
     * }
     */
    public static GroupLayout asn_DEF_Attachment$layout() {
        return asn_DEF_Attachment$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Attachment
     * }
     */
    public static MemorySegment asn_DEF_Attachment() {
        return asn_DEF_Attachment$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Attachment
     * }
     */
    public static void asn_DEF_Attachment(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_Attachment$constants.SEGMENT, 0L, asn_DEF_Attachment$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_Attachment_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_Attachment_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_Attachment_specs_1
     * }
     */
    public static GroupLayout asn_SPC_Attachment_specs_1$layout() {
        return asn_SPC_Attachment_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_Attachment_specs_1
     * }
     */
    public static MemorySegment asn_SPC_Attachment_specs_1() {
        return asn_SPC_Attachment_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_Attachment_specs_1
     * }
     */
    public static void asn_SPC_Attachment_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_Attachment_specs_1$constants.SEGMENT, 0L, asn_SPC_Attachment_specs_1$constants.LAYOUT.byteSize());
    }

    private static class Attachment_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Attachment_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Attachment_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor Attachment_free$descriptor() {
        return Attachment_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Attachment_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle Attachment_free$handle() {
        return Attachment_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Attachment_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment Attachment_free$address() {
        return Attachment_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Attachment_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void Attachment_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = Attachment_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Attachment_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Attachment_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Attachment_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Attachment_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Attachment_print$descriptor() {
        return Attachment_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Attachment_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Attachment_print$handle() {
        return Attachment_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Attachment_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Attachment_print$address() {
        return Attachment_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Attachment_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int Attachment_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Attachment_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Attachment_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Attachment_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Attachment_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Attachment_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor Attachment_constraint$descriptor() {
        return Attachment_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Attachment_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle Attachment_constraint$handle() {
        return Attachment_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Attachment_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment Attachment_constraint$address() {
        return Attachment_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Attachment_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int Attachment_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Attachment_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Attachment_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Attachment_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Attachment_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Attachment_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor Attachment_decode_ber$descriptor() {
        return Attachment_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Attachment_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle Attachment_decode_ber$handle() {
        return Attachment_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Attachment_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Attachment_decode_ber$address() {
        return Attachment_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Attachment_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Attachment_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = Attachment_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Attachment_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Attachment_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Attachment_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Attachment_encode_der$descriptor() {
        return Attachment_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Attachment_encode_der$handle() {
        return Attachment_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Attachment_encode_der$address() {
        return Attachment_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Attachment_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Attachment_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Attachment_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Attachment_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Attachment_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Attachment_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Attachment_decode_xer$descriptor() {
        return Attachment_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Attachment_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle Attachment_decode_xer$handle() {
        return Attachment_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Attachment_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Attachment_decode_xer$address() {
        return Attachment_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Attachment_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Attachment_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Attachment_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Attachment_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Attachment_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Attachment_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Attachment_encode_xer$descriptor() {
        return Attachment_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Attachment_encode_xer$handle() {
        return Attachment_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Attachment_encode_xer$address() {
        return Attachment_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Attachment_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Attachment_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Attachment_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Attachment_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Attachment_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Attachment_encode_jer$descriptor() {
        return Attachment_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Attachment_encode_jer$handle() {
        return Attachment_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Attachment_encode_jer$address() {
        return Attachment_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Attachment_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = Attachment_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Attachment_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Attachment_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Attachment_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Attachment_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Attachment_decode_oer$descriptor() {
        return Attachment_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Attachment_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle Attachment_decode_oer$handle() {
        return Attachment_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Attachment_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Attachment_decode_oer$address() {
        return Attachment_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Attachment_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Attachment_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Attachment_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Attachment_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Attachment_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Attachment_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Attachment_encode_oer$descriptor() {
        return Attachment_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Attachment_encode_oer$handle() {
        return Attachment_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Attachment_encode_oer$address() {
        return Attachment_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Attachment_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Attachment_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Attachment_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Attachment_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Attachment_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Attachment_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Attachment_decode_uper$descriptor() {
        return Attachment_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Attachment_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Attachment_decode_uper$handle() {
        return Attachment_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Attachment_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Attachment_decode_uper$address() {
        return Attachment_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Attachment_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Attachment_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Attachment_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Attachment_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Attachment_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Attachment_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Attachment_encode_uper$descriptor() {
        return Attachment_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Attachment_encode_uper$handle() {
        return Attachment_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Attachment_encode_uper$address() {
        return Attachment_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Attachment_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Attachment_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Attachment_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Attachment_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Attachment_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Attachment_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Attachment_decode_aper$descriptor() {
        return Attachment_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Attachment_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Attachment_decode_aper$handle() {
        return Attachment_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Attachment_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Attachment_decode_aper$address() {
        return Attachment_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Attachment_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Attachment_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Attachment_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Attachment_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Attachment_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Attachment_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Attachment_encode_aper$descriptor() {
        return Attachment_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Attachment_encode_aper$handle() {
        return Attachment_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Attachment_encode_aper$address() {
        return Attachment_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Attachment_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Attachment_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Attachment_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Attachment_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long AttachmentRadius_t
     * }
     */
    public static final OfLong AttachmentRadius_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_AttachmentRadius_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_AttachmentRadius_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AttachmentRadius_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_AttachmentRadius_constr_1$layout() {
        return asn_PER_type_AttachmentRadius_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AttachmentRadius_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_AttachmentRadius_constr_1() {
        return asn_PER_type_AttachmentRadius_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AttachmentRadius_constr_1
     * }
     */
    public static void asn_PER_type_AttachmentRadius_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_AttachmentRadius_constr_1$constants.SEGMENT, 0L, asn_PER_type_AttachmentRadius_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_AttachmentRadius$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_AttachmentRadius").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AttachmentRadius
     * }
     */
    public static GroupLayout asn_DEF_AttachmentRadius$layout() {
        return asn_DEF_AttachmentRadius$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AttachmentRadius
     * }
     */
    public static MemorySegment asn_DEF_AttachmentRadius() {
        return asn_DEF_AttachmentRadius$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AttachmentRadius
     * }
     */
    public static void asn_DEF_AttachmentRadius(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_AttachmentRadius$constants.SEGMENT, 0L, asn_DEF_AttachmentRadius$constants.LAYOUT.byteSize());
    }

    private static class AttachmentRadius_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AttachmentRadius_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void AttachmentRadius_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor AttachmentRadius_free$descriptor() {
        return AttachmentRadius_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void AttachmentRadius_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle AttachmentRadius_free$handle() {
        return AttachmentRadius_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void AttachmentRadius_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment AttachmentRadius_free$address() {
        return AttachmentRadius_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void AttachmentRadius_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void AttachmentRadius_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = AttachmentRadius_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachmentRadius_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachmentRadius_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AttachmentRadius_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AttachmentRadius_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AttachmentRadius_print$descriptor() {
        return AttachmentRadius_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AttachmentRadius_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AttachmentRadius_print$handle() {
        return AttachmentRadius_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AttachmentRadius_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AttachmentRadius_print$address() {
        return AttachmentRadius_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AttachmentRadius_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int AttachmentRadius_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AttachmentRadius_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachmentRadius_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachmentRadius_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AttachmentRadius_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AttachmentRadius_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor AttachmentRadius_constraint$descriptor() {
        return AttachmentRadius_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AttachmentRadius_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle AttachmentRadius_constraint$handle() {
        return AttachmentRadius_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AttachmentRadius_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment AttachmentRadius_constraint$address() {
        return AttachmentRadius_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AttachmentRadius_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int AttachmentRadius_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = AttachmentRadius_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachmentRadius_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachmentRadius_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AttachmentRadius_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AttachmentRadius_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor AttachmentRadius_decode_ber$descriptor() {
        return AttachmentRadius_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AttachmentRadius_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle AttachmentRadius_decode_ber$handle() {
        return AttachmentRadius_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AttachmentRadius_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment AttachmentRadius_decode_ber$address() {
        return AttachmentRadius_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AttachmentRadius_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment AttachmentRadius_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = AttachmentRadius_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachmentRadius_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachmentRadius_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AttachmentRadius_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AttachmentRadius_encode_der$descriptor() {
        return AttachmentRadius_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AttachmentRadius_encode_der$handle() {
        return AttachmentRadius_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AttachmentRadius_encode_der$address() {
        return AttachmentRadius_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AttachmentRadius_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = AttachmentRadius_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachmentRadius_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachmentRadius_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AttachmentRadius_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AttachmentRadius_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor AttachmentRadius_decode_xer$descriptor() {
        return AttachmentRadius_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AttachmentRadius_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle AttachmentRadius_decode_xer$handle() {
        return AttachmentRadius_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AttachmentRadius_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment AttachmentRadius_decode_xer$address() {
        return AttachmentRadius_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AttachmentRadius_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment AttachmentRadius_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = AttachmentRadius_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachmentRadius_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachmentRadius_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AttachmentRadius_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AttachmentRadius_encode_xer$descriptor() {
        return AttachmentRadius_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AttachmentRadius_encode_xer$handle() {
        return AttachmentRadius_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AttachmentRadius_encode_xer$address() {
        return AttachmentRadius_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AttachmentRadius_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = AttachmentRadius_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachmentRadius_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachmentRadius_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AttachmentRadius_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AttachmentRadius_encode_jer$descriptor() {
        return AttachmentRadius_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AttachmentRadius_encode_jer$handle() {
        return AttachmentRadius_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AttachmentRadius_encode_jer$address() {
        return AttachmentRadius_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AttachmentRadius_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = AttachmentRadius_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachmentRadius_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachmentRadius_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AttachmentRadius_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AttachmentRadius_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor AttachmentRadius_decode_oer$descriptor() {
        return AttachmentRadius_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AttachmentRadius_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle AttachmentRadius_decode_oer$handle() {
        return AttachmentRadius_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AttachmentRadius_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment AttachmentRadius_decode_oer$address() {
        return AttachmentRadius_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AttachmentRadius_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment AttachmentRadius_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = AttachmentRadius_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachmentRadius_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachmentRadius_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AttachmentRadius_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AttachmentRadius_encode_oer$descriptor() {
        return AttachmentRadius_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AttachmentRadius_encode_oer$handle() {
        return AttachmentRadius_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AttachmentRadius_encode_oer$address() {
        return AttachmentRadius_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AttachmentRadius_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AttachmentRadius_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachmentRadius_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachmentRadius_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AttachmentRadius_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AttachmentRadius_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor AttachmentRadius_decode_uper$descriptor() {
        return AttachmentRadius_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AttachmentRadius_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle AttachmentRadius_decode_uper$handle() {
        return AttachmentRadius_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AttachmentRadius_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AttachmentRadius_decode_uper$address() {
        return AttachmentRadius_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AttachmentRadius_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AttachmentRadius_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AttachmentRadius_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachmentRadius_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachmentRadius_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AttachmentRadius_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor AttachmentRadius_encode_uper$descriptor() {
        return AttachmentRadius_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle AttachmentRadius_encode_uper$handle() {
        return AttachmentRadius_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AttachmentRadius_encode_uper$address() {
        return AttachmentRadius_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AttachmentRadius_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = AttachmentRadius_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachmentRadius_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachmentRadius_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AttachmentRadius_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AttachmentRadius_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor AttachmentRadius_decode_aper$descriptor() {
        return AttachmentRadius_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AttachmentRadius_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle AttachmentRadius_decode_aper$handle() {
        return AttachmentRadius_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AttachmentRadius_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AttachmentRadius_decode_aper$address() {
        return AttachmentRadius_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AttachmentRadius_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AttachmentRadius_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AttachmentRadius_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachmentRadius_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AttachmentRadius_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AttachmentRadius_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor AttachmentRadius_encode_aper$descriptor() {
        return AttachmentRadius_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle AttachmentRadius_encode_aper$handle() {
        return AttachmentRadius_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AttachmentRadius_encode_aper$address() {
        return AttachmentRadius_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AttachmentRadius_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AttachmentRadius_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = AttachmentRadius_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AttachmentRadius_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AnimalType_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AnimalType.AnimalType_unavailable = 0
     * }
     */
    public static int AnimalType_unavailable() {
        return AnimalType_unavailable;
    }
    private static final int AnimalType_serviceUse = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AnimalType.AnimalType_serviceUse = 1
     * }
     */
    public static int AnimalType_serviceUse() {
        return AnimalType_serviceUse;
    }
    private static final int AnimalType_pet = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AnimalType.AnimalType_pet = 2
     * }
     */
    public static int AnimalType_pet() {
        return AnimalType_pet;
    }
    private static final int AnimalType_farm = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AnimalType.AnimalType_farm = 3
     * }
     */
    public static int AnimalType_farm() {
        return AnimalType_farm;
    }
    /**
     * {@snippet lang=c :
     * typedef long AnimalType_t
     * }
     */
    public static final OfLong AnimalType_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_AnimalType_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_AnimalType_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AnimalType_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_AnimalType_constr_1$layout() {
        return asn_PER_type_AnimalType_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AnimalType_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_AnimalType_constr_1() {
        return asn_PER_type_AnimalType_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AnimalType_constr_1
     * }
     */
    public static void asn_PER_type_AnimalType_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_AnimalType_constr_1$constants.SEGMENT, 0L, asn_PER_type_AnimalType_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_AnimalType$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_AnimalType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AnimalType
     * }
     */
    public static GroupLayout asn_DEF_AnimalType$layout() {
        return asn_DEF_AnimalType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AnimalType
     * }
     */
    public static MemorySegment asn_DEF_AnimalType() {
        return asn_DEF_AnimalType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AnimalType
     * }
     */
    public static void asn_DEF_AnimalType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_AnimalType$constants.SEGMENT, 0L, asn_DEF_AnimalType$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_AnimalType_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_AnimalType_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_AnimalType_specs_1
     * }
     */
    public static GroupLayout asn_SPC_AnimalType_specs_1$layout() {
        return asn_SPC_AnimalType_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_AnimalType_specs_1
     * }
     */
    public static MemorySegment asn_SPC_AnimalType_specs_1() {
        return asn_SPC_AnimalType_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_AnimalType_specs_1
     * }
     */
    public static void asn_SPC_AnimalType_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_AnimalType_specs_1$constants.SEGMENT, 0L, asn_SPC_AnimalType_specs_1$constants.LAYOUT.byteSize());
    }

    private static class AnimalType_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalType_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void AnimalType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor AnimalType_free$descriptor() {
        return AnimalType_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void AnimalType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle AnimalType_free$handle() {
        return AnimalType_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void AnimalType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment AnimalType_free$address() {
        return AnimalType_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void AnimalType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void AnimalType_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = AnimalType_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalType_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalType_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalType_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AnimalType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AnimalType_print$descriptor() {
        return AnimalType_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AnimalType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AnimalType_print$handle() {
        return AnimalType_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AnimalType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AnimalType_print$address() {
        return AnimalType_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AnimalType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int AnimalType_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AnimalType_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalType_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalType_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalType_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AnimalType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor AnimalType_constraint$descriptor() {
        return AnimalType_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AnimalType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle AnimalType_constraint$handle() {
        return AnimalType_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AnimalType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment AnimalType_constraint$address() {
        return AnimalType_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AnimalType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int AnimalType_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = AnimalType_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalType_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalType_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalType_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor AnimalType_decode_ber$descriptor() {
        return AnimalType_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle AnimalType_decode_ber$handle() {
        return AnimalType_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment AnimalType_decode_ber$address() {
        return AnimalType_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment AnimalType_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = AnimalType_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalType_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalType_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalType_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AnimalType_encode_der$descriptor() {
        return AnimalType_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AnimalType_encode_der$handle() {
        return AnimalType_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AnimalType_encode_der$address() {
        return AnimalType_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AnimalType_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = AnimalType_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalType_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalType_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalType_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor AnimalType_decode_xer$descriptor() {
        return AnimalType_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle AnimalType_decode_xer$handle() {
        return AnimalType_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment AnimalType_decode_xer$address() {
        return AnimalType_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment AnimalType_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = AnimalType_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalType_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalType_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalType_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AnimalType_encode_xer$descriptor() {
        return AnimalType_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AnimalType_encode_xer$handle() {
        return AnimalType_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AnimalType_encode_xer$address() {
        return AnimalType_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AnimalType_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = AnimalType_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalType_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalType_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalType_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AnimalType_encode_jer$descriptor() {
        return AnimalType_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AnimalType_encode_jer$handle() {
        return AnimalType_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AnimalType_encode_jer$address() {
        return AnimalType_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AnimalType_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = AnimalType_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalType_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalType_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalType_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor AnimalType_decode_oer$descriptor() {
        return AnimalType_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle AnimalType_decode_oer$handle() {
        return AnimalType_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment AnimalType_decode_oer$address() {
        return AnimalType_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment AnimalType_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = AnimalType_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalType_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalType_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalType_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AnimalType_encode_oer$descriptor() {
        return AnimalType_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AnimalType_encode_oer$handle() {
        return AnimalType_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AnimalType_encode_oer$address() {
        return AnimalType_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AnimalType_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AnimalType_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalType_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalType_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalType_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor AnimalType_decode_uper$descriptor() {
        return AnimalType_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle AnimalType_decode_uper$handle() {
        return AnimalType_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AnimalType_decode_uper$address() {
        return AnimalType_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AnimalType_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AnimalType_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalType_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalType_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalType_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor AnimalType_encode_uper$descriptor() {
        return AnimalType_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle AnimalType_encode_uper$handle() {
        return AnimalType_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AnimalType_encode_uper$address() {
        return AnimalType_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AnimalType_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = AnimalType_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalType_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalType_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalType_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor AnimalType_decode_aper$descriptor() {
        return AnimalType_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle AnimalType_decode_aper$handle() {
        return AnimalType_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AnimalType_decode_aper$address() {
        return AnimalType_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AnimalType_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AnimalType_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalType_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalType_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalType_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor AnimalType_encode_aper$descriptor() {
        return AnimalType_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle AnimalType_encode_aper$handle() {
        return AnimalType_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AnimalType_encode_aper$address() {
        return AnimalType_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AnimalType_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = AnimalType_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalType_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_PersonalSafetyMessage$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_PersonalSafetyMessage").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PersonalSafetyMessage
     * }
     */
    public static GroupLayout asn_DEF_PersonalSafetyMessage$layout() {
        return asn_DEF_PersonalSafetyMessage$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PersonalSafetyMessage
     * }
     */
    public static MemorySegment asn_DEF_PersonalSafetyMessage() {
        return asn_DEF_PersonalSafetyMessage$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PersonalSafetyMessage
     * }
     */
    public static void asn_DEF_PersonalSafetyMessage(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_PersonalSafetyMessage$constants.SEGMENT, 0L, asn_DEF_PersonalSafetyMessage$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_PersonalSafetyMessage_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_PersonalSafetyMessage_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_PersonalSafetyMessage_specs_1
     * }
     */
    public static GroupLayout asn_SPC_PersonalSafetyMessage_specs_1$layout() {
        return asn_SPC_PersonalSafetyMessage_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_PersonalSafetyMessage_specs_1
     * }
     */
    public static MemorySegment asn_SPC_PersonalSafetyMessage_specs_1() {
        return asn_SPC_PersonalSafetyMessage_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_PersonalSafetyMessage_specs_1
     * }
     */
    public static void asn_SPC_PersonalSafetyMessage_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_PersonalSafetyMessage_specs_1$constants.SEGMENT, 0L, asn_SPC_PersonalSafetyMessage_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_PersonalSafetyMessage_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(26, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_PersonalSafetyMessage_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 26 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PersonalSafetyMessage_1[26]
     * }
     */
    public static SequenceLayout asn_MBR_PersonalSafetyMessage_1$layout() {
        return asn_MBR_PersonalSafetyMessage_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PersonalSafetyMessage_1[26]
     * }
     */
    public static long[] asn_MBR_PersonalSafetyMessage_1$dimensions() {
        return asn_MBR_PersonalSafetyMessage_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PersonalSafetyMessage_1[26]
     * }
     */
    public static MemorySegment asn_MBR_PersonalSafetyMessage_1() {
        return asn_MBR_PersonalSafetyMessage_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PersonalSafetyMessage_1[26]
     * }
     */
    public static void asn_MBR_PersonalSafetyMessage_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_PersonalSafetyMessage_1$constants.SEGMENT, 0L, asn_MBR_PersonalSafetyMessage_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PersonalSafetyMessage_1[26]
     * }
     */
    public static MemorySegment asn_MBR_PersonalSafetyMessage_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_PersonalSafetyMessage_1$constants.HANDLE.invokeExact(asn_MBR_PersonalSafetyMessage_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PersonalSafetyMessage_1[26]
     * }
     */
    public static void asn_MBR_PersonalSafetyMessage_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_PersonalSafetyMessage_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    private static final int HumanPropelledType_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum HumanPropelledType.HumanPropelledType_unavailable = 0
     * }
     */
    public static int HumanPropelledType_unavailable() {
        return HumanPropelledType_unavailable;
    }
    private static final int HumanPropelledType_otherTypes = (int)1L;
    /**
     * {@snippet lang=c :
     * enum HumanPropelledType.HumanPropelledType_otherTypes = 1
     * }
     */
    public static int HumanPropelledType_otherTypes() {
        return HumanPropelledType_otherTypes;
    }
    private static final int HumanPropelledType_onFoot = (int)2L;
    /**
     * {@snippet lang=c :
     * enum HumanPropelledType.HumanPropelledType_onFoot = 2
     * }
     */
    public static int HumanPropelledType_onFoot() {
        return HumanPropelledType_onFoot;
    }
    private static final int HumanPropelledType_skateboard = (int)3L;
    /**
     * {@snippet lang=c :
     * enum HumanPropelledType.HumanPropelledType_skateboard = 3
     * }
     */
    public static int HumanPropelledType_skateboard() {
        return HumanPropelledType_skateboard;
    }
    private static final int HumanPropelledType_pushOrKickScooter = (int)4L;
    /**
     * {@snippet lang=c :
     * enum HumanPropelledType.HumanPropelledType_pushOrKickScooter = 4
     * }
     */
    public static int HumanPropelledType_pushOrKickScooter() {
        return HumanPropelledType_pushOrKickScooter;
    }
    private static final int HumanPropelledType_wheelchair = (int)5L;
    /**
     * {@snippet lang=c :
     * enum HumanPropelledType.HumanPropelledType_wheelchair = 5
     * }
     */
    public static int HumanPropelledType_wheelchair() {
        return HumanPropelledType_wheelchair;
    }
    /**
     * {@snippet lang=c :
     * typedef long HumanPropelledType_t
     * }
     */
    public static final OfLong HumanPropelledType_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_HumanPropelledType_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_HumanPropelledType_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_HumanPropelledType_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_HumanPropelledType_constr_1$layout() {
        return asn_PER_type_HumanPropelledType_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_HumanPropelledType_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_HumanPropelledType_constr_1() {
        return asn_PER_type_HumanPropelledType_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_HumanPropelledType_constr_1
     * }
     */
    public static void asn_PER_type_HumanPropelledType_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_HumanPropelledType_constr_1$constants.SEGMENT, 0L, asn_PER_type_HumanPropelledType_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_HumanPropelledType$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_HumanPropelledType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_HumanPropelledType
     * }
     */
    public static GroupLayout asn_DEF_HumanPropelledType$layout() {
        return asn_DEF_HumanPropelledType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_HumanPropelledType
     * }
     */
    public static MemorySegment asn_DEF_HumanPropelledType() {
        return asn_DEF_HumanPropelledType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_HumanPropelledType
     * }
     */
    public static void asn_DEF_HumanPropelledType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_HumanPropelledType$constants.SEGMENT, 0L, asn_DEF_HumanPropelledType$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_HumanPropelledType_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_HumanPropelledType_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_HumanPropelledType_specs_1
     * }
     */
    public static GroupLayout asn_SPC_HumanPropelledType_specs_1$layout() {
        return asn_SPC_HumanPropelledType_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_HumanPropelledType_specs_1
     * }
     */
    public static MemorySegment asn_SPC_HumanPropelledType_specs_1() {
        return asn_SPC_HumanPropelledType_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_HumanPropelledType_specs_1
     * }
     */
    public static void asn_SPC_HumanPropelledType_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_HumanPropelledType_specs_1$constants.SEGMENT, 0L, asn_SPC_HumanPropelledType_specs_1$constants.LAYOUT.byteSize());
    }

    private static class HumanPropelledType_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HumanPropelledType_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void HumanPropelledType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor HumanPropelledType_free$descriptor() {
        return HumanPropelledType_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void HumanPropelledType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle HumanPropelledType_free$handle() {
        return HumanPropelledType_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void HumanPropelledType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment HumanPropelledType_free$address() {
        return HumanPropelledType_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void HumanPropelledType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void HumanPropelledType_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = HumanPropelledType_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HumanPropelledType_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HumanPropelledType_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HumanPropelledType_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int HumanPropelledType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor HumanPropelledType_print$descriptor() {
        return HumanPropelledType_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int HumanPropelledType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle HumanPropelledType_print$handle() {
        return HumanPropelledType_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int HumanPropelledType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HumanPropelledType_print$address() {
        return HumanPropelledType_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int HumanPropelledType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int HumanPropelledType_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = HumanPropelledType_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HumanPropelledType_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HumanPropelledType_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HumanPropelledType_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int HumanPropelledType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor HumanPropelledType_constraint$descriptor() {
        return HumanPropelledType_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int HumanPropelledType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle HumanPropelledType_constraint$handle() {
        return HumanPropelledType_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int HumanPropelledType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment HumanPropelledType_constraint$address() {
        return HumanPropelledType_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int HumanPropelledType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int HumanPropelledType_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = HumanPropelledType_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HumanPropelledType_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HumanPropelledType_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HumanPropelledType_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t HumanPropelledType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor HumanPropelledType_decode_ber$descriptor() {
        return HumanPropelledType_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t HumanPropelledType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle HumanPropelledType_decode_ber$handle() {
        return HumanPropelledType_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t HumanPropelledType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment HumanPropelledType_decode_ber$address() {
        return HumanPropelledType_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t HumanPropelledType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment HumanPropelledType_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = HumanPropelledType_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HumanPropelledType_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HumanPropelledType_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HumanPropelledType_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor HumanPropelledType_encode_der$descriptor() {
        return HumanPropelledType_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle HumanPropelledType_encode_der$handle() {
        return HumanPropelledType_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HumanPropelledType_encode_der$address() {
        return HumanPropelledType_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HumanPropelledType_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = HumanPropelledType_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HumanPropelledType_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HumanPropelledType_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HumanPropelledType_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t HumanPropelledType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor HumanPropelledType_decode_xer$descriptor() {
        return HumanPropelledType_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t HumanPropelledType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle HumanPropelledType_decode_xer$handle() {
        return HumanPropelledType_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t HumanPropelledType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment HumanPropelledType_decode_xer$address() {
        return HumanPropelledType_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t HumanPropelledType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment HumanPropelledType_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = HumanPropelledType_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HumanPropelledType_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HumanPropelledType_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HumanPropelledType_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor HumanPropelledType_encode_xer$descriptor() {
        return HumanPropelledType_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle HumanPropelledType_encode_xer$handle() {
        return HumanPropelledType_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HumanPropelledType_encode_xer$address() {
        return HumanPropelledType_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HumanPropelledType_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = HumanPropelledType_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HumanPropelledType_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HumanPropelledType_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HumanPropelledType_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor HumanPropelledType_encode_jer$descriptor() {
        return HumanPropelledType_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle HumanPropelledType_encode_jer$handle() {
        return HumanPropelledType_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HumanPropelledType_encode_jer$address() {
        return HumanPropelledType_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HumanPropelledType_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = HumanPropelledType_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HumanPropelledType_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HumanPropelledType_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HumanPropelledType_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t HumanPropelledType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor HumanPropelledType_decode_oer$descriptor() {
        return HumanPropelledType_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t HumanPropelledType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle HumanPropelledType_decode_oer$handle() {
        return HumanPropelledType_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t HumanPropelledType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment HumanPropelledType_decode_oer$address() {
        return HumanPropelledType_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t HumanPropelledType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment HumanPropelledType_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = HumanPropelledType_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HumanPropelledType_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HumanPropelledType_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HumanPropelledType_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor HumanPropelledType_encode_oer$descriptor() {
        return HumanPropelledType_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle HumanPropelledType_encode_oer$handle() {
        return HumanPropelledType_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HumanPropelledType_encode_oer$address() {
        return HumanPropelledType_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HumanPropelledType_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = HumanPropelledType_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HumanPropelledType_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HumanPropelledType_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HumanPropelledType_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t HumanPropelledType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor HumanPropelledType_decode_uper$descriptor() {
        return HumanPropelledType_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t HumanPropelledType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle HumanPropelledType_decode_uper$handle() {
        return HumanPropelledType_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t HumanPropelledType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment HumanPropelledType_decode_uper$address() {
        return HumanPropelledType_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t HumanPropelledType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment HumanPropelledType_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = HumanPropelledType_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HumanPropelledType_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HumanPropelledType_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HumanPropelledType_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor HumanPropelledType_encode_uper$descriptor() {
        return HumanPropelledType_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle HumanPropelledType_encode_uper$handle() {
        return HumanPropelledType_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment HumanPropelledType_encode_uper$address() {
        return HumanPropelledType_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment HumanPropelledType_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = HumanPropelledType_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HumanPropelledType_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HumanPropelledType_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HumanPropelledType_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t HumanPropelledType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor HumanPropelledType_decode_aper$descriptor() {
        return HumanPropelledType_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t HumanPropelledType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle HumanPropelledType_decode_aper$handle() {
        return HumanPropelledType_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t HumanPropelledType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment HumanPropelledType_decode_aper$address() {
        return HumanPropelledType_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t HumanPropelledType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment HumanPropelledType_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = HumanPropelledType_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HumanPropelledType_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HumanPropelledType_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HumanPropelledType_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor HumanPropelledType_encode_aper$descriptor() {
        return HumanPropelledType_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle HumanPropelledType_encode_aper$handle() {
        return HumanPropelledType_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment HumanPropelledType_encode_aper$address() {
        return HumanPropelledType_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t HumanPropelledType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment HumanPropelledType_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = HumanPropelledType_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HumanPropelledType_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AnimalPropelledType_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AnimalPropelledType.AnimalPropelledType_unavailable = 0
     * }
     */
    public static int AnimalPropelledType_unavailable() {
        return AnimalPropelledType_unavailable;
    }
    private static final int AnimalPropelledType_otherTypes = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AnimalPropelledType.AnimalPropelledType_otherTypes = 1
     * }
     */
    public static int AnimalPropelledType_otherTypes() {
        return AnimalPropelledType_otherTypes;
    }
    private static final int AnimalPropelledType_animalMounted = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AnimalPropelledType.AnimalPropelledType_animalMounted = 2
     * }
     */
    public static int AnimalPropelledType_animalMounted() {
        return AnimalPropelledType_animalMounted;
    }
    private static final int AnimalPropelledType_animalDrawnCarriage = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AnimalPropelledType.AnimalPropelledType_animalDrawnCarriage = 3
     * }
     */
    public static int AnimalPropelledType_animalDrawnCarriage() {
        return AnimalPropelledType_animalDrawnCarriage;
    }
    /**
     * {@snippet lang=c :
     * typedef long AnimalPropelledType_t
     * }
     */
    public static final OfLong AnimalPropelledType_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_AnimalPropelledType_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_AnimalPropelledType_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AnimalPropelledType_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_AnimalPropelledType_constr_1$layout() {
        return asn_PER_type_AnimalPropelledType_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AnimalPropelledType_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_AnimalPropelledType_constr_1() {
        return asn_PER_type_AnimalPropelledType_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AnimalPropelledType_constr_1
     * }
     */
    public static void asn_PER_type_AnimalPropelledType_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_AnimalPropelledType_constr_1$constants.SEGMENT, 0L, asn_PER_type_AnimalPropelledType_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_AnimalPropelledType$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_AnimalPropelledType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AnimalPropelledType
     * }
     */
    public static GroupLayout asn_DEF_AnimalPropelledType$layout() {
        return asn_DEF_AnimalPropelledType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AnimalPropelledType
     * }
     */
    public static MemorySegment asn_DEF_AnimalPropelledType() {
        return asn_DEF_AnimalPropelledType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AnimalPropelledType
     * }
     */
    public static void asn_DEF_AnimalPropelledType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_AnimalPropelledType$constants.SEGMENT, 0L, asn_DEF_AnimalPropelledType$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_AnimalPropelledType_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_AnimalPropelledType_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_AnimalPropelledType_specs_1
     * }
     */
    public static GroupLayout asn_SPC_AnimalPropelledType_specs_1$layout() {
        return asn_SPC_AnimalPropelledType_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_AnimalPropelledType_specs_1
     * }
     */
    public static MemorySegment asn_SPC_AnimalPropelledType_specs_1() {
        return asn_SPC_AnimalPropelledType_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_AnimalPropelledType_specs_1
     * }
     */
    public static void asn_SPC_AnimalPropelledType_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_AnimalPropelledType_specs_1$constants.SEGMENT, 0L, asn_SPC_AnimalPropelledType_specs_1$constants.LAYOUT.byteSize());
    }

    private static class AnimalPropelledType_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalPropelledType_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void AnimalPropelledType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor AnimalPropelledType_free$descriptor() {
        return AnimalPropelledType_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void AnimalPropelledType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle AnimalPropelledType_free$handle() {
        return AnimalPropelledType_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void AnimalPropelledType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment AnimalPropelledType_free$address() {
        return AnimalPropelledType_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void AnimalPropelledType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void AnimalPropelledType_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = AnimalPropelledType_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalPropelledType_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalPropelledType_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalPropelledType_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AnimalPropelledType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AnimalPropelledType_print$descriptor() {
        return AnimalPropelledType_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AnimalPropelledType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AnimalPropelledType_print$handle() {
        return AnimalPropelledType_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AnimalPropelledType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AnimalPropelledType_print$address() {
        return AnimalPropelledType_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AnimalPropelledType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int AnimalPropelledType_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AnimalPropelledType_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalPropelledType_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalPropelledType_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalPropelledType_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AnimalPropelledType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor AnimalPropelledType_constraint$descriptor() {
        return AnimalPropelledType_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AnimalPropelledType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle AnimalPropelledType_constraint$handle() {
        return AnimalPropelledType_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AnimalPropelledType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment AnimalPropelledType_constraint$address() {
        return AnimalPropelledType_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AnimalPropelledType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int AnimalPropelledType_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = AnimalPropelledType_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalPropelledType_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalPropelledType_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalPropelledType_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalPropelledType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor AnimalPropelledType_decode_ber$descriptor() {
        return AnimalPropelledType_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalPropelledType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle AnimalPropelledType_decode_ber$handle() {
        return AnimalPropelledType_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalPropelledType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment AnimalPropelledType_decode_ber$address() {
        return AnimalPropelledType_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalPropelledType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment AnimalPropelledType_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = AnimalPropelledType_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalPropelledType_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalPropelledType_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalPropelledType_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AnimalPropelledType_encode_der$descriptor() {
        return AnimalPropelledType_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AnimalPropelledType_encode_der$handle() {
        return AnimalPropelledType_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AnimalPropelledType_encode_der$address() {
        return AnimalPropelledType_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AnimalPropelledType_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = AnimalPropelledType_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalPropelledType_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalPropelledType_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalPropelledType_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalPropelledType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor AnimalPropelledType_decode_xer$descriptor() {
        return AnimalPropelledType_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalPropelledType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle AnimalPropelledType_decode_xer$handle() {
        return AnimalPropelledType_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalPropelledType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment AnimalPropelledType_decode_xer$address() {
        return AnimalPropelledType_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalPropelledType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment AnimalPropelledType_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = AnimalPropelledType_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalPropelledType_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalPropelledType_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalPropelledType_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AnimalPropelledType_encode_xer$descriptor() {
        return AnimalPropelledType_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AnimalPropelledType_encode_xer$handle() {
        return AnimalPropelledType_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AnimalPropelledType_encode_xer$address() {
        return AnimalPropelledType_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AnimalPropelledType_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = AnimalPropelledType_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalPropelledType_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalPropelledType_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalPropelledType_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AnimalPropelledType_encode_jer$descriptor() {
        return AnimalPropelledType_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AnimalPropelledType_encode_jer$handle() {
        return AnimalPropelledType_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AnimalPropelledType_encode_jer$address() {
        return AnimalPropelledType_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AnimalPropelledType_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = AnimalPropelledType_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalPropelledType_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalPropelledType_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalPropelledType_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalPropelledType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor AnimalPropelledType_decode_oer$descriptor() {
        return AnimalPropelledType_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalPropelledType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle AnimalPropelledType_decode_oer$handle() {
        return AnimalPropelledType_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalPropelledType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment AnimalPropelledType_decode_oer$address() {
        return AnimalPropelledType_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalPropelledType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment AnimalPropelledType_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = AnimalPropelledType_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalPropelledType_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalPropelledType_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalPropelledType_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AnimalPropelledType_encode_oer$descriptor() {
        return AnimalPropelledType_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AnimalPropelledType_encode_oer$handle() {
        return AnimalPropelledType_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AnimalPropelledType_encode_oer$address() {
        return AnimalPropelledType_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AnimalPropelledType_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AnimalPropelledType_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalPropelledType_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalPropelledType_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalPropelledType_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalPropelledType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor AnimalPropelledType_decode_uper$descriptor() {
        return AnimalPropelledType_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalPropelledType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle AnimalPropelledType_decode_uper$handle() {
        return AnimalPropelledType_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalPropelledType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AnimalPropelledType_decode_uper$address() {
        return AnimalPropelledType_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalPropelledType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AnimalPropelledType_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AnimalPropelledType_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalPropelledType_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalPropelledType_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalPropelledType_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor AnimalPropelledType_encode_uper$descriptor() {
        return AnimalPropelledType_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle AnimalPropelledType_encode_uper$handle() {
        return AnimalPropelledType_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AnimalPropelledType_encode_uper$address() {
        return AnimalPropelledType_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AnimalPropelledType_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = AnimalPropelledType_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalPropelledType_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalPropelledType_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalPropelledType_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalPropelledType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor AnimalPropelledType_decode_aper$descriptor() {
        return AnimalPropelledType_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalPropelledType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle AnimalPropelledType_decode_aper$handle() {
        return AnimalPropelledType_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalPropelledType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AnimalPropelledType_decode_aper$address() {
        return AnimalPropelledType_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AnimalPropelledType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AnimalPropelledType_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AnimalPropelledType_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalPropelledType_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AnimalPropelledType_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AnimalPropelledType_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor AnimalPropelledType_encode_aper$descriptor() {
        return AnimalPropelledType_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle AnimalPropelledType_encode_aper$handle() {
        return AnimalPropelledType_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AnimalPropelledType_encode_aper$address() {
        return AnimalPropelledType_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AnimalPropelledType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AnimalPropelledType_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = AnimalPropelledType_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AnimalPropelledType_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int MotorizedPropelledType_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum MotorizedPropelledType.MotorizedPropelledType_unavailable = 0
     * }
     */
    public static int MotorizedPropelledType_unavailable() {
        return MotorizedPropelledType_unavailable;
    }
    private static final int MotorizedPropelledType_otherTypes = (int)1L;
    /**
     * {@snippet lang=c :
     * enum MotorizedPropelledType.MotorizedPropelledType_otherTypes = 1
     * }
     */
    public static int MotorizedPropelledType_otherTypes() {
        return MotorizedPropelledType_otherTypes;
    }
    private static final int MotorizedPropelledType_wheelChair = (int)2L;
    /**
     * {@snippet lang=c :
     * enum MotorizedPropelledType.MotorizedPropelledType_wheelChair = 2
     * }
     */
    public static int MotorizedPropelledType_wheelChair() {
        return MotorizedPropelledType_wheelChair;
    }
    private static final int MotorizedPropelledType_bicycle = (int)3L;
    /**
     * {@snippet lang=c :
     * enum MotorizedPropelledType.MotorizedPropelledType_bicycle = 3
     * }
     */
    public static int MotorizedPropelledType_bicycle() {
        return MotorizedPropelledType_bicycle;
    }
    private static final int MotorizedPropelledType_scooter = (int)4L;
    /**
     * {@snippet lang=c :
     * enum MotorizedPropelledType.MotorizedPropelledType_scooter = 4
     * }
     */
    public static int MotorizedPropelledType_scooter() {
        return MotorizedPropelledType_scooter;
    }
    private static final int MotorizedPropelledType_selfBalancingDevice = (int)5L;
    /**
     * {@snippet lang=c :
     * enum MotorizedPropelledType.MotorizedPropelledType_selfBalancingDevice = 5
     * }
     */
    public static int MotorizedPropelledType_selfBalancingDevice() {
        return MotorizedPropelledType_selfBalancingDevice;
    }
    /**
     * {@snippet lang=c :
     * typedef long MotorizedPropelledType_t
     * }
     */
    public static final OfLong MotorizedPropelledType_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_MotorizedPropelledType_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_MotorizedPropelledType_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_MotorizedPropelledType_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_MotorizedPropelledType_constr_1$layout() {
        return asn_PER_type_MotorizedPropelledType_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_MotorizedPropelledType_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_MotorizedPropelledType_constr_1() {
        return asn_PER_type_MotorizedPropelledType_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_MotorizedPropelledType_constr_1
     * }
     */
    public static void asn_PER_type_MotorizedPropelledType_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_MotorizedPropelledType_constr_1$constants.SEGMENT, 0L, asn_PER_type_MotorizedPropelledType_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_MotorizedPropelledType$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_MotorizedPropelledType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_MotorizedPropelledType
     * }
     */
    public static GroupLayout asn_DEF_MotorizedPropelledType$layout() {
        return asn_DEF_MotorizedPropelledType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_MotorizedPropelledType
     * }
     */
    public static MemorySegment asn_DEF_MotorizedPropelledType() {
        return asn_DEF_MotorizedPropelledType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_MotorizedPropelledType
     * }
     */
    public static void asn_DEF_MotorizedPropelledType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_MotorizedPropelledType$constants.SEGMENT, 0L, asn_DEF_MotorizedPropelledType$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_MotorizedPropelledType_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_MotorizedPropelledType_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_MotorizedPropelledType_specs_1
     * }
     */
    public static GroupLayout asn_SPC_MotorizedPropelledType_specs_1$layout() {
        return asn_SPC_MotorizedPropelledType_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_MotorizedPropelledType_specs_1
     * }
     */
    public static MemorySegment asn_SPC_MotorizedPropelledType_specs_1() {
        return asn_SPC_MotorizedPropelledType_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_MotorizedPropelledType_specs_1
     * }
     */
    public static void asn_SPC_MotorizedPropelledType_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_MotorizedPropelledType_specs_1$constants.SEGMENT, 0L, asn_SPC_MotorizedPropelledType_specs_1$constants.LAYOUT.byteSize());
    }

    private static class MotorizedPropelledType_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MotorizedPropelledType_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void MotorizedPropelledType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor MotorizedPropelledType_free$descriptor() {
        return MotorizedPropelledType_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void MotorizedPropelledType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle MotorizedPropelledType_free$handle() {
        return MotorizedPropelledType_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void MotorizedPropelledType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment MotorizedPropelledType_free$address() {
        return MotorizedPropelledType_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void MotorizedPropelledType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void MotorizedPropelledType_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = MotorizedPropelledType_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MotorizedPropelledType_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MotorizedPropelledType_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MotorizedPropelledType_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MotorizedPropelledType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor MotorizedPropelledType_print$descriptor() {
        return MotorizedPropelledType_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MotorizedPropelledType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle MotorizedPropelledType_print$handle() {
        return MotorizedPropelledType_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int MotorizedPropelledType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment MotorizedPropelledType_print$address() {
        return MotorizedPropelledType_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int MotorizedPropelledType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int MotorizedPropelledType_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = MotorizedPropelledType_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MotorizedPropelledType_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MotorizedPropelledType_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MotorizedPropelledType_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MotorizedPropelledType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor MotorizedPropelledType_constraint$descriptor() {
        return MotorizedPropelledType_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MotorizedPropelledType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle MotorizedPropelledType_constraint$handle() {
        return MotorizedPropelledType_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int MotorizedPropelledType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment MotorizedPropelledType_constraint$address() {
        return MotorizedPropelledType_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int MotorizedPropelledType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int MotorizedPropelledType_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = MotorizedPropelledType_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MotorizedPropelledType_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MotorizedPropelledType_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MotorizedPropelledType_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t MotorizedPropelledType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor MotorizedPropelledType_decode_ber$descriptor() {
        return MotorizedPropelledType_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t MotorizedPropelledType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle MotorizedPropelledType_decode_ber$handle() {
        return MotorizedPropelledType_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t MotorizedPropelledType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment MotorizedPropelledType_decode_ber$address() {
        return MotorizedPropelledType_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t MotorizedPropelledType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment MotorizedPropelledType_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = MotorizedPropelledType_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MotorizedPropelledType_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MotorizedPropelledType_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MotorizedPropelledType_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor MotorizedPropelledType_encode_der$descriptor() {
        return MotorizedPropelledType_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle MotorizedPropelledType_encode_der$handle() {
        return MotorizedPropelledType_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment MotorizedPropelledType_encode_der$address() {
        return MotorizedPropelledType_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment MotorizedPropelledType_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = MotorizedPropelledType_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MotorizedPropelledType_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MotorizedPropelledType_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MotorizedPropelledType_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t MotorizedPropelledType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor MotorizedPropelledType_decode_xer$descriptor() {
        return MotorizedPropelledType_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t MotorizedPropelledType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle MotorizedPropelledType_decode_xer$handle() {
        return MotorizedPropelledType_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t MotorizedPropelledType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment MotorizedPropelledType_decode_xer$address() {
        return MotorizedPropelledType_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t MotorizedPropelledType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment MotorizedPropelledType_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = MotorizedPropelledType_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MotorizedPropelledType_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MotorizedPropelledType_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MotorizedPropelledType_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor MotorizedPropelledType_encode_xer$descriptor() {
        return MotorizedPropelledType_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle MotorizedPropelledType_encode_xer$handle() {
        return MotorizedPropelledType_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment MotorizedPropelledType_encode_xer$address() {
        return MotorizedPropelledType_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment MotorizedPropelledType_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = MotorizedPropelledType_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MotorizedPropelledType_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MotorizedPropelledType_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MotorizedPropelledType_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor MotorizedPropelledType_encode_jer$descriptor() {
        return MotorizedPropelledType_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle MotorizedPropelledType_encode_jer$handle() {
        return MotorizedPropelledType_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment MotorizedPropelledType_encode_jer$address() {
        return MotorizedPropelledType_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment MotorizedPropelledType_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = MotorizedPropelledType_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MotorizedPropelledType_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MotorizedPropelledType_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MotorizedPropelledType_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t MotorizedPropelledType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor MotorizedPropelledType_decode_oer$descriptor() {
        return MotorizedPropelledType_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t MotorizedPropelledType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle MotorizedPropelledType_decode_oer$handle() {
        return MotorizedPropelledType_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t MotorizedPropelledType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment MotorizedPropelledType_decode_oer$address() {
        return MotorizedPropelledType_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t MotorizedPropelledType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment MotorizedPropelledType_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = MotorizedPropelledType_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MotorizedPropelledType_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MotorizedPropelledType_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MotorizedPropelledType_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor MotorizedPropelledType_encode_oer$descriptor() {
        return MotorizedPropelledType_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle MotorizedPropelledType_encode_oer$handle() {
        return MotorizedPropelledType_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment MotorizedPropelledType_encode_oer$address() {
        return MotorizedPropelledType_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment MotorizedPropelledType_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = MotorizedPropelledType_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MotorizedPropelledType_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MotorizedPropelledType_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MotorizedPropelledType_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t MotorizedPropelledType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor MotorizedPropelledType_decode_uper$descriptor() {
        return MotorizedPropelledType_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t MotorizedPropelledType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle MotorizedPropelledType_decode_uper$handle() {
        return MotorizedPropelledType_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t MotorizedPropelledType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment MotorizedPropelledType_decode_uper$address() {
        return MotorizedPropelledType_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t MotorizedPropelledType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment MotorizedPropelledType_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = MotorizedPropelledType_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MotorizedPropelledType_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MotorizedPropelledType_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MotorizedPropelledType_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor MotorizedPropelledType_encode_uper$descriptor() {
        return MotorizedPropelledType_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle MotorizedPropelledType_encode_uper$handle() {
        return MotorizedPropelledType_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment MotorizedPropelledType_encode_uper$address() {
        return MotorizedPropelledType_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment MotorizedPropelledType_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = MotorizedPropelledType_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MotorizedPropelledType_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MotorizedPropelledType_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MotorizedPropelledType_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t MotorizedPropelledType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor MotorizedPropelledType_decode_aper$descriptor() {
        return MotorizedPropelledType_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t MotorizedPropelledType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle MotorizedPropelledType_decode_aper$handle() {
        return MotorizedPropelledType_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t MotorizedPropelledType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment MotorizedPropelledType_decode_aper$address() {
        return MotorizedPropelledType_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t MotorizedPropelledType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment MotorizedPropelledType_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = MotorizedPropelledType_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MotorizedPropelledType_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MotorizedPropelledType_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MotorizedPropelledType_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor MotorizedPropelledType_encode_aper$descriptor() {
        return MotorizedPropelledType_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle MotorizedPropelledType_encode_aper$handle() {
        return MotorizedPropelledType_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment MotorizedPropelledType_encode_aper$address() {
        return MotorizedPropelledType_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t MotorizedPropelledType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment MotorizedPropelledType_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = MotorizedPropelledType_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MotorizedPropelledType_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int PropelledInformation_PR_NOTHING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum PropelledInformation_PR.PropelledInformation_PR_NOTHING = 0
     * }
     */
    public static int PropelledInformation_PR_NOTHING() {
        return PropelledInformation_PR_NOTHING;
    }
    private static final int PropelledInformation_PR_human = (int)1L;
    /**
     * {@snippet lang=c :
     * enum PropelledInformation_PR.PropelledInformation_PR_human = 1
     * }
     */
    public static int PropelledInformation_PR_human() {
        return PropelledInformation_PR_human;
    }
    private static final int PropelledInformation_PR_animal = (int)2L;
    /**
     * {@snippet lang=c :
     * enum PropelledInformation_PR.PropelledInformation_PR_animal = 2
     * }
     */
    public static int PropelledInformation_PR_animal() {
        return PropelledInformation_PR_animal;
    }
    private static final int PropelledInformation_PR_motor = (int)3L;
    /**
     * {@snippet lang=c :
     * enum PropelledInformation_PR.PropelledInformation_PR_motor = 3
     * }
     */
    public static int PropelledInformation_PR_motor() {
        return PropelledInformation_PR_motor;
    }

    private static class asn_DEF_PropelledInformation$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_PropelledInformation").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PropelledInformation
     * }
     */
    public static GroupLayout asn_DEF_PropelledInformation$layout() {
        return asn_DEF_PropelledInformation$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PropelledInformation
     * }
     */
    public static MemorySegment asn_DEF_PropelledInformation() {
        return asn_DEF_PropelledInformation$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PropelledInformation
     * }
     */
    public static void asn_DEF_PropelledInformation(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_PropelledInformation$constants.SEGMENT, 0L, asn_DEF_PropelledInformation$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_PropelledInformation_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_CHOICE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_PropelledInformation_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_PropelledInformation_specs_1
     * }
     */
    public static GroupLayout asn_SPC_PropelledInformation_specs_1$layout() {
        return asn_SPC_PropelledInformation_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_PropelledInformation_specs_1
     * }
     */
    public static MemorySegment asn_SPC_PropelledInformation_specs_1() {
        return asn_SPC_PropelledInformation_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_PropelledInformation_specs_1
     * }
     */
    public static void asn_SPC_PropelledInformation_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_PropelledInformation_specs_1$constants.SEGMENT, 0L, asn_SPC_PropelledInformation_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_PropelledInformation_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(3, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_PropelledInformation_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 3 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PropelledInformation_1[3]
     * }
     */
    public static SequenceLayout asn_MBR_PropelledInformation_1$layout() {
        return asn_MBR_PropelledInformation_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PropelledInformation_1[3]
     * }
     */
    public static long[] asn_MBR_PropelledInformation_1$dimensions() {
        return asn_MBR_PropelledInformation_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PropelledInformation_1[3]
     * }
     */
    public static MemorySegment asn_MBR_PropelledInformation_1() {
        return asn_MBR_PropelledInformation_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PropelledInformation_1[3]
     * }
     */
    public static void asn_MBR_PropelledInformation_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_PropelledInformation_1$constants.SEGMENT, 0L, asn_MBR_PropelledInformation_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PropelledInformation_1[3]
     * }
     */
    public static MemorySegment asn_MBR_PropelledInformation_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_PropelledInformation_1$constants.HANDLE.invokeExact(asn_MBR_PropelledInformation_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PropelledInformation_1[3]
     * }
     */
    public static void asn_MBR_PropelledInformation_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_PropelledInformation_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_PropelledInformation_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_PropelledInformation_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PropelledInformation_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_PropelledInformation_constr_1$layout() {
        return asn_PER_type_PropelledInformation_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PropelledInformation_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_PropelledInformation_constr_1() {
        return asn_PER_type_PropelledInformation_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PropelledInformation_constr_1
     * }
     */
    public static void asn_PER_type_PropelledInformation_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_PropelledInformation_constr_1$constants.SEGMENT, 0L, asn_PER_type_PropelledInformation_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_EventIdentifier$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_EventIdentifier").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_EventIdentifier
     * }
     */
    public static GroupLayout asn_DEF_EventIdentifier$layout() {
        return asn_DEF_EventIdentifier$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_EventIdentifier
     * }
     */
    public static MemorySegment asn_DEF_EventIdentifier() {
        return asn_DEF_EventIdentifier$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_EventIdentifier
     * }
     */
    public static void asn_DEF_EventIdentifier(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_EventIdentifier$constants.SEGMENT, 0L, asn_DEF_EventIdentifier$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_EventIdentifier_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_EventIdentifier_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_EventIdentifier_specs_1
     * }
     */
    public static GroupLayout asn_SPC_EventIdentifier_specs_1$layout() {
        return asn_SPC_EventIdentifier_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_EventIdentifier_specs_1
     * }
     */
    public static MemorySegment asn_SPC_EventIdentifier_specs_1() {
        return asn_SPC_EventIdentifier_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_EventIdentifier_specs_1
     * }
     */
    public static void asn_SPC_EventIdentifier_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_EventIdentifier_specs_1$constants.SEGMENT, 0L, asn_SPC_EventIdentifier_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_EventIdentifier_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_EventIdentifier_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EventIdentifier_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_EventIdentifier_1$layout() {
        return asn_MBR_EventIdentifier_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EventIdentifier_1[2]
     * }
     */
    public static long[] asn_MBR_EventIdentifier_1$dimensions() {
        return asn_MBR_EventIdentifier_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EventIdentifier_1[2]
     * }
     */
    public static MemorySegment asn_MBR_EventIdentifier_1() {
        return asn_MBR_EventIdentifier_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EventIdentifier_1[2]
     * }
     */
    public static void asn_MBR_EventIdentifier_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_EventIdentifier_1$constants.SEGMENT, 0L, asn_MBR_EventIdentifier_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EventIdentifier_1[2]
     * }
     */
    public static MemorySegment asn_MBR_EventIdentifier_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_EventIdentifier_1$constants.HANDLE.invokeExact(asn_MBR_EventIdentifier_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EventIdentifier_1[2]
     * }
     */
    public static void asn_MBR_EventIdentifier_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_EventIdentifier_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef BOOLEAN_t Activity_t
     * }
     */
    public static final OfInt Activity_t = MessageFrame_h.C_INT;

    private static class asn_DEF_Activity$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_Activity").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Activity
     * }
     */
    public static GroupLayout asn_DEF_Activity$layout() {
        return asn_DEF_Activity$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Activity
     * }
     */
    public static MemorySegment asn_DEF_Activity() {
        return asn_DEF_Activity$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Activity
     * }
     */
    public static void asn_DEF_Activity(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_Activity$constants.SEGMENT, 0L, asn_DEF_Activity$constants.LAYOUT.byteSize());
    }

    private static class Activity_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Activity_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Activity_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor Activity_free$descriptor() {
        return Activity_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Activity_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle Activity_free$handle() {
        return Activity_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Activity_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment Activity_free$address() {
        return Activity_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Activity_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void Activity_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = Activity_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Activity_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Activity_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Activity_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Activity_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Activity_print$descriptor() {
        return Activity_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Activity_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Activity_print$handle() {
        return Activity_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Activity_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Activity_print$address() {
        return Activity_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Activity_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int Activity_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Activity_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Activity_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Activity_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Activity_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Activity_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor Activity_constraint$descriptor() {
        return Activity_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Activity_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle Activity_constraint$handle() {
        return Activity_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Activity_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment Activity_constraint$address() {
        return Activity_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Activity_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int Activity_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Activity_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Activity_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Activity_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Activity_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Activity_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor Activity_decode_ber$descriptor() {
        return Activity_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Activity_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle Activity_decode_ber$handle() {
        return Activity_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Activity_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Activity_decode_ber$address() {
        return Activity_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Activity_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Activity_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = Activity_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Activity_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Activity_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Activity_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Activity_encode_der$descriptor() {
        return Activity_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Activity_encode_der$handle() {
        return Activity_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Activity_encode_der$address() {
        return Activity_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Activity_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Activity_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Activity_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Activity_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Activity_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Activity_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Activity_decode_xer$descriptor() {
        return Activity_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Activity_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle Activity_decode_xer$handle() {
        return Activity_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Activity_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Activity_decode_xer$address() {
        return Activity_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Activity_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Activity_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Activity_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Activity_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Activity_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Activity_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Activity_encode_xer$descriptor() {
        return Activity_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Activity_encode_xer$handle() {
        return Activity_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Activity_encode_xer$address() {
        return Activity_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Activity_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Activity_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Activity_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Activity_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Activity_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Activity_encode_jer$descriptor() {
        return Activity_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Activity_encode_jer$handle() {
        return Activity_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Activity_encode_jer$address() {
        return Activity_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Activity_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = Activity_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Activity_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Activity_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Activity_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Activity_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Activity_decode_oer$descriptor() {
        return Activity_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Activity_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle Activity_decode_oer$handle() {
        return Activity_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Activity_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Activity_decode_oer$address() {
        return Activity_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Activity_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Activity_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Activity_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Activity_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Activity_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Activity_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Activity_encode_oer$descriptor() {
        return Activity_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Activity_encode_oer$handle() {
        return Activity_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Activity_encode_oer$address() {
        return Activity_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Activity_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Activity_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Activity_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Activity_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Activity_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Activity_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Activity_decode_uper$descriptor() {
        return Activity_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Activity_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Activity_decode_uper$handle() {
        return Activity_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Activity_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Activity_decode_uper$address() {
        return Activity_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Activity_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Activity_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Activity_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Activity_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Activity_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Activity_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Activity_encode_uper$descriptor() {
        return Activity_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Activity_encode_uper$handle() {
        return Activity_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Activity_encode_uper$address() {
        return Activity_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Activity_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Activity_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Activity_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Activity_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Activity_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Activity_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Activity_decode_aper$descriptor() {
        return Activity_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Activity_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Activity_decode_aper$handle() {
        return Activity_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Activity_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Activity_decode_aper$address() {
        return Activity_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Activity_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Activity_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Activity_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Activity_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Activity_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Activity_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Activity_encode_aper$descriptor() {
        return Activity_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Activity_encode_aper$handle() {
        return Activity_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Activity_encode_aper$address() {
        return Activity_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Activity_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Activity_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Activity_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Activity_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ITISgroups_trafficConditions = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_trafficConditions = 1
     * }
     */
    public static int ITISgroups_trafficConditions() {
        return ITISgroups_trafficConditions;
    }
    private static final int ITISgroups_accidentsAndIncidents = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_accidentsAndIncidents = 2
     * }
     */
    public static int ITISgroups_accidentsAndIncidents() {
        return ITISgroups_accidentsAndIncidents;
    }
    private static final int ITISgroups_closures = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_closures = 3
     * }
     */
    public static int ITISgroups_closures() {
        return ITISgroups_closures;
    }
    private static final int ITISgroups_roadwork = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_roadwork = 4
     * }
     */
    public static int ITISgroups_roadwork() {
        return ITISgroups_roadwork;
    }
    private static final int ITISgroups_obstruction = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_obstruction = 5
     * }
     */
    public static int ITISgroups_obstruction() {
        return ITISgroups_obstruction;
    }
    private static final int ITISgroups_delayStatusCancellation = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_delayStatusCancellation = 6
     * }
     */
    public static int ITISgroups_delayStatusCancellation() {
        return ITISgroups_delayStatusCancellation;
    }
    private static final int ITISgroups_unusualDriving = (int)7L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_unusualDriving = 7
     * }
     */
    public static int ITISgroups_unusualDriving() {
        return ITISgroups_unusualDriving;
    }
    private static final int ITISgroups_mobileSituation = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_mobileSituation = 8
     * }
     */
    public static int ITISgroups_mobileSituation() {
        return ITISgroups_mobileSituation;
    }
    private static final int ITISgroups_deviceStatus = (int)9L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_deviceStatus = 9
     * }
     */
    public static int ITISgroups_deviceStatus() {
        return ITISgroups_deviceStatus;
    }
    private static final int ITISgroups_restrictionClass = (int)10L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_restrictionClass = 10
     * }
     */
    public static int ITISgroups_restrictionClass() {
        return ITISgroups_restrictionClass;
    }
    private static final int ITISgroups_incidentResponseStatus = (int)11L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_incidentResponseStatus = 11
     * }
     */
    public static int ITISgroups_incidentResponseStatus() {
        return ITISgroups_incidentResponseStatus;
    }
    private static final int ITISgroups_disasters = (int)12L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_disasters = 12
     * }
     */
    public static int ITISgroups_disasters() {
        return ITISgroups_disasters;
    }
    private static final int ITISgroups_disturbances = (int)13L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_disturbances = 13
     * }
     */
    public static int ITISgroups_disturbances() {
        return ITISgroups_disturbances;
    }
    private static final int ITISgroups_sportingEvents = (int)14L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_sportingEvents = 14
     * }
     */
    public static int ITISgroups_sportingEvents() {
        return ITISgroups_sportingEvents;
    }
    private static final int ITISgroups_specialEvents = (int)15L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_specialEvents = 15
     * }
     */
    public static int ITISgroups_specialEvents() {
        return ITISgroups_specialEvents;
    }
    private static final int ITISgroups_parkingInformation = (int)16L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_parkingInformation = 16
     * }
     */
    public static int ITISgroups_parkingInformation() {
        return ITISgroups_parkingInformation;
    }
    private static final int ITISgroups_systemInformation = (int)17L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_systemInformation = 17
     * }
     */
    public static int ITISgroups_systemInformation() {
        return ITISgroups_systemInformation;
    }
    private static final int ITISgroups_weatherConditions = (int)18L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_weatherConditions = 18
     * }
     */
    public static int ITISgroups_weatherConditions() {
        return ITISgroups_weatherConditions;
    }
    private static final int ITISgroups_precipitation = (int)19L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_precipitation = 19
     * }
     */
    public static int ITISgroups_precipitation() {
        return ITISgroups_precipitation;
    }
    private static final int ITISgroups_winds = (int)20L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_winds = 20
     * }
     */
    public static int ITISgroups_winds() {
        return ITISgroups_winds;
    }
    private static final int ITISgroups_visibilityAndAirQuality = (int)21L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_visibilityAndAirQuality = 21
     * }
     */
    public static int ITISgroups_visibilityAndAirQuality() {
        return ITISgroups_visibilityAndAirQuality;
    }
    private static final int ITISgroups_temperature = (int)22L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_temperature = 22
     * }
     */
    public static int ITISgroups_temperature() {
        return ITISgroups_temperature;
    }
    private static final int ITISgroups_pavementConditions = (int)23L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_pavementConditions = 23
     * }
     */
    public static int ITISgroups_pavementConditions() {
        return ITISgroups_pavementConditions;
    }
    private static final int ITISgroups_winterDrivingRestrictions = (int)24L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_winterDrivingRestrictions = 24
     * }
     */
    public static int ITISgroups_winterDrivingRestrictions() {
        return ITISgroups_winterDrivingRestrictions;
    }
    private static final int ITISgroups_winterDrivingIndex = (int)25L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_winterDrivingIndex = 25
     * }
     */
    public static int ITISgroups_winterDrivingIndex() {
        return ITISgroups_winterDrivingIndex;
    }
    private static final int ITISgroups_suggestionAdvice = (int)26L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_suggestionAdvice = 26
     * }
     */
    public static int ITISgroups_suggestionAdvice() {
        return ITISgroups_suggestionAdvice;
    }
    private static final int ITISgroups_warningAdvice = (int)27L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_warningAdvice = 27
     * }
     */
    public static int ITISgroups_warningAdvice() {
        return ITISgroups_warningAdvice;
    }
    private static final int ITISgroups_adviceInstructionsRecommendations = (int)28L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_adviceInstructionsRecommendations = 28
     * }
     */
    public static int ITISgroups_adviceInstructionsRecommendations() {
        return ITISgroups_adviceInstructionsRecommendations;
    }
    private static final int ITISgroups_adviceInstructionsMandatory = (int)29L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_adviceInstructionsMandatory = 29
     * }
     */
    public static int ITISgroups_adviceInstructionsMandatory() {
        return ITISgroups_adviceInstructionsMandatory;
    }
    private static final int ITISgroups_qualifiers = (int)30L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_qualifiers = 30
     * }
     */
    public static int ITISgroups_qualifiers() {
        return ITISgroups_qualifiers;
    }
    private static final int ITISgroups_genericLocations = (int)31L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_genericLocations = 31
     * }
     */
    public static int ITISgroups_genericLocations() {
        return ITISgroups_genericLocations;
    }
    private static final int ITISgroups_laneRoadway = (int)32L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_laneRoadway = 32
     * }
     */
    public static int ITISgroups_laneRoadway() {
        return ITISgroups_laneRoadway;
    }
    private static final int ITISgroups_alternateRoute = (int)33L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_alternateRoute = 33
     * }
     */
    public static int ITISgroups_alternateRoute() {
        return ITISgroups_alternateRoute;
    }
    private static final int ITISgroups_units = (int)34L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_units = 34
     * }
     */
    public static int ITISgroups_units() {
        return ITISgroups_units;
    }
    private static final int ITISgroups_transitMode = (int)35L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_transitMode = 35
     * }
     */
    public static int ITISgroups_transitMode() {
        return ITISgroups_transitMode;
    }
    private static final int ITISgroups_vehicleGroupAffected = (int)36L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_vehicleGroupAffected = 36
     * }
     */
    public static int ITISgroups_vehicleGroupAffected() {
        return ITISgroups_vehicleGroupAffected;
    }
    private static final int ITISgroups_travelerGroupAffected = (int)37L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_travelerGroupAffected = 37
     * }
     */
    public static int ITISgroups_travelerGroupAffected() {
        return ITISgroups_travelerGroupAffected;
    }
    private static final int ITISgroups_responderGroupAffected = (int)38L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_responderGroupAffected = 38
     * }
     */
    public static int ITISgroups_responderGroupAffected() {
        return ITISgroups_responderGroupAffected;
    }
    private static final int ITISgroups_incidentResponseEquipment = (int)39L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_incidentResponseEquipment = 39
     * }
     */
    public static int ITISgroups_incidentResponseEquipment() {
        return ITISgroups_incidentResponseEquipment;
    }
    private static final int ITISgroups_assetStatus = (int)40L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_assetStatus = 40
     * }
     */
    public static int ITISgroups_assetStatus() {
        return ITISgroups_assetStatus;
    }
    private static final int ITISgroups_roadsideAssets = (int)41L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_roadsideAssets = 41
     * }
     */
    public static int ITISgroups_roadsideAssets() {
        return ITISgroups_roadsideAssets;
    }
    private static final int ITISgroups_transitOperations = (int)42L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_transitOperations = 42
     * }
     */
    public static int ITISgroups_transitOperations() {
        return ITISgroups_transitOperations;
    }
    private static final int ITISgroups_objects = (int)43L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_objects = 43
     * }
     */
    public static int ITISgroups_objects() {
        return ITISgroups_objects;
    }
    private static final int ITISgroups_validManeuvers = (int)44L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_validManeuvers = 44
     * }
     */
    public static int ITISgroups_validManeuvers() {
        return ITISgroups_validManeuvers;
    }
    private static final int ITISgroups_largeNumbers = (int)45L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_largeNumbers = 45
     * }
     */
    public static int ITISgroups_largeNumbers() {
        return ITISgroups_largeNumbers;
    }
    private static final int ITISgroups_namedObjects = (int)46L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_namedObjects = 46
     * }
     */
    public static int ITISgroups_namedObjects() {
        return ITISgroups_namedObjects;
    }
    private static final int ITISgroups_recreationalObjectsAndActivities = (int)47L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_recreationalObjectsAndActivities = 47
     * }
     */
    public static int ITISgroups_recreationalObjectsAndActivities() {
        return ITISgroups_recreationalObjectsAndActivities;
    }
    private static final int ITISgroups_regulatoryAndWarningSigns = (int)48L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_regulatoryAndWarningSigns = 48
     * }
     */
    public static int ITISgroups_regulatoryAndWarningSigns() {
        return ITISgroups_regulatoryAndWarningSigns;
    }
    private static final int ITISgroups_smallNumbers = (int)49L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_smallNumbers = 49
     * }
     */
    public static int ITISgroups_smallNumbers() {
        return ITISgroups_smallNumbers;
    }
    private static final int ITISgroups_states = (int)50L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_states = 50
     * }
     */
    public static int ITISgroups_states() {
        return ITISgroups_states;
    }
    private static final int ITISgroups_structures = (int)51L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_structures = 51
     * }
     */
    public static int ITISgroups_structures() {
        return ITISgroups_structures;
    }
    private static final int ITISgroups_streetSuffixes = (int)52L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_streetSuffixes = 52
     * }
     */
    public static int ITISgroups_streetSuffixes() {
        return ITISgroups_streetSuffixes;
    }
    private static final int ITISgroups_mUTCDLocations = (int)53L;
    /**
     * {@snippet lang=c :
     * enum ITISgroups.ITISgroups_mUTCDLocations = 53
     * }
     */
    public static int ITISgroups_mUTCDLocations() {
        return ITISgroups_mUTCDLocations;
    }
    /**
     * {@snippet lang=c :
     * typedef long ITISgroups_t
     * }
     */
    public static final OfLong ITISgroups_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_ITISgroups_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_ITISgroups_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ITISgroups_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_ITISgroups_constr_1$layout() {
        return asn_PER_type_ITISgroups_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ITISgroups_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_ITISgroups_constr_1() {
        return asn_PER_type_ITISgroups_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ITISgroups_constr_1
     * }
     */
    public static void asn_PER_type_ITISgroups_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_ITISgroups_constr_1$constants.SEGMENT, 0L, asn_PER_type_ITISgroups_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_ITISgroups$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_ITISgroups").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ITISgroups
     * }
     */
    public static GroupLayout asn_DEF_ITISgroups$layout() {
        return asn_DEF_ITISgroups$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ITISgroups
     * }
     */
    public static MemorySegment asn_DEF_ITISgroups() {
        return asn_DEF_ITISgroups$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ITISgroups
     * }
     */
    public static void asn_DEF_ITISgroups(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_ITISgroups$constants.SEGMENT, 0L, asn_DEF_ITISgroups$constants.LAYOUT.byteSize());
    }

    private static class ITISgroups_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ITISgroups_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ITISgroups_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor ITISgroups_free$descriptor() {
        return ITISgroups_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ITISgroups_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle ITISgroups_free$handle() {
        return ITISgroups_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ITISgroups_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment ITISgroups_free$address() {
        return ITISgroups_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ITISgroups_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void ITISgroups_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = ITISgroups_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ITISgroups_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ITISgroups_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ITISgroups_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ITISgroups_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ITISgroups_print$descriptor() {
        return ITISgroups_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ITISgroups_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ITISgroups_print$handle() {
        return ITISgroups_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ITISgroups_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ITISgroups_print$address() {
        return ITISgroups_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ITISgroups_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int ITISgroups_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ITISgroups_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ITISgroups_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ITISgroups_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ITISgroups_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ITISgroups_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor ITISgroups_constraint$descriptor() {
        return ITISgroups_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ITISgroups_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle ITISgroups_constraint$handle() {
        return ITISgroups_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ITISgroups_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment ITISgroups_constraint$address() {
        return ITISgroups_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ITISgroups_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int ITISgroups_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ITISgroups_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ITISgroups_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ITISgroups_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ITISgroups_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ITISgroups_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor ITISgroups_decode_ber$descriptor() {
        return ITISgroups_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ITISgroups_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle ITISgroups_decode_ber$handle() {
        return ITISgroups_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ITISgroups_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment ITISgroups_decode_ber$address() {
        return ITISgroups_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ITISgroups_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment ITISgroups_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = ITISgroups_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ITISgroups_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ITISgroups_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ITISgroups_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ITISgroups_encode_der$descriptor() {
        return ITISgroups_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ITISgroups_encode_der$handle() {
        return ITISgroups_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ITISgroups_encode_der$address() {
        return ITISgroups_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ITISgroups_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ITISgroups_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ITISgroups_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ITISgroups_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ITISgroups_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ITISgroups_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor ITISgroups_decode_xer$descriptor() {
        return ITISgroups_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ITISgroups_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle ITISgroups_decode_xer$handle() {
        return ITISgroups_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ITISgroups_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment ITISgroups_decode_xer$address() {
        return ITISgroups_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ITISgroups_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment ITISgroups_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = ITISgroups_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ITISgroups_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ITISgroups_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ITISgroups_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ITISgroups_encode_xer$descriptor() {
        return ITISgroups_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ITISgroups_encode_xer$handle() {
        return ITISgroups_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ITISgroups_encode_xer$address() {
        return ITISgroups_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ITISgroups_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ITISgroups_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ITISgroups_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ITISgroups_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ITISgroups_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ITISgroups_encode_jer$descriptor() {
        return ITISgroups_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ITISgroups_encode_jer$handle() {
        return ITISgroups_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ITISgroups_encode_jer$address() {
        return ITISgroups_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ITISgroups_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = ITISgroups_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ITISgroups_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ITISgroups_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ITISgroups_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ITISgroups_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor ITISgroups_decode_oer$descriptor() {
        return ITISgroups_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ITISgroups_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle ITISgroups_decode_oer$handle() {
        return ITISgroups_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ITISgroups_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ITISgroups_decode_oer$address() {
        return ITISgroups_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ITISgroups_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ITISgroups_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = ITISgroups_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ITISgroups_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ITISgroups_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ITISgroups_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ITISgroups_encode_oer$descriptor() {
        return ITISgroups_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ITISgroups_encode_oer$handle() {
        return ITISgroups_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ITISgroups_encode_oer$address() {
        return ITISgroups_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ITISgroups_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ITISgroups_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ITISgroups_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ITISgroups_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ITISgroups_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ITISgroups_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor ITISgroups_decode_uper$descriptor() {
        return ITISgroups_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ITISgroups_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle ITISgroups_decode_uper$handle() {
        return ITISgroups_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ITISgroups_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ITISgroups_decode_uper$address() {
        return ITISgroups_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ITISgroups_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ITISgroups_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ITISgroups_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ITISgroups_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ITISgroups_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ITISgroups_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor ITISgroups_encode_uper$descriptor() {
        return ITISgroups_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle ITISgroups_encode_uper$handle() {
        return ITISgroups_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ITISgroups_encode_uper$address() {
        return ITISgroups_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ITISgroups_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ITISgroups_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ITISgroups_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ITISgroups_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ITISgroups_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ITISgroups_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor ITISgroups_decode_aper$descriptor() {
        return ITISgroups_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ITISgroups_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle ITISgroups_decode_aper$handle() {
        return ITISgroups_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ITISgroups_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ITISgroups_decode_aper$address() {
        return ITISgroups_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ITISgroups_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ITISgroups_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ITISgroups_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ITISgroups_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ITISgroups_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ITISgroups_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor ITISgroups_encode_aper$descriptor() {
        return ITISgroups_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle ITISgroups_encode_aper$handle() {
        return ITISgroups_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ITISgroups_encode_aper$address() {
        return ITISgroups_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ITISgroups_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ITISgroups_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ITISgroups_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ITISgroups_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_EventInfo$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_EventInfo").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_EventInfo
     * }
     */
    public static GroupLayout asn_DEF_EventInfo$layout() {
        return asn_DEF_EventInfo$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_EventInfo
     * }
     */
    public static MemorySegment asn_DEF_EventInfo() {
        return asn_DEF_EventInfo$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_EventInfo
     * }
     */
    public static void asn_DEF_EventInfo(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_EventInfo$constants.SEGMENT, 0L, asn_DEF_EventInfo$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_EventInfo_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_EventInfo_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_EventInfo_specs_1
     * }
     */
    public static GroupLayout asn_SPC_EventInfo_specs_1$layout() {
        return asn_SPC_EventInfo_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_EventInfo_specs_1
     * }
     */
    public static MemorySegment asn_SPC_EventInfo_specs_1() {
        return asn_SPC_EventInfo_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_EventInfo_specs_1
     * }
     */
    public static void asn_SPC_EventInfo_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_EventInfo_specs_1$constants.SEGMENT, 0L, asn_SPC_EventInfo_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_EventInfo_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(9, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_EventInfo_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 9 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EventInfo_1[9]
     * }
     */
    public static SequenceLayout asn_MBR_EventInfo_1$layout() {
        return asn_MBR_EventInfo_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EventInfo_1[9]
     * }
     */
    public static long[] asn_MBR_EventInfo_1$dimensions() {
        return asn_MBR_EventInfo_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EventInfo_1[9]
     * }
     */
    public static MemorySegment asn_MBR_EventInfo_1() {
        return asn_MBR_EventInfo_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EventInfo_1[9]
     * }
     */
    public static void asn_MBR_EventInfo_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_EventInfo_1$constants.SEGMENT, 0L, asn_MBR_EventInfo_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EventInfo_1[9]
     * }
     */
    public static MemorySegment asn_MBR_EventInfo_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_EventInfo_1$constants.HANDLE.invokeExact(asn_MBR_EventInfo_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EventInfo_1[9]
     * }
     */
    public static void asn_MBR_EventInfo_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_EventInfo_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_EventRecurrence$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_EventRecurrence").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_EventRecurrence
     * }
     */
    public static GroupLayout asn_DEF_EventRecurrence$layout() {
        return asn_DEF_EventRecurrence$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_EventRecurrence
     * }
     */
    public static MemorySegment asn_DEF_EventRecurrence() {
        return asn_DEF_EventRecurrence$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_EventRecurrence
     * }
     */
    public static void asn_DEF_EventRecurrence(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_EventRecurrence$constants.SEGMENT, 0L, asn_DEF_EventRecurrence$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_EventRecurrence_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_EventRecurrence_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_EventRecurrence_specs_1
     * }
     */
    public static GroupLayout asn_SPC_EventRecurrence_specs_1$layout() {
        return asn_SPC_EventRecurrence_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_EventRecurrence_specs_1
     * }
     */
    public static MemorySegment asn_SPC_EventRecurrence_specs_1() {
        return asn_SPC_EventRecurrence_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_EventRecurrence_specs_1
     * }
     */
    public static void asn_SPC_EventRecurrence_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_EventRecurrence_specs_1$constants.SEGMENT, 0L, asn_SPC_EventRecurrence_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_EventRecurrence_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(12, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_EventRecurrence_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 12 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EventRecurrence_1[12]
     * }
     */
    public static SequenceLayout asn_MBR_EventRecurrence_1$layout() {
        return asn_MBR_EventRecurrence_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EventRecurrence_1[12]
     * }
     */
    public static long[] asn_MBR_EventRecurrence_1$dimensions() {
        return asn_MBR_EventRecurrence_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EventRecurrence_1[12]
     * }
     */
    public static MemorySegment asn_MBR_EventRecurrence_1() {
        return asn_MBR_EventRecurrence_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EventRecurrence_1[12]
     * }
     */
    public static void asn_MBR_EventRecurrence_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_EventRecurrence_1$constants.SEGMENT, 0L, asn_MBR_EventRecurrence_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EventRecurrence_1[12]
     * }
     */
    public static MemorySegment asn_MBR_EventRecurrence_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_EventRecurrence_1$constants.HANDLE.invokeExact(asn_MBR_EventRecurrence_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EventRecurrence_1[12]
     * }
     */
    public static void asn_MBR_EventRecurrence_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_EventRecurrence_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_DTime$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_DTime").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DTime
     * }
     */
    public static GroupLayout asn_DEF_DTime$layout() {
        return asn_DEF_DTime$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DTime
     * }
     */
    public static MemorySegment asn_DEF_DTime() {
        return asn_DEF_DTime$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DTime
     * }
     */
    public static void asn_DEF_DTime(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_DTime$constants.SEGMENT, 0L, asn_DEF_DTime$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_DTime_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_DTime_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_DTime_specs_1
     * }
     */
    public static GroupLayout asn_SPC_DTime_specs_1$layout() {
        return asn_SPC_DTime_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_DTime_specs_1
     * }
     */
    public static MemorySegment asn_SPC_DTime_specs_1() {
        return asn_SPC_DTime_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_DTime_specs_1
     * }
     */
    public static void asn_SPC_DTime_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_DTime_specs_1$constants.SEGMENT, 0L, asn_SPC_DTime_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_DTime_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(4, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_DTime_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 4 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DTime_1[4]
     * }
     */
    public static SequenceLayout asn_MBR_DTime_1$layout() {
        return asn_MBR_DTime_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DTime_1[4]
     * }
     */
    public static long[] asn_MBR_DTime_1$dimensions() {
        return asn_MBR_DTime_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DTime_1[4]
     * }
     */
    public static MemorySegment asn_MBR_DTime_1() {
        return asn_MBR_DTime_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DTime_1[4]
     * }
     */
    public static void asn_MBR_DTime_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_DTime_1$constants.SEGMENT, 0L, asn_MBR_DTime_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DTime_1[4]
     * }
     */
    public static MemorySegment asn_MBR_DTime_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_DTime_1$constants.HANDLE.invokeExact(asn_MBR_DTime_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DTime_1[4]
     * }
     */
    public static void asn_MBR_DTime_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_DTime_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_DDate$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_DDate").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DDate
     * }
     */
    public static GroupLayout asn_DEF_DDate$layout() {
        return asn_DEF_DDate$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DDate
     * }
     */
    public static MemorySegment asn_DEF_DDate() {
        return asn_DEF_DDate$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DDate
     * }
     */
    public static void asn_DEF_DDate(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_DDate$constants.SEGMENT, 0L, asn_DEF_DDate$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_DDate_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_DDate_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_DDate_specs_1
     * }
     */
    public static GroupLayout asn_SPC_DDate_specs_1$layout() {
        return asn_SPC_DDate_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_DDate_specs_1
     * }
     */
    public static MemorySegment asn_SPC_DDate_specs_1() {
        return asn_SPC_DDate_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_DDate_specs_1
     * }
     */
    public static void asn_SPC_DDate_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_DDate_specs_1$constants.SEGMENT, 0L, asn_SPC_DDate_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_DDate_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(3, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_DDate_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 3 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DDate_1[3]
     * }
     */
    public static SequenceLayout asn_MBR_DDate_1$layout() {
        return asn_MBR_DDate_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DDate_1[3]
     * }
     */
    public static long[] asn_MBR_DDate_1$dimensions() {
        return asn_MBR_DDate_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DDate_1[3]
     * }
     */
    public static MemorySegment asn_MBR_DDate_1() {
        return asn_MBR_DDate_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DDate_1[3]
     * }
     */
    public static void asn_MBR_DDate_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_DDate_1$constants.SEGMENT, 0L, asn_MBR_DDate_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DDate_1[3]
     * }
     */
    public static MemorySegment asn_MBR_DDate_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_DDate_1$constants.HANDLE.invokeExact(asn_MBR_DDate_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DDate_1[3]
     * }
     */
    public static void asn_MBR_DDate_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_DDate_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_CommonContainer$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_CommonContainer").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_CommonContainer
     * }
     */
    public static GroupLayout asn_DEF_CommonContainer$layout() {
        return asn_DEF_CommonContainer$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_CommonContainer
     * }
     */
    public static MemorySegment asn_DEF_CommonContainer() {
        return asn_DEF_CommonContainer$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_CommonContainer
     * }
     */
    public static void asn_DEF_CommonContainer(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_CommonContainer$constants.SEGMENT, 0L, asn_DEF_CommonContainer$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_CommonContainer_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_CommonContainer_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_CommonContainer_specs_1
     * }
     */
    public static GroupLayout asn_SPC_CommonContainer_specs_1$layout() {
        return asn_SPC_CommonContainer_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_CommonContainer_specs_1
     * }
     */
    public static MemorySegment asn_SPC_CommonContainer_specs_1() {
        return asn_SPC_CommonContainer_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_CommonContainer_specs_1
     * }
     */
    public static void asn_SPC_CommonContainer_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_CommonContainer_specs_1$constants.SEGMENT, 0L, asn_SPC_CommonContainer_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_CommonContainer_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(3, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_CommonContainer_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 3 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CommonContainer_1[3]
     * }
     */
    public static SequenceLayout asn_MBR_CommonContainer_1$layout() {
        return asn_MBR_CommonContainer_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CommonContainer_1[3]
     * }
     */
    public static long[] asn_MBR_CommonContainer_1$dimensions() {
        return asn_MBR_CommonContainer_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CommonContainer_1[3]
     * }
     */
    public static MemorySegment asn_MBR_CommonContainer_1() {
        return asn_MBR_CommonContainer_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CommonContainer_1[3]
     * }
     */
    public static void asn_MBR_CommonContainer_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_CommonContainer_1$constants.SEGMENT, 0L, asn_MBR_CommonContainer_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CommonContainer_1[3]
     * }
     */
    public static MemorySegment asn_MBR_CommonContainer_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_CommonContainer_1$constants.HANDLE.invokeExact(asn_MBR_CommonContainer_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CommonContainer_1[3]
     * }
     */
    public static void asn_MBR_CommonContainer_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_CommonContainer_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_CrossLinking$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_CrossLinking").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_CrossLinking
     * }
     */
    public static GroupLayout asn_DEF_CrossLinking$layout() {
        return asn_DEF_CrossLinking$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_CrossLinking
     * }
     */
    public static MemorySegment asn_DEF_CrossLinking() {
        return asn_DEF_CrossLinking$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_CrossLinking
     * }
     */
    public static void asn_DEF_CrossLinking(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_CrossLinking$constants.SEGMENT, 0L, asn_DEF_CrossLinking$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_CrossLinking_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_CrossLinking_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_CrossLinking_specs_1
     * }
     */
    public static GroupLayout asn_SPC_CrossLinking_specs_1$layout() {
        return asn_SPC_CrossLinking_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_CrossLinking_specs_1
     * }
     */
    public static MemorySegment asn_SPC_CrossLinking_specs_1() {
        return asn_SPC_CrossLinking_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_CrossLinking_specs_1
     * }
     */
    public static void asn_SPC_CrossLinking_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_CrossLinking_specs_1$constants.SEGMENT, 0L, asn_SPC_CrossLinking_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_CrossLinking_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(3, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_CrossLinking_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 3 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CrossLinking_1[3]
     * }
     */
    public static SequenceLayout asn_MBR_CrossLinking_1$layout() {
        return asn_MBR_CrossLinking_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CrossLinking_1[3]
     * }
     */
    public static long[] asn_MBR_CrossLinking_1$dimensions() {
        return asn_MBR_CrossLinking_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CrossLinking_1[3]
     * }
     */
    public static MemorySegment asn_MBR_CrossLinking_1() {
        return asn_MBR_CrossLinking_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CrossLinking_1[3]
     * }
     */
    public static void asn_MBR_CrossLinking_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_CrossLinking_1$constants.SEGMENT, 0L, asn_MBR_CrossLinking_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CrossLinking_1[3]
     * }
     */
    public static MemorySegment asn_MBR_CrossLinking_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_CrossLinking_1$constants.HANDLE.invokeExact(asn_MBR_CrossLinking_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CrossLinking_1[3]
     * }
     */
    public static void asn_MBR_CrossLinking_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_CrossLinking_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_AudioLink$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_AudioLink").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AudioLink
     * }
     */
    public static GroupLayout asn_DEF_AudioLink$layout() {
        return asn_DEF_AudioLink$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AudioLink
     * }
     */
    public static MemorySegment asn_DEF_AudioLink() {
        return asn_DEF_AudioLink$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AudioLink
     * }
     */
    public static void asn_DEF_AudioLink(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_AudioLink$constants.SEGMENT, 0L, asn_DEF_AudioLink$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_AudioLink_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_AudioLink_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_AudioLink_specs_1
     * }
     */
    public static GroupLayout asn_SPC_AudioLink_specs_1$layout() {
        return asn_SPC_AudioLink_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_AudioLink_specs_1
     * }
     */
    public static MemorySegment asn_SPC_AudioLink_specs_1() {
        return asn_SPC_AudioLink_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_AudioLink_specs_1
     * }
     */
    public static void asn_SPC_AudioLink_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_AudioLink_specs_1$constants.SEGMENT, 0L, asn_SPC_AudioLink_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_AudioLink_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(4, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_AudioLink_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 4 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AudioLink_1[4]
     * }
     */
    public static SequenceLayout asn_MBR_AudioLink_1$layout() {
        return asn_MBR_AudioLink_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AudioLink_1[4]
     * }
     */
    public static long[] asn_MBR_AudioLink_1$dimensions() {
        return asn_MBR_AudioLink_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AudioLink_1[4]
     * }
     */
    public static MemorySegment asn_MBR_AudioLink_1() {
        return asn_MBR_AudioLink_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AudioLink_1[4]
     * }
     */
    public static void asn_MBR_AudioLink_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_AudioLink_1$constants.SEGMENT, 0L, asn_MBR_AudioLink_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AudioLink_1[4]
     * }
     */
    public static MemorySegment asn_MBR_AudioLink_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_AudioLink_1$constants.HANDLE.invokeExact(asn_MBR_AudioLink_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AudioLink_1[4]
     * }
     */
    public static void asn_MBR_AudioLink_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_AudioLink_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_VisualLink$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_VisualLink").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VisualLink
     * }
     */
    public static GroupLayout asn_DEF_VisualLink$layout() {
        return asn_DEF_VisualLink$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VisualLink
     * }
     */
    public static MemorySegment asn_DEF_VisualLink() {
        return asn_DEF_VisualLink$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VisualLink
     * }
     */
    public static void asn_DEF_VisualLink(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_VisualLink$constants.SEGMENT, 0L, asn_DEF_VisualLink$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_VisualLink_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_VisualLink_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_VisualLink_specs_1
     * }
     */
    public static GroupLayout asn_SPC_VisualLink_specs_1$layout() {
        return asn_SPC_VisualLink_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_VisualLink_specs_1
     * }
     */
    public static MemorySegment asn_SPC_VisualLink_specs_1() {
        return asn_SPC_VisualLink_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_VisualLink_specs_1
     * }
     */
    public static void asn_SPC_VisualLink_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_VisualLink_specs_1$constants.SEGMENT, 0L, asn_SPC_VisualLink_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_VisualLink_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(1, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_VisualLink_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 1 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VisualLink_1[1]
     * }
     */
    public static SequenceLayout asn_MBR_VisualLink_1$layout() {
        return asn_MBR_VisualLink_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VisualLink_1[1]
     * }
     */
    public static long[] asn_MBR_VisualLink_1$dimensions() {
        return asn_MBR_VisualLink_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VisualLink_1[1]
     * }
     */
    public static MemorySegment asn_MBR_VisualLink_1() {
        return asn_MBR_VisualLink_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VisualLink_1[1]
     * }
     */
    public static void asn_MBR_VisualLink_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_VisualLink_1$constants.SEGMENT, 0L, asn_MBR_VisualLink_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VisualLink_1[1]
     * }
     */
    public static MemorySegment asn_MBR_VisualLink_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_VisualLink_1$constants.HANDLE.invokeExact(asn_MBR_VisualLink_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VisualLink_1[1]
     * }
     */
    public static void asn_MBR_VisualLink_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_VisualLink_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    private static final int ReferencePointType_startOfEvent = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ReferencePointType.ReferencePointType_startOfEvent = 0
     * }
     */
    public static int ReferencePointType_startOfEvent() {
        return ReferencePointType_startOfEvent;
    }
    private static final int ReferencePointType_arbitrary = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ReferencePointType.ReferencePointType_arbitrary = 1
     * }
     */
    public static int ReferencePointType_arbitrary() {
        return ReferencePointType_arbitrary;
    }
    /**
     * {@snippet lang=c :
     * typedef long ReferencePointType_t
     * }
     */
    public static final OfLong ReferencePointType_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_ReferencePointType_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_ReferencePointType_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ReferencePointType_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_ReferencePointType_constr_1$layout() {
        return asn_PER_type_ReferencePointType_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ReferencePointType_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_ReferencePointType_constr_1() {
        return asn_PER_type_ReferencePointType_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ReferencePointType_constr_1
     * }
     */
    public static void asn_PER_type_ReferencePointType_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_ReferencePointType_constr_1$constants.SEGMENT, 0L, asn_PER_type_ReferencePointType_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_ReferencePointType$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_ReferencePointType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ReferencePointType
     * }
     */
    public static GroupLayout asn_DEF_ReferencePointType$layout() {
        return asn_DEF_ReferencePointType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ReferencePointType
     * }
     */
    public static MemorySegment asn_DEF_ReferencePointType() {
        return asn_DEF_ReferencePointType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ReferencePointType
     * }
     */
    public static void asn_DEF_ReferencePointType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_ReferencePointType$constants.SEGMENT, 0L, asn_DEF_ReferencePointType$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_ReferencePointType_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_ReferencePointType_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_ReferencePointType_specs_1
     * }
     */
    public static GroupLayout asn_SPC_ReferencePointType_specs_1$layout() {
        return asn_SPC_ReferencePointType_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_ReferencePointType_specs_1
     * }
     */
    public static MemorySegment asn_SPC_ReferencePointType_specs_1() {
        return asn_SPC_ReferencePointType_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_ReferencePointType_specs_1
     * }
     */
    public static void asn_SPC_ReferencePointType_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_ReferencePointType_specs_1$constants.SEGMENT, 0L, asn_SPC_ReferencePointType_specs_1$constants.LAYOUT.byteSize());
    }

    private static class ReferencePointType_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ReferencePointType_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ReferencePointType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor ReferencePointType_free$descriptor() {
        return ReferencePointType_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ReferencePointType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle ReferencePointType_free$handle() {
        return ReferencePointType_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ReferencePointType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment ReferencePointType_free$address() {
        return ReferencePointType_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ReferencePointType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void ReferencePointType_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = ReferencePointType_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReferencePointType_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReferencePointType_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ReferencePointType_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ReferencePointType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ReferencePointType_print$descriptor() {
        return ReferencePointType_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ReferencePointType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ReferencePointType_print$handle() {
        return ReferencePointType_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ReferencePointType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ReferencePointType_print$address() {
        return ReferencePointType_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ReferencePointType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int ReferencePointType_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ReferencePointType_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReferencePointType_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReferencePointType_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ReferencePointType_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ReferencePointType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor ReferencePointType_constraint$descriptor() {
        return ReferencePointType_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ReferencePointType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle ReferencePointType_constraint$handle() {
        return ReferencePointType_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ReferencePointType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment ReferencePointType_constraint$address() {
        return ReferencePointType_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ReferencePointType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int ReferencePointType_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ReferencePointType_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReferencePointType_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReferencePointType_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ReferencePointType_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ReferencePointType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor ReferencePointType_decode_ber$descriptor() {
        return ReferencePointType_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ReferencePointType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle ReferencePointType_decode_ber$handle() {
        return ReferencePointType_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ReferencePointType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment ReferencePointType_decode_ber$address() {
        return ReferencePointType_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ReferencePointType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment ReferencePointType_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = ReferencePointType_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReferencePointType_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReferencePointType_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ReferencePointType_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ReferencePointType_encode_der$descriptor() {
        return ReferencePointType_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ReferencePointType_encode_der$handle() {
        return ReferencePointType_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ReferencePointType_encode_der$address() {
        return ReferencePointType_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ReferencePointType_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ReferencePointType_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReferencePointType_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReferencePointType_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ReferencePointType_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ReferencePointType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor ReferencePointType_decode_xer$descriptor() {
        return ReferencePointType_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ReferencePointType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle ReferencePointType_decode_xer$handle() {
        return ReferencePointType_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ReferencePointType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment ReferencePointType_decode_xer$address() {
        return ReferencePointType_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ReferencePointType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment ReferencePointType_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = ReferencePointType_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReferencePointType_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReferencePointType_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ReferencePointType_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ReferencePointType_encode_xer$descriptor() {
        return ReferencePointType_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ReferencePointType_encode_xer$handle() {
        return ReferencePointType_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ReferencePointType_encode_xer$address() {
        return ReferencePointType_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ReferencePointType_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ReferencePointType_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReferencePointType_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReferencePointType_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ReferencePointType_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ReferencePointType_encode_jer$descriptor() {
        return ReferencePointType_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ReferencePointType_encode_jer$handle() {
        return ReferencePointType_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ReferencePointType_encode_jer$address() {
        return ReferencePointType_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ReferencePointType_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = ReferencePointType_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReferencePointType_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReferencePointType_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ReferencePointType_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ReferencePointType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor ReferencePointType_decode_oer$descriptor() {
        return ReferencePointType_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ReferencePointType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle ReferencePointType_decode_oer$handle() {
        return ReferencePointType_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ReferencePointType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ReferencePointType_decode_oer$address() {
        return ReferencePointType_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ReferencePointType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ReferencePointType_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = ReferencePointType_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReferencePointType_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReferencePointType_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ReferencePointType_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ReferencePointType_encode_oer$descriptor() {
        return ReferencePointType_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ReferencePointType_encode_oer$handle() {
        return ReferencePointType_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ReferencePointType_encode_oer$address() {
        return ReferencePointType_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ReferencePointType_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ReferencePointType_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReferencePointType_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReferencePointType_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ReferencePointType_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ReferencePointType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor ReferencePointType_decode_uper$descriptor() {
        return ReferencePointType_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ReferencePointType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle ReferencePointType_decode_uper$handle() {
        return ReferencePointType_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ReferencePointType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ReferencePointType_decode_uper$address() {
        return ReferencePointType_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ReferencePointType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ReferencePointType_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ReferencePointType_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReferencePointType_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReferencePointType_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ReferencePointType_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor ReferencePointType_encode_uper$descriptor() {
        return ReferencePointType_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle ReferencePointType_encode_uper$handle() {
        return ReferencePointType_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ReferencePointType_encode_uper$address() {
        return ReferencePointType_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ReferencePointType_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ReferencePointType_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReferencePointType_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReferencePointType_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ReferencePointType_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ReferencePointType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor ReferencePointType_decode_aper$descriptor() {
        return ReferencePointType_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ReferencePointType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle ReferencePointType_decode_aper$handle() {
        return ReferencePointType_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ReferencePointType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ReferencePointType_decode_aper$address() {
        return ReferencePointType_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ReferencePointType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ReferencePointType_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ReferencePointType_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReferencePointType_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ReferencePointType_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ReferencePointType_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor ReferencePointType_encode_aper$descriptor() {
        return ReferencePointType_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle ReferencePointType_encode_aper$handle() {
        return ReferencePointType_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ReferencePointType_encode_aper$address() {
        return ReferencePointType_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ReferencePointType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ReferencePointType_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ReferencePointType_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ReferencePointType_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_RegionInfo$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_RegionInfo").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RegionInfo
     * }
     */
    public static GroupLayout asn_DEF_RegionInfo$layout() {
        return asn_DEF_RegionInfo$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RegionInfo
     * }
     */
    public static MemorySegment asn_DEF_RegionInfo() {
        return asn_DEF_RegionInfo$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RegionInfo
     * }
     */
    public static void asn_DEF_RegionInfo(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_RegionInfo$constants.SEGMENT, 0L, asn_DEF_RegionInfo$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_RegionInfo_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_RegionInfo_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RegionInfo_specs_1
     * }
     */
    public static GroupLayout asn_SPC_RegionInfo_specs_1$layout() {
        return asn_SPC_RegionInfo_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RegionInfo_specs_1
     * }
     */
    public static MemorySegment asn_SPC_RegionInfo_specs_1() {
        return asn_SPC_RegionInfo_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RegionInfo_specs_1
     * }
     */
    public static void asn_SPC_RegionInfo_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_RegionInfo_specs_1$constants.SEGMENT, 0L, asn_SPC_RegionInfo_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_RegionInfo_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(6, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_RegionInfo_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 6 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionInfo_1[6]
     * }
     */
    public static SequenceLayout asn_MBR_RegionInfo_1$layout() {
        return asn_MBR_RegionInfo_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionInfo_1[6]
     * }
     */
    public static long[] asn_MBR_RegionInfo_1$dimensions() {
        return asn_MBR_RegionInfo_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionInfo_1[6]
     * }
     */
    public static MemorySegment asn_MBR_RegionInfo_1() {
        return asn_MBR_RegionInfo_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionInfo_1[6]
     * }
     */
    public static void asn_MBR_RegionInfo_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RegionInfo_1$constants.SEGMENT, 0L, asn_MBR_RegionInfo_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionInfo_1[6]
     * }
     */
    public static MemorySegment asn_MBR_RegionInfo_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_RegionInfo_1$constants.HANDLE.invokeExact(asn_MBR_RegionInfo_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionInfo_1[6]
     * }
     */
    public static void asn_MBR_RegionInfo_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RegionInfo_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef long LatOffset_t
     * }
     */
    public static final OfLong LatOffset_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_LatOffset_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_LatOffset_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_LatOffset_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_LatOffset_constr_1$layout() {
        return asn_PER_type_LatOffset_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_LatOffset_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_LatOffset_constr_1() {
        return asn_PER_type_LatOffset_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_LatOffset_constr_1
     * }
     */
    public static void asn_PER_type_LatOffset_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_LatOffset_constr_1$constants.SEGMENT, 0L, asn_PER_type_LatOffset_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_LatOffset$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_LatOffset").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_LatOffset
     * }
     */
    public static GroupLayout asn_DEF_LatOffset$layout() {
        return asn_DEF_LatOffset$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_LatOffset
     * }
     */
    public static MemorySegment asn_DEF_LatOffset() {
        return asn_DEF_LatOffset$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_LatOffset
     * }
     */
    public static void asn_DEF_LatOffset(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_LatOffset$constants.SEGMENT, 0L, asn_DEF_LatOffset$constants.LAYOUT.byteSize());
    }

    private static class LatOffset_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LatOffset_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LatOffset_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor LatOffset_free$descriptor() {
        return LatOffset_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LatOffset_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle LatOffset_free$handle() {
        return LatOffset_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LatOffset_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment LatOffset_free$address() {
        return LatOffset_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LatOffset_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void LatOffset_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = LatOffset_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LatOffset_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LatOffset_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LatOffset_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LatOffset_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor LatOffset_print$descriptor() {
        return LatOffset_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LatOffset_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle LatOffset_print$handle() {
        return LatOffset_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LatOffset_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LatOffset_print$address() {
        return LatOffset_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LatOffset_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int LatOffset_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = LatOffset_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LatOffset_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LatOffset_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LatOffset_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LatOffset_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor LatOffset_constraint$descriptor() {
        return LatOffset_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LatOffset_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle LatOffset_constraint$handle() {
        return LatOffset_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LatOffset_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment LatOffset_constraint$address() {
        return LatOffset_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LatOffset_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int LatOffset_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = LatOffset_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LatOffset_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LatOffset_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LatOffset_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t LatOffset_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor LatOffset_decode_ber$descriptor() {
        return LatOffset_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t LatOffset_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle LatOffset_decode_ber$handle() {
        return LatOffset_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t LatOffset_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment LatOffset_decode_ber$address() {
        return LatOffset_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t LatOffset_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment LatOffset_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = LatOffset_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LatOffset_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LatOffset_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LatOffset_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor LatOffset_encode_der$descriptor() {
        return LatOffset_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle LatOffset_encode_der$handle() {
        return LatOffset_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LatOffset_encode_der$address() {
        return LatOffset_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LatOffset_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = LatOffset_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LatOffset_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LatOffset_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LatOffset_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t LatOffset_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor LatOffset_decode_xer$descriptor() {
        return LatOffset_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t LatOffset_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle LatOffset_decode_xer$handle() {
        return LatOffset_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t LatOffset_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment LatOffset_decode_xer$address() {
        return LatOffset_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t LatOffset_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment LatOffset_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = LatOffset_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LatOffset_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LatOffset_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LatOffset_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor LatOffset_encode_xer$descriptor() {
        return LatOffset_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle LatOffset_encode_xer$handle() {
        return LatOffset_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LatOffset_encode_xer$address() {
        return LatOffset_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LatOffset_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = LatOffset_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LatOffset_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LatOffset_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LatOffset_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor LatOffset_encode_jer$descriptor() {
        return LatOffset_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle LatOffset_encode_jer$handle() {
        return LatOffset_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LatOffset_encode_jer$address() {
        return LatOffset_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LatOffset_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = LatOffset_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LatOffset_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LatOffset_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LatOffset_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t LatOffset_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor LatOffset_decode_oer$descriptor() {
        return LatOffset_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t LatOffset_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle LatOffset_decode_oer$handle() {
        return LatOffset_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t LatOffset_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment LatOffset_decode_oer$address() {
        return LatOffset_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t LatOffset_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment LatOffset_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = LatOffset_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LatOffset_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LatOffset_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LatOffset_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor LatOffset_encode_oer$descriptor() {
        return LatOffset_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle LatOffset_encode_oer$handle() {
        return LatOffset_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LatOffset_encode_oer$address() {
        return LatOffset_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LatOffset_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = LatOffset_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LatOffset_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LatOffset_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LatOffset_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t LatOffset_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor LatOffset_decode_uper$descriptor() {
        return LatOffset_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t LatOffset_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle LatOffset_decode_uper$handle() {
        return LatOffset_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t LatOffset_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment LatOffset_decode_uper$address() {
        return LatOffset_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t LatOffset_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment LatOffset_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = LatOffset_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LatOffset_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LatOffset_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LatOffset_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor LatOffset_encode_uper$descriptor() {
        return LatOffset_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle LatOffset_encode_uper$handle() {
        return LatOffset_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment LatOffset_encode_uper$address() {
        return LatOffset_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment LatOffset_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = LatOffset_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LatOffset_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LatOffset_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LatOffset_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t LatOffset_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor LatOffset_decode_aper$descriptor() {
        return LatOffset_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t LatOffset_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle LatOffset_decode_aper$handle() {
        return LatOffset_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t LatOffset_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment LatOffset_decode_aper$address() {
        return LatOffset_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t LatOffset_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment LatOffset_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = LatOffset_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LatOffset_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LatOffset_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LatOffset_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor LatOffset_encode_aper$descriptor() {
        return LatOffset_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle LatOffset_encode_aper$handle() {
        return LatOffset_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment LatOffset_encode_aper$address() {
        return LatOffset_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t LatOffset_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment LatOffset_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = LatOffset_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LatOffset_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long LongOffset_t
     * }
     */
    public static final OfLong LongOffset_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_LongOffset_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_LongOffset_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_LongOffset_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_LongOffset_constr_1$layout() {
        return asn_PER_type_LongOffset_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_LongOffset_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_LongOffset_constr_1() {
        return asn_PER_type_LongOffset_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_LongOffset_constr_1
     * }
     */
    public static void asn_PER_type_LongOffset_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_LongOffset_constr_1$constants.SEGMENT, 0L, asn_PER_type_LongOffset_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_LongOffset$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_LongOffset").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_LongOffset
     * }
     */
    public static GroupLayout asn_DEF_LongOffset$layout() {
        return asn_DEF_LongOffset$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_LongOffset
     * }
     */
    public static MemorySegment asn_DEF_LongOffset() {
        return asn_DEF_LongOffset$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_LongOffset
     * }
     */
    public static void asn_DEF_LongOffset(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_LongOffset$constants.SEGMENT, 0L, asn_DEF_LongOffset$constants.LAYOUT.byteSize());
    }

    private static class LongOffset_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LongOffset_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LongOffset_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor LongOffset_free$descriptor() {
        return LongOffset_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LongOffset_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle LongOffset_free$handle() {
        return LongOffset_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LongOffset_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment LongOffset_free$address() {
        return LongOffset_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LongOffset_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void LongOffset_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = LongOffset_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LongOffset_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LongOffset_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LongOffset_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LongOffset_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor LongOffset_print$descriptor() {
        return LongOffset_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LongOffset_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle LongOffset_print$handle() {
        return LongOffset_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LongOffset_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LongOffset_print$address() {
        return LongOffset_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LongOffset_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int LongOffset_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = LongOffset_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LongOffset_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LongOffset_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LongOffset_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LongOffset_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor LongOffset_constraint$descriptor() {
        return LongOffset_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LongOffset_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle LongOffset_constraint$handle() {
        return LongOffset_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LongOffset_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment LongOffset_constraint$address() {
        return LongOffset_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LongOffset_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int LongOffset_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = LongOffset_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LongOffset_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LongOffset_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LongOffset_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t LongOffset_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor LongOffset_decode_ber$descriptor() {
        return LongOffset_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t LongOffset_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle LongOffset_decode_ber$handle() {
        return LongOffset_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t LongOffset_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment LongOffset_decode_ber$address() {
        return LongOffset_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t LongOffset_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment LongOffset_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = LongOffset_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LongOffset_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LongOffset_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LongOffset_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor LongOffset_encode_der$descriptor() {
        return LongOffset_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle LongOffset_encode_der$handle() {
        return LongOffset_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LongOffset_encode_der$address() {
        return LongOffset_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LongOffset_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = LongOffset_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LongOffset_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LongOffset_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LongOffset_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t LongOffset_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor LongOffset_decode_xer$descriptor() {
        return LongOffset_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t LongOffset_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle LongOffset_decode_xer$handle() {
        return LongOffset_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t LongOffset_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment LongOffset_decode_xer$address() {
        return LongOffset_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t LongOffset_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment LongOffset_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = LongOffset_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LongOffset_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LongOffset_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LongOffset_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor LongOffset_encode_xer$descriptor() {
        return LongOffset_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle LongOffset_encode_xer$handle() {
        return LongOffset_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LongOffset_encode_xer$address() {
        return LongOffset_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LongOffset_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = LongOffset_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LongOffset_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LongOffset_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LongOffset_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor LongOffset_encode_jer$descriptor() {
        return LongOffset_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle LongOffset_encode_jer$handle() {
        return LongOffset_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LongOffset_encode_jer$address() {
        return LongOffset_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LongOffset_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = LongOffset_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LongOffset_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LongOffset_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LongOffset_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t LongOffset_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor LongOffset_decode_oer$descriptor() {
        return LongOffset_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t LongOffset_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle LongOffset_decode_oer$handle() {
        return LongOffset_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t LongOffset_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment LongOffset_decode_oer$address() {
        return LongOffset_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t LongOffset_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment LongOffset_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = LongOffset_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LongOffset_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LongOffset_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LongOffset_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor LongOffset_encode_oer$descriptor() {
        return LongOffset_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle LongOffset_encode_oer$handle() {
        return LongOffset_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LongOffset_encode_oer$address() {
        return LongOffset_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LongOffset_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = LongOffset_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LongOffset_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LongOffset_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LongOffset_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t LongOffset_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor LongOffset_decode_uper$descriptor() {
        return LongOffset_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t LongOffset_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle LongOffset_decode_uper$handle() {
        return LongOffset_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t LongOffset_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment LongOffset_decode_uper$address() {
        return LongOffset_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t LongOffset_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment LongOffset_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = LongOffset_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LongOffset_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LongOffset_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LongOffset_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor LongOffset_encode_uper$descriptor() {
        return LongOffset_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle LongOffset_encode_uper$handle() {
        return LongOffset_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment LongOffset_encode_uper$address() {
        return LongOffset_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment LongOffset_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = LongOffset_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LongOffset_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LongOffset_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LongOffset_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t LongOffset_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor LongOffset_decode_aper$descriptor() {
        return LongOffset_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t LongOffset_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle LongOffset_decode_aper$handle() {
        return LongOffset_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t LongOffset_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment LongOffset_decode_aper$address() {
        return LongOffset_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t LongOffset_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment LongOffset_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = LongOffset_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LongOffset_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LongOffset_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LongOffset_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor LongOffset_encode_aper$descriptor() {
        return LongOffset_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle LongOffset_encode_aper$handle() {
        return LongOffset_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment LongOffset_encode_aper$address() {
        return LongOffset_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t LongOffset_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment LongOffset_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = LongOffset_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LongOffset_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long ElevOffset_t
     * }
     */
    public static final OfLong ElevOffset_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_ElevOffset_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_ElevOffset_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ElevOffset_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_ElevOffset_constr_1$layout() {
        return asn_PER_type_ElevOffset_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ElevOffset_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_ElevOffset_constr_1() {
        return asn_PER_type_ElevOffset_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ElevOffset_constr_1
     * }
     */
    public static void asn_PER_type_ElevOffset_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_ElevOffset_constr_1$constants.SEGMENT, 0L, asn_PER_type_ElevOffset_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_ElevOffset$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_ElevOffset").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ElevOffset
     * }
     */
    public static GroupLayout asn_DEF_ElevOffset$layout() {
        return asn_DEF_ElevOffset$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ElevOffset
     * }
     */
    public static MemorySegment asn_DEF_ElevOffset() {
        return asn_DEF_ElevOffset$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ElevOffset
     * }
     */
    public static void asn_DEF_ElevOffset(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_ElevOffset$constants.SEGMENT, 0L, asn_DEF_ElevOffset$constants.LAYOUT.byteSize());
    }

    private static class ElevOffset_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevOffset_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ElevOffset_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor ElevOffset_free$descriptor() {
        return ElevOffset_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ElevOffset_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle ElevOffset_free$handle() {
        return ElevOffset_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ElevOffset_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment ElevOffset_free$address() {
        return ElevOffset_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ElevOffset_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void ElevOffset_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = ElevOffset_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevOffset_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevOffset_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevOffset_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ElevOffset_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ElevOffset_print$descriptor() {
        return ElevOffset_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ElevOffset_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ElevOffset_print$handle() {
        return ElevOffset_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ElevOffset_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ElevOffset_print$address() {
        return ElevOffset_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ElevOffset_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int ElevOffset_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ElevOffset_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevOffset_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevOffset_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevOffset_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ElevOffset_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor ElevOffset_constraint$descriptor() {
        return ElevOffset_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ElevOffset_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle ElevOffset_constraint$handle() {
        return ElevOffset_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ElevOffset_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment ElevOffset_constraint$address() {
        return ElevOffset_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ElevOffset_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int ElevOffset_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ElevOffset_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevOffset_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevOffset_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevOffset_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevOffset_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor ElevOffset_decode_ber$descriptor() {
        return ElevOffset_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevOffset_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle ElevOffset_decode_ber$handle() {
        return ElevOffset_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevOffset_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment ElevOffset_decode_ber$address() {
        return ElevOffset_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ElevOffset_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment ElevOffset_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = ElevOffset_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevOffset_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevOffset_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevOffset_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ElevOffset_encode_der$descriptor() {
        return ElevOffset_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ElevOffset_encode_der$handle() {
        return ElevOffset_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ElevOffset_encode_der$address() {
        return ElevOffset_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ElevOffset_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ElevOffset_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevOffset_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevOffset_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevOffset_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevOffset_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor ElevOffset_decode_xer$descriptor() {
        return ElevOffset_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevOffset_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle ElevOffset_decode_xer$handle() {
        return ElevOffset_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevOffset_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment ElevOffset_decode_xer$address() {
        return ElevOffset_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ElevOffset_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment ElevOffset_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = ElevOffset_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevOffset_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevOffset_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevOffset_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ElevOffset_encode_xer$descriptor() {
        return ElevOffset_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ElevOffset_encode_xer$handle() {
        return ElevOffset_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ElevOffset_encode_xer$address() {
        return ElevOffset_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ElevOffset_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ElevOffset_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevOffset_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevOffset_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevOffset_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ElevOffset_encode_jer$descriptor() {
        return ElevOffset_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ElevOffset_encode_jer$handle() {
        return ElevOffset_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ElevOffset_encode_jer$address() {
        return ElevOffset_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ElevOffset_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = ElevOffset_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevOffset_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevOffset_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevOffset_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevOffset_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor ElevOffset_decode_oer$descriptor() {
        return ElevOffset_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevOffset_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle ElevOffset_decode_oer$handle() {
        return ElevOffset_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevOffset_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ElevOffset_decode_oer$address() {
        return ElevOffset_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ElevOffset_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ElevOffset_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = ElevOffset_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevOffset_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevOffset_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevOffset_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ElevOffset_encode_oer$descriptor() {
        return ElevOffset_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ElevOffset_encode_oer$handle() {
        return ElevOffset_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ElevOffset_encode_oer$address() {
        return ElevOffset_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ElevOffset_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ElevOffset_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevOffset_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevOffset_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevOffset_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevOffset_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor ElevOffset_decode_uper$descriptor() {
        return ElevOffset_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevOffset_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle ElevOffset_decode_uper$handle() {
        return ElevOffset_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevOffset_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ElevOffset_decode_uper$address() {
        return ElevOffset_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ElevOffset_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ElevOffset_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ElevOffset_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevOffset_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevOffset_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevOffset_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor ElevOffset_encode_uper$descriptor() {
        return ElevOffset_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle ElevOffset_encode_uper$handle() {
        return ElevOffset_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ElevOffset_encode_uper$address() {
        return ElevOffset_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ElevOffset_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ElevOffset_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevOffset_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevOffset_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevOffset_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevOffset_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor ElevOffset_decode_aper$descriptor() {
        return ElevOffset_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevOffset_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle ElevOffset_decode_aper$handle() {
        return ElevOffset_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevOffset_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ElevOffset_decode_aper$address() {
        return ElevOffset_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ElevOffset_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ElevOffset_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ElevOffset_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevOffset_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevOffset_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevOffset_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor ElevOffset_encode_aper$descriptor() {
        return ElevOffset_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle ElevOffset_encode_aper$handle() {
        return ElevOffset_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ElevOffset_encode_aper$address() {
        return ElevOffset_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ElevOffset_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ElevOffset_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ElevOffset_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevOffset_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_Offset3D$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_Offset3D").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Offset3D
     * }
     */
    public static GroupLayout asn_DEF_Offset3D$layout() {
        return asn_DEF_Offset3D$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Offset3D
     * }
     */
    public static MemorySegment asn_DEF_Offset3D() {
        return asn_DEF_Offset3D$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Offset3D
     * }
     */
    public static void asn_DEF_Offset3D(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_Offset3D$constants.SEGMENT, 0L, asn_DEF_Offset3D$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_Offset3D_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_Offset3D_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Offset3D_specs_1
     * }
     */
    public static GroupLayout asn_SPC_Offset3D_specs_1$layout() {
        return asn_SPC_Offset3D_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Offset3D_specs_1
     * }
     */
    public static MemorySegment asn_SPC_Offset3D_specs_1() {
        return asn_SPC_Offset3D_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Offset3D_specs_1
     * }
     */
    public static void asn_SPC_Offset3D_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_Offset3D_specs_1$constants.SEGMENT, 0L, asn_SPC_Offset3D_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_Offset3D_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(3, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_Offset3D_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 3 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Offset3D_1[3]
     * }
     */
    public static SequenceLayout asn_MBR_Offset3D_1$layout() {
        return asn_MBR_Offset3D_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Offset3D_1[3]
     * }
     */
    public static long[] asn_MBR_Offset3D_1$dimensions() {
        return asn_MBR_Offset3D_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Offset3D_1[3]
     * }
     */
    public static MemorySegment asn_MBR_Offset3D_1() {
        return asn_MBR_Offset3D_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Offset3D_1[3]
     * }
     */
    public static void asn_MBR_Offset3D_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_Offset3D_1$constants.SEGMENT, 0L, asn_MBR_Offset3D_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Offset3D_1[3]
     * }
     */
    public static MemorySegment asn_MBR_Offset3D_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_Offset3D_1$constants.HANDLE.invokeExact(asn_MBR_Offset3D_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Offset3D_1[3]
     * }
     */
    public static void asn_MBR_Offset3D_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_Offset3D_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    private static final int RegionUncertainty_PR_NOTHING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum RegionUncertainty_PR.RegionUncertainty_PR_NOTHING = 0
     * }
     */
    public static int RegionUncertainty_PR_NOTHING() {
        return RegionUncertainty_PR_NOTHING;
    }
    private static final int RegionUncertainty_PR_alongPath = (int)1L;
    /**
     * {@snippet lang=c :
     * enum RegionUncertainty_PR.RegionUncertainty_PR_alongPath = 1
     * }
     */
    public static int RegionUncertainty_PR_alongPath() {
        return RegionUncertainty_PR_alongPath;
    }
    private static final int RegionUncertainty_PR_inCoordinateFrame = (int)2L;
    /**
     * {@snippet lang=c :
     * enum RegionUncertainty_PR.RegionUncertainty_PR_inCoordinateFrame = 2
     * }
     */
    public static int RegionUncertainty_PR_inCoordinateFrame() {
        return RegionUncertainty_PR_inCoordinateFrame;
    }

    private static class asn_DEF_RegionUncertainty$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_RegionUncertainty").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RegionUncertainty
     * }
     */
    public static GroupLayout asn_DEF_RegionUncertainty$layout() {
        return asn_DEF_RegionUncertainty$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RegionUncertainty
     * }
     */
    public static MemorySegment asn_DEF_RegionUncertainty() {
        return asn_DEF_RegionUncertainty$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RegionUncertainty
     * }
     */
    public static void asn_DEF_RegionUncertainty(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_RegionUncertainty$constants.SEGMENT, 0L, asn_DEF_RegionUncertainty$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_RegionUncertainty_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_CHOICE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_RegionUncertainty_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_RegionUncertainty_specs_1
     * }
     */
    public static GroupLayout asn_SPC_RegionUncertainty_specs_1$layout() {
        return asn_SPC_RegionUncertainty_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_RegionUncertainty_specs_1
     * }
     */
    public static MemorySegment asn_SPC_RegionUncertainty_specs_1() {
        return asn_SPC_RegionUncertainty_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_RegionUncertainty_specs_1
     * }
     */
    public static void asn_SPC_RegionUncertainty_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_RegionUncertainty_specs_1$constants.SEGMENT, 0L, asn_SPC_RegionUncertainty_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_RegionUncertainty_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_RegionUncertainty_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionUncertainty_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_RegionUncertainty_1$layout() {
        return asn_MBR_RegionUncertainty_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionUncertainty_1[2]
     * }
     */
    public static long[] asn_MBR_RegionUncertainty_1$dimensions() {
        return asn_MBR_RegionUncertainty_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionUncertainty_1[2]
     * }
     */
    public static MemorySegment asn_MBR_RegionUncertainty_1() {
        return asn_MBR_RegionUncertainty_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionUncertainty_1[2]
     * }
     */
    public static void asn_MBR_RegionUncertainty_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RegionUncertainty_1$constants.SEGMENT, 0L, asn_MBR_RegionUncertainty_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionUncertainty_1[2]
     * }
     */
    public static MemorySegment asn_MBR_RegionUncertainty_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_RegionUncertainty_1$constants.HANDLE.invokeExact(asn_MBR_RegionUncertainty_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RegionUncertainty_1[2]
     * }
     */
    public static void asn_MBR_RegionUncertainty_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RegionUncertainty_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_RegionUncertainty_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_RegionUncertainty_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RegionUncertainty_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_RegionUncertainty_constr_1$layout() {
        return asn_PER_type_RegionUncertainty_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RegionUncertainty_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_RegionUncertainty_constr_1() {
        return asn_PER_type_RegionUncertainty_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RegionUncertainty_constr_1
     * }
     */
    public static void asn_PER_type_RegionUncertainty_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_RegionUncertainty_constr_1$constants.SEGMENT, 0L, asn_PER_type_RegionUncertainty_constr_1$constants.LAYOUT.byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef long HeadingDeg_t
     * }
     */
    public static final OfLong HeadingDeg_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_HeadingDeg_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_HeadingDeg_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_HeadingDeg_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_HeadingDeg_constr_1$layout() {
        return asn_PER_type_HeadingDeg_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_HeadingDeg_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_HeadingDeg_constr_1() {
        return asn_PER_type_HeadingDeg_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_HeadingDeg_constr_1
     * }
     */
    public static void asn_PER_type_HeadingDeg_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_HeadingDeg_constr_1$constants.SEGMENT, 0L, asn_PER_type_HeadingDeg_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_HeadingDeg$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_HeadingDeg").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_HeadingDeg
     * }
     */
    public static GroupLayout asn_DEF_HeadingDeg$layout() {
        return asn_DEF_HeadingDeg$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_HeadingDeg
     * }
     */
    public static MemorySegment asn_DEF_HeadingDeg() {
        return asn_DEF_HeadingDeg$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_HeadingDeg
     * }
     */
    public static void asn_DEF_HeadingDeg(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_HeadingDeg$constants.SEGMENT, 0L, asn_DEF_HeadingDeg$constants.LAYOUT.byteSize());
    }

    private static class HeadingDeg_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingDeg_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void HeadingDeg_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor HeadingDeg_free$descriptor() {
        return HeadingDeg_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void HeadingDeg_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle HeadingDeg_free$handle() {
        return HeadingDeg_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void HeadingDeg_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment HeadingDeg_free$address() {
        return HeadingDeg_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void HeadingDeg_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void HeadingDeg_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = HeadingDeg_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingDeg_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingDeg_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingDeg_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int HeadingDeg_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor HeadingDeg_print$descriptor() {
        return HeadingDeg_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int HeadingDeg_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle HeadingDeg_print$handle() {
        return HeadingDeg_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int HeadingDeg_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HeadingDeg_print$address() {
        return HeadingDeg_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int HeadingDeg_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int HeadingDeg_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = HeadingDeg_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingDeg_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingDeg_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingDeg_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int HeadingDeg_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor HeadingDeg_constraint$descriptor() {
        return HeadingDeg_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int HeadingDeg_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle HeadingDeg_constraint$handle() {
        return HeadingDeg_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int HeadingDeg_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment HeadingDeg_constraint$address() {
        return HeadingDeg_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int HeadingDeg_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int HeadingDeg_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = HeadingDeg_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingDeg_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingDeg_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingDeg_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingDeg_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor HeadingDeg_decode_ber$descriptor() {
        return HeadingDeg_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingDeg_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle HeadingDeg_decode_ber$handle() {
        return HeadingDeg_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingDeg_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment HeadingDeg_decode_ber$address() {
        return HeadingDeg_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingDeg_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment HeadingDeg_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = HeadingDeg_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingDeg_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingDeg_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingDeg_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor HeadingDeg_encode_der$descriptor() {
        return HeadingDeg_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle HeadingDeg_encode_der$handle() {
        return HeadingDeg_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HeadingDeg_encode_der$address() {
        return HeadingDeg_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HeadingDeg_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = HeadingDeg_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingDeg_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingDeg_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingDeg_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingDeg_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor HeadingDeg_decode_xer$descriptor() {
        return HeadingDeg_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingDeg_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle HeadingDeg_decode_xer$handle() {
        return HeadingDeg_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingDeg_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment HeadingDeg_decode_xer$address() {
        return HeadingDeg_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingDeg_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment HeadingDeg_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = HeadingDeg_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingDeg_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingDeg_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingDeg_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor HeadingDeg_encode_xer$descriptor() {
        return HeadingDeg_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle HeadingDeg_encode_xer$handle() {
        return HeadingDeg_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HeadingDeg_encode_xer$address() {
        return HeadingDeg_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HeadingDeg_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = HeadingDeg_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingDeg_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingDeg_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingDeg_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor HeadingDeg_encode_jer$descriptor() {
        return HeadingDeg_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle HeadingDeg_encode_jer$handle() {
        return HeadingDeg_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HeadingDeg_encode_jer$address() {
        return HeadingDeg_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HeadingDeg_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = HeadingDeg_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingDeg_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingDeg_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingDeg_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingDeg_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor HeadingDeg_decode_oer$descriptor() {
        return HeadingDeg_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingDeg_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle HeadingDeg_decode_oer$handle() {
        return HeadingDeg_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingDeg_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment HeadingDeg_decode_oer$address() {
        return HeadingDeg_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingDeg_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment HeadingDeg_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = HeadingDeg_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingDeg_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingDeg_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingDeg_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor HeadingDeg_encode_oer$descriptor() {
        return HeadingDeg_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle HeadingDeg_encode_oer$handle() {
        return HeadingDeg_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HeadingDeg_encode_oer$address() {
        return HeadingDeg_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HeadingDeg_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = HeadingDeg_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingDeg_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingDeg_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingDeg_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingDeg_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor HeadingDeg_decode_uper$descriptor() {
        return HeadingDeg_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingDeg_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle HeadingDeg_decode_uper$handle() {
        return HeadingDeg_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingDeg_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment HeadingDeg_decode_uper$address() {
        return HeadingDeg_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingDeg_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment HeadingDeg_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = HeadingDeg_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingDeg_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingDeg_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingDeg_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor HeadingDeg_encode_uper$descriptor() {
        return HeadingDeg_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle HeadingDeg_encode_uper$handle() {
        return HeadingDeg_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment HeadingDeg_encode_uper$address() {
        return HeadingDeg_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment HeadingDeg_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = HeadingDeg_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingDeg_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingDeg_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingDeg_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingDeg_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor HeadingDeg_decode_aper$descriptor() {
        return HeadingDeg_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingDeg_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle HeadingDeg_decode_aper$handle() {
        return HeadingDeg_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingDeg_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment HeadingDeg_decode_aper$address() {
        return HeadingDeg_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingDeg_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment HeadingDeg_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = HeadingDeg_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingDeg_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingDeg_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingDeg_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor HeadingDeg_encode_aper$descriptor() {
        return HeadingDeg_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle HeadingDeg_encode_aper$handle() {
        return HeadingDeg_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment HeadingDeg_encode_aper$address() {
        return HeadingDeg_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingDeg_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment HeadingDeg_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = HeadingDeg_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingDeg_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long Tolerance_t
     * }
     */
    public static final OfLong Tolerance_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_Tolerance_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_Tolerance_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Tolerance_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_Tolerance_constr_1$layout() {
        return asn_PER_type_Tolerance_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Tolerance_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_Tolerance_constr_1() {
        return asn_PER_type_Tolerance_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Tolerance_constr_1
     * }
     */
    public static void asn_PER_type_Tolerance_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_Tolerance_constr_1$constants.SEGMENT, 0L, asn_PER_type_Tolerance_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_Tolerance$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_Tolerance").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Tolerance
     * }
     */
    public static GroupLayout asn_DEF_Tolerance$layout() {
        return asn_DEF_Tolerance$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Tolerance
     * }
     */
    public static MemorySegment asn_DEF_Tolerance() {
        return asn_DEF_Tolerance$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Tolerance
     * }
     */
    public static void asn_DEF_Tolerance(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_Tolerance$constants.SEGMENT, 0L, asn_DEF_Tolerance$constants.LAYOUT.byteSize());
    }

    private static class Tolerance_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Tolerance_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Tolerance_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor Tolerance_free$descriptor() {
        return Tolerance_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Tolerance_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle Tolerance_free$handle() {
        return Tolerance_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Tolerance_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment Tolerance_free$address() {
        return Tolerance_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Tolerance_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void Tolerance_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = Tolerance_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Tolerance_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Tolerance_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Tolerance_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Tolerance_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Tolerance_print$descriptor() {
        return Tolerance_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Tolerance_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Tolerance_print$handle() {
        return Tolerance_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Tolerance_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Tolerance_print$address() {
        return Tolerance_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Tolerance_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int Tolerance_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Tolerance_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Tolerance_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Tolerance_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Tolerance_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Tolerance_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor Tolerance_constraint$descriptor() {
        return Tolerance_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Tolerance_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle Tolerance_constraint$handle() {
        return Tolerance_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Tolerance_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment Tolerance_constraint$address() {
        return Tolerance_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Tolerance_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int Tolerance_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Tolerance_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Tolerance_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Tolerance_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Tolerance_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Tolerance_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor Tolerance_decode_ber$descriptor() {
        return Tolerance_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Tolerance_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle Tolerance_decode_ber$handle() {
        return Tolerance_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Tolerance_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Tolerance_decode_ber$address() {
        return Tolerance_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Tolerance_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Tolerance_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = Tolerance_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Tolerance_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Tolerance_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Tolerance_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Tolerance_encode_der$descriptor() {
        return Tolerance_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Tolerance_encode_der$handle() {
        return Tolerance_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Tolerance_encode_der$address() {
        return Tolerance_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Tolerance_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Tolerance_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Tolerance_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Tolerance_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Tolerance_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Tolerance_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Tolerance_decode_xer$descriptor() {
        return Tolerance_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Tolerance_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle Tolerance_decode_xer$handle() {
        return Tolerance_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Tolerance_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Tolerance_decode_xer$address() {
        return Tolerance_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Tolerance_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Tolerance_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Tolerance_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Tolerance_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Tolerance_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Tolerance_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Tolerance_encode_xer$descriptor() {
        return Tolerance_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Tolerance_encode_xer$handle() {
        return Tolerance_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Tolerance_encode_xer$address() {
        return Tolerance_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Tolerance_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Tolerance_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Tolerance_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Tolerance_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Tolerance_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Tolerance_encode_jer$descriptor() {
        return Tolerance_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Tolerance_encode_jer$handle() {
        return Tolerance_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Tolerance_encode_jer$address() {
        return Tolerance_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Tolerance_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = Tolerance_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Tolerance_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Tolerance_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Tolerance_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Tolerance_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Tolerance_decode_oer$descriptor() {
        return Tolerance_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Tolerance_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle Tolerance_decode_oer$handle() {
        return Tolerance_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Tolerance_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Tolerance_decode_oer$address() {
        return Tolerance_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Tolerance_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Tolerance_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Tolerance_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Tolerance_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Tolerance_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Tolerance_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Tolerance_encode_oer$descriptor() {
        return Tolerance_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Tolerance_encode_oer$handle() {
        return Tolerance_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Tolerance_encode_oer$address() {
        return Tolerance_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Tolerance_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Tolerance_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Tolerance_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Tolerance_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Tolerance_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Tolerance_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Tolerance_decode_uper$descriptor() {
        return Tolerance_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Tolerance_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Tolerance_decode_uper$handle() {
        return Tolerance_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Tolerance_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Tolerance_decode_uper$address() {
        return Tolerance_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Tolerance_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Tolerance_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Tolerance_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Tolerance_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Tolerance_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Tolerance_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Tolerance_encode_uper$descriptor() {
        return Tolerance_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Tolerance_encode_uper$handle() {
        return Tolerance_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Tolerance_encode_uper$address() {
        return Tolerance_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Tolerance_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Tolerance_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Tolerance_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Tolerance_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Tolerance_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Tolerance_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Tolerance_decode_aper$descriptor() {
        return Tolerance_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Tolerance_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Tolerance_decode_aper$handle() {
        return Tolerance_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Tolerance_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Tolerance_decode_aper$address() {
        return Tolerance_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Tolerance_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Tolerance_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Tolerance_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Tolerance_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Tolerance_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Tolerance_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Tolerance_encode_aper$descriptor() {
        return Tolerance_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Tolerance_encode_aper$handle() {
        return Tolerance_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Tolerance_encode_aper$address() {
        return Tolerance_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Tolerance_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Tolerance_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Tolerance_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Tolerance_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_ApplicableHeading$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_ApplicableHeading").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ApplicableHeading
     * }
     */
    public static GroupLayout asn_DEF_ApplicableHeading$layout() {
        return asn_DEF_ApplicableHeading$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ApplicableHeading
     * }
     */
    public static MemorySegment asn_DEF_ApplicableHeading() {
        return asn_DEF_ApplicableHeading$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ApplicableHeading
     * }
     */
    public static void asn_DEF_ApplicableHeading(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_ApplicableHeading$constants.SEGMENT, 0L, asn_DEF_ApplicableHeading$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_ApplicableHeading_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_ApplicableHeading_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_ApplicableHeading_specs_1
     * }
     */
    public static GroupLayout asn_SPC_ApplicableHeading_specs_1$layout() {
        return asn_SPC_ApplicableHeading_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_ApplicableHeading_specs_1
     * }
     */
    public static MemorySegment asn_SPC_ApplicableHeading_specs_1() {
        return asn_SPC_ApplicableHeading_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_ApplicableHeading_specs_1
     * }
     */
    public static void asn_SPC_ApplicableHeading_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_ApplicableHeading_specs_1$constants.SEGMENT, 0L, asn_SPC_ApplicableHeading_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_ApplicableHeading_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_ApplicableHeading_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ApplicableHeading_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_ApplicableHeading_1$layout() {
        return asn_MBR_ApplicableHeading_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ApplicableHeading_1[2]
     * }
     */
    public static long[] asn_MBR_ApplicableHeading_1$dimensions() {
        return asn_MBR_ApplicableHeading_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ApplicableHeading_1[2]
     * }
     */
    public static MemorySegment asn_MBR_ApplicableHeading_1() {
        return asn_MBR_ApplicableHeading_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ApplicableHeading_1[2]
     * }
     */
    public static void asn_MBR_ApplicableHeading_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_ApplicableHeading_1$constants.SEGMENT, 0L, asn_MBR_ApplicableHeading_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ApplicableHeading_1[2]
     * }
     */
    public static MemorySegment asn_MBR_ApplicableHeading_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_ApplicableHeading_1$constants.HANDLE.invokeExact(asn_MBR_ApplicableHeading_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ApplicableHeading_1[2]
     * }
     */
    public static void asn_MBR_ApplicableHeading_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_ApplicableHeading_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_RSMPolygon$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_RSMPolygon").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RSMPolygon
     * }
     */
    public static GroupLayout asn_DEF_RSMPolygon$layout() {
        return asn_DEF_RSMPolygon$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RSMPolygon
     * }
     */
    public static MemorySegment asn_DEF_RSMPolygon() {
        return asn_DEF_RSMPolygon$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RSMPolygon
     * }
     */
    public static void asn_DEF_RSMPolygon(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_RSMPolygon$constants.SEGMENT, 0L, asn_DEF_RSMPolygon$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_RSMPolygon_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SET_OF_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_RSMPolygon_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_RSMPolygon_specs_1
     * }
     */
    public static GroupLayout asn_SPC_RSMPolygon_specs_1$layout() {
        return asn_SPC_RSMPolygon_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_RSMPolygon_specs_1
     * }
     */
    public static MemorySegment asn_SPC_RSMPolygon_specs_1() {
        return asn_SPC_RSMPolygon_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_RSMPolygon_specs_1
     * }
     */
    public static void asn_SPC_RSMPolygon_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_RSMPolygon_specs_1$constants.SEGMENT, 0L, asn_SPC_RSMPolygon_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_RSMPolygon_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(1, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_RSMPolygon_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 1 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RSMPolygon_1[1]
     * }
     */
    public static SequenceLayout asn_MBR_RSMPolygon_1$layout() {
        return asn_MBR_RSMPolygon_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RSMPolygon_1[1]
     * }
     */
    public static long[] asn_MBR_RSMPolygon_1$dimensions() {
        return asn_MBR_RSMPolygon_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RSMPolygon_1[1]
     * }
     */
    public static MemorySegment asn_MBR_RSMPolygon_1() {
        return asn_MBR_RSMPolygon_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RSMPolygon_1[1]
     * }
     */
    public static void asn_MBR_RSMPolygon_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RSMPolygon_1$constants.SEGMENT, 0L, asn_MBR_RSMPolygon_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RSMPolygon_1[1]
     * }
     */
    public static MemorySegment asn_MBR_RSMPolygon_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_RSMPolygon_1$constants.HANDLE.invokeExact(asn_MBR_RSMPolygon_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RSMPolygon_1[1]
     * }
     */
    public static void asn_MBR_RSMPolygon_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RSMPolygon_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_RSMPolygon_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_RSMPolygon_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RSMPolygon_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_RSMPolygon_constr_1$layout() {
        return asn_PER_type_RSMPolygon_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RSMPolygon_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_RSMPolygon_constr_1() {
        return asn_PER_type_RSMPolygon_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RSMPolygon_constr_1
     * }
     */
    public static void asn_PER_type_RSMPolygon_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_RSMPolygon_constr_1$constants.SEGMENT, 0L, asn_PER_type_RSMPolygon_constr_1$constants.LAYOUT.byteSize());
    }
    private static final int NodePointLLE_PR_NOTHING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum NodePointLLE_PR.NodePointLLE_PR_NOTHING = 0
     * }
     */
    public static int NodePointLLE_PR_NOTHING() {
        return NodePointLLE_PR_NOTHING;
    }
    private static final int NodePointLLE_PR_node_3Dabsolute = (int)1L;
    /**
     * {@snippet lang=c :
     * enum NodePointLLE_PR.NodePointLLE_PR_node_3Dabsolute = 1
     * }
     */
    public static int NodePointLLE_PR_node_3Dabsolute() {
        return NodePointLLE_PR_node_3Dabsolute;
    }
    private static final int NodePointLLE_PR_node_3Doffset = (int)2L;
    /**
     * {@snippet lang=c :
     * enum NodePointLLE_PR.NodePointLLE_PR_node_3Doffset = 2
     * }
     */
    public static int NodePointLLE_PR_node_3Doffset() {
        return NodePointLLE_PR_node_3Doffset;
    }

    private static class asn_DEF_NodePointLLE$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_NodePointLLE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NodePointLLE
     * }
     */
    public static GroupLayout asn_DEF_NodePointLLE$layout() {
        return asn_DEF_NodePointLLE$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NodePointLLE
     * }
     */
    public static MemorySegment asn_DEF_NodePointLLE() {
        return asn_DEF_NodePointLLE$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NodePointLLE
     * }
     */
    public static void asn_DEF_NodePointLLE(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_NodePointLLE$constants.SEGMENT, 0L, asn_DEF_NodePointLLE$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_NodePointLLE_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_CHOICE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_NodePointLLE_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_NodePointLLE_specs_1
     * }
     */
    public static GroupLayout asn_SPC_NodePointLLE_specs_1$layout() {
        return asn_SPC_NodePointLLE_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_NodePointLLE_specs_1
     * }
     */
    public static MemorySegment asn_SPC_NodePointLLE_specs_1() {
        return asn_SPC_NodePointLLE_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_NodePointLLE_specs_1
     * }
     */
    public static void asn_SPC_NodePointLLE_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_NodePointLLE_specs_1$constants.SEGMENT, 0L, asn_SPC_NodePointLLE_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_NodePointLLE_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_NodePointLLE_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodePointLLE_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_NodePointLLE_1$layout() {
        return asn_MBR_NodePointLLE_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodePointLLE_1[2]
     * }
     */
    public static long[] asn_MBR_NodePointLLE_1$dimensions() {
        return asn_MBR_NodePointLLE_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodePointLLE_1[2]
     * }
     */
    public static MemorySegment asn_MBR_NodePointLLE_1() {
        return asn_MBR_NodePointLLE_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodePointLLE_1[2]
     * }
     */
    public static void asn_MBR_NodePointLLE_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_NodePointLLE_1$constants.SEGMENT, 0L, asn_MBR_NodePointLLE_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodePointLLE_1[2]
     * }
     */
    public static MemorySegment asn_MBR_NodePointLLE_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_NodePointLLE_1$constants.HANDLE.invokeExact(asn_MBR_NodePointLLE_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NodePointLLE_1[2]
     * }
     */
    public static void asn_MBR_NodePointLLE_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_NodePointLLE_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_NodePointLLE_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_NodePointLLE_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NodePointLLE_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_NodePointLLE_constr_1$layout() {
        return asn_PER_type_NodePointLLE_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NodePointLLE_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_NodePointLLE_constr_1() {
        return asn_PER_type_NodePointLLE_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NodePointLLE_constr_1
     * }
     */
    public static void asn_PER_type_NodePointLLE_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_NodePointLLE_constr_1$constants.SEGMENT, 0L, asn_PER_type_NodePointLLE_constr_1$constants.LAYOUT.byteSize());
    }
    private static final int BroadRegionArea_PR_NOTHING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum BroadRegionArea_PR.BroadRegionArea_PR_NOTHING = 0
     * }
     */
    public static int BroadRegionArea_PR_NOTHING() {
        return BroadRegionArea_PR_NOTHING;
    }
    private static final int BroadRegionArea_PR_polygon = (int)1L;
    /**
     * {@snippet lang=c :
     * enum BroadRegionArea_PR.BroadRegionArea_PR_polygon = 1
     * }
     */
    public static int BroadRegionArea_PR_polygon() {
        return BroadRegionArea_PR_polygon;
    }
    private static final int BroadRegionArea_PR_circle = (int)2L;
    /**
     * {@snippet lang=c :
     * enum BroadRegionArea_PR.BroadRegionArea_PR_circle = 2
     * }
     */
    public static int BroadRegionArea_PR_circle() {
        return BroadRegionArea_PR_circle;
    }

    private static class asn_DEF_BroadRegionArea$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_BroadRegionArea").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BroadRegionArea
     * }
     */
    public static GroupLayout asn_DEF_BroadRegionArea$layout() {
        return asn_DEF_BroadRegionArea$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BroadRegionArea
     * }
     */
    public static MemorySegment asn_DEF_BroadRegionArea() {
        return asn_DEF_BroadRegionArea$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BroadRegionArea
     * }
     */
    public static void asn_DEF_BroadRegionArea(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_BroadRegionArea$constants.SEGMENT, 0L, asn_DEF_BroadRegionArea$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_BroadRegionArea_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_CHOICE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_BroadRegionArea_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_BroadRegionArea_specs_1
     * }
     */
    public static GroupLayout asn_SPC_BroadRegionArea_specs_1$layout() {
        return asn_SPC_BroadRegionArea_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_BroadRegionArea_specs_1
     * }
     */
    public static MemorySegment asn_SPC_BroadRegionArea_specs_1() {
        return asn_SPC_BroadRegionArea_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_BroadRegionArea_specs_1
     * }
     */
    public static void asn_SPC_BroadRegionArea_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_BroadRegionArea_specs_1$constants.SEGMENT, 0L, asn_SPC_BroadRegionArea_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_BroadRegionArea_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_BroadRegionArea_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BroadRegionArea_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_BroadRegionArea_1$layout() {
        return asn_MBR_BroadRegionArea_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BroadRegionArea_1[2]
     * }
     */
    public static long[] asn_MBR_BroadRegionArea_1$dimensions() {
        return asn_MBR_BroadRegionArea_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BroadRegionArea_1[2]
     * }
     */
    public static MemorySegment asn_MBR_BroadRegionArea_1() {
        return asn_MBR_BroadRegionArea_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BroadRegionArea_1[2]
     * }
     */
    public static void asn_MBR_BroadRegionArea_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_BroadRegionArea_1$constants.SEGMENT, 0L, asn_MBR_BroadRegionArea_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BroadRegionArea_1[2]
     * }
     */
    public static MemorySegment asn_MBR_BroadRegionArea_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_BroadRegionArea_1$constants.HANDLE.invokeExact(asn_MBR_BroadRegionArea_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BroadRegionArea_1[2]
     * }
     */
    public static void asn_MBR_BroadRegionArea_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_BroadRegionArea_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_BroadRegionArea_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_BroadRegionArea_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_BroadRegionArea_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_BroadRegionArea_constr_1$layout() {
        return asn_PER_type_BroadRegionArea_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_BroadRegionArea_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_BroadRegionArea_constr_1() {
        return asn_PER_type_BroadRegionArea_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_BroadRegionArea_constr_1
     * }
     */
    public static void asn_PER_type_BroadRegionArea_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_BroadRegionArea_constr_1$constants.SEGMENT, 0L, asn_PER_type_BroadRegionArea_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_BroadRegion$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_BroadRegion").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BroadRegion
     * }
     */
    public static GroupLayout asn_DEF_BroadRegion$layout() {
        return asn_DEF_BroadRegion$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BroadRegion
     * }
     */
    public static MemorySegment asn_DEF_BroadRegion() {
        return asn_DEF_BroadRegion$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BroadRegion
     * }
     */
    public static void asn_DEF_BroadRegion(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_BroadRegion$constants.SEGMENT, 0L, asn_DEF_BroadRegion$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_BroadRegion_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_BroadRegion_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_BroadRegion_specs_1
     * }
     */
    public static GroupLayout asn_SPC_BroadRegion_specs_1$layout() {
        return asn_SPC_BroadRegion_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_BroadRegion_specs_1
     * }
     */
    public static MemorySegment asn_SPC_BroadRegion_specs_1() {
        return asn_SPC_BroadRegion_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_BroadRegion_specs_1
     * }
     */
    public static void asn_SPC_BroadRegion_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_BroadRegion_specs_1$constants.SEGMENT, 0L, asn_SPC_BroadRegion_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_BroadRegion_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_BroadRegion_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BroadRegion_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_BroadRegion_1$layout() {
        return asn_MBR_BroadRegion_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BroadRegion_1[2]
     * }
     */
    public static long[] asn_MBR_BroadRegion_1$dimensions() {
        return asn_MBR_BroadRegion_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BroadRegion_1[2]
     * }
     */
    public static MemorySegment asn_MBR_BroadRegion_1() {
        return asn_MBR_BroadRegion_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BroadRegion_1[2]
     * }
     */
    public static void asn_MBR_BroadRegion_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_BroadRegion_1$constants.SEGMENT, 0L, asn_MBR_BroadRegion_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BroadRegion_1[2]
     * }
     */
    public static MemorySegment asn_MBR_BroadRegion_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_BroadRegion_1$constants.HANDLE.invokeExact(asn_MBR_BroadRegion_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BroadRegion_1[2]
     * }
     */
    public static void asn_MBR_BroadRegion_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_BroadRegion_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_PathList$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_PathList").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PathList
     * }
     */
    public static GroupLayout asn_DEF_PathList$layout() {
        return asn_DEF_PathList$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PathList
     * }
     */
    public static MemorySegment asn_DEF_PathList() {
        return asn_DEF_PathList$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PathList
     * }
     */
    public static void asn_DEF_PathList(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_PathList$constants.SEGMENT, 0L, asn_DEF_PathList$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_PathList_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SET_OF_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_PathList_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_PathList_specs_1
     * }
     */
    public static GroupLayout asn_SPC_PathList_specs_1$layout() {
        return asn_SPC_PathList_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_PathList_specs_1
     * }
     */
    public static MemorySegment asn_SPC_PathList_specs_1() {
        return asn_SPC_PathList_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_PathList_specs_1
     * }
     */
    public static void asn_SPC_PathList_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_PathList_specs_1$constants.SEGMENT, 0L, asn_SPC_PathList_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_PathList_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(1, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_PathList_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 1 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathList_1[1]
     * }
     */
    public static SequenceLayout asn_MBR_PathList_1$layout() {
        return asn_MBR_PathList_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathList_1[1]
     * }
     */
    public static long[] asn_MBR_PathList_1$dimensions() {
        return asn_MBR_PathList_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_PathList_1() {
        return asn_MBR_PathList_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathList_1[1]
     * }
     */
    public static void asn_MBR_PathList_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_PathList_1$constants.SEGMENT, 0L, asn_MBR_PathList_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_PathList_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_PathList_1$constants.HANDLE.invokeExact(asn_MBR_PathList_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathList_1[1]
     * }
     */
    public static void asn_MBR_PathList_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_PathList_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_PathList_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_PathList_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PathList_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_PathList_constr_1$layout() {
        return asn_PER_type_PathList_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PathList_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_PathList_constr_1() {
        return asn_PER_type_PathList_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PathList_constr_1
     * }
     */
    public static void asn_PER_type_PathList_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_PathList_constr_1$constants.SEGMENT, 0L, asn_PER_type_PathList_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_PathPoints$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_PathPoints").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PathPoints
     * }
     */
    public static GroupLayout asn_DEF_PathPoints$layout() {
        return asn_DEF_PathPoints$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PathPoints
     * }
     */
    public static MemorySegment asn_DEF_PathPoints() {
        return asn_DEF_PathPoints$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PathPoints
     * }
     */
    public static void asn_DEF_PathPoints(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_PathPoints$constants.SEGMENT, 0L, asn_DEF_PathPoints$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_PathPoints_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SET_OF_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_PathPoints_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_PathPoints_specs_1
     * }
     */
    public static GroupLayout asn_SPC_PathPoints_specs_1$layout() {
        return asn_SPC_PathPoints_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_PathPoints_specs_1
     * }
     */
    public static MemorySegment asn_SPC_PathPoints_specs_1() {
        return asn_SPC_PathPoints_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_PathPoints_specs_1
     * }
     */
    public static void asn_SPC_PathPoints_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_PathPoints_specs_1$constants.SEGMENT, 0L, asn_SPC_PathPoints_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_PathPoints_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(1, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_PathPoints_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 1 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathPoints_1[1]
     * }
     */
    public static SequenceLayout asn_MBR_PathPoints_1$layout() {
        return asn_MBR_PathPoints_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathPoints_1[1]
     * }
     */
    public static long[] asn_MBR_PathPoints_1$dimensions() {
        return asn_MBR_PathPoints_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathPoints_1[1]
     * }
     */
    public static MemorySegment asn_MBR_PathPoints_1() {
        return asn_MBR_PathPoints_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathPoints_1[1]
     * }
     */
    public static void asn_MBR_PathPoints_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_PathPoints_1$constants.SEGMENT, 0L, asn_MBR_PathPoints_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathPoints_1[1]
     * }
     */
    public static MemorySegment asn_MBR_PathPoints_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_PathPoints_1$constants.HANDLE.invokeExact(asn_MBR_PathPoints_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathPoints_1[1]
     * }
     */
    public static void asn_MBR_PathPoints_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_PathPoints_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_PathPoints_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_PathPoints_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PathPoints_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_PathPoints_constr_1$layout() {
        return asn_PER_type_PathPoints_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PathPoints_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_PathPoints_constr_1() {
        return asn_PER_type_PathPoints_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PathPoints_constr_1
     * }
     */
    public static void asn_PER_type_PathPoints_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_PathPoints_constr_1$constants.SEGMENT, 0L, asn_PER_type_PathPoints_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_Path$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_Path").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Path
     * }
     */
    public static GroupLayout asn_DEF_Path$layout() {
        return asn_DEF_Path$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Path
     * }
     */
    public static MemorySegment asn_DEF_Path() {
        return asn_DEF_Path$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Path
     * }
     */
    public static void asn_DEF_Path(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_Path$constants.SEGMENT, 0L, asn_DEF_Path$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_Path_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_Path_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Path_specs_1
     * }
     */
    public static GroupLayout asn_SPC_Path_specs_1$layout() {
        return asn_SPC_Path_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Path_specs_1
     * }
     */
    public static MemorySegment asn_SPC_Path_specs_1() {
        return asn_SPC_Path_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Path_specs_1
     * }
     */
    public static void asn_SPC_Path_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_Path_specs_1$constants.SEGMENT, 0L, asn_SPC_Path_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_Path_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_Path_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Path_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_Path_1$layout() {
        return asn_MBR_Path_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Path_1[2]
     * }
     */
    public static long[] asn_MBR_Path_1$dimensions() {
        return asn_MBR_Path_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Path_1[2]
     * }
     */
    public static MemorySegment asn_MBR_Path_1() {
        return asn_MBR_Path_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Path_1[2]
     * }
     */
    public static void asn_MBR_Path_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_Path_1$constants.SEGMENT, 0L, asn_MBR_Path_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Path_1[2]
     * }
     */
    public static MemorySegment asn_MBR_Path_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_Path_1$constants.HANDLE.invokeExact(asn_MBR_Path_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Path_1[2]
     * }
     */
    public static void asn_MBR_Path_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_Path_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    private static final int AreaType_PR_NOTHING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AreaType_PR.AreaType_PR_NOTHING = 0
     * }
     */
    public static int AreaType_PR_NOTHING() {
        return AreaType_PR_NOTHING;
    }
    private static final int AreaType_PR_broadRegion = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AreaType_PR.AreaType_PR_broadRegion = 1
     * }
     */
    public static int AreaType_PR_broadRegion() {
        return AreaType_PR_broadRegion;
    }
    private static final int AreaType_PR_paths = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AreaType_PR.AreaType_PR_paths = 2
     * }
     */
    public static int AreaType_PR_paths() {
        return AreaType_PR_paths;
    }

    private static class asn_DEF_AreaType$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_AreaType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AreaType
     * }
     */
    public static GroupLayout asn_DEF_AreaType$layout() {
        return asn_DEF_AreaType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AreaType
     * }
     */
    public static MemorySegment asn_DEF_AreaType() {
        return asn_DEF_AreaType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AreaType
     * }
     */
    public static void asn_DEF_AreaType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_AreaType$constants.SEGMENT, 0L, asn_DEF_AreaType$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_AreaType_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_CHOICE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_AreaType_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_AreaType_specs_1
     * }
     */
    public static GroupLayout asn_SPC_AreaType_specs_1$layout() {
        return asn_SPC_AreaType_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_AreaType_specs_1
     * }
     */
    public static MemorySegment asn_SPC_AreaType_specs_1() {
        return asn_SPC_AreaType_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_AreaType_specs_1
     * }
     */
    public static void asn_SPC_AreaType_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_AreaType_specs_1$constants.SEGMENT, 0L, asn_SPC_AreaType_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_AreaType_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_AreaType_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AreaType_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_AreaType_1$layout() {
        return asn_MBR_AreaType_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AreaType_1[2]
     * }
     */
    public static long[] asn_MBR_AreaType_1$dimensions() {
        return asn_MBR_AreaType_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AreaType_1[2]
     * }
     */
    public static MemorySegment asn_MBR_AreaType_1() {
        return asn_MBR_AreaType_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AreaType_1[2]
     * }
     */
    public static void asn_MBR_AreaType_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_AreaType_1$constants.SEGMENT, 0L, asn_MBR_AreaType_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AreaType_1[2]
     * }
     */
    public static MemorySegment asn_MBR_AreaType_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_AreaType_1$constants.HANDLE.invokeExact(asn_MBR_AreaType_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AreaType_1[2]
     * }
     */
    public static void asn_MBR_AreaType_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_AreaType_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_AreaType_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_AreaType_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AreaType_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_AreaType_constr_1$layout() {
        return asn_PER_type_AreaType_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AreaType_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_AreaType_constr_1() {
        return asn_PER_type_AreaType_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AreaType_constr_1
     * }
     */
    public static void asn_PER_type_AreaType_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_AreaType_constr_1$constants.SEGMENT, 0L, asn_PER_type_AreaType_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_RoadSafetyMessage$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_RoadSafetyMessage").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadSafetyMessage
     * }
     */
    public static GroupLayout asn_DEF_RoadSafetyMessage$layout() {
        return asn_DEF_RoadSafetyMessage$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadSafetyMessage
     * }
     */
    public static MemorySegment asn_DEF_RoadSafetyMessage() {
        return asn_DEF_RoadSafetyMessage$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadSafetyMessage
     * }
     */
    public static void asn_DEF_RoadSafetyMessage(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_RoadSafetyMessage$constants.SEGMENT, 0L, asn_DEF_RoadSafetyMessage$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_RoadSafetyMessage_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_RoadSafetyMessage_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RoadSafetyMessage_specs_1
     * }
     */
    public static GroupLayout asn_SPC_RoadSafetyMessage_specs_1$layout() {
        return asn_SPC_RoadSafetyMessage_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RoadSafetyMessage_specs_1
     * }
     */
    public static MemorySegment asn_SPC_RoadSafetyMessage_specs_1() {
        return asn_SPC_RoadSafetyMessage_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RoadSafetyMessage_specs_1
     * }
     */
    public static void asn_SPC_RoadSafetyMessage_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_RoadSafetyMessage_specs_1$constants.SEGMENT, 0L, asn_SPC_RoadSafetyMessage_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_RoadSafetyMessage_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_RoadSafetyMessage_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSafetyMessage_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_RoadSafetyMessage_1$layout() {
        return asn_MBR_RoadSafetyMessage_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSafetyMessage_1[2]
     * }
     */
    public static long[] asn_MBR_RoadSafetyMessage_1$dimensions() {
        return asn_MBR_RoadSafetyMessage_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSafetyMessage_1[2]
     * }
     */
    public static MemorySegment asn_MBR_RoadSafetyMessage_1() {
        return asn_MBR_RoadSafetyMessage_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSafetyMessage_1[2]
     * }
     */
    public static void asn_MBR_RoadSafetyMessage_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RoadSafetyMessage_1$constants.SEGMENT, 0L, asn_MBR_RoadSafetyMessage_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSafetyMessage_1[2]
     * }
     */
    public static MemorySegment asn_MBR_RoadSafetyMessage_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_RoadSafetyMessage_1$constants.HANDLE.invokeExact(asn_MBR_RoadSafetyMessage_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSafetyMessage_1[2]
     * }
     */
    public static void asn_MBR_RoadSafetyMessage_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RoadSafetyMessage_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_ReducedSpeedZoneContainer$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_ReducedSpeedZoneContainer").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ReducedSpeedZoneContainer
     * }
     */
    public static GroupLayout asn_DEF_ReducedSpeedZoneContainer$layout() {
        return asn_DEF_ReducedSpeedZoneContainer$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ReducedSpeedZoneContainer
     * }
     */
    public static MemorySegment asn_DEF_ReducedSpeedZoneContainer() {
        return asn_DEF_ReducedSpeedZoneContainer$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ReducedSpeedZoneContainer
     * }
     */
    public static void asn_DEF_ReducedSpeedZoneContainer(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_ReducedSpeedZoneContainer$constants.SEGMENT, 0L, asn_DEF_ReducedSpeedZoneContainer$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_ReducedSpeedZoneContainer_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_ReducedSpeedZoneContainer_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_ReducedSpeedZoneContainer_specs_1
     * }
     */
    public static GroupLayout asn_SPC_ReducedSpeedZoneContainer_specs_1$layout() {
        return asn_SPC_ReducedSpeedZoneContainer_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_ReducedSpeedZoneContainer_specs_1
     * }
     */
    public static MemorySegment asn_SPC_ReducedSpeedZoneContainer_specs_1() {
        return asn_SPC_ReducedSpeedZoneContainer_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_ReducedSpeedZoneContainer_specs_1
     * }
     */
    public static void asn_SPC_ReducedSpeedZoneContainer_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_ReducedSpeedZoneContainer_specs_1$constants.SEGMENT, 0L, asn_SPC_ReducedSpeedZoneContainer_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_ReducedSpeedZoneContainer_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_ReducedSpeedZoneContainer_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ReducedSpeedZoneContainer_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_ReducedSpeedZoneContainer_1$layout() {
        return asn_MBR_ReducedSpeedZoneContainer_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ReducedSpeedZoneContainer_1[2]
     * }
     */
    public static long[] asn_MBR_ReducedSpeedZoneContainer_1$dimensions() {
        return asn_MBR_ReducedSpeedZoneContainer_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ReducedSpeedZoneContainer_1[2]
     * }
     */
    public static MemorySegment asn_MBR_ReducedSpeedZoneContainer_1() {
        return asn_MBR_ReducedSpeedZoneContainer_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ReducedSpeedZoneContainer_1[2]
     * }
     */
    public static void asn_MBR_ReducedSpeedZoneContainer_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_ReducedSpeedZoneContainer_1$constants.SEGMENT, 0L, asn_MBR_ReducedSpeedZoneContainer_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ReducedSpeedZoneContainer_1[2]
     * }
     */
    public static MemorySegment asn_MBR_ReducedSpeedZoneContainer_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_ReducedSpeedZoneContainer_1$constants.HANDLE.invokeExact(asn_MBR_ReducedSpeedZoneContainer_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ReducedSpeedZoneContainer_1[2]
     * }
     */
    public static void asn_MBR_ReducedSpeedZoneContainer_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_ReducedSpeedZoneContainer_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_LaneClosureContainer$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_LaneClosureContainer").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_LaneClosureContainer
     * }
     */
    public static GroupLayout asn_DEF_LaneClosureContainer$layout() {
        return asn_DEF_LaneClosureContainer$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_LaneClosureContainer
     * }
     */
    public static MemorySegment asn_DEF_LaneClosureContainer() {
        return asn_DEF_LaneClosureContainer$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_LaneClosureContainer
     * }
     */
    public static void asn_DEF_LaneClosureContainer(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_LaneClosureContainer$constants.SEGMENT, 0L, asn_DEF_LaneClosureContainer$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_LaneClosureContainer_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_LaneClosureContainer_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_LaneClosureContainer_specs_1
     * }
     */
    public static GroupLayout asn_SPC_LaneClosureContainer_specs_1$layout() {
        return asn_SPC_LaneClosureContainer_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_LaneClosureContainer_specs_1
     * }
     */
    public static MemorySegment asn_SPC_LaneClosureContainer_specs_1() {
        return asn_SPC_LaneClosureContainer_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_LaneClosureContainer_specs_1
     * }
     */
    public static void asn_SPC_LaneClosureContainer_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_LaneClosureContainer_specs_1$constants.SEGMENT, 0L, asn_SPC_LaneClosureContainer_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_LaneClosureContainer_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(3, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_LaneClosureContainer_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 3 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_LaneClosureContainer_1[3]
     * }
     */
    public static SequenceLayout asn_MBR_LaneClosureContainer_1$layout() {
        return asn_MBR_LaneClosureContainer_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_LaneClosureContainer_1[3]
     * }
     */
    public static long[] asn_MBR_LaneClosureContainer_1$dimensions() {
        return asn_MBR_LaneClosureContainer_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_LaneClosureContainer_1[3]
     * }
     */
    public static MemorySegment asn_MBR_LaneClosureContainer_1() {
        return asn_MBR_LaneClosureContainer_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_LaneClosureContainer_1[3]
     * }
     */
    public static void asn_MBR_LaneClosureContainer_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_LaneClosureContainer_1$constants.SEGMENT, 0L, asn_MBR_LaneClosureContainer_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_LaneClosureContainer_1[3]
     * }
     */
    public static MemorySegment asn_MBR_LaneClosureContainer_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_LaneClosureContainer_1$constants.HANDLE.invokeExact(asn_MBR_LaneClosureContainer_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_LaneClosureContainer_1[3]
     * }
     */
    public static void asn_MBR_LaneClosureContainer_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_LaneClosureContainer_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef long RSMLanePosition_t
     * }
     */
    public static final OfLong RSMLanePosition_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_RSMLanePosition_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_RSMLanePosition_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RSMLanePosition_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_RSMLanePosition_constr_1$layout() {
        return asn_PER_type_RSMLanePosition_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RSMLanePosition_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_RSMLanePosition_constr_1() {
        return asn_PER_type_RSMLanePosition_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RSMLanePosition_constr_1
     * }
     */
    public static void asn_PER_type_RSMLanePosition_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_RSMLanePosition_constr_1$constants.SEGMENT, 0L, asn_PER_type_RSMLanePosition_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_RSMLanePosition$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_RSMLanePosition").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RSMLanePosition
     * }
     */
    public static GroupLayout asn_DEF_RSMLanePosition$layout() {
        return asn_DEF_RSMLanePosition$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RSMLanePosition
     * }
     */
    public static MemorySegment asn_DEF_RSMLanePosition() {
        return asn_DEF_RSMLanePosition$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RSMLanePosition
     * }
     */
    public static void asn_DEF_RSMLanePosition(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_RSMLanePosition$constants.SEGMENT, 0L, asn_DEF_RSMLanePosition$constants.LAYOUT.byteSize());
    }

    private static class RSMLanePosition_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RSMLanePosition_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RSMLanePosition_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor RSMLanePosition_free$descriptor() {
        return RSMLanePosition_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RSMLanePosition_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle RSMLanePosition_free$handle() {
        return RSMLanePosition_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RSMLanePosition_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment RSMLanePosition_free$address() {
        return RSMLanePosition_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RSMLanePosition_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void RSMLanePosition_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = RSMLanePosition_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RSMLanePosition_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RSMLanePosition_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RSMLanePosition_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int RSMLanePosition_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RSMLanePosition_print$descriptor() {
        return RSMLanePosition_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int RSMLanePosition_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RSMLanePosition_print$handle() {
        return RSMLanePosition_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int RSMLanePosition_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RSMLanePosition_print$address() {
        return RSMLanePosition_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int RSMLanePosition_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int RSMLanePosition_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = RSMLanePosition_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RSMLanePosition_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RSMLanePosition_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RSMLanePosition_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int RSMLanePosition_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor RSMLanePosition_constraint$descriptor() {
        return RSMLanePosition_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int RSMLanePosition_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle RSMLanePosition_constraint$handle() {
        return RSMLanePosition_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int RSMLanePosition_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment RSMLanePosition_constraint$address() {
        return RSMLanePosition_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int RSMLanePosition_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int RSMLanePosition_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = RSMLanePosition_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RSMLanePosition_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RSMLanePosition_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RSMLanePosition_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RSMLanePosition_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor RSMLanePosition_decode_ber$descriptor() {
        return RSMLanePosition_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RSMLanePosition_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle RSMLanePosition_decode_ber$handle() {
        return RSMLanePosition_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RSMLanePosition_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment RSMLanePosition_decode_ber$address() {
        return RSMLanePosition_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RSMLanePosition_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment RSMLanePosition_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = RSMLanePosition_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RSMLanePosition_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RSMLanePosition_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RSMLanePosition_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RSMLanePosition_encode_der$descriptor() {
        return RSMLanePosition_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RSMLanePosition_encode_der$handle() {
        return RSMLanePosition_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RSMLanePosition_encode_der$address() {
        return RSMLanePosition_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RSMLanePosition_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = RSMLanePosition_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RSMLanePosition_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RSMLanePosition_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RSMLanePosition_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RSMLanePosition_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor RSMLanePosition_decode_xer$descriptor() {
        return RSMLanePosition_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RSMLanePosition_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle RSMLanePosition_decode_xer$handle() {
        return RSMLanePosition_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RSMLanePosition_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment RSMLanePosition_decode_xer$address() {
        return RSMLanePosition_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RSMLanePosition_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment RSMLanePosition_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = RSMLanePosition_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RSMLanePosition_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RSMLanePosition_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RSMLanePosition_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RSMLanePosition_encode_xer$descriptor() {
        return RSMLanePosition_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RSMLanePosition_encode_xer$handle() {
        return RSMLanePosition_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RSMLanePosition_encode_xer$address() {
        return RSMLanePosition_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RSMLanePosition_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = RSMLanePosition_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RSMLanePosition_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RSMLanePosition_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RSMLanePosition_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RSMLanePosition_encode_jer$descriptor() {
        return RSMLanePosition_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RSMLanePosition_encode_jer$handle() {
        return RSMLanePosition_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RSMLanePosition_encode_jer$address() {
        return RSMLanePosition_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RSMLanePosition_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = RSMLanePosition_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RSMLanePosition_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RSMLanePosition_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RSMLanePosition_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RSMLanePosition_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor RSMLanePosition_decode_oer$descriptor() {
        return RSMLanePosition_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RSMLanePosition_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle RSMLanePosition_decode_oer$handle() {
        return RSMLanePosition_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RSMLanePosition_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment RSMLanePosition_decode_oer$address() {
        return RSMLanePosition_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RSMLanePosition_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment RSMLanePosition_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = RSMLanePosition_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RSMLanePosition_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RSMLanePosition_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RSMLanePosition_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RSMLanePosition_encode_oer$descriptor() {
        return RSMLanePosition_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RSMLanePosition_encode_oer$handle() {
        return RSMLanePosition_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RSMLanePosition_encode_oer$address() {
        return RSMLanePosition_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RSMLanePosition_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = RSMLanePosition_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RSMLanePosition_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RSMLanePosition_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RSMLanePosition_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RSMLanePosition_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor RSMLanePosition_decode_uper$descriptor() {
        return RSMLanePosition_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RSMLanePosition_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle RSMLanePosition_decode_uper$handle() {
        return RSMLanePosition_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RSMLanePosition_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment RSMLanePosition_decode_uper$address() {
        return RSMLanePosition_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RSMLanePosition_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment RSMLanePosition_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = RSMLanePosition_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RSMLanePosition_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RSMLanePosition_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RSMLanePosition_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor RSMLanePosition_encode_uper$descriptor() {
        return RSMLanePosition_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle RSMLanePosition_encode_uper$handle() {
        return RSMLanePosition_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment RSMLanePosition_encode_uper$address() {
        return RSMLanePosition_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment RSMLanePosition_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = RSMLanePosition_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RSMLanePosition_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RSMLanePosition_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RSMLanePosition_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RSMLanePosition_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor RSMLanePosition_decode_aper$descriptor() {
        return RSMLanePosition_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RSMLanePosition_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle RSMLanePosition_decode_aper$handle() {
        return RSMLanePosition_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RSMLanePosition_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment RSMLanePosition_decode_aper$address() {
        return RSMLanePosition_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RSMLanePosition_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment RSMLanePosition_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = RSMLanePosition_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RSMLanePosition_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RSMLanePosition_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RSMLanePosition_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor RSMLanePosition_encode_aper$descriptor() {
        return RSMLanePosition_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle RSMLanePosition_encode_aper$handle() {
        return RSMLanePosition_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment RSMLanePosition_encode_aper$address() {
        return RSMLanePosition_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RSMLanePosition_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment RSMLanePosition_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = RSMLanePosition_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RSMLanePosition_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef BOOLEAN_t LaneClosed_t
     * }
     */
    public static final OfInt LaneClosed_t = MessageFrame_h.C_INT;

    private static class asn_DEF_LaneClosed$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_LaneClosed").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_LaneClosed
     * }
     */
    public static GroupLayout asn_DEF_LaneClosed$layout() {
        return asn_DEF_LaneClosed$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_LaneClosed
     * }
     */
    public static MemorySegment asn_DEF_LaneClosed() {
        return asn_DEF_LaneClosed$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_LaneClosed
     * }
     */
    public static void asn_DEF_LaneClosed(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_LaneClosed$constants.SEGMENT, 0L, asn_DEF_LaneClosed$constants.LAYOUT.byteSize());
    }

    private static class LaneClosed_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LaneClosed_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void LaneClosed_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor LaneClosed_free$descriptor() {
        return LaneClosed_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void LaneClosed_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle LaneClosed_free$handle() {
        return LaneClosed_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void LaneClosed_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment LaneClosed_free$address() {
        return LaneClosed_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void LaneClosed_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void LaneClosed_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = LaneClosed_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LaneClosed_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LaneClosed_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LaneClosed_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LaneClosed_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor LaneClosed_print$descriptor() {
        return LaneClosed_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LaneClosed_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle LaneClosed_print$handle() {
        return LaneClosed_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LaneClosed_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LaneClosed_print$address() {
        return LaneClosed_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LaneClosed_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int LaneClosed_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = LaneClosed_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LaneClosed_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LaneClosed_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LaneClosed_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int LaneClosed_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor LaneClosed_constraint$descriptor() {
        return LaneClosed_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int LaneClosed_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle LaneClosed_constraint$handle() {
        return LaneClosed_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int LaneClosed_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment LaneClosed_constraint$address() {
        return LaneClosed_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int LaneClosed_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int LaneClosed_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = LaneClosed_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LaneClosed_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LaneClosed_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LaneClosed_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t LaneClosed_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor LaneClosed_decode_ber$descriptor() {
        return LaneClosed_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t LaneClosed_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle LaneClosed_decode_ber$handle() {
        return LaneClosed_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t LaneClosed_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment LaneClosed_decode_ber$address() {
        return LaneClosed_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t LaneClosed_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment LaneClosed_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = LaneClosed_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LaneClosed_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LaneClosed_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LaneClosed_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor LaneClosed_encode_der$descriptor() {
        return LaneClosed_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle LaneClosed_encode_der$handle() {
        return LaneClosed_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LaneClosed_encode_der$address() {
        return LaneClosed_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LaneClosed_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = LaneClosed_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LaneClosed_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LaneClosed_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LaneClosed_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t LaneClosed_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor LaneClosed_decode_xer$descriptor() {
        return LaneClosed_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t LaneClosed_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle LaneClosed_decode_xer$handle() {
        return LaneClosed_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t LaneClosed_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment LaneClosed_decode_xer$address() {
        return LaneClosed_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t LaneClosed_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment LaneClosed_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = LaneClosed_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LaneClosed_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LaneClosed_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LaneClosed_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor LaneClosed_encode_xer$descriptor() {
        return LaneClosed_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle LaneClosed_encode_xer$handle() {
        return LaneClosed_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LaneClosed_encode_xer$address() {
        return LaneClosed_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LaneClosed_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = LaneClosed_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LaneClosed_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LaneClosed_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LaneClosed_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor LaneClosed_encode_jer$descriptor() {
        return LaneClosed_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle LaneClosed_encode_jer$handle() {
        return LaneClosed_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LaneClosed_encode_jer$address() {
        return LaneClosed_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LaneClosed_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = LaneClosed_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LaneClosed_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LaneClosed_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LaneClosed_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t LaneClosed_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor LaneClosed_decode_oer$descriptor() {
        return LaneClosed_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t LaneClosed_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle LaneClosed_decode_oer$handle() {
        return LaneClosed_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t LaneClosed_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment LaneClosed_decode_oer$address() {
        return LaneClosed_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t LaneClosed_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment LaneClosed_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = LaneClosed_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LaneClosed_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LaneClosed_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LaneClosed_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor LaneClosed_encode_oer$descriptor() {
        return LaneClosed_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle LaneClosed_encode_oer$handle() {
        return LaneClosed_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LaneClosed_encode_oer$address() {
        return LaneClosed_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment LaneClosed_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = LaneClosed_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LaneClosed_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LaneClosed_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LaneClosed_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t LaneClosed_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor LaneClosed_decode_uper$descriptor() {
        return LaneClosed_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t LaneClosed_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle LaneClosed_decode_uper$handle() {
        return LaneClosed_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t LaneClosed_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment LaneClosed_decode_uper$address() {
        return LaneClosed_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t LaneClosed_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment LaneClosed_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = LaneClosed_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LaneClosed_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LaneClosed_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LaneClosed_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor LaneClosed_encode_uper$descriptor() {
        return LaneClosed_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle LaneClosed_encode_uper$handle() {
        return LaneClosed_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment LaneClosed_encode_uper$address() {
        return LaneClosed_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment LaneClosed_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = LaneClosed_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LaneClosed_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LaneClosed_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LaneClosed_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t LaneClosed_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor LaneClosed_decode_aper$descriptor() {
        return LaneClosed_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t LaneClosed_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle LaneClosed_decode_aper$handle() {
        return LaneClosed_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t LaneClosed_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment LaneClosed_decode_aper$address() {
        return LaneClosed_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t LaneClosed_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment LaneClosed_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = LaneClosed_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LaneClosed_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class LaneClosed_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("LaneClosed_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor LaneClosed_encode_aper$descriptor() {
        return LaneClosed_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle LaneClosed_encode_aper$handle() {
        return LaneClosed_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment LaneClosed_encode_aper$address() {
        return LaneClosed_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t LaneClosed_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment LaneClosed_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = LaneClosed_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("LaneClosed_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_LaneInfo$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_LaneInfo").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_LaneInfo
     * }
     */
    public static GroupLayout asn_DEF_LaneInfo$layout() {
        return asn_DEF_LaneInfo$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_LaneInfo
     * }
     */
    public static MemorySegment asn_DEF_LaneInfo() {
        return asn_DEF_LaneInfo$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_LaneInfo
     * }
     */
    public static void asn_DEF_LaneInfo(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_LaneInfo$constants.SEGMENT, 0L, asn_DEF_LaneInfo$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_LaneInfo_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_LaneInfo_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_LaneInfo_specs_1
     * }
     */
    public static GroupLayout asn_SPC_LaneInfo_specs_1$layout() {
        return asn_SPC_LaneInfo_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_LaneInfo_specs_1
     * }
     */
    public static MemorySegment asn_SPC_LaneInfo_specs_1() {
        return asn_SPC_LaneInfo_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_LaneInfo_specs_1
     * }
     */
    public static void asn_SPC_LaneInfo_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_LaneInfo_specs_1$constants.SEGMENT, 0L, asn_SPC_LaneInfo_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_LaneInfo_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(3, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_LaneInfo_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 3 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_LaneInfo_1[3]
     * }
     */
    public static SequenceLayout asn_MBR_LaneInfo_1$layout() {
        return asn_MBR_LaneInfo_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_LaneInfo_1[3]
     * }
     */
    public static long[] asn_MBR_LaneInfo_1$dimensions() {
        return asn_MBR_LaneInfo_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_LaneInfo_1[3]
     * }
     */
    public static MemorySegment asn_MBR_LaneInfo_1() {
        return asn_MBR_LaneInfo_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_LaneInfo_1[3]
     * }
     */
    public static void asn_MBR_LaneInfo_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_LaneInfo_1$constants.SEGMENT, 0L, asn_MBR_LaneInfo_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_LaneInfo_1[3]
     * }
     */
    public static MemorySegment asn_MBR_LaneInfo_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_LaneInfo_1$constants.HANDLE.invokeExact(asn_MBR_LaneInfo_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_LaneInfo_1[3]
     * }
     */
    public static void asn_MBR_LaneInfo_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_LaneInfo_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef long Radius_t
     * }
     */
    public static final OfLong Radius_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_Radius_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_Radius_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Radius_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_Radius_constr_1$layout() {
        return asn_PER_type_Radius_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Radius_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_Radius_constr_1() {
        return asn_PER_type_Radius_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Radius_constr_1
     * }
     */
    public static void asn_PER_type_Radius_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_Radius_constr_1$constants.SEGMENT, 0L, asn_PER_type_Radius_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_Radius$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_Radius").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Radius
     * }
     */
    public static GroupLayout asn_DEF_Radius$layout() {
        return asn_DEF_Radius$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Radius
     * }
     */
    public static MemorySegment asn_DEF_Radius() {
        return asn_DEF_Radius$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Radius
     * }
     */
    public static void asn_DEF_Radius(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_Radius$constants.SEGMENT, 0L, asn_DEF_Radius$constants.LAYOUT.byteSize());
    }

    private static class Radius_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Radius_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor Radius_free$descriptor() {
        return Radius_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Radius_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle Radius_free$handle() {
        return Radius_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Radius_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment Radius_free$address() {
        return Radius_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Radius_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void Radius_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = Radius_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Radius_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Radius_print$descriptor() {
        return Radius_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Radius_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Radius_print$handle() {
        return Radius_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Radius_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Radius_print$address() {
        return Radius_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Radius_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int Radius_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Radius_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Radius_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor Radius_constraint$descriptor() {
        return Radius_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Radius_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle Radius_constraint$handle() {
        return Radius_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Radius_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment Radius_constraint$address() {
        return Radius_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Radius_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int Radius_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Radius_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor Radius_decode_ber$descriptor() {
        return Radius_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle Radius_decode_ber$handle() {
        return Radius_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Radius_decode_ber$address() {
        return Radius_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Radius_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = Radius_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Radius_encode_der$descriptor() {
        return Radius_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Radius_encode_der$handle() {
        return Radius_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Radius_encode_der$address() {
        return Radius_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Radius_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Radius_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Radius_decode_xer$descriptor() {
        return Radius_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle Radius_decode_xer$handle() {
        return Radius_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Radius_decode_xer$address() {
        return Radius_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Radius_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Radius_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Radius_encode_xer$descriptor() {
        return Radius_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Radius_encode_xer$handle() {
        return Radius_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Radius_encode_xer$address() {
        return Radius_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Radius_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Radius_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Radius_encode_jer$descriptor() {
        return Radius_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Radius_encode_jer$handle() {
        return Radius_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Radius_encode_jer$address() {
        return Radius_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Radius_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = Radius_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Radius_decode_oer$descriptor() {
        return Radius_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle Radius_decode_oer$handle() {
        return Radius_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Radius_decode_oer$address() {
        return Radius_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Radius_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Radius_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Radius_encode_oer$descriptor() {
        return Radius_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Radius_encode_oer$handle() {
        return Radius_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Radius_encode_oer$address() {
        return Radius_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Radius_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Radius_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Radius_decode_uper$descriptor() {
        return Radius_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Radius_decode_uper$handle() {
        return Radius_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Radius_decode_uper$address() {
        return Radius_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Radius_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Radius_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Radius_encode_uper$descriptor() {
        return Radius_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Radius_encode_uper$handle() {
        return Radius_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Radius_encode_uper$address() {
        return Radius_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Radius_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Radius_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Radius_decode_aper$descriptor() {
        return Radius_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Radius_decode_aper$handle() {
        return Radius_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Radius_decode_aper$address() {
        return Radius_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Radius_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Radius_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Radius_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Radius_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Radius_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Radius_encode_aper$descriptor() {
        return Radius_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Radius_encode_aper$handle() {
        return Radius_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Radius_encode_aper$address() {
        return Radius_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Radius_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Radius_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Radius_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Radius_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long BankAngle_t
     * }
     */
    public static final OfLong BankAngle_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_BankAngle_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_BankAngle_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_BankAngle_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_BankAngle_constr_1$layout() {
        return asn_PER_type_BankAngle_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_BankAngle_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_BankAngle_constr_1() {
        return asn_PER_type_BankAngle_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_BankAngle_constr_1
     * }
     */
    public static void asn_PER_type_BankAngle_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_BankAngle_constr_1$constants.SEGMENT, 0L, asn_PER_type_BankAngle_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_BankAngle$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_BankAngle").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BankAngle
     * }
     */
    public static GroupLayout asn_DEF_BankAngle$layout() {
        return asn_DEF_BankAngle$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BankAngle
     * }
     */
    public static MemorySegment asn_DEF_BankAngle() {
        return asn_DEF_BankAngle$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BankAngle
     * }
     */
    public static void asn_DEF_BankAngle(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_BankAngle$constants.SEGMENT, 0L, asn_DEF_BankAngle$constants.LAYOUT.byteSize());
    }

    private static class BankAngle_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BankAngle_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BankAngle_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor BankAngle_free$descriptor() {
        return BankAngle_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BankAngle_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle BankAngle_free$handle() {
        return BankAngle_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BankAngle_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment BankAngle_free$address() {
        return BankAngle_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BankAngle_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void BankAngle_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = BankAngle_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BankAngle_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BankAngle_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BankAngle_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int BankAngle_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BankAngle_print$descriptor() {
        return BankAngle_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int BankAngle_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BankAngle_print$handle() {
        return BankAngle_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int BankAngle_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BankAngle_print$address() {
        return BankAngle_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int BankAngle_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int BankAngle_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = BankAngle_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BankAngle_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BankAngle_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BankAngle_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int BankAngle_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor BankAngle_constraint$descriptor() {
        return BankAngle_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int BankAngle_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle BankAngle_constraint$handle() {
        return BankAngle_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int BankAngle_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment BankAngle_constraint$address() {
        return BankAngle_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int BankAngle_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int BankAngle_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = BankAngle_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BankAngle_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BankAngle_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BankAngle_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BankAngle_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor BankAngle_decode_ber$descriptor() {
        return BankAngle_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BankAngle_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle BankAngle_decode_ber$handle() {
        return BankAngle_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BankAngle_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment BankAngle_decode_ber$address() {
        return BankAngle_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BankAngle_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment BankAngle_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = BankAngle_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BankAngle_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BankAngle_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BankAngle_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BankAngle_encode_der$descriptor() {
        return BankAngle_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BankAngle_encode_der$handle() {
        return BankAngle_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BankAngle_encode_der$address() {
        return BankAngle_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BankAngle_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = BankAngle_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BankAngle_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BankAngle_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BankAngle_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BankAngle_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor BankAngle_decode_xer$descriptor() {
        return BankAngle_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BankAngle_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle BankAngle_decode_xer$handle() {
        return BankAngle_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BankAngle_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment BankAngle_decode_xer$address() {
        return BankAngle_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BankAngle_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment BankAngle_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = BankAngle_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BankAngle_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BankAngle_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BankAngle_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BankAngle_encode_xer$descriptor() {
        return BankAngle_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BankAngle_encode_xer$handle() {
        return BankAngle_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BankAngle_encode_xer$address() {
        return BankAngle_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BankAngle_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = BankAngle_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BankAngle_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BankAngle_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BankAngle_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BankAngle_encode_jer$descriptor() {
        return BankAngle_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BankAngle_encode_jer$handle() {
        return BankAngle_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BankAngle_encode_jer$address() {
        return BankAngle_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BankAngle_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = BankAngle_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BankAngle_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BankAngle_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BankAngle_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BankAngle_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor BankAngle_decode_oer$descriptor() {
        return BankAngle_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BankAngle_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle BankAngle_decode_oer$handle() {
        return BankAngle_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BankAngle_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment BankAngle_decode_oer$address() {
        return BankAngle_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BankAngle_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment BankAngle_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = BankAngle_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BankAngle_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BankAngle_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BankAngle_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BankAngle_encode_oer$descriptor() {
        return BankAngle_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BankAngle_encode_oer$handle() {
        return BankAngle_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BankAngle_encode_oer$address() {
        return BankAngle_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BankAngle_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = BankAngle_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BankAngle_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BankAngle_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BankAngle_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BankAngle_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor BankAngle_decode_uper$descriptor() {
        return BankAngle_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BankAngle_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle BankAngle_decode_uper$handle() {
        return BankAngle_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BankAngle_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment BankAngle_decode_uper$address() {
        return BankAngle_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BankAngle_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment BankAngle_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = BankAngle_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BankAngle_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BankAngle_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BankAngle_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor BankAngle_encode_uper$descriptor() {
        return BankAngle_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle BankAngle_encode_uper$handle() {
        return BankAngle_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment BankAngle_encode_uper$address() {
        return BankAngle_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment BankAngle_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = BankAngle_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BankAngle_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BankAngle_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BankAngle_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BankAngle_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor BankAngle_decode_aper$descriptor() {
        return BankAngle_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BankAngle_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle BankAngle_decode_aper$handle() {
        return BankAngle_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BankAngle_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment BankAngle_decode_aper$address() {
        return BankAngle_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BankAngle_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment BankAngle_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = BankAngle_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BankAngle_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BankAngle_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BankAngle_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor BankAngle_encode_aper$descriptor() {
        return BankAngle_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle BankAngle_encode_aper$handle() {
        return BankAngle_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment BankAngle_encode_aper$address() {
        return BankAngle_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BankAngle_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment BankAngle_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = BankAngle_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BankAngle_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_CurveContainer$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_CurveContainer").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_CurveContainer
     * }
     */
    public static GroupLayout asn_DEF_CurveContainer$layout() {
        return asn_DEF_CurveContainer$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_CurveContainer
     * }
     */
    public static MemorySegment asn_DEF_CurveContainer() {
        return asn_DEF_CurveContainer$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_CurveContainer
     * }
     */
    public static void asn_DEF_CurveContainer(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_CurveContainer$constants.SEGMENT, 0L, asn_DEF_CurveContainer$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_CurveContainer_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_CurveContainer_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_CurveContainer_specs_1
     * }
     */
    public static GroupLayout asn_SPC_CurveContainer_specs_1$layout() {
        return asn_SPC_CurveContainer_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_CurveContainer_specs_1
     * }
     */
    public static MemorySegment asn_SPC_CurveContainer_specs_1() {
        return asn_SPC_CurveContainer_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_CurveContainer_specs_1
     * }
     */
    public static void asn_SPC_CurveContainer_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_CurveContainer_specs_1$constants.SEGMENT, 0L, asn_SPC_CurveContainer_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_CurveContainer_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(5, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_CurveContainer_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 5 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CurveContainer_1[5]
     * }
     */
    public static SequenceLayout asn_MBR_CurveContainer_1$layout() {
        return asn_MBR_CurveContainer_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CurveContainer_1[5]
     * }
     */
    public static long[] asn_MBR_CurveContainer_1$dimensions() {
        return asn_MBR_CurveContainer_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CurveContainer_1[5]
     * }
     */
    public static MemorySegment asn_MBR_CurveContainer_1() {
        return asn_MBR_CurveContainer_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CurveContainer_1[5]
     * }
     */
    public static void asn_MBR_CurveContainer_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_CurveContainer_1$constants.SEGMENT, 0L, asn_MBR_CurveContainer_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CurveContainer_1[5]
     * }
     */
    public static MemorySegment asn_MBR_CurveContainer_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_CurveContainer_1$constants.HANDLE.invokeExact(asn_MBR_CurveContainer_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CurveContainer_1[5]
     * }
     */
    public static void asn_MBR_CurveContainer_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_CurveContainer_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_ShortString_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_ShortString_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ShortString_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_ShortString_constr_1$layout() {
        return asn_PER_type_ShortString_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ShortString_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_ShortString_constr_1() {
        return asn_PER_type_ShortString_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ShortString_constr_1
     * }
     */
    public static void asn_PER_type_ShortString_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_ShortString_constr_1$constants.SEGMENT, 0L, asn_PER_type_ShortString_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_ShortString$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_ShortString").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ShortString
     * }
     */
    public static GroupLayout asn_DEF_ShortString$layout() {
        return asn_DEF_ShortString$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ShortString
     * }
     */
    public static MemorySegment asn_DEF_ShortString() {
        return asn_DEF_ShortString$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ShortString
     * }
     */
    public static void asn_DEF_ShortString(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_ShortString$constants.SEGMENT, 0L, asn_DEF_ShortString$constants.LAYOUT.byteSize());
    }

    private static class ShortString_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ShortString_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ShortString_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor ShortString_free$descriptor() {
        return ShortString_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ShortString_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle ShortString_free$handle() {
        return ShortString_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ShortString_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment ShortString_free$address() {
        return ShortString_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ShortString_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void ShortString_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = ShortString_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShortString_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShortString_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ShortString_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ShortString_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ShortString_print$descriptor() {
        return ShortString_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ShortString_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ShortString_print$handle() {
        return ShortString_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ShortString_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ShortString_print$address() {
        return ShortString_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ShortString_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int ShortString_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ShortString_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShortString_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShortString_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ShortString_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ShortString_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor ShortString_constraint$descriptor() {
        return ShortString_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ShortString_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle ShortString_constraint$handle() {
        return ShortString_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ShortString_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment ShortString_constraint$address() {
        return ShortString_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ShortString_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int ShortString_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ShortString_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShortString_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShortString_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ShortString_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ShortString_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor ShortString_decode_ber$descriptor() {
        return ShortString_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ShortString_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle ShortString_decode_ber$handle() {
        return ShortString_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ShortString_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment ShortString_decode_ber$address() {
        return ShortString_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ShortString_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment ShortString_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = ShortString_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShortString_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShortString_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ShortString_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ShortString_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ShortString_encode_der$descriptor() {
        return ShortString_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ShortString_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ShortString_encode_der$handle() {
        return ShortString_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ShortString_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ShortString_encode_der$address() {
        return ShortString_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ShortString_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ShortString_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ShortString_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShortString_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShortString_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ShortString_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ShortString_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor ShortString_decode_xer$descriptor() {
        return ShortString_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ShortString_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle ShortString_decode_xer$handle() {
        return ShortString_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ShortString_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment ShortString_decode_xer$address() {
        return ShortString_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ShortString_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment ShortString_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = ShortString_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShortString_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShortString_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ShortString_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ShortString_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ShortString_encode_xer$descriptor() {
        return ShortString_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ShortString_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ShortString_encode_xer$handle() {
        return ShortString_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ShortString_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ShortString_encode_xer$address() {
        return ShortString_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ShortString_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ShortString_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ShortString_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShortString_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShortString_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ShortString_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ShortString_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ShortString_encode_jer$descriptor() {
        return ShortString_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ShortString_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ShortString_encode_jer$handle() {
        return ShortString_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ShortString_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ShortString_encode_jer$address() {
        return ShortString_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ShortString_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ShortString_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = ShortString_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShortString_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShortString_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ShortString_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ShortString_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor ShortString_decode_oer$descriptor() {
        return ShortString_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ShortString_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle ShortString_decode_oer$handle() {
        return ShortString_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ShortString_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ShortString_decode_oer$address() {
        return ShortString_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ShortString_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ShortString_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = ShortString_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShortString_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ShortString_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ShortString_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ShortString_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ShortString_encode_oer$descriptor() {
        return ShortString_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ShortString_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ShortString_encode_oer$handle() {
        return ShortString_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ShortString_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ShortString_encode_oer$address() {
        return ShortString_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ShortString_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ShortString_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ShortString_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ShortString_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

