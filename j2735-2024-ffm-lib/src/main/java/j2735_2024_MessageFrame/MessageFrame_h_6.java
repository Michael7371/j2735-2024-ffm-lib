// Generated by jextract

package j2735_2024_MessageFrame;

import java.lang.invoke.*;
import java.lang.foreign.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class MessageFrame_h_6 extends MessageFrame_h_7 {

    MessageFrame_h_6() {
        // Should not be called directly
    }

    private static class RelativeRoadAuthorityID_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RelativeRoadAuthorityID_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RelativeRoadAuthorityID_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor RelativeRoadAuthorityID_decode_aper$descriptor() {
        return RelativeRoadAuthorityID_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RelativeRoadAuthorityID_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle RelativeRoadAuthorityID_decode_aper$handle() {
        return RelativeRoadAuthorityID_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RelativeRoadAuthorityID_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment RelativeRoadAuthorityID_decode_aper$address() {
        return RelativeRoadAuthorityID_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RelativeRoadAuthorityID_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment RelativeRoadAuthorityID_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = RelativeRoadAuthorityID_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RelativeRoadAuthorityID_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RelativeRoadAuthorityID_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RelativeRoadAuthorityID_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RelativeRoadAuthorityID_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor RelativeRoadAuthorityID_encode_aper$descriptor() {
        return RelativeRoadAuthorityID_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RelativeRoadAuthorityID_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle RelativeRoadAuthorityID_encode_aper$handle() {
        return RelativeRoadAuthorityID_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RelativeRoadAuthorityID_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment RelativeRoadAuthorityID_encode_aper$address() {
        return RelativeRoadAuthorityID_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RelativeRoadAuthorityID_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment RelativeRoadAuthorityID_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = RelativeRoadAuthorityID_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RelativeRoadAuthorityID_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int RoadAuthorityID_PR_NOTHING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum RoadAuthorityID_PR.RoadAuthorityID_PR_NOTHING = 0
     * }
     */
    public static int RoadAuthorityID_PR_NOTHING() {
        return RoadAuthorityID_PR_NOTHING;
    }
    private static final int RoadAuthorityID_PR_fullRdAuthID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum RoadAuthorityID_PR.RoadAuthorityID_PR_fullRdAuthID = 1
     * }
     */
    public static int RoadAuthorityID_PR_fullRdAuthID() {
        return RoadAuthorityID_PR_fullRdAuthID;
    }
    private static final int RoadAuthorityID_PR_relRdAuthID = (int)2L;
    /**
     * {@snippet lang=c :
     * enum RoadAuthorityID_PR.RoadAuthorityID_PR_relRdAuthID = 2
     * }
     */
    public static int RoadAuthorityID_PR_relRdAuthID() {
        return RoadAuthorityID_PR_relRdAuthID;
    }

    private static class asn_DEF_RoadAuthorityID$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_RoadAuthorityID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadAuthorityID
     * }
     */
    public static GroupLayout asn_DEF_RoadAuthorityID$layout() {
        return asn_DEF_RoadAuthorityID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadAuthorityID
     * }
     */
    public static MemorySegment asn_DEF_RoadAuthorityID() {
        return asn_DEF_RoadAuthorityID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadAuthorityID
     * }
     */
    public static void asn_DEF_RoadAuthorityID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_RoadAuthorityID$constants.SEGMENT, 0L, asn_DEF_RoadAuthorityID$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_RoadAuthorityID_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_CHOICE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_RoadAuthorityID_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_RoadAuthorityID_specs_1
     * }
     */
    public static GroupLayout asn_SPC_RoadAuthorityID_specs_1$layout() {
        return asn_SPC_RoadAuthorityID_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_RoadAuthorityID_specs_1
     * }
     */
    public static MemorySegment asn_SPC_RoadAuthorityID_specs_1() {
        return asn_SPC_RoadAuthorityID_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_RoadAuthorityID_specs_1
     * }
     */
    public static void asn_SPC_RoadAuthorityID_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_RoadAuthorityID_specs_1$constants.SEGMENT, 0L, asn_SPC_RoadAuthorityID_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_RoadAuthorityID_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_RoadAuthorityID_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadAuthorityID_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_RoadAuthorityID_1$layout() {
        return asn_MBR_RoadAuthorityID_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadAuthorityID_1[2]
     * }
     */
    public static long[] asn_MBR_RoadAuthorityID_1$dimensions() {
        return asn_MBR_RoadAuthorityID_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadAuthorityID_1[2]
     * }
     */
    public static MemorySegment asn_MBR_RoadAuthorityID_1() {
        return asn_MBR_RoadAuthorityID_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadAuthorityID_1[2]
     * }
     */
    public static void asn_MBR_RoadAuthorityID_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RoadAuthorityID_1$constants.SEGMENT, 0L, asn_MBR_RoadAuthorityID_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadAuthorityID_1[2]
     * }
     */
    public static MemorySegment asn_MBR_RoadAuthorityID_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_RoadAuthorityID_1$constants.HANDLE.invokeExact(asn_MBR_RoadAuthorityID_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadAuthorityID_1[2]
     * }
     */
    public static void asn_MBR_RoadAuthorityID_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RoadAuthorityID_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_RoadAuthorityID_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_RoadAuthorityID_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RoadAuthorityID_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_RoadAuthorityID_constr_1$layout() {
        return asn_PER_type_RoadAuthorityID_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RoadAuthorityID_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_RoadAuthorityID_constr_1() {
        return asn_PER_type_RoadAuthorityID_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RoadAuthorityID_constr_1
     * }
     */
    public static void asn_PER_type_RoadAuthorityID_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_RoadAuthorityID_constr_1$constants.SEGMENT, 0L, asn_PER_type_RoadAuthorityID_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_RoadSegmentList$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_RoadSegmentList").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadSegmentList
     * }
     */
    public static GroupLayout asn_DEF_RoadSegmentList$layout() {
        return asn_DEF_RoadSegmentList$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadSegmentList
     * }
     */
    public static MemorySegment asn_DEF_RoadSegmentList() {
        return asn_DEF_RoadSegmentList$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadSegmentList
     * }
     */
    public static void asn_DEF_RoadSegmentList(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_RoadSegmentList$constants.SEGMENT, 0L, asn_DEF_RoadSegmentList$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_RoadSegmentList_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SET_OF_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_RoadSegmentList_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_RoadSegmentList_specs_1
     * }
     */
    public static GroupLayout asn_SPC_RoadSegmentList_specs_1$layout() {
        return asn_SPC_RoadSegmentList_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_RoadSegmentList_specs_1
     * }
     */
    public static MemorySegment asn_SPC_RoadSegmentList_specs_1() {
        return asn_SPC_RoadSegmentList_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_RoadSegmentList_specs_1
     * }
     */
    public static void asn_SPC_RoadSegmentList_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_RoadSegmentList_specs_1$constants.SEGMENT, 0L, asn_SPC_RoadSegmentList_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_RoadSegmentList_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(1, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_RoadSegmentList_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 1 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSegmentList_1[1]
     * }
     */
    public static SequenceLayout asn_MBR_RoadSegmentList_1$layout() {
        return asn_MBR_RoadSegmentList_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSegmentList_1[1]
     * }
     */
    public static long[] asn_MBR_RoadSegmentList_1$dimensions() {
        return asn_MBR_RoadSegmentList_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSegmentList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_RoadSegmentList_1() {
        return asn_MBR_RoadSegmentList_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSegmentList_1[1]
     * }
     */
    public static void asn_MBR_RoadSegmentList_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RoadSegmentList_1$constants.SEGMENT, 0L, asn_MBR_RoadSegmentList_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSegmentList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_RoadSegmentList_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_RoadSegmentList_1$constants.HANDLE.invokeExact(asn_MBR_RoadSegmentList_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSegmentList_1[1]
     * }
     */
    public static void asn_MBR_RoadSegmentList_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RoadSegmentList_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_RoadSegmentList_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_RoadSegmentList_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RoadSegmentList_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_RoadSegmentList_constr_1$layout() {
        return asn_PER_type_RoadSegmentList_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RoadSegmentList_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_RoadSegmentList_constr_1() {
        return asn_PER_type_RoadSegmentList_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RoadSegmentList_constr_1
     * }
     */
    public static void asn_PER_type_RoadSegmentList_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_RoadSegmentList_constr_1$constants.SEGMENT, 0L, asn_PER_type_RoadSegmentList_constr_1$constants.LAYOUT.byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef long RoadSegmentID_t
     * }
     */
    public static final OfLong RoadSegmentID_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_RoadSegmentID_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_RoadSegmentID_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RoadSegmentID_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_RoadSegmentID_constr_1$layout() {
        return asn_PER_type_RoadSegmentID_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RoadSegmentID_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_RoadSegmentID_constr_1() {
        return asn_PER_type_RoadSegmentID_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RoadSegmentID_constr_1
     * }
     */
    public static void asn_PER_type_RoadSegmentID_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_RoadSegmentID_constr_1$constants.SEGMENT, 0L, asn_PER_type_RoadSegmentID_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_RoadSegmentID$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_RoadSegmentID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadSegmentID
     * }
     */
    public static GroupLayout asn_DEF_RoadSegmentID$layout() {
        return asn_DEF_RoadSegmentID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadSegmentID
     * }
     */
    public static MemorySegment asn_DEF_RoadSegmentID() {
        return asn_DEF_RoadSegmentID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadSegmentID
     * }
     */
    public static void asn_DEF_RoadSegmentID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_RoadSegmentID$constants.SEGMENT, 0L, asn_DEF_RoadSegmentID$constants.LAYOUT.byteSize());
    }

    private static class RoadSegmentID_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RoadSegmentID_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RoadSegmentID_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor RoadSegmentID_free$descriptor() {
        return RoadSegmentID_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RoadSegmentID_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle RoadSegmentID_free$handle() {
        return RoadSegmentID_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RoadSegmentID_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment RoadSegmentID_free$address() {
        return RoadSegmentID_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RoadSegmentID_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void RoadSegmentID_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = RoadSegmentID_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RoadSegmentID_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RoadSegmentID_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RoadSegmentID_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int RoadSegmentID_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RoadSegmentID_print$descriptor() {
        return RoadSegmentID_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int RoadSegmentID_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RoadSegmentID_print$handle() {
        return RoadSegmentID_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int RoadSegmentID_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RoadSegmentID_print$address() {
        return RoadSegmentID_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int RoadSegmentID_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int RoadSegmentID_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = RoadSegmentID_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RoadSegmentID_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RoadSegmentID_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RoadSegmentID_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int RoadSegmentID_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor RoadSegmentID_constraint$descriptor() {
        return RoadSegmentID_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int RoadSegmentID_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle RoadSegmentID_constraint$handle() {
        return RoadSegmentID_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int RoadSegmentID_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment RoadSegmentID_constraint$address() {
        return RoadSegmentID_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int RoadSegmentID_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int RoadSegmentID_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = RoadSegmentID_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RoadSegmentID_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RoadSegmentID_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RoadSegmentID_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RoadSegmentID_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor RoadSegmentID_decode_ber$descriptor() {
        return RoadSegmentID_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RoadSegmentID_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle RoadSegmentID_decode_ber$handle() {
        return RoadSegmentID_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RoadSegmentID_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment RoadSegmentID_decode_ber$address() {
        return RoadSegmentID_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RoadSegmentID_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment RoadSegmentID_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = RoadSegmentID_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RoadSegmentID_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RoadSegmentID_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RoadSegmentID_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RoadSegmentID_encode_der$descriptor() {
        return RoadSegmentID_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RoadSegmentID_encode_der$handle() {
        return RoadSegmentID_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RoadSegmentID_encode_der$address() {
        return RoadSegmentID_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RoadSegmentID_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = RoadSegmentID_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RoadSegmentID_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RoadSegmentID_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RoadSegmentID_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RoadSegmentID_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor RoadSegmentID_decode_xer$descriptor() {
        return RoadSegmentID_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RoadSegmentID_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle RoadSegmentID_decode_xer$handle() {
        return RoadSegmentID_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RoadSegmentID_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment RoadSegmentID_decode_xer$address() {
        return RoadSegmentID_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RoadSegmentID_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment RoadSegmentID_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = RoadSegmentID_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RoadSegmentID_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RoadSegmentID_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RoadSegmentID_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RoadSegmentID_encode_xer$descriptor() {
        return RoadSegmentID_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RoadSegmentID_encode_xer$handle() {
        return RoadSegmentID_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RoadSegmentID_encode_xer$address() {
        return RoadSegmentID_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RoadSegmentID_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = RoadSegmentID_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RoadSegmentID_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RoadSegmentID_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RoadSegmentID_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RoadSegmentID_encode_jer$descriptor() {
        return RoadSegmentID_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RoadSegmentID_encode_jer$handle() {
        return RoadSegmentID_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RoadSegmentID_encode_jer$address() {
        return RoadSegmentID_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RoadSegmentID_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = RoadSegmentID_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RoadSegmentID_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RoadSegmentID_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RoadSegmentID_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RoadSegmentID_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor RoadSegmentID_decode_oer$descriptor() {
        return RoadSegmentID_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RoadSegmentID_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle RoadSegmentID_decode_oer$handle() {
        return RoadSegmentID_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RoadSegmentID_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment RoadSegmentID_decode_oer$address() {
        return RoadSegmentID_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RoadSegmentID_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment RoadSegmentID_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = RoadSegmentID_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RoadSegmentID_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RoadSegmentID_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RoadSegmentID_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RoadSegmentID_encode_oer$descriptor() {
        return RoadSegmentID_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RoadSegmentID_encode_oer$handle() {
        return RoadSegmentID_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RoadSegmentID_encode_oer$address() {
        return RoadSegmentID_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RoadSegmentID_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = RoadSegmentID_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RoadSegmentID_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RoadSegmentID_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RoadSegmentID_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RoadSegmentID_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor RoadSegmentID_decode_uper$descriptor() {
        return RoadSegmentID_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RoadSegmentID_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle RoadSegmentID_decode_uper$handle() {
        return RoadSegmentID_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RoadSegmentID_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment RoadSegmentID_decode_uper$address() {
        return RoadSegmentID_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RoadSegmentID_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment RoadSegmentID_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = RoadSegmentID_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RoadSegmentID_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RoadSegmentID_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RoadSegmentID_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor RoadSegmentID_encode_uper$descriptor() {
        return RoadSegmentID_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle RoadSegmentID_encode_uper$handle() {
        return RoadSegmentID_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment RoadSegmentID_encode_uper$address() {
        return RoadSegmentID_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment RoadSegmentID_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = RoadSegmentID_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RoadSegmentID_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RoadSegmentID_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RoadSegmentID_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RoadSegmentID_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor RoadSegmentID_decode_aper$descriptor() {
        return RoadSegmentID_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RoadSegmentID_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle RoadSegmentID_decode_aper$handle() {
        return RoadSegmentID_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RoadSegmentID_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment RoadSegmentID_decode_aper$address() {
        return RoadSegmentID_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RoadSegmentID_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment RoadSegmentID_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = RoadSegmentID_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RoadSegmentID_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RoadSegmentID_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RoadSegmentID_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor RoadSegmentID_encode_aper$descriptor() {
        return RoadSegmentID_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle RoadSegmentID_encode_aper$handle() {
        return RoadSegmentID_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment RoadSegmentID_encode_aper$address() {
        return RoadSegmentID_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RoadSegmentID_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment RoadSegmentID_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = RoadSegmentID_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RoadSegmentID_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_RoadSegmentReferenceID$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_RoadSegmentReferenceID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadSegmentReferenceID
     * }
     */
    public static GroupLayout asn_DEF_RoadSegmentReferenceID$layout() {
        return asn_DEF_RoadSegmentReferenceID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadSegmentReferenceID
     * }
     */
    public static MemorySegment asn_DEF_RoadSegmentReferenceID() {
        return asn_DEF_RoadSegmentReferenceID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadSegmentReferenceID
     * }
     */
    public static void asn_DEF_RoadSegmentReferenceID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_RoadSegmentReferenceID$constants.SEGMENT, 0L, asn_DEF_RoadSegmentReferenceID$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_RoadSegmentReferenceID_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_RoadSegmentReferenceID_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RoadSegmentReferenceID_specs_1
     * }
     */
    public static GroupLayout asn_SPC_RoadSegmentReferenceID_specs_1$layout() {
        return asn_SPC_RoadSegmentReferenceID_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RoadSegmentReferenceID_specs_1
     * }
     */
    public static MemorySegment asn_SPC_RoadSegmentReferenceID_specs_1() {
        return asn_SPC_RoadSegmentReferenceID_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RoadSegmentReferenceID_specs_1
     * }
     */
    public static void asn_SPC_RoadSegmentReferenceID_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_RoadSegmentReferenceID_specs_1$constants.SEGMENT, 0L, asn_SPC_RoadSegmentReferenceID_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_RoadSegmentReferenceID_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_RoadSegmentReferenceID_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSegmentReferenceID_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_RoadSegmentReferenceID_1$layout() {
        return asn_MBR_RoadSegmentReferenceID_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSegmentReferenceID_1[2]
     * }
     */
    public static long[] asn_MBR_RoadSegmentReferenceID_1$dimensions() {
        return asn_MBR_RoadSegmentReferenceID_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSegmentReferenceID_1[2]
     * }
     */
    public static MemorySegment asn_MBR_RoadSegmentReferenceID_1() {
        return asn_MBR_RoadSegmentReferenceID_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSegmentReferenceID_1[2]
     * }
     */
    public static void asn_MBR_RoadSegmentReferenceID_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RoadSegmentReferenceID_1$constants.SEGMENT, 0L, asn_MBR_RoadSegmentReferenceID_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSegmentReferenceID_1[2]
     * }
     */
    public static MemorySegment asn_MBR_RoadSegmentReferenceID_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_RoadSegmentReferenceID_1$constants.HANDLE.invokeExact(asn_MBR_RoadSegmentReferenceID_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSegmentReferenceID_1[2]
     * }
     */
    public static void asn_MBR_RoadSegmentReferenceID_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RoadSegmentReferenceID_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_RoadLaneSetList$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_RoadLaneSetList").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadLaneSetList
     * }
     */
    public static GroupLayout asn_DEF_RoadLaneSetList$layout() {
        return asn_DEF_RoadLaneSetList$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadLaneSetList
     * }
     */
    public static MemorySegment asn_DEF_RoadLaneSetList() {
        return asn_DEF_RoadLaneSetList$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadLaneSetList
     * }
     */
    public static void asn_DEF_RoadLaneSetList(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_RoadLaneSetList$constants.SEGMENT, 0L, asn_DEF_RoadLaneSetList$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_RoadLaneSetList_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SET_OF_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_RoadLaneSetList_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_RoadLaneSetList_specs_1
     * }
     */
    public static GroupLayout asn_SPC_RoadLaneSetList_specs_1$layout() {
        return asn_SPC_RoadLaneSetList_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_RoadLaneSetList_specs_1
     * }
     */
    public static MemorySegment asn_SPC_RoadLaneSetList_specs_1() {
        return asn_SPC_RoadLaneSetList_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_RoadLaneSetList_specs_1
     * }
     */
    public static void asn_SPC_RoadLaneSetList_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_RoadLaneSetList_specs_1$constants.SEGMENT, 0L, asn_SPC_RoadLaneSetList_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_RoadLaneSetList_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(1, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_RoadLaneSetList_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 1 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadLaneSetList_1[1]
     * }
     */
    public static SequenceLayout asn_MBR_RoadLaneSetList_1$layout() {
        return asn_MBR_RoadLaneSetList_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadLaneSetList_1[1]
     * }
     */
    public static long[] asn_MBR_RoadLaneSetList_1$dimensions() {
        return asn_MBR_RoadLaneSetList_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadLaneSetList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_RoadLaneSetList_1() {
        return asn_MBR_RoadLaneSetList_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadLaneSetList_1[1]
     * }
     */
    public static void asn_MBR_RoadLaneSetList_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RoadLaneSetList_1$constants.SEGMENT, 0L, asn_MBR_RoadLaneSetList_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadLaneSetList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_RoadLaneSetList_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_RoadLaneSetList_1$constants.HANDLE.invokeExact(asn_MBR_RoadLaneSetList_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadLaneSetList_1[1]
     * }
     */
    public static void asn_MBR_RoadLaneSetList_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RoadLaneSetList_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_RoadLaneSetList_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_RoadLaneSetList_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RoadLaneSetList_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_RoadLaneSetList_constr_1$layout() {
        return asn_PER_type_RoadLaneSetList_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RoadLaneSetList_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_RoadLaneSetList_constr_1() {
        return asn_PER_type_RoadLaneSetList_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RoadLaneSetList_constr_1
     * }
     */
    public static void asn_PER_type_RoadLaneSetList_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_RoadLaneSetList_constr_1$constants.SEGMENT, 0L, asn_PER_type_RoadLaneSetList_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_RoadSegment$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_RoadSegment").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadSegment
     * }
     */
    public static GroupLayout asn_DEF_RoadSegment$layout() {
        return asn_DEF_RoadSegment$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadSegment
     * }
     */
    public static MemorySegment asn_DEF_RoadSegment() {
        return asn_DEF_RoadSegment$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadSegment
     * }
     */
    public static void asn_DEF_RoadSegment(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_RoadSegment$constants.SEGMENT, 0L, asn_DEF_RoadSegment$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_RoadSegment_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_RoadSegment_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RoadSegment_specs_1
     * }
     */
    public static GroupLayout asn_SPC_RoadSegment_specs_1$layout() {
        return asn_SPC_RoadSegment_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RoadSegment_specs_1
     * }
     */
    public static MemorySegment asn_SPC_RoadSegment_specs_1() {
        return asn_SPC_RoadSegment_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RoadSegment_specs_1
     * }
     */
    public static void asn_SPC_RoadSegment_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_RoadSegment_specs_1$constants.SEGMENT, 0L, asn_SPC_RoadSegment_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_RoadSegment_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(8, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_RoadSegment_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 8 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSegment_1[8]
     * }
     */
    public static SequenceLayout asn_MBR_RoadSegment_1$layout() {
        return asn_MBR_RoadSegment_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSegment_1[8]
     * }
     */
    public static long[] asn_MBR_RoadSegment_1$dimensions() {
        return asn_MBR_RoadSegment_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSegment_1[8]
     * }
     */
    public static MemorySegment asn_MBR_RoadSegment_1() {
        return asn_MBR_RoadSegment_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSegment_1[8]
     * }
     */
    public static void asn_MBR_RoadSegment_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RoadSegment_1$constants.SEGMENT, 0L, asn_MBR_RoadSegment_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSegment_1[8]
     * }
     */
    public static MemorySegment asn_MBR_RoadSegment_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_RoadSegment_1$constants.HANDLE.invokeExact(asn_MBR_RoadSegment_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSegment_1[8]
     * }
     */
    public static void asn_MBR_RoadSegment_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RoadSegment_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_DataParameters$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_DataParameters").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DataParameters
     * }
     */
    public static GroupLayout asn_DEF_DataParameters$layout() {
        return asn_DEF_DataParameters$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DataParameters
     * }
     */
    public static MemorySegment asn_DEF_DataParameters() {
        return asn_DEF_DataParameters$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DataParameters
     * }
     */
    public static void asn_DEF_DataParameters(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_DataParameters$constants.SEGMENT, 0L, asn_DEF_DataParameters$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_DataParameters_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_DataParameters_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_DataParameters_specs_1
     * }
     */
    public static GroupLayout asn_SPC_DataParameters_specs_1$layout() {
        return asn_SPC_DataParameters_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_DataParameters_specs_1
     * }
     */
    public static MemorySegment asn_SPC_DataParameters_specs_1() {
        return asn_SPC_DataParameters_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_DataParameters_specs_1
     * }
     */
    public static void asn_SPC_DataParameters_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_DataParameters_specs_1$constants.SEGMENT, 0L, asn_SPC_DataParameters_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_DataParameters_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(4, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_DataParameters_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 4 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DataParameters_1[4]
     * }
     */
    public static SequenceLayout asn_MBR_DataParameters_1$layout() {
        return asn_MBR_DataParameters_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DataParameters_1[4]
     * }
     */
    public static long[] asn_MBR_DataParameters_1$dimensions() {
        return asn_MBR_DataParameters_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DataParameters_1[4]
     * }
     */
    public static MemorySegment asn_MBR_DataParameters_1() {
        return asn_MBR_DataParameters_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DataParameters_1[4]
     * }
     */
    public static void asn_MBR_DataParameters_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_DataParameters_1$constants.SEGMENT, 0L, asn_MBR_DataParameters_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DataParameters_1[4]
     * }
     */
    public static MemorySegment asn_MBR_DataParameters_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_DataParameters_1$constants.HANDLE.invokeExact(asn_MBR_DataParameters_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DataParameters_1[4]
     * }
     */
    public static void asn_MBR_DataParameters_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_DataParameters_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_RestrictionClassList$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_RestrictionClassList").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RestrictionClassList
     * }
     */
    public static GroupLayout asn_DEF_RestrictionClassList$layout() {
        return asn_DEF_RestrictionClassList$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RestrictionClassList
     * }
     */
    public static MemorySegment asn_DEF_RestrictionClassList() {
        return asn_DEF_RestrictionClassList$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RestrictionClassList
     * }
     */
    public static void asn_DEF_RestrictionClassList(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_RestrictionClassList$constants.SEGMENT, 0L, asn_DEF_RestrictionClassList$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_RestrictionClassList_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SET_OF_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_RestrictionClassList_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_RestrictionClassList_specs_1
     * }
     */
    public static GroupLayout asn_SPC_RestrictionClassList_specs_1$layout() {
        return asn_SPC_RestrictionClassList_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_RestrictionClassList_specs_1
     * }
     */
    public static MemorySegment asn_SPC_RestrictionClassList_specs_1() {
        return asn_SPC_RestrictionClassList_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_RestrictionClassList_specs_1
     * }
     */
    public static void asn_SPC_RestrictionClassList_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_RestrictionClassList_specs_1$constants.SEGMENT, 0L, asn_SPC_RestrictionClassList_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_RestrictionClassList_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(1, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_RestrictionClassList_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 1 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionClassList_1[1]
     * }
     */
    public static SequenceLayout asn_MBR_RestrictionClassList_1$layout() {
        return asn_MBR_RestrictionClassList_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionClassList_1[1]
     * }
     */
    public static long[] asn_MBR_RestrictionClassList_1$dimensions() {
        return asn_MBR_RestrictionClassList_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionClassList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_RestrictionClassList_1() {
        return asn_MBR_RestrictionClassList_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionClassList_1[1]
     * }
     */
    public static void asn_MBR_RestrictionClassList_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RestrictionClassList_1$constants.SEGMENT, 0L, asn_MBR_RestrictionClassList_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionClassList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_RestrictionClassList_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_RestrictionClassList_1$constants.HANDLE.invokeExact(asn_MBR_RestrictionClassList_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionClassList_1[1]
     * }
     */
    public static void asn_MBR_RestrictionClassList_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RestrictionClassList_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_RestrictionClassList_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_RestrictionClassList_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RestrictionClassList_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_RestrictionClassList_constr_1$layout() {
        return asn_PER_type_RestrictionClassList_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RestrictionClassList_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_RestrictionClassList_constr_1() {
        return asn_PER_type_RestrictionClassList_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RestrictionClassList_constr_1
     * }
     */
    public static void asn_PER_type_RestrictionClassList_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_RestrictionClassList_constr_1$constants.SEGMENT, 0L, asn_PER_type_RestrictionClassList_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_RestrictionUserTypeList$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_RestrictionUserTypeList").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RestrictionUserTypeList
     * }
     */
    public static GroupLayout asn_DEF_RestrictionUserTypeList$layout() {
        return asn_DEF_RestrictionUserTypeList$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RestrictionUserTypeList
     * }
     */
    public static MemorySegment asn_DEF_RestrictionUserTypeList() {
        return asn_DEF_RestrictionUserTypeList$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RestrictionUserTypeList
     * }
     */
    public static void asn_DEF_RestrictionUserTypeList(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_RestrictionUserTypeList$constants.SEGMENT, 0L, asn_DEF_RestrictionUserTypeList$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_RestrictionUserTypeList_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SET_OF_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_RestrictionUserTypeList_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_RestrictionUserTypeList_specs_1
     * }
     */
    public static GroupLayout asn_SPC_RestrictionUserTypeList_specs_1$layout() {
        return asn_SPC_RestrictionUserTypeList_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_RestrictionUserTypeList_specs_1
     * }
     */
    public static MemorySegment asn_SPC_RestrictionUserTypeList_specs_1() {
        return asn_SPC_RestrictionUserTypeList_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_RestrictionUserTypeList_specs_1
     * }
     */
    public static void asn_SPC_RestrictionUserTypeList_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_RestrictionUserTypeList_specs_1$constants.SEGMENT, 0L, asn_SPC_RestrictionUserTypeList_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_RestrictionUserTypeList_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(1, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_RestrictionUserTypeList_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 1 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionUserTypeList_1[1]
     * }
     */
    public static SequenceLayout asn_MBR_RestrictionUserTypeList_1$layout() {
        return asn_MBR_RestrictionUserTypeList_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionUserTypeList_1[1]
     * }
     */
    public static long[] asn_MBR_RestrictionUserTypeList_1$dimensions() {
        return asn_MBR_RestrictionUserTypeList_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionUserTypeList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_RestrictionUserTypeList_1() {
        return asn_MBR_RestrictionUserTypeList_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionUserTypeList_1[1]
     * }
     */
    public static void asn_MBR_RestrictionUserTypeList_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RestrictionUserTypeList_1$constants.SEGMENT, 0L, asn_MBR_RestrictionUserTypeList_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionUserTypeList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_RestrictionUserTypeList_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_RestrictionUserTypeList_1$constants.HANDLE.invokeExact(asn_MBR_RestrictionUserTypeList_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionUserTypeList_1[1]
     * }
     */
    public static void asn_MBR_RestrictionUserTypeList_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RestrictionUserTypeList_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_RestrictionUserTypeList_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_RestrictionUserTypeList_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RestrictionUserTypeList_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_RestrictionUserTypeList_constr_1$layout() {
        return asn_PER_type_RestrictionUserTypeList_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RestrictionUserTypeList_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_RestrictionUserTypeList_constr_1() {
        return asn_PER_type_RestrictionUserTypeList_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RestrictionUserTypeList_constr_1
     * }
     */
    public static void asn_PER_type_RestrictionUserTypeList_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_RestrictionUserTypeList_constr_1$constants.SEGMENT, 0L, asn_PER_type_RestrictionUserTypeList_constr_1$constants.LAYOUT.byteSize());
    }
    private static final int RestrictionAppliesTo_none = (int)0L;
    /**
     * {@snippet lang=c :
     * enum RestrictionAppliesTo.RestrictionAppliesTo_none = 0
     * }
     */
    public static int RestrictionAppliesTo_none() {
        return RestrictionAppliesTo_none;
    }
    private static final int RestrictionAppliesTo_equippedTransit = (int)1L;
    /**
     * {@snippet lang=c :
     * enum RestrictionAppliesTo.RestrictionAppliesTo_equippedTransit = 1
     * }
     */
    public static int RestrictionAppliesTo_equippedTransit() {
        return RestrictionAppliesTo_equippedTransit;
    }
    private static final int RestrictionAppliesTo_equippedTaxis = (int)2L;
    /**
     * {@snippet lang=c :
     * enum RestrictionAppliesTo.RestrictionAppliesTo_equippedTaxis = 2
     * }
     */
    public static int RestrictionAppliesTo_equippedTaxis() {
        return RestrictionAppliesTo_equippedTaxis;
    }
    private static final int RestrictionAppliesTo_equippedOther = (int)3L;
    /**
     * {@snippet lang=c :
     * enum RestrictionAppliesTo.RestrictionAppliesTo_equippedOther = 3
     * }
     */
    public static int RestrictionAppliesTo_equippedOther() {
        return RestrictionAppliesTo_equippedOther;
    }
    private static final int RestrictionAppliesTo_emissionCompliant = (int)4L;
    /**
     * {@snippet lang=c :
     * enum RestrictionAppliesTo.RestrictionAppliesTo_emissionCompliant = 4
     * }
     */
    public static int RestrictionAppliesTo_emissionCompliant() {
        return RestrictionAppliesTo_emissionCompliant;
    }
    private static final int RestrictionAppliesTo_equippedBicycle = (int)5L;
    /**
     * {@snippet lang=c :
     * enum RestrictionAppliesTo.RestrictionAppliesTo_equippedBicycle = 5
     * }
     */
    public static int RestrictionAppliesTo_equippedBicycle() {
        return RestrictionAppliesTo_equippedBicycle;
    }
    private static final int RestrictionAppliesTo_weightCompliant = (int)6L;
    /**
     * {@snippet lang=c :
     * enum RestrictionAppliesTo.RestrictionAppliesTo_weightCompliant = 6
     * }
     */
    public static int RestrictionAppliesTo_weightCompliant() {
        return RestrictionAppliesTo_weightCompliant;
    }
    private static final int RestrictionAppliesTo_heightCompliant = (int)7L;
    /**
     * {@snippet lang=c :
     * enum RestrictionAppliesTo.RestrictionAppliesTo_heightCompliant = 7
     * }
     */
    public static int RestrictionAppliesTo_heightCompliant() {
        return RestrictionAppliesTo_heightCompliant;
    }
    private static final int RestrictionAppliesTo_pedestrians = (int)8L;
    /**
     * {@snippet lang=c :
     * enum RestrictionAppliesTo.RestrictionAppliesTo_pedestrians = 8
     * }
     */
    public static int RestrictionAppliesTo_pedestrians() {
        return RestrictionAppliesTo_pedestrians;
    }
    private static final int RestrictionAppliesTo_slowMovingPersons = (int)9L;
    /**
     * {@snippet lang=c :
     * enum RestrictionAppliesTo.RestrictionAppliesTo_slowMovingPersons = 9
     * }
     */
    public static int RestrictionAppliesTo_slowMovingPersons() {
        return RestrictionAppliesTo_slowMovingPersons;
    }
    private static final int RestrictionAppliesTo_wheelchairUsers = (int)10L;
    /**
     * {@snippet lang=c :
     * enum RestrictionAppliesTo.RestrictionAppliesTo_wheelchairUsers = 10
     * }
     */
    public static int RestrictionAppliesTo_wheelchairUsers() {
        return RestrictionAppliesTo_wheelchairUsers;
    }
    private static final int RestrictionAppliesTo_visualDisabilities = (int)11L;
    /**
     * {@snippet lang=c :
     * enum RestrictionAppliesTo.RestrictionAppliesTo_visualDisabilities = 11
     * }
     */
    public static int RestrictionAppliesTo_visualDisabilities() {
        return RestrictionAppliesTo_visualDisabilities;
    }
    private static final int RestrictionAppliesTo_audioDisabilities = (int)12L;
    /**
     * {@snippet lang=c :
     * enum RestrictionAppliesTo.RestrictionAppliesTo_audioDisabilities = 12
     * }
     */
    public static int RestrictionAppliesTo_audioDisabilities() {
        return RestrictionAppliesTo_audioDisabilities;
    }
    private static final int RestrictionAppliesTo_otherUnknownDisabilities = (int)13L;
    /**
     * {@snippet lang=c :
     * enum RestrictionAppliesTo.RestrictionAppliesTo_otherUnknownDisabilities = 13
     * }
     */
    public static int RestrictionAppliesTo_otherUnknownDisabilities() {
        return RestrictionAppliesTo_otherUnknownDisabilities;
    }
    /**
     * {@snippet lang=c :
     * typedef long RestrictionAppliesTo_t
     * }
     */
    public static final OfLong RestrictionAppliesTo_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_RestrictionAppliesTo_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_RestrictionAppliesTo_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RestrictionAppliesTo_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_RestrictionAppliesTo_constr_1$layout() {
        return asn_PER_type_RestrictionAppliesTo_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RestrictionAppliesTo_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_RestrictionAppliesTo_constr_1() {
        return asn_PER_type_RestrictionAppliesTo_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RestrictionAppliesTo_constr_1
     * }
     */
    public static void asn_PER_type_RestrictionAppliesTo_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_RestrictionAppliesTo_constr_1$constants.SEGMENT, 0L, asn_PER_type_RestrictionAppliesTo_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_RestrictionAppliesTo$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_RestrictionAppliesTo").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RestrictionAppliesTo
     * }
     */
    public static GroupLayout asn_DEF_RestrictionAppliesTo$layout() {
        return asn_DEF_RestrictionAppliesTo$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RestrictionAppliesTo
     * }
     */
    public static MemorySegment asn_DEF_RestrictionAppliesTo() {
        return asn_DEF_RestrictionAppliesTo$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RestrictionAppliesTo
     * }
     */
    public static void asn_DEF_RestrictionAppliesTo(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_RestrictionAppliesTo$constants.SEGMENT, 0L, asn_DEF_RestrictionAppliesTo$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_RestrictionAppliesTo_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_RestrictionAppliesTo_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_RestrictionAppliesTo_specs_1
     * }
     */
    public static GroupLayout asn_SPC_RestrictionAppliesTo_specs_1$layout() {
        return asn_SPC_RestrictionAppliesTo_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_RestrictionAppliesTo_specs_1
     * }
     */
    public static MemorySegment asn_SPC_RestrictionAppliesTo_specs_1() {
        return asn_SPC_RestrictionAppliesTo_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_RestrictionAppliesTo_specs_1
     * }
     */
    public static void asn_SPC_RestrictionAppliesTo_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_RestrictionAppliesTo_specs_1$constants.SEGMENT, 0L, asn_SPC_RestrictionAppliesTo_specs_1$constants.LAYOUT.byteSize());
    }

    private static class RestrictionAppliesTo_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RestrictionAppliesTo_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RestrictionAppliesTo_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor RestrictionAppliesTo_free$descriptor() {
        return RestrictionAppliesTo_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RestrictionAppliesTo_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle RestrictionAppliesTo_free$handle() {
        return RestrictionAppliesTo_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RestrictionAppliesTo_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_free$address() {
        return RestrictionAppliesTo_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RestrictionAppliesTo_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void RestrictionAppliesTo_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = RestrictionAppliesTo_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RestrictionAppliesTo_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RestrictionAppliesTo_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RestrictionAppliesTo_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int RestrictionAppliesTo_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RestrictionAppliesTo_print$descriptor() {
        return RestrictionAppliesTo_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int RestrictionAppliesTo_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RestrictionAppliesTo_print$handle() {
        return RestrictionAppliesTo_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int RestrictionAppliesTo_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_print$address() {
        return RestrictionAppliesTo_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int RestrictionAppliesTo_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int RestrictionAppliesTo_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = RestrictionAppliesTo_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RestrictionAppliesTo_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RestrictionAppliesTo_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RestrictionAppliesTo_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int RestrictionAppliesTo_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor RestrictionAppliesTo_constraint$descriptor() {
        return RestrictionAppliesTo_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int RestrictionAppliesTo_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle RestrictionAppliesTo_constraint$handle() {
        return RestrictionAppliesTo_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int RestrictionAppliesTo_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_constraint$address() {
        return RestrictionAppliesTo_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int RestrictionAppliesTo_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int RestrictionAppliesTo_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = RestrictionAppliesTo_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RestrictionAppliesTo_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RestrictionAppliesTo_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RestrictionAppliesTo_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RestrictionAppliesTo_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor RestrictionAppliesTo_decode_ber$descriptor() {
        return RestrictionAppliesTo_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RestrictionAppliesTo_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle RestrictionAppliesTo_decode_ber$handle() {
        return RestrictionAppliesTo_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RestrictionAppliesTo_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_decode_ber$address() {
        return RestrictionAppliesTo_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RestrictionAppliesTo_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = RestrictionAppliesTo_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RestrictionAppliesTo_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RestrictionAppliesTo_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RestrictionAppliesTo_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RestrictionAppliesTo_encode_der$descriptor() {
        return RestrictionAppliesTo_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RestrictionAppliesTo_encode_der$handle() {
        return RestrictionAppliesTo_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_encode_der$address() {
        return RestrictionAppliesTo_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = RestrictionAppliesTo_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RestrictionAppliesTo_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RestrictionAppliesTo_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RestrictionAppliesTo_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RestrictionAppliesTo_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor RestrictionAppliesTo_decode_xer$descriptor() {
        return RestrictionAppliesTo_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RestrictionAppliesTo_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle RestrictionAppliesTo_decode_xer$handle() {
        return RestrictionAppliesTo_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RestrictionAppliesTo_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_decode_xer$address() {
        return RestrictionAppliesTo_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RestrictionAppliesTo_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = RestrictionAppliesTo_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RestrictionAppliesTo_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RestrictionAppliesTo_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RestrictionAppliesTo_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RestrictionAppliesTo_encode_xer$descriptor() {
        return RestrictionAppliesTo_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RestrictionAppliesTo_encode_xer$handle() {
        return RestrictionAppliesTo_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_encode_xer$address() {
        return RestrictionAppliesTo_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = RestrictionAppliesTo_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RestrictionAppliesTo_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RestrictionAppliesTo_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RestrictionAppliesTo_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RestrictionAppliesTo_encode_jer$descriptor() {
        return RestrictionAppliesTo_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RestrictionAppliesTo_encode_jer$handle() {
        return RestrictionAppliesTo_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_encode_jer$address() {
        return RestrictionAppliesTo_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = RestrictionAppliesTo_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RestrictionAppliesTo_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RestrictionAppliesTo_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RestrictionAppliesTo_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RestrictionAppliesTo_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor RestrictionAppliesTo_decode_oer$descriptor() {
        return RestrictionAppliesTo_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RestrictionAppliesTo_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle RestrictionAppliesTo_decode_oer$handle() {
        return RestrictionAppliesTo_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RestrictionAppliesTo_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_decode_oer$address() {
        return RestrictionAppliesTo_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RestrictionAppliesTo_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = RestrictionAppliesTo_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RestrictionAppliesTo_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RestrictionAppliesTo_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RestrictionAppliesTo_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RestrictionAppliesTo_encode_oer$descriptor() {
        return RestrictionAppliesTo_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RestrictionAppliesTo_encode_oer$handle() {
        return RestrictionAppliesTo_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_encode_oer$address() {
        return RestrictionAppliesTo_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = RestrictionAppliesTo_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RestrictionAppliesTo_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RestrictionAppliesTo_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RestrictionAppliesTo_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RestrictionAppliesTo_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor RestrictionAppliesTo_decode_uper$descriptor() {
        return RestrictionAppliesTo_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RestrictionAppliesTo_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle RestrictionAppliesTo_decode_uper$handle() {
        return RestrictionAppliesTo_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RestrictionAppliesTo_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_decode_uper$address() {
        return RestrictionAppliesTo_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RestrictionAppliesTo_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = RestrictionAppliesTo_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RestrictionAppliesTo_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RestrictionAppliesTo_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RestrictionAppliesTo_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor RestrictionAppliesTo_encode_uper$descriptor() {
        return RestrictionAppliesTo_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle RestrictionAppliesTo_encode_uper$handle() {
        return RestrictionAppliesTo_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_encode_uper$address() {
        return RestrictionAppliesTo_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = RestrictionAppliesTo_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RestrictionAppliesTo_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RestrictionAppliesTo_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RestrictionAppliesTo_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RestrictionAppliesTo_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor RestrictionAppliesTo_decode_aper$descriptor() {
        return RestrictionAppliesTo_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RestrictionAppliesTo_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle RestrictionAppliesTo_decode_aper$handle() {
        return RestrictionAppliesTo_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RestrictionAppliesTo_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_decode_aper$address() {
        return RestrictionAppliesTo_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RestrictionAppliesTo_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = RestrictionAppliesTo_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RestrictionAppliesTo_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RestrictionAppliesTo_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RestrictionAppliesTo_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor RestrictionAppliesTo_encode_aper$descriptor() {
        return RestrictionAppliesTo_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle RestrictionAppliesTo_encode_aper$handle() {
        return RestrictionAppliesTo_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_encode_aper$address() {
        return RestrictionAppliesTo_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RestrictionAppliesTo_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment RestrictionAppliesTo_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = RestrictionAppliesTo_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RestrictionAppliesTo_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int RestrictionUserType_PR_NOTHING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum RestrictionUserType_PR.RestrictionUserType_PR_NOTHING = 0
     * }
     */
    public static int RestrictionUserType_PR_NOTHING() {
        return RestrictionUserType_PR_NOTHING;
    }
    private static final int RestrictionUserType_PR_basicType = (int)1L;
    /**
     * {@snippet lang=c :
     * enum RestrictionUserType_PR.RestrictionUserType_PR_basicType = 1
     * }
     */
    public static int RestrictionUserType_PR_basicType() {
        return RestrictionUserType_PR_basicType;
    }
    private static final int RestrictionUserType_PR_regional = (int)2L;
    /**
     * {@snippet lang=c :
     * enum RestrictionUserType_PR.RestrictionUserType_PR_regional = 2
     * }
     */
    public static int RestrictionUserType_PR_regional() {
        return RestrictionUserType_PR_regional;
    }

    private static class asn_DEF_RestrictionUserType$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_RestrictionUserType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RestrictionUserType
     * }
     */
    public static GroupLayout asn_DEF_RestrictionUserType$layout() {
        return asn_DEF_RestrictionUserType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RestrictionUserType
     * }
     */
    public static MemorySegment asn_DEF_RestrictionUserType() {
        return asn_DEF_RestrictionUserType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RestrictionUserType
     * }
     */
    public static void asn_DEF_RestrictionUserType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_RestrictionUserType$constants.SEGMENT, 0L, asn_DEF_RestrictionUserType$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_RestrictionUserType_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_CHOICE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_RestrictionUserType_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_RestrictionUserType_specs_1
     * }
     */
    public static GroupLayout asn_SPC_RestrictionUserType_specs_1$layout() {
        return asn_SPC_RestrictionUserType_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_RestrictionUserType_specs_1
     * }
     */
    public static MemorySegment asn_SPC_RestrictionUserType_specs_1() {
        return asn_SPC_RestrictionUserType_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_RestrictionUserType_specs_1
     * }
     */
    public static void asn_SPC_RestrictionUserType_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_RestrictionUserType_specs_1$constants.SEGMENT, 0L, asn_SPC_RestrictionUserType_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_RestrictionUserType_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_RestrictionUserType_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionUserType_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_RestrictionUserType_1$layout() {
        return asn_MBR_RestrictionUserType_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionUserType_1[2]
     * }
     */
    public static long[] asn_MBR_RestrictionUserType_1$dimensions() {
        return asn_MBR_RestrictionUserType_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionUserType_1[2]
     * }
     */
    public static MemorySegment asn_MBR_RestrictionUserType_1() {
        return asn_MBR_RestrictionUserType_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionUserType_1[2]
     * }
     */
    public static void asn_MBR_RestrictionUserType_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RestrictionUserType_1$constants.SEGMENT, 0L, asn_MBR_RestrictionUserType_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionUserType_1[2]
     * }
     */
    public static MemorySegment asn_MBR_RestrictionUserType_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_RestrictionUserType_1$constants.HANDLE.invokeExact(asn_MBR_RestrictionUserType_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionUserType_1[2]
     * }
     */
    public static void asn_MBR_RestrictionUserType_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RestrictionUserType_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_RestrictionUserType_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_RestrictionUserType_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RestrictionUserType_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_RestrictionUserType_constr_1$layout() {
        return asn_PER_type_RestrictionUserType_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RestrictionUserType_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_RestrictionUserType_constr_1() {
        return asn_PER_type_RestrictionUserType_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RestrictionUserType_constr_1
     * }
     */
    public static void asn_PER_type_RestrictionUserType_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_RestrictionUserType_constr_1$constants.SEGMENT, 0L, asn_PER_type_RestrictionUserType_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_RestrictionClassAssignment$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_RestrictionClassAssignment").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RestrictionClassAssignment
     * }
     */
    public static GroupLayout asn_DEF_RestrictionClassAssignment$layout() {
        return asn_DEF_RestrictionClassAssignment$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RestrictionClassAssignment
     * }
     */
    public static MemorySegment asn_DEF_RestrictionClassAssignment() {
        return asn_DEF_RestrictionClassAssignment$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RestrictionClassAssignment
     * }
     */
    public static void asn_DEF_RestrictionClassAssignment(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_RestrictionClassAssignment$constants.SEGMENT, 0L, asn_DEF_RestrictionClassAssignment$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_RestrictionClassAssignment_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_RestrictionClassAssignment_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RestrictionClassAssignment_specs_1
     * }
     */
    public static GroupLayout asn_SPC_RestrictionClassAssignment_specs_1$layout() {
        return asn_SPC_RestrictionClassAssignment_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RestrictionClassAssignment_specs_1
     * }
     */
    public static MemorySegment asn_SPC_RestrictionClassAssignment_specs_1() {
        return asn_SPC_RestrictionClassAssignment_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RestrictionClassAssignment_specs_1
     * }
     */
    public static void asn_SPC_RestrictionClassAssignment_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_RestrictionClassAssignment_specs_1$constants.SEGMENT, 0L, asn_SPC_RestrictionClassAssignment_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_RestrictionClassAssignment_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_RestrictionClassAssignment_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionClassAssignment_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_RestrictionClassAssignment_1$layout() {
        return asn_MBR_RestrictionClassAssignment_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionClassAssignment_1[2]
     * }
     */
    public static long[] asn_MBR_RestrictionClassAssignment_1$dimensions() {
        return asn_MBR_RestrictionClassAssignment_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionClassAssignment_1[2]
     * }
     */
    public static MemorySegment asn_MBR_RestrictionClassAssignment_1() {
        return asn_MBR_RestrictionClassAssignment_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionClassAssignment_1[2]
     * }
     */
    public static void asn_MBR_RestrictionClassAssignment_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RestrictionClassAssignment_1$constants.SEGMENT, 0L, asn_MBR_RestrictionClassAssignment_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionClassAssignment_1[2]
     * }
     */
    public static MemorySegment asn_MBR_RestrictionClassAssignment_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_RestrictionClassAssignment_1$constants.HANDLE.invokeExact(asn_MBR_RestrictionClassAssignment_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RestrictionClassAssignment_1[2]
     * }
     */
    public static void asn_MBR_RestrictionClassAssignment_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RestrictionClassAssignment_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_IntersectionStateList$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_IntersectionStateList").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_IntersectionStateList
     * }
     */
    public static GroupLayout asn_DEF_IntersectionStateList$layout() {
        return asn_DEF_IntersectionStateList$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_IntersectionStateList
     * }
     */
    public static MemorySegment asn_DEF_IntersectionStateList() {
        return asn_DEF_IntersectionStateList$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_IntersectionStateList
     * }
     */
    public static void asn_DEF_IntersectionStateList(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_IntersectionStateList$constants.SEGMENT, 0L, asn_DEF_IntersectionStateList$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_IntersectionStateList_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SET_OF_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_IntersectionStateList_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_IntersectionStateList_specs_1
     * }
     */
    public static GroupLayout asn_SPC_IntersectionStateList_specs_1$layout() {
        return asn_SPC_IntersectionStateList_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_IntersectionStateList_specs_1
     * }
     */
    public static MemorySegment asn_SPC_IntersectionStateList_specs_1() {
        return asn_SPC_IntersectionStateList_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_IntersectionStateList_specs_1
     * }
     */
    public static void asn_SPC_IntersectionStateList_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_IntersectionStateList_specs_1$constants.SEGMENT, 0L, asn_SPC_IntersectionStateList_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_IntersectionStateList_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(1, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_IntersectionStateList_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 1 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_IntersectionStateList_1[1]
     * }
     */
    public static SequenceLayout asn_MBR_IntersectionStateList_1$layout() {
        return asn_MBR_IntersectionStateList_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_IntersectionStateList_1[1]
     * }
     */
    public static long[] asn_MBR_IntersectionStateList_1$dimensions() {
        return asn_MBR_IntersectionStateList_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_IntersectionStateList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_IntersectionStateList_1() {
        return asn_MBR_IntersectionStateList_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_IntersectionStateList_1[1]
     * }
     */
    public static void asn_MBR_IntersectionStateList_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_IntersectionStateList_1$constants.SEGMENT, 0L, asn_MBR_IntersectionStateList_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_IntersectionStateList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_IntersectionStateList_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_IntersectionStateList_1$constants.HANDLE.invokeExact(asn_MBR_IntersectionStateList_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_IntersectionStateList_1[1]
     * }
     */
    public static void asn_MBR_IntersectionStateList_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_IntersectionStateList_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_IntersectionStateList_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_IntersectionStateList_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_IntersectionStateList_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_IntersectionStateList_constr_1$layout() {
        return asn_PER_type_IntersectionStateList_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_IntersectionStateList_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_IntersectionStateList_constr_1() {
        return asn_PER_type_IntersectionStateList_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_IntersectionStateList_constr_1
     * }
     */
    public static void asn_PER_type_IntersectionStateList_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_IntersectionStateList_constr_1$constants.SEGMENT, 0L, asn_PER_type_IntersectionStateList_constr_1$constants.LAYOUT.byteSize());
    }
    private static final int IntersectionStatusObject_manualControlIsEnabled = (int)0L;
    /**
     * {@snippet lang=c :
     * enum IntersectionStatusObject.IntersectionStatusObject_manualControlIsEnabled = 0
     * }
     */
    public static int IntersectionStatusObject_manualControlIsEnabled() {
        return IntersectionStatusObject_manualControlIsEnabled;
    }
    private static final int IntersectionStatusObject_stopTimeIsActivated = (int)1L;
    /**
     * {@snippet lang=c :
     * enum IntersectionStatusObject.IntersectionStatusObject_stopTimeIsActivated = 1
     * }
     */
    public static int IntersectionStatusObject_stopTimeIsActivated() {
        return IntersectionStatusObject_stopTimeIsActivated;
    }
    private static final int IntersectionStatusObject_failureFlash = (int)2L;
    /**
     * {@snippet lang=c :
     * enum IntersectionStatusObject.IntersectionStatusObject_failureFlash = 2
     * }
     */
    public static int IntersectionStatusObject_failureFlash() {
        return IntersectionStatusObject_failureFlash;
    }
    private static final int IntersectionStatusObject_preemptIsActive = (int)3L;
    /**
     * {@snippet lang=c :
     * enum IntersectionStatusObject.IntersectionStatusObject_preemptIsActive = 3
     * }
     */
    public static int IntersectionStatusObject_preemptIsActive() {
        return IntersectionStatusObject_preemptIsActive;
    }
    private static final int IntersectionStatusObject_signalPriorityIsActive = (int)4L;
    /**
     * {@snippet lang=c :
     * enum IntersectionStatusObject.IntersectionStatusObject_signalPriorityIsActive = 4
     * }
     */
    public static int IntersectionStatusObject_signalPriorityIsActive() {
        return IntersectionStatusObject_signalPriorityIsActive;
    }
    private static final int IntersectionStatusObject_fixedTimeOperation = (int)5L;
    /**
     * {@snippet lang=c :
     * enum IntersectionStatusObject.IntersectionStatusObject_fixedTimeOperation = 5
     * }
     */
    public static int IntersectionStatusObject_fixedTimeOperation() {
        return IntersectionStatusObject_fixedTimeOperation;
    }
    private static final int IntersectionStatusObject_trafficDependentOperation = (int)6L;
    /**
     * {@snippet lang=c :
     * enum IntersectionStatusObject.IntersectionStatusObject_trafficDependentOperation = 6
     * }
     */
    public static int IntersectionStatusObject_trafficDependentOperation() {
        return IntersectionStatusObject_trafficDependentOperation;
    }
    private static final int IntersectionStatusObject_standbyOperation = (int)7L;
    /**
     * {@snippet lang=c :
     * enum IntersectionStatusObject.IntersectionStatusObject_standbyOperation = 7
     * }
     */
    public static int IntersectionStatusObject_standbyOperation() {
        return IntersectionStatusObject_standbyOperation;
    }
    private static final int IntersectionStatusObject_failureMode = (int)8L;
    /**
     * {@snippet lang=c :
     * enum IntersectionStatusObject.IntersectionStatusObject_failureMode = 8
     * }
     */
    public static int IntersectionStatusObject_failureMode() {
        return IntersectionStatusObject_failureMode;
    }
    private static final int IntersectionStatusObject_off = (int)9L;
    /**
     * {@snippet lang=c :
     * enum IntersectionStatusObject.IntersectionStatusObject_off = 9
     * }
     */
    public static int IntersectionStatusObject_off() {
        return IntersectionStatusObject_off;
    }
    private static final int IntersectionStatusObject_recentMAPmessageUpdate = (int)10L;
    /**
     * {@snippet lang=c :
     * enum IntersectionStatusObject.IntersectionStatusObject_recentMAPmessageUpdate = 10
     * }
     */
    public static int IntersectionStatusObject_recentMAPmessageUpdate() {
        return IntersectionStatusObject_recentMAPmessageUpdate;
    }
    private static final int IntersectionStatusObject_recentChangeInMAPassignedLanesIDsUsed = (int)11L;
    /**
     * {@snippet lang=c :
     * enum IntersectionStatusObject.IntersectionStatusObject_recentChangeInMAPassignedLanesIDsUsed = 11
     * }
     */
    public static int IntersectionStatusObject_recentChangeInMAPassignedLanesIDsUsed() {
        return IntersectionStatusObject_recentChangeInMAPassignedLanesIDsUsed;
    }
    private static final int IntersectionStatusObject_noValidMAPisAvailableAtThisTime = (int)12L;
    /**
     * {@snippet lang=c :
     * enum IntersectionStatusObject.IntersectionStatusObject_noValidMAPisAvailableAtThisTime = 12
     * }
     */
    public static int IntersectionStatusObject_noValidMAPisAvailableAtThisTime() {
        return IntersectionStatusObject_noValidMAPisAvailableAtThisTime;
    }
    private static final int IntersectionStatusObject_noValidSPATisAvailableAtThisTime = (int)13L;
    /**
     * {@snippet lang=c :
     * enum IntersectionStatusObject.IntersectionStatusObject_noValidSPATisAvailableAtThisTime = 13
     * }
     */
    public static int IntersectionStatusObject_noValidSPATisAvailableAtThisTime() {
        return IntersectionStatusObject_noValidSPATisAvailableAtThisTime;
    }

    private static class asn_PER_type_IntersectionStatusObject_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_IntersectionStatusObject_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_IntersectionStatusObject_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_IntersectionStatusObject_constr_1$layout() {
        return asn_PER_type_IntersectionStatusObject_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_IntersectionStatusObject_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_IntersectionStatusObject_constr_1() {
        return asn_PER_type_IntersectionStatusObject_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_IntersectionStatusObject_constr_1
     * }
     */
    public static void asn_PER_type_IntersectionStatusObject_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_IntersectionStatusObject_constr_1$constants.SEGMENT, 0L, asn_PER_type_IntersectionStatusObject_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_IntersectionStatusObject$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_IntersectionStatusObject").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_IntersectionStatusObject
     * }
     */
    public static GroupLayout asn_DEF_IntersectionStatusObject$layout() {
        return asn_DEF_IntersectionStatusObject$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_IntersectionStatusObject
     * }
     */
    public static MemorySegment asn_DEF_IntersectionStatusObject() {
        return asn_DEF_IntersectionStatusObject$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_IntersectionStatusObject
     * }
     */
    public static void asn_DEF_IntersectionStatusObject(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_IntersectionStatusObject$constants.SEGMENT, 0L, asn_DEF_IntersectionStatusObject$constants.LAYOUT.byteSize());
    }

    private static class IntersectionStatusObject_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("IntersectionStatusObject_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void IntersectionStatusObject_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor IntersectionStatusObject_free$descriptor() {
        return IntersectionStatusObject_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void IntersectionStatusObject_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle IntersectionStatusObject_free$handle() {
        return IntersectionStatusObject_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void IntersectionStatusObject_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment IntersectionStatusObject_free$address() {
        return IntersectionStatusObject_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void IntersectionStatusObject_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void IntersectionStatusObject_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = IntersectionStatusObject_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IntersectionStatusObject_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IntersectionStatusObject_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("IntersectionStatusObject_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int IntersectionStatusObject_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor IntersectionStatusObject_print$descriptor() {
        return IntersectionStatusObject_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int IntersectionStatusObject_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle IntersectionStatusObject_print$handle() {
        return IntersectionStatusObject_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int IntersectionStatusObject_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment IntersectionStatusObject_print$address() {
        return IntersectionStatusObject_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int IntersectionStatusObject_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int IntersectionStatusObject_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = IntersectionStatusObject_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IntersectionStatusObject_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IntersectionStatusObject_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("IntersectionStatusObject_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int IntersectionStatusObject_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor IntersectionStatusObject_constraint$descriptor() {
        return IntersectionStatusObject_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int IntersectionStatusObject_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle IntersectionStatusObject_constraint$handle() {
        return IntersectionStatusObject_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int IntersectionStatusObject_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment IntersectionStatusObject_constraint$address() {
        return IntersectionStatusObject_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int IntersectionStatusObject_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int IntersectionStatusObject_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = IntersectionStatusObject_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IntersectionStatusObject_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IntersectionStatusObject_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("IntersectionStatusObject_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t IntersectionStatusObject_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor IntersectionStatusObject_decode_ber$descriptor() {
        return IntersectionStatusObject_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t IntersectionStatusObject_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle IntersectionStatusObject_decode_ber$handle() {
        return IntersectionStatusObject_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t IntersectionStatusObject_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment IntersectionStatusObject_decode_ber$address() {
        return IntersectionStatusObject_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t IntersectionStatusObject_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment IntersectionStatusObject_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = IntersectionStatusObject_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IntersectionStatusObject_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IntersectionStatusObject_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("IntersectionStatusObject_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor IntersectionStatusObject_encode_der$descriptor() {
        return IntersectionStatusObject_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle IntersectionStatusObject_encode_der$handle() {
        return IntersectionStatusObject_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment IntersectionStatusObject_encode_der$address() {
        return IntersectionStatusObject_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment IntersectionStatusObject_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = IntersectionStatusObject_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IntersectionStatusObject_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IntersectionStatusObject_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("IntersectionStatusObject_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t IntersectionStatusObject_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor IntersectionStatusObject_decode_xer$descriptor() {
        return IntersectionStatusObject_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t IntersectionStatusObject_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle IntersectionStatusObject_decode_xer$handle() {
        return IntersectionStatusObject_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t IntersectionStatusObject_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment IntersectionStatusObject_decode_xer$address() {
        return IntersectionStatusObject_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t IntersectionStatusObject_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment IntersectionStatusObject_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = IntersectionStatusObject_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IntersectionStatusObject_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IntersectionStatusObject_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("IntersectionStatusObject_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor IntersectionStatusObject_encode_xer$descriptor() {
        return IntersectionStatusObject_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle IntersectionStatusObject_encode_xer$handle() {
        return IntersectionStatusObject_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment IntersectionStatusObject_encode_xer$address() {
        return IntersectionStatusObject_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment IntersectionStatusObject_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = IntersectionStatusObject_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IntersectionStatusObject_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IntersectionStatusObject_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("IntersectionStatusObject_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor IntersectionStatusObject_encode_jer$descriptor() {
        return IntersectionStatusObject_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle IntersectionStatusObject_encode_jer$handle() {
        return IntersectionStatusObject_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment IntersectionStatusObject_encode_jer$address() {
        return IntersectionStatusObject_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment IntersectionStatusObject_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = IntersectionStatusObject_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IntersectionStatusObject_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IntersectionStatusObject_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("IntersectionStatusObject_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t IntersectionStatusObject_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor IntersectionStatusObject_decode_oer$descriptor() {
        return IntersectionStatusObject_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t IntersectionStatusObject_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle IntersectionStatusObject_decode_oer$handle() {
        return IntersectionStatusObject_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t IntersectionStatusObject_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment IntersectionStatusObject_decode_oer$address() {
        return IntersectionStatusObject_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t IntersectionStatusObject_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment IntersectionStatusObject_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = IntersectionStatusObject_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IntersectionStatusObject_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IntersectionStatusObject_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("IntersectionStatusObject_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor IntersectionStatusObject_encode_oer$descriptor() {
        return IntersectionStatusObject_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle IntersectionStatusObject_encode_oer$handle() {
        return IntersectionStatusObject_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment IntersectionStatusObject_encode_oer$address() {
        return IntersectionStatusObject_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment IntersectionStatusObject_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = IntersectionStatusObject_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IntersectionStatusObject_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IntersectionStatusObject_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("IntersectionStatusObject_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t IntersectionStatusObject_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor IntersectionStatusObject_decode_uper$descriptor() {
        return IntersectionStatusObject_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t IntersectionStatusObject_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle IntersectionStatusObject_decode_uper$handle() {
        return IntersectionStatusObject_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t IntersectionStatusObject_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment IntersectionStatusObject_decode_uper$address() {
        return IntersectionStatusObject_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t IntersectionStatusObject_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment IntersectionStatusObject_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = IntersectionStatusObject_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IntersectionStatusObject_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IntersectionStatusObject_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("IntersectionStatusObject_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor IntersectionStatusObject_encode_uper$descriptor() {
        return IntersectionStatusObject_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle IntersectionStatusObject_encode_uper$handle() {
        return IntersectionStatusObject_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment IntersectionStatusObject_encode_uper$address() {
        return IntersectionStatusObject_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment IntersectionStatusObject_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = IntersectionStatusObject_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IntersectionStatusObject_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IntersectionStatusObject_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("IntersectionStatusObject_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t IntersectionStatusObject_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor IntersectionStatusObject_decode_aper$descriptor() {
        return IntersectionStatusObject_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t IntersectionStatusObject_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle IntersectionStatusObject_decode_aper$handle() {
        return IntersectionStatusObject_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t IntersectionStatusObject_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment IntersectionStatusObject_decode_aper$address() {
        return IntersectionStatusObject_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t IntersectionStatusObject_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment IntersectionStatusObject_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = IntersectionStatusObject_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IntersectionStatusObject_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class IntersectionStatusObject_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("IntersectionStatusObject_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor IntersectionStatusObject_encode_aper$descriptor() {
        return IntersectionStatusObject_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle IntersectionStatusObject_encode_aper$handle() {
        return IntersectionStatusObject_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment IntersectionStatusObject_encode_aper$address() {
        return IntersectionStatusObject_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t IntersectionStatusObject_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment IntersectionStatusObject_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = IntersectionStatusObject_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("IntersectionStatusObject_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_MovementList$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_MovementList").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_MovementList
     * }
     */
    public static GroupLayout asn_DEF_MovementList$layout() {
        return asn_DEF_MovementList$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_MovementList
     * }
     */
    public static MemorySegment asn_DEF_MovementList() {
        return asn_DEF_MovementList$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_MovementList
     * }
     */
    public static void asn_DEF_MovementList(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_MovementList$constants.SEGMENT, 0L, asn_DEF_MovementList$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_MovementList_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SET_OF_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_MovementList_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_MovementList_specs_1
     * }
     */
    public static GroupLayout asn_SPC_MovementList_specs_1$layout() {
        return asn_SPC_MovementList_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_MovementList_specs_1
     * }
     */
    public static MemorySegment asn_SPC_MovementList_specs_1() {
        return asn_SPC_MovementList_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_MovementList_specs_1
     * }
     */
    public static void asn_SPC_MovementList_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_MovementList_specs_1$constants.SEGMENT, 0L, asn_SPC_MovementList_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_MovementList_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(1, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_MovementList_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 1 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementList_1[1]
     * }
     */
    public static SequenceLayout asn_MBR_MovementList_1$layout() {
        return asn_MBR_MovementList_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementList_1[1]
     * }
     */
    public static long[] asn_MBR_MovementList_1$dimensions() {
        return asn_MBR_MovementList_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_MovementList_1() {
        return asn_MBR_MovementList_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementList_1[1]
     * }
     */
    public static void asn_MBR_MovementList_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_MovementList_1$constants.SEGMENT, 0L, asn_MBR_MovementList_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_MovementList_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_MovementList_1$constants.HANDLE.invokeExact(asn_MBR_MovementList_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementList_1[1]
     * }
     */
    public static void asn_MBR_MovementList_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_MovementList_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_MovementList_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_MovementList_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_MovementList_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_MovementList_constr_1$layout() {
        return asn_PER_type_MovementList_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_MovementList_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_MovementList_constr_1() {
        return asn_PER_type_MovementList_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_MovementList_constr_1
     * }
     */
    public static void asn_PER_type_MovementList_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_MovementList_constr_1$constants.SEGMENT, 0L, asn_PER_type_MovementList_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_MovementEventList$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_MovementEventList").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_MovementEventList
     * }
     */
    public static GroupLayout asn_DEF_MovementEventList$layout() {
        return asn_DEF_MovementEventList$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_MovementEventList
     * }
     */
    public static MemorySegment asn_DEF_MovementEventList() {
        return asn_DEF_MovementEventList$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_MovementEventList
     * }
     */
    public static void asn_DEF_MovementEventList(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_MovementEventList$constants.SEGMENT, 0L, asn_DEF_MovementEventList$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_MovementEventList_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SET_OF_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_MovementEventList_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_MovementEventList_specs_1
     * }
     */
    public static GroupLayout asn_SPC_MovementEventList_specs_1$layout() {
        return asn_SPC_MovementEventList_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_MovementEventList_specs_1
     * }
     */
    public static MemorySegment asn_SPC_MovementEventList_specs_1() {
        return asn_SPC_MovementEventList_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_MovementEventList_specs_1
     * }
     */
    public static void asn_SPC_MovementEventList_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_MovementEventList_specs_1$constants.SEGMENT, 0L, asn_SPC_MovementEventList_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_MovementEventList_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(1, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_MovementEventList_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 1 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementEventList_1[1]
     * }
     */
    public static SequenceLayout asn_MBR_MovementEventList_1$layout() {
        return asn_MBR_MovementEventList_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementEventList_1[1]
     * }
     */
    public static long[] asn_MBR_MovementEventList_1$dimensions() {
        return asn_MBR_MovementEventList_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementEventList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_MovementEventList_1() {
        return asn_MBR_MovementEventList_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementEventList_1[1]
     * }
     */
    public static void asn_MBR_MovementEventList_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_MovementEventList_1$constants.SEGMENT, 0L, asn_MBR_MovementEventList_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementEventList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_MovementEventList_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_MovementEventList_1$constants.HANDLE.invokeExact(asn_MBR_MovementEventList_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementEventList_1[1]
     * }
     */
    public static void asn_MBR_MovementEventList_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_MovementEventList_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_MovementEventList_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_MovementEventList_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_MovementEventList_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_MovementEventList_constr_1$layout() {
        return asn_PER_type_MovementEventList_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_MovementEventList_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_MovementEventList_constr_1() {
        return asn_PER_type_MovementEventList_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_MovementEventList_constr_1
     * }
     */
    public static void asn_PER_type_MovementEventList_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_MovementEventList_constr_1$constants.SEGMENT, 0L, asn_PER_type_MovementEventList_constr_1$constants.LAYOUT.byteSize());
    }
    private static final int MovementPhaseState_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum MovementPhaseState.MovementPhaseState_unavailable = 0
     * }
     */
    public static int MovementPhaseState_unavailable() {
        return MovementPhaseState_unavailable;
    }
    private static final int MovementPhaseState_dark = (int)1L;
    /**
     * {@snippet lang=c :
     * enum MovementPhaseState.MovementPhaseState_dark = 1
     * }
     */
    public static int MovementPhaseState_dark() {
        return MovementPhaseState_dark;
    }
    private static final int MovementPhaseState_stop_Then_Proceed = (int)2L;
    /**
     * {@snippet lang=c :
     * enum MovementPhaseState.MovementPhaseState_stop_Then_Proceed = 2
     * }
     */
    public static int MovementPhaseState_stop_Then_Proceed() {
        return MovementPhaseState_stop_Then_Proceed;
    }
    private static final int MovementPhaseState_stop_And_Remain = (int)3L;
    /**
     * {@snippet lang=c :
     * enum MovementPhaseState.MovementPhaseState_stop_And_Remain = 3
     * }
     */
    public static int MovementPhaseState_stop_And_Remain() {
        return MovementPhaseState_stop_And_Remain;
    }
    private static final int MovementPhaseState_pre_Movement = (int)4L;
    /**
     * {@snippet lang=c :
     * enum MovementPhaseState.MovementPhaseState_pre_Movement = 4
     * }
     */
    public static int MovementPhaseState_pre_Movement() {
        return MovementPhaseState_pre_Movement;
    }
    private static final int MovementPhaseState_permissive_Movement_Allowed = (int)5L;
    /**
     * {@snippet lang=c :
     * enum MovementPhaseState.MovementPhaseState_permissive_Movement_Allowed = 5
     * }
     */
    public static int MovementPhaseState_permissive_Movement_Allowed() {
        return MovementPhaseState_permissive_Movement_Allowed;
    }
    private static final int MovementPhaseState_protected_Movement_Allowed = (int)6L;
    /**
     * {@snippet lang=c :
     * enum MovementPhaseState.MovementPhaseState_protected_Movement_Allowed = 6
     * }
     */
    public static int MovementPhaseState_protected_Movement_Allowed() {
        return MovementPhaseState_protected_Movement_Allowed;
    }
    private static final int MovementPhaseState_permissive_clearance = (int)7L;
    /**
     * {@snippet lang=c :
     * enum MovementPhaseState.MovementPhaseState_permissive_clearance = 7
     * }
     */
    public static int MovementPhaseState_permissive_clearance() {
        return MovementPhaseState_permissive_clearance;
    }
    private static final int MovementPhaseState_protected_clearance = (int)8L;
    /**
     * {@snippet lang=c :
     * enum MovementPhaseState.MovementPhaseState_protected_clearance = 8
     * }
     */
    public static int MovementPhaseState_protected_clearance() {
        return MovementPhaseState_protected_clearance;
    }
    private static final int MovementPhaseState_caution_Conflicting_Traffic = (int)9L;
    /**
     * {@snippet lang=c :
     * enum MovementPhaseState.MovementPhaseState_caution_Conflicting_Traffic = 9
     * }
     */
    public static int MovementPhaseState_caution_Conflicting_Traffic() {
        return MovementPhaseState_caution_Conflicting_Traffic;
    }
    /**
     * {@snippet lang=c :
     * typedef long MovementPhaseState_t
     * }
     */
    public static final OfLong MovementPhaseState_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_MovementPhaseState_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_MovementPhaseState_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_MovementPhaseState_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_MovementPhaseState_constr_1$layout() {
        return asn_PER_type_MovementPhaseState_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_MovementPhaseState_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_MovementPhaseState_constr_1() {
        return asn_PER_type_MovementPhaseState_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_MovementPhaseState_constr_1
     * }
     */
    public static void asn_PER_type_MovementPhaseState_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_MovementPhaseState_constr_1$constants.SEGMENT, 0L, asn_PER_type_MovementPhaseState_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_MovementPhaseState$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_MovementPhaseState").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_MovementPhaseState
     * }
     */
    public static GroupLayout asn_DEF_MovementPhaseState$layout() {
        return asn_DEF_MovementPhaseState$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_MovementPhaseState
     * }
     */
    public static MemorySegment asn_DEF_MovementPhaseState() {
        return asn_DEF_MovementPhaseState$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_MovementPhaseState
     * }
     */
    public static void asn_DEF_MovementPhaseState(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_MovementPhaseState$constants.SEGMENT, 0L, asn_DEF_MovementPhaseState$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_MovementPhaseState_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_MovementPhaseState_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_MovementPhaseState_specs_1
     * }
     */
    public static GroupLayout asn_SPC_MovementPhaseState_specs_1$layout() {
        return asn_SPC_MovementPhaseState_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_MovementPhaseState_specs_1
     * }
     */
    public static MemorySegment asn_SPC_MovementPhaseState_specs_1() {
        return asn_SPC_MovementPhaseState_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_MovementPhaseState_specs_1
     * }
     */
    public static void asn_SPC_MovementPhaseState_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_MovementPhaseState_specs_1$constants.SEGMENT, 0L, asn_SPC_MovementPhaseState_specs_1$constants.LAYOUT.byteSize());
    }

    private static class MovementPhaseState_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MovementPhaseState_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void MovementPhaseState_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor MovementPhaseState_free$descriptor() {
        return MovementPhaseState_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void MovementPhaseState_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle MovementPhaseState_free$handle() {
        return MovementPhaseState_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void MovementPhaseState_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment MovementPhaseState_free$address() {
        return MovementPhaseState_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void MovementPhaseState_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void MovementPhaseState_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = MovementPhaseState_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MovementPhaseState_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MovementPhaseState_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MovementPhaseState_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MovementPhaseState_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor MovementPhaseState_print$descriptor() {
        return MovementPhaseState_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MovementPhaseState_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle MovementPhaseState_print$handle() {
        return MovementPhaseState_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int MovementPhaseState_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment MovementPhaseState_print$address() {
        return MovementPhaseState_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int MovementPhaseState_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int MovementPhaseState_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = MovementPhaseState_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MovementPhaseState_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MovementPhaseState_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MovementPhaseState_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int MovementPhaseState_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor MovementPhaseState_constraint$descriptor() {
        return MovementPhaseState_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int MovementPhaseState_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle MovementPhaseState_constraint$handle() {
        return MovementPhaseState_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int MovementPhaseState_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment MovementPhaseState_constraint$address() {
        return MovementPhaseState_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int MovementPhaseState_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int MovementPhaseState_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = MovementPhaseState_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MovementPhaseState_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MovementPhaseState_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MovementPhaseState_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t MovementPhaseState_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor MovementPhaseState_decode_ber$descriptor() {
        return MovementPhaseState_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t MovementPhaseState_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle MovementPhaseState_decode_ber$handle() {
        return MovementPhaseState_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t MovementPhaseState_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment MovementPhaseState_decode_ber$address() {
        return MovementPhaseState_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t MovementPhaseState_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment MovementPhaseState_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = MovementPhaseState_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MovementPhaseState_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MovementPhaseState_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MovementPhaseState_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor MovementPhaseState_encode_der$descriptor() {
        return MovementPhaseState_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle MovementPhaseState_encode_der$handle() {
        return MovementPhaseState_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment MovementPhaseState_encode_der$address() {
        return MovementPhaseState_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment MovementPhaseState_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = MovementPhaseState_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MovementPhaseState_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MovementPhaseState_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MovementPhaseState_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t MovementPhaseState_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor MovementPhaseState_decode_xer$descriptor() {
        return MovementPhaseState_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t MovementPhaseState_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle MovementPhaseState_decode_xer$handle() {
        return MovementPhaseState_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t MovementPhaseState_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment MovementPhaseState_decode_xer$address() {
        return MovementPhaseState_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t MovementPhaseState_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment MovementPhaseState_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = MovementPhaseState_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MovementPhaseState_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MovementPhaseState_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MovementPhaseState_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor MovementPhaseState_encode_xer$descriptor() {
        return MovementPhaseState_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle MovementPhaseState_encode_xer$handle() {
        return MovementPhaseState_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment MovementPhaseState_encode_xer$address() {
        return MovementPhaseState_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment MovementPhaseState_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = MovementPhaseState_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MovementPhaseState_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MovementPhaseState_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MovementPhaseState_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor MovementPhaseState_encode_jer$descriptor() {
        return MovementPhaseState_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle MovementPhaseState_encode_jer$handle() {
        return MovementPhaseState_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment MovementPhaseState_encode_jer$address() {
        return MovementPhaseState_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment MovementPhaseState_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = MovementPhaseState_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MovementPhaseState_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MovementPhaseState_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MovementPhaseState_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t MovementPhaseState_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor MovementPhaseState_decode_oer$descriptor() {
        return MovementPhaseState_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t MovementPhaseState_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle MovementPhaseState_decode_oer$handle() {
        return MovementPhaseState_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t MovementPhaseState_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment MovementPhaseState_decode_oer$address() {
        return MovementPhaseState_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t MovementPhaseState_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment MovementPhaseState_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = MovementPhaseState_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MovementPhaseState_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MovementPhaseState_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MovementPhaseState_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor MovementPhaseState_encode_oer$descriptor() {
        return MovementPhaseState_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle MovementPhaseState_encode_oer$handle() {
        return MovementPhaseState_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment MovementPhaseState_encode_oer$address() {
        return MovementPhaseState_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment MovementPhaseState_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = MovementPhaseState_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MovementPhaseState_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MovementPhaseState_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MovementPhaseState_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t MovementPhaseState_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor MovementPhaseState_decode_uper$descriptor() {
        return MovementPhaseState_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t MovementPhaseState_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle MovementPhaseState_decode_uper$handle() {
        return MovementPhaseState_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t MovementPhaseState_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment MovementPhaseState_decode_uper$address() {
        return MovementPhaseState_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t MovementPhaseState_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment MovementPhaseState_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = MovementPhaseState_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MovementPhaseState_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MovementPhaseState_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MovementPhaseState_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor MovementPhaseState_encode_uper$descriptor() {
        return MovementPhaseState_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle MovementPhaseState_encode_uper$handle() {
        return MovementPhaseState_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment MovementPhaseState_encode_uper$address() {
        return MovementPhaseState_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment MovementPhaseState_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = MovementPhaseState_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MovementPhaseState_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MovementPhaseState_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MovementPhaseState_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t MovementPhaseState_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor MovementPhaseState_decode_aper$descriptor() {
        return MovementPhaseState_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t MovementPhaseState_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle MovementPhaseState_decode_aper$handle() {
        return MovementPhaseState_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t MovementPhaseState_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment MovementPhaseState_decode_aper$address() {
        return MovementPhaseState_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t MovementPhaseState_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment MovementPhaseState_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = MovementPhaseState_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MovementPhaseState_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class MovementPhaseState_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("MovementPhaseState_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor MovementPhaseState_encode_aper$descriptor() {
        return MovementPhaseState_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle MovementPhaseState_encode_aper$handle() {
        return MovementPhaseState_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment MovementPhaseState_encode_aper$address() {
        return MovementPhaseState_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t MovementPhaseState_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment MovementPhaseState_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = MovementPhaseState_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("MovementPhaseState_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_MovementEvent$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_MovementEvent").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_MovementEvent
     * }
     */
    public static GroupLayout asn_DEF_MovementEvent$layout() {
        return asn_DEF_MovementEvent$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_MovementEvent
     * }
     */
    public static MemorySegment asn_DEF_MovementEvent() {
        return asn_DEF_MovementEvent$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_MovementEvent
     * }
     */
    public static void asn_DEF_MovementEvent(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_MovementEvent$constants.SEGMENT, 0L, asn_DEF_MovementEvent$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_MovementEvent_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_MovementEvent_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_MovementEvent_specs_1
     * }
     */
    public static GroupLayout asn_SPC_MovementEvent_specs_1$layout() {
        return asn_SPC_MovementEvent_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_MovementEvent_specs_1
     * }
     */
    public static MemorySegment asn_SPC_MovementEvent_specs_1() {
        return asn_SPC_MovementEvent_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_MovementEvent_specs_1
     * }
     */
    public static void asn_SPC_MovementEvent_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_MovementEvent_specs_1$constants.SEGMENT, 0L, asn_SPC_MovementEvent_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_MovementEvent_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(4, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_MovementEvent_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 4 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementEvent_1[4]
     * }
     */
    public static SequenceLayout asn_MBR_MovementEvent_1$layout() {
        return asn_MBR_MovementEvent_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementEvent_1[4]
     * }
     */
    public static long[] asn_MBR_MovementEvent_1$dimensions() {
        return asn_MBR_MovementEvent_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementEvent_1[4]
     * }
     */
    public static MemorySegment asn_MBR_MovementEvent_1() {
        return asn_MBR_MovementEvent_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementEvent_1[4]
     * }
     */
    public static void asn_MBR_MovementEvent_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_MovementEvent_1$constants.SEGMENT, 0L, asn_MBR_MovementEvent_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementEvent_1[4]
     * }
     */
    public static MemorySegment asn_MBR_MovementEvent_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_MovementEvent_1$constants.HANDLE.invokeExact(asn_MBR_MovementEvent_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementEvent_1[4]
     * }
     */
    public static void asn_MBR_MovementEvent_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_MovementEvent_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef long SPAT_TimeMark_t
     * }
     */
    public static final OfLong SPAT_TimeMark_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_SPAT_TimeMark_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_SPAT_TimeMark_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SPAT_TimeMark_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_SPAT_TimeMark_constr_1$layout() {
        return asn_PER_type_SPAT_TimeMark_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SPAT_TimeMark_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_SPAT_TimeMark_constr_1() {
        return asn_PER_type_SPAT_TimeMark_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SPAT_TimeMark_constr_1
     * }
     */
    public static void asn_PER_type_SPAT_TimeMark_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_SPAT_TimeMark_constr_1$constants.SEGMENT, 0L, asn_PER_type_SPAT_TimeMark_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_SPAT_TimeMark$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_SPAT_TimeMark").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SPAT_TimeMark
     * }
     */
    public static GroupLayout asn_DEF_SPAT_TimeMark$layout() {
        return asn_DEF_SPAT_TimeMark$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SPAT_TimeMark
     * }
     */
    public static MemorySegment asn_DEF_SPAT_TimeMark() {
        return asn_DEF_SPAT_TimeMark$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SPAT_TimeMark
     * }
     */
    public static void asn_DEF_SPAT_TimeMark(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_SPAT_TimeMark$constants.SEGMENT, 0L, asn_DEF_SPAT_TimeMark$constants.LAYOUT.byteSize());
    }

    private static class SPAT_TimeMark_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SPAT_TimeMark_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SPAT_TimeMark_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor SPAT_TimeMark_free$descriptor() {
        return SPAT_TimeMark_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SPAT_TimeMark_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle SPAT_TimeMark_free$handle() {
        return SPAT_TimeMark_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SPAT_TimeMark_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment SPAT_TimeMark_free$address() {
        return SPAT_TimeMark_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SPAT_TimeMark_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void SPAT_TimeMark_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = SPAT_TimeMark_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SPAT_TimeMark_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SPAT_TimeMark_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SPAT_TimeMark_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SPAT_TimeMark_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SPAT_TimeMark_print$descriptor() {
        return SPAT_TimeMark_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SPAT_TimeMark_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SPAT_TimeMark_print$handle() {
        return SPAT_TimeMark_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SPAT_TimeMark_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SPAT_TimeMark_print$address() {
        return SPAT_TimeMark_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SPAT_TimeMark_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int SPAT_TimeMark_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SPAT_TimeMark_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SPAT_TimeMark_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SPAT_TimeMark_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SPAT_TimeMark_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SPAT_TimeMark_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor SPAT_TimeMark_constraint$descriptor() {
        return SPAT_TimeMark_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SPAT_TimeMark_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle SPAT_TimeMark_constraint$handle() {
        return SPAT_TimeMark_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SPAT_TimeMark_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment SPAT_TimeMark_constraint$address() {
        return SPAT_TimeMark_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SPAT_TimeMark_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int SPAT_TimeMark_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SPAT_TimeMark_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SPAT_TimeMark_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SPAT_TimeMark_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SPAT_TimeMark_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SPAT_TimeMark_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor SPAT_TimeMark_decode_ber$descriptor() {
        return SPAT_TimeMark_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SPAT_TimeMark_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle SPAT_TimeMark_decode_ber$handle() {
        return SPAT_TimeMark_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SPAT_TimeMark_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SPAT_TimeMark_decode_ber$address() {
        return SPAT_TimeMark_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SPAT_TimeMark_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SPAT_TimeMark_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = SPAT_TimeMark_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SPAT_TimeMark_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SPAT_TimeMark_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SPAT_TimeMark_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SPAT_TimeMark_encode_der$descriptor() {
        return SPAT_TimeMark_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SPAT_TimeMark_encode_der$handle() {
        return SPAT_TimeMark_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SPAT_TimeMark_encode_der$address() {
        return SPAT_TimeMark_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SPAT_TimeMark_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SPAT_TimeMark_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SPAT_TimeMark_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SPAT_TimeMark_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SPAT_TimeMark_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SPAT_TimeMark_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SPAT_TimeMark_decode_xer$descriptor() {
        return SPAT_TimeMark_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SPAT_TimeMark_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle SPAT_TimeMark_decode_xer$handle() {
        return SPAT_TimeMark_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SPAT_TimeMark_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SPAT_TimeMark_decode_xer$address() {
        return SPAT_TimeMark_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SPAT_TimeMark_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SPAT_TimeMark_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SPAT_TimeMark_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SPAT_TimeMark_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SPAT_TimeMark_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SPAT_TimeMark_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SPAT_TimeMark_encode_xer$descriptor() {
        return SPAT_TimeMark_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SPAT_TimeMark_encode_xer$handle() {
        return SPAT_TimeMark_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SPAT_TimeMark_encode_xer$address() {
        return SPAT_TimeMark_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SPAT_TimeMark_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SPAT_TimeMark_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SPAT_TimeMark_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SPAT_TimeMark_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SPAT_TimeMark_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SPAT_TimeMark_encode_jer$descriptor() {
        return SPAT_TimeMark_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SPAT_TimeMark_encode_jer$handle() {
        return SPAT_TimeMark_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SPAT_TimeMark_encode_jer$address() {
        return SPAT_TimeMark_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SPAT_TimeMark_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = SPAT_TimeMark_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SPAT_TimeMark_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SPAT_TimeMark_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SPAT_TimeMark_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SPAT_TimeMark_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SPAT_TimeMark_decode_oer$descriptor() {
        return SPAT_TimeMark_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SPAT_TimeMark_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle SPAT_TimeMark_decode_oer$handle() {
        return SPAT_TimeMark_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SPAT_TimeMark_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SPAT_TimeMark_decode_oer$address() {
        return SPAT_TimeMark_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SPAT_TimeMark_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SPAT_TimeMark_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SPAT_TimeMark_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SPAT_TimeMark_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SPAT_TimeMark_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SPAT_TimeMark_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SPAT_TimeMark_encode_oer$descriptor() {
        return SPAT_TimeMark_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SPAT_TimeMark_encode_oer$handle() {
        return SPAT_TimeMark_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SPAT_TimeMark_encode_oer$address() {
        return SPAT_TimeMark_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SPAT_TimeMark_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SPAT_TimeMark_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SPAT_TimeMark_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SPAT_TimeMark_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SPAT_TimeMark_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SPAT_TimeMark_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SPAT_TimeMark_decode_uper$descriptor() {
        return SPAT_TimeMark_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SPAT_TimeMark_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SPAT_TimeMark_decode_uper$handle() {
        return SPAT_TimeMark_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SPAT_TimeMark_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SPAT_TimeMark_decode_uper$address() {
        return SPAT_TimeMark_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SPAT_TimeMark_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SPAT_TimeMark_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SPAT_TimeMark_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SPAT_TimeMark_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SPAT_TimeMark_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SPAT_TimeMark_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SPAT_TimeMark_encode_uper$descriptor() {
        return SPAT_TimeMark_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SPAT_TimeMark_encode_uper$handle() {
        return SPAT_TimeMark_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SPAT_TimeMark_encode_uper$address() {
        return SPAT_TimeMark_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SPAT_TimeMark_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SPAT_TimeMark_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SPAT_TimeMark_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SPAT_TimeMark_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SPAT_TimeMark_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SPAT_TimeMark_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SPAT_TimeMark_decode_aper$descriptor() {
        return SPAT_TimeMark_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SPAT_TimeMark_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SPAT_TimeMark_decode_aper$handle() {
        return SPAT_TimeMark_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SPAT_TimeMark_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SPAT_TimeMark_decode_aper$address() {
        return SPAT_TimeMark_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SPAT_TimeMark_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SPAT_TimeMark_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SPAT_TimeMark_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SPAT_TimeMark_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SPAT_TimeMark_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SPAT_TimeMark_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SPAT_TimeMark_encode_aper$descriptor() {
        return SPAT_TimeMark_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SPAT_TimeMark_encode_aper$handle() {
        return SPAT_TimeMark_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SPAT_TimeMark_encode_aper$address() {
        return SPAT_TimeMark_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SPAT_TimeMark_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SPAT_TimeMark_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SPAT_TimeMark_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SPAT_TimeMark_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_TimeChangeDetails$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_TimeChangeDetails").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TimeChangeDetails
     * }
     */
    public static GroupLayout asn_DEF_TimeChangeDetails$layout() {
        return asn_DEF_TimeChangeDetails$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TimeChangeDetails
     * }
     */
    public static MemorySegment asn_DEF_TimeChangeDetails() {
        return asn_DEF_TimeChangeDetails$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TimeChangeDetails
     * }
     */
    public static void asn_DEF_TimeChangeDetails(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_TimeChangeDetails$constants.SEGMENT, 0L, asn_DEF_TimeChangeDetails$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_TimeChangeDetails_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_TimeChangeDetails_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_TimeChangeDetails_specs_1
     * }
     */
    public static GroupLayout asn_SPC_TimeChangeDetails_specs_1$layout() {
        return asn_SPC_TimeChangeDetails_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_TimeChangeDetails_specs_1
     * }
     */
    public static MemorySegment asn_SPC_TimeChangeDetails_specs_1() {
        return asn_SPC_TimeChangeDetails_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_TimeChangeDetails_specs_1
     * }
     */
    public static void asn_SPC_TimeChangeDetails_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_TimeChangeDetails_specs_1$constants.SEGMENT, 0L, asn_SPC_TimeChangeDetails_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_TimeChangeDetails_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(6, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_TimeChangeDetails_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 6 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TimeChangeDetails_1[6]
     * }
     */
    public static SequenceLayout asn_MBR_TimeChangeDetails_1$layout() {
        return asn_MBR_TimeChangeDetails_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TimeChangeDetails_1[6]
     * }
     */
    public static long[] asn_MBR_TimeChangeDetails_1$dimensions() {
        return asn_MBR_TimeChangeDetails_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TimeChangeDetails_1[6]
     * }
     */
    public static MemorySegment asn_MBR_TimeChangeDetails_1() {
        return asn_MBR_TimeChangeDetails_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TimeChangeDetails_1[6]
     * }
     */
    public static void asn_MBR_TimeChangeDetails_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_TimeChangeDetails_1$constants.SEGMENT, 0L, asn_MBR_TimeChangeDetails_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TimeChangeDetails_1[6]
     * }
     */
    public static MemorySegment asn_MBR_TimeChangeDetails_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_TimeChangeDetails_1$constants.HANDLE.invokeExact(asn_MBR_TimeChangeDetails_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TimeChangeDetails_1[6]
     * }
     */
    public static void asn_MBR_TimeChangeDetails_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_TimeChangeDetails_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_AdvisorySpeedList$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_AdvisorySpeedList").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AdvisorySpeedList
     * }
     */
    public static GroupLayout asn_DEF_AdvisorySpeedList$layout() {
        return asn_DEF_AdvisorySpeedList$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AdvisorySpeedList
     * }
     */
    public static MemorySegment asn_DEF_AdvisorySpeedList() {
        return asn_DEF_AdvisorySpeedList$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AdvisorySpeedList
     * }
     */
    public static void asn_DEF_AdvisorySpeedList(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_AdvisorySpeedList$constants.SEGMENT, 0L, asn_DEF_AdvisorySpeedList$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_AdvisorySpeedList_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SET_OF_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_AdvisorySpeedList_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_AdvisorySpeedList_specs_1
     * }
     */
    public static GroupLayout asn_SPC_AdvisorySpeedList_specs_1$layout() {
        return asn_SPC_AdvisorySpeedList_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_AdvisorySpeedList_specs_1
     * }
     */
    public static MemorySegment asn_SPC_AdvisorySpeedList_specs_1() {
        return asn_SPC_AdvisorySpeedList_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_AdvisorySpeedList_specs_1
     * }
     */
    public static void asn_SPC_AdvisorySpeedList_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_AdvisorySpeedList_specs_1$constants.SEGMENT, 0L, asn_SPC_AdvisorySpeedList_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_AdvisorySpeedList_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(1, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_AdvisorySpeedList_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 1 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AdvisorySpeedList_1[1]
     * }
     */
    public static SequenceLayout asn_MBR_AdvisorySpeedList_1$layout() {
        return asn_MBR_AdvisorySpeedList_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AdvisorySpeedList_1[1]
     * }
     */
    public static long[] asn_MBR_AdvisorySpeedList_1$dimensions() {
        return asn_MBR_AdvisorySpeedList_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AdvisorySpeedList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_AdvisorySpeedList_1() {
        return asn_MBR_AdvisorySpeedList_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AdvisorySpeedList_1[1]
     * }
     */
    public static void asn_MBR_AdvisorySpeedList_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_AdvisorySpeedList_1$constants.SEGMENT, 0L, asn_MBR_AdvisorySpeedList_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AdvisorySpeedList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_AdvisorySpeedList_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_AdvisorySpeedList_1$constants.HANDLE.invokeExact(asn_MBR_AdvisorySpeedList_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AdvisorySpeedList_1[1]
     * }
     */
    public static void asn_MBR_AdvisorySpeedList_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_AdvisorySpeedList_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_AdvisorySpeedList_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_AdvisorySpeedList_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AdvisorySpeedList_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_AdvisorySpeedList_constr_1$layout() {
        return asn_PER_type_AdvisorySpeedList_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AdvisorySpeedList_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_AdvisorySpeedList_constr_1() {
        return asn_PER_type_AdvisorySpeedList_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AdvisorySpeedList_constr_1
     * }
     */
    public static void asn_PER_type_AdvisorySpeedList_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_AdvisorySpeedList_constr_1$constants.SEGMENT, 0L, asn_PER_type_AdvisorySpeedList_constr_1$constants.LAYOUT.byteSize());
    }
    private static final int AdvisorySpeedType_none = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AdvisorySpeedType.AdvisorySpeedType_none = 0
     * }
     */
    public static int AdvisorySpeedType_none() {
        return AdvisorySpeedType_none;
    }
    private static final int AdvisorySpeedType_greenwave = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AdvisorySpeedType.AdvisorySpeedType_greenwave = 1
     * }
     */
    public static int AdvisorySpeedType_greenwave() {
        return AdvisorySpeedType_greenwave;
    }
    private static final int AdvisorySpeedType_ecoDrive = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AdvisorySpeedType.AdvisorySpeedType_ecoDrive = 2
     * }
     */
    public static int AdvisorySpeedType_ecoDrive() {
        return AdvisorySpeedType_ecoDrive;
    }
    private static final int AdvisorySpeedType_transit = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AdvisorySpeedType.AdvisorySpeedType_transit = 3
     * }
     */
    public static int AdvisorySpeedType_transit() {
        return AdvisorySpeedType_transit;
    }
    /**
     * {@snippet lang=c :
     * typedef long AdvisorySpeedType_t
     * }
     */
    public static final OfLong AdvisorySpeedType_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_AdvisorySpeedType_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_AdvisorySpeedType_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AdvisorySpeedType_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_AdvisorySpeedType_constr_1$layout() {
        return asn_PER_type_AdvisorySpeedType_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AdvisorySpeedType_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_AdvisorySpeedType_constr_1() {
        return asn_PER_type_AdvisorySpeedType_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AdvisorySpeedType_constr_1
     * }
     */
    public static void asn_PER_type_AdvisorySpeedType_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_AdvisorySpeedType_constr_1$constants.SEGMENT, 0L, asn_PER_type_AdvisorySpeedType_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_AdvisorySpeedType$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_AdvisorySpeedType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AdvisorySpeedType
     * }
     */
    public static GroupLayout asn_DEF_AdvisorySpeedType$layout() {
        return asn_DEF_AdvisorySpeedType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AdvisorySpeedType
     * }
     */
    public static MemorySegment asn_DEF_AdvisorySpeedType() {
        return asn_DEF_AdvisorySpeedType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AdvisorySpeedType
     * }
     */
    public static void asn_DEF_AdvisorySpeedType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_AdvisorySpeedType$constants.SEGMENT, 0L, asn_DEF_AdvisorySpeedType$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_AdvisorySpeedType_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_AdvisorySpeedType_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_AdvisorySpeedType_specs_1
     * }
     */
    public static GroupLayout asn_SPC_AdvisorySpeedType_specs_1$layout() {
        return asn_SPC_AdvisorySpeedType_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_AdvisorySpeedType_specs_1
     * }
     */
    public static MemorySegment asn_SPC_AdvisorySpeedType_specs_1() {
        return asn_SPC_AdvisorySpeedType_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_AdvisorySpeedType_specs_1
     * }
     */
    public static void asn_SPC_AdvisorySpeedType_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_AdvisorySpeedType_specs_1$constants.SEGMENT, 0L, asn_SPC_AdvisorySpeedType_specs_1$constants.LAYOUT.byteSize());
    }

    private static class AdvisorySpeedType_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AdvisorySpeedType_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void AdvisorySpeedType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor AdvisorySpeedType_free$descriptor() {
        return AdvisorySpeedType_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void AdvisorySpeedType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle AdvisorySpeedType_free$handle() {
        return AdvisorySpeedType_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void AdvisorySpeedType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment AdvisorySpeedType_free$address() {
        return AdvisorySpeedType_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void AdvisorySpeedType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void AdvisorySpeedType_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = AdvisorySpeedType_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdvisorySpeedType_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdvisorySpeedType_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AdvisorySpeedType_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AdvisorySpeedType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AdvisorySpeedType_print$descriptor() {
        return AdvisorySpeedType_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AdvisorySpeedType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AdvisorySpeedType_print$handle() {
        return AdvisorySpeedType_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AdvisorySpeedType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AdvisorySpeedType_print$address() {
        return AdvisorySpeedType_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AdvisorySpeedType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int AdvisorySpeedType_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AdvisorySpeedType_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdvisorySpeedType_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdvisorySpeedType_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AdvisorySpeedType_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AdvisorySpeedType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor AdvisorySpeedType_constraint$descriptor() {
        return AdvisorySpeedType_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AdvisorySpeedType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle AdvisorySpeedType_constraint$handle() {
        return AdvisorySpeedType_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AdvisorySpeedType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment AdvisorySpeedType_constraint$address() {
        return AdvisorySpeedType_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AdvisorySpeedType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int AdvisorySpeedType_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = AdvisorySpeedType_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdvisorySpeedType_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdvisorySpeedType_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AdvisorySpeedType_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AdvisorySpeedType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor AdvisorySpeedType_decode_ber$descriptor() {
        return AdvisorySpeedType_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AdvisorySpeedType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle AdvisorySpeedType_decode_ber$handle() {
        return AdvisorySpeedType_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AdvisorySpeedType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment AdvisorySpeedType_decode_ber$address() {
        return AdvisorySpeedType_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AdvisorySpeedType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment AdvisorySpeedType_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = AdvisorySpeedType_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdvisorySpeedType_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdvisorySpeedType_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AdvisorySpeedType_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AdvisorySpeedType_encode_der$descriptor() {
        return AdvisorySpeedType_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AdvisorySpeedType_encode_der$handle() {
        return AdvisorySpeedType_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AdvisorySpeedType_encode_der$address() {
        return AdvisorySpeedType_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AdvisorySpeedType_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = AdvisorySpeedType_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdvisorySpeedType_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdvisorySpeedType_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AdvisorySpeedType_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AdvisorySpeedType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor AdvisorySpeedType_decode_xer$descriptor() {
        return AdvisorySpeedType_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AdvisorySpeedType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle AdvisorySpeedType_decode_xer$handle() {
        return AdvisorySpeedType_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AdvisorySpeedType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment AdvisorySpeedType_decode_xer$address() {
        return AdvisorySpeedType_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AdvisorySpeedType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment AdvisorySpeedType_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = AdvisorySpeedType_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdvisorySpeedType_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdvisorySpeedType_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AdvisorySpeedType_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AdvisorySpeedType_encode_xer$descriptor() {
        return AdvisorySpeedType_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AdvisorySpeedType_encode_xer$handle() {
        return AdvisorySpeedType_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AdvisorySpeedType_encode_xer$address() {
        return AdvisorySpeedType_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AdvisorySpeedType_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = AdvisorySpeedType_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdvisorySpeedType_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdvisorySpeedType_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AdvisorySpeedType_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AdvisorySpeedType_encode_jer$descriptor() {
        return AdvisorySpeedType_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AdvisorySpeedType_encode_jer$handle() {
        return AdvisorySpeedType_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AdvisorySpeedType_encode_jer$address() {
        return AdvisorySpeedType_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AdvisorySpeedType_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = AdvisorySpeedType_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdvisorySpeedType_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdvisorySpeedType_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AdvisorySpeedType_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AdvisorySpeedType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor AdvisorySpeedType_decode_oer$descriptor() {
        return AdvisorySpeedType_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AdvisorySpeedType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle AdvisorySpeedType_decode_oer$handle() {
        return AdvisorySpeedType_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AdvisorySpeedType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment AdvisorySpeedType_decode_oer$address() {
        return AdvisorySpeedType_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AdvisorySpeedType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment AdvisorySpeedType_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = AdvisorySpeedType_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdvisorySpeedType_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdvisorySpeedType_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AdvisorySpeedType_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AdvisorySpeedType_encode_oer$descriptor() {
        return AdvisorySpeedType_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AdvisorySpeedType_encode_oer$handle() {
        return AdvisorySpeedType_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AdvisorySpeedType_encode_oer$address() {
        return AdvisorySpeedType_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AdvisorySpeedType_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AdvisorySpeedType_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdvisorySpeedType_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdvisorySpeedType_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AdvisorySpeedType_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AdvisorySpeedType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor AdvisorySpeedType_decode_uper$descriptor() {
        return AdvisorySpeedType_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AdvisorySpeedType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle AdvisorySpeedType_decode_uper$handle() {
        return AdvisorySpeedType_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AdvisorySpeedType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AdvisorySpeedType_decode_uper$address() {
        return AdvisorySpeedType_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AdvisorySpeedType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AdvisorySpeedType_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AdvisorySpeedType_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdvisorySpeedType_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdvisorySpeedType_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AdvisorySpeedType_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor AdvisorySpeedType_encode_uper$descriptor() {
        return AdvisorySpeedType_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle AdvisorySpeedType_encode_uper$handle() {
        return AdvisorySpeedType_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AdvisorySpeedType_encode_uper$address() {
        return AdvisorySpeedType_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AdvisorySpeedType_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = AdvisorySpeedType_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdvisorySpeedType_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdvisorySpeedType_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AdvisorySpeedType_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AdvisorySpeedType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor AdvisorySpeedType_decode_aper$descriptor() {
        return AdvisorySpeedType_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AdvisorySpeedType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle AdvisorySpeedType_decode_aper$handle() {
        return AdvisorySpeedType_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AdvisorySpeedType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AdvisorySpeedType_decode_aper$address() {
        return AdvisorySpeedType_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AdvisorySpeedType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AdvisorySpeedType_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AdvisorySpeedType_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdvisorySpeedType_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AdvisorySpeedType_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AdvisorySpeedType_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor AdvisorySpeedType_encode_aper$descriptor() {
        return AdvisorySpeedType_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle AdvisorySpeedType_encode_aper$handle() {
        return AdvisorySpeedType_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AdvisorySpeedType_encode_aper$address() {
        return AdvisorySpeedType_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AdvisorySpeedType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AdvisorySpeedType_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = AdvisorySpeedType_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AdvisorySpeedType_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long SpeedAdvice_t
     * }
     */
    public static final OfLong SpeedAdvice_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_SpeedAdvice_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_SpeedAdvice_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SpeedAdvice_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_SpeedAdvice_constr_1$layout() {
        return asn_PER_type_SpeedAdvice_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SpeedAdvice_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_SpeedAdvice_constr_1() {
        return asn_PER_type_SpeedAdvice_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SpeedAdvice_constr_1
     * }
     */
    public static void asn_PER_type_SpeedAdvice_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_SpeedAdvice_constr_1$constants.SEGMENT, 0L, asn_PER_type_SpeedAdvice_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_SpeedAdvice$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_SpeedAdvice").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SpeedAdvice
     * }
     */
    public static GroupLayout asn_DEF_SpeedAdvice$layout() {
        return asn_DEF_SpeedAdvice$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SpeedAdvice
     * }
     */
    public static MemorySegment asn_DEF_SpeedAdvice() {
        return asn_DEF_SpeedAdvice$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SpeedAdvice
     * }
     */
    public static void asn_DEF_SpeedAdvice(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_SpeedAdvice$constants.SEGMENT, 0L, asn_DEF_SpeedAdvice$constants.LAYOUT.byteSize());
    }

    private static class SpeedAdvice_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedAdvice_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SpeedAdvice_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor SpeedAdvice_free$descriptor() {
        return SpeedAdvice_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SpeedAdvice_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle SpeedAdvice_free$handle() {
        return SpeedAdvice_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SpeedAdvice_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment SpeedAdvice_free$address() {
        return SpeedAdvice_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SpeedAdvice_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void SpeedAdvice_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = SpeedAdvice_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedAdvice_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedAdvice_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedAdvice_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SpeedAdvice_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SpeedAdvice_print$descriptor() {
        return SpeedAdvice_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SpeedAdvice_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SpeedAdvice_print$handle() {
        return SpeedAdvice_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SpeedAdvice_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SpeedAdvice_print$address() {
        return SpeedAdvice_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SpeedAdvice_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int SpeedAdvice_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SpeedAdvice_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedAdvice_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedAdvice_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedAdvice_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SpeedAdvice_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor SpeedAdvice_constraint$descriptor() {
        return SpeedAdvice_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SpeedAdvice_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle SpeedAdvice_constraint$handle() {
        return SpeedAdvice_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SpeedAdvice_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment SpeedAdvice_constraint$address() {
        return SpeedAdvice_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SpeedAdvice_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int SpeedAdvice_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SpeedAdvice_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedAdvice_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedAdvice_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedAdvice_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedAdvice_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor SpeedAdvice_decode_ber$descriptor() {
        return SpeedAdvice_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedAdvice_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle SpeedAdvice_decode_ber$handle() {
        return SpeedAdvice_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedAdvice_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SpeedAdvice_decode_ber$address() {
        return SpeedAdvice_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedAdvice_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SpeedAdvice_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = SpeedAdvice_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedAdvice_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedAdvice_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedAdvice_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SpeedAdvice_encode_der$descriptor() {
        return SpeedAdvice_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SpeedAdvice_encode_der$handle() {
        return SpeedAdvice_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SpeedAdvice_encode_der$address() {
        return SpeedAdvice_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SpeedAdvice_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SpeedAdvice_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedAdvice_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedAdvice_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedAdvice_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedAdvice_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SpeedAdvice_decode_xer$descriptor() {
        return SpeedAdvice_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedAdvice_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle SpeedAdvice_decode_xer$handle() {
        return SpeedAdvice_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedAdvice_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SpeedAdvice_decode_xer$address() {
        return SpeedAdvice_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedAdvice_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SpeedAdvice_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SpeedAdvice_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedAdvice_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedAdvice_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedAdvice_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SpeedAdvice_encode_xer$descriptor() {
        return SpeedAdvice_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SpeedAdvice_encode_xer$handle() {
        return SpeedAdvice_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SpeedAdvice_encode_xer$address() {
        return SpeedAdvice_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SpeedAdvice_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SpeedAdvice_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedAdvice_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedAdvice_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedAdvice_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SpeedAdvice_encode_jer$descriptor() {
        return SpeedAdvice_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SpeedAdvice_encode_jer$handle() {
        return SpeedAdvice_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SpeedAdvice_encode_jer$address() {
        return SpeedAdvice_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SpeedAdvice_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = SpeedAdvice_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedAdvice_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedAdvice_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedAdvice_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedAdvice_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SpeedAdvice_decode_oer$descriptor() {
        return SpeedAdvice_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedAdvice_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle SpeedAdvice_decode_oer$handle() {
        return SpeedAdvice_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedAdvice_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SpeedAdvice_decode_oer$address() {
        return SpeedAdvice_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedAdvice_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SpeedAdvice_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SpeedAdvice_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedAdvice_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedAdvice_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedAdvice_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SpeedAdvice_encode_oer$descriptor() {
        return SpeedAdvice_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SpeedAdvice_encode_oer$handle() {
        return SpeedAdvice_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SpeedAdvice_encode_oer$address() {
        return SpeedAdvice_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SpeedAdvice_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SpeedAdvice_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedAdvice_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedAdvice_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedAdvice_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedAdvice_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SpeedAdvice_decode_uper$descriptor() {
        return SpeedAdvice_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedAdvice_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SpeedAdvice_decode_uper$handle() {
        return SpeedAdvice_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedAdvice_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SpeedAdvice_decode_uper$address() {
        return SpeedAdvice_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedAdvice_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SpeedAdvice_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SpeedAdvice_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedAdvice_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedAdvice_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedAdvice_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SpeedAdvice_encode_uper$descriptor() {
        return SpeedAdvice_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SpeedAdvice_encode_uper$handle() {
        return SpeedAdvice_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SpeedAdvice_encode_uper$address() {
        return SpeedAdvice_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SpeedAdvice_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SpeedAdvice_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedAdvice_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedAdvice_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedAdvice_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedAdvice_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SpeedAdvice_decode_aper$descriptor() {
        return SpeedAdvice_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedAdvice_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SpeedAdvice_decode_aper$handle() {
        return SpeedAdvice_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedAdvice_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SpeedAdvice_decode_aper$address() {
        return SpeedAdvice_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedAdvice_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SpeedAdvice_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SpeedAdvice_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedAdvice_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedAdvice_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedAdvice_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SpeedAdvice_encode_aper$descriptor() {
        return SpeedAdvice_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SpeedAdvice_encode_aper$handle() {
        return SpeedAdvice_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SpeedAdvice_encode_aper$address() {
        return SpeedAdvice_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedAdvice_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SpeedAdvice_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SpeedAdvice_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedAdvice_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long ZoneLength_t
     * }
     */
    public static final OfLong ZoneLength_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_ZoneLength_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_ZoneLength_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ZoneLength_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_ZoneLength_constr_1$layout() {
        return asn_PER_type_ZoneLength_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ZoneLength_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_ZoneLength_constr_1() {
        return asn_PER_type_ZoneLength_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ZoneLength_constr_1
     * }
     */
    public static void asn_PER_type_ZoneLength_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_ZoneLength_constr_1$constants.SEGMENT, 0L, asn_PER_type_ZoneLength_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_ZoneLength$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_ZoneLength").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ZoneLength
     * }
     */
    public static GroupLayout asn_DEF_ZoneLength$layout() {
        return asn_DEF_ZoneLength$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ZoneLength
     * }
     */
    public static MemorySegment asn_DEF_ZoneLength() {
        return asn_DEF_ZoneLength$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ZoneLength
     * }
     */
    public static void asn_DEF_ZoneLength(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_ZoneLength$constants.SEGMENT, 0L, asn_DEF_ZoneLength$constants.LAYOUT.byteSize());
    }

    private static class ZoneLength_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ZoneLength_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ZoneLength_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor ZoneLength_free$descriptor() {
        return ZoneLength_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ZoneLength_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle ZoneLength_free$handle() {
        return ZoneLength_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ZoneLength_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment ZoneLength_free$address() {
        return ZoneLength_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ZoneLength_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void ZoneLength_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = ZoneLength_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ZoneLength_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ZoneLength_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ZoneLength_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ZoneLength_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ZoneLength_print$descriptor() {
        return ZoneLength_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ZoneLength_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ZoneLength_print$handle() {
        return ZoneLength_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ZoneLength_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ZoneLength_print$address() {
        return ZoneLength_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ZoneLength_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int ZoneLength_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ZoneLength_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ZoneLength_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ZoneLength_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ZoneLength_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ZoneLength_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor ZoneLength_constraint$descriptor() {
        return ZoneLength_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ZoneLength_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle ZoneLength_constraint$handle() {
        return ZoneLength_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ZoneLength_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment ZoneLength_constraint$address() {
        return ZoneLength_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ZoneLength_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int ZoneLength_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ZoneLength_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ZoneLength_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ZoneLength_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ZoneLength_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ZoneLength_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor ZoneLength_decode_ber$descriptor() {
        return ZoneLength_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ZoneLength_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle ZoneLength_decode_ber$handle() {
        return ZoneLength_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ZoneLength_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment ZoneLength_decode_ber$address() {
        return ZoneLength_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ZoneLength_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment ZoneLength_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = ZoneLength_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ZoneLength_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ZoneLength_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ZoneLength_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ZoneLength_encode_der$descriptor() {
        return ZoneLength_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ZoneLength_encode_der$handle() {
        return ZoneLength_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ZoneLength_encode_der$address() {
        return ZoneLength_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ZoneLength_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ZoneLength_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ZoneLength_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ZoneLength_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ZoneLength_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ZoneLength_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor ZoneLength_decode_xer$descriptor() {
        return ZoneLength_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ZoneLength_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle ZoneLength_decode_xer$handle() {
        return ZoneLength_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ZoneLength_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment ZoneLength_decode_xer$address() {
        return ZoneLength_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ZoneLength_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment ZoneLength_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = ZoneLength_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ZoneLength_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ZoneLength_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ZoneLength_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ZoneLength_encode_xer$descriptor() {
        return ZoneLength_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ZoneLength_encode_xer$handle() {
        return ZoneLength_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ZoneLength_encode_xer$address() {
        return ZoneLength_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ZoneLength_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ZoneLength_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ZoneLength_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ZoneLength_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ZoneLength_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ZoneLength_encode_jer$descriptor() {
        return ZoneLength_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ZoneLength_encode_jer$handle() {
        return ZoneLength_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ZoneLength_encode_jer$address() {
        return ZoneLength_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ZoneLength_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = ZoneLength_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ZoneLength_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ZoneLength_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ZoneLength_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ZoneLength_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor ZoneLength_decode_oer$descriptor() {
        return ZoneLength_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ZoneLength_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle ZoneLength_decode_oer$handle() {
        return ZoneLength_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ZoneLength_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ZoneLength_decode_oer$address() {
        return ZoneLength_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ZoneLength_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ZoneLength_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = ZoneLength_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ZoneLength_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ZoneLength_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ZoneLength_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ZoneLength_encode_oer$descriptor() {
        return ZoneLength_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ZoneLength_encode_oer$handle() {
        return ZoneLength_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ZoneLength_encode_oer$address() {
        return ZoneLength_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ZoneLength_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ZoneLength_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ZoneLength_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ZoneLength_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ZoneLength_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ZoneLength_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor ZoneLength_decode_uper$descriptor() {
        return ZoneLength_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ZoneLength_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle ZoneLength_decode_uper$handle() {
        return ZoneLength_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ZoneLength_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ZoneLength_decode_uper$address() {
        return ZoneLength_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ZoneLength_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ZoneLength_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ZoneLength_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ZoneLength_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ZoneLength_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ZoneLength_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor ZoneLength_encode_uper$descriptor() {
        return ZoneLength_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle ZoneLength_encode_uper$handle() {
        return ZoneLength_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ZoneLength_encode_uper$address() {
        return ZoneLength_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ZoneLength_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ZoneLength_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ZoneLength_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ZoneLength_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ZoneLength_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ZoneLength_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor ZoneLength_decode_aper$descriptor() {
        return ZoneLength_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ZoneLength_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle ZoneLength_decode_aper$handle() {
        return ZoneLength_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ZoneLength_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ZoneLength_decode_aper$address() {
        return ZoneLength_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ZoneLength_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ZoneLength_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ZoneLength_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ZoneLength_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ZoneLength_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ZoneLength_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor ZoneLength_encode_aper$descriptor() {
        return ZoneLength_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle ZoneLength_encode_aper$handle() {
        return ZoneLength_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ZoneLength_encode_aper$address() {
        return ZoneLength_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ZoneLength_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ZoneLength_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ZoneLength_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ZoneLength_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_AdvisorySpeed$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_AdvisorySpeed").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AdvisorySpeed
     * }
     */
    public static GroupLayout asn_DEF_AdvisorySpeed$layout() {
        return asn_DEF_AdvisorySpeed$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AdvisorySpeed
     * }
     */
    public static MemorySegment asn_DEF_AdvisorySpeed() {
        return asn_DEF_AdvisorySpeed$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AdvisorySpeed
     * }
     */
    public static void asn_DEF_AdvisorySpeed(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_AdvisorySpeed$constants.SEGMENT, 0L, asn_DEF_AdvisorySpeed$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_AdvisorySpeed_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_AdvisorySpeed_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_AdvisorySpeed_specs_1
     * }
     */
    public static GroupLayout asn_SPC_AdvisorySpeed_specs_1$layout() {
        return asn_SPC_AdvisorySpeed_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_AdvisorySpeed_specs_1
     * }
     */
    public static MemorySegment asn_SPC_AdvisorySpeed_specs_1() {
        return asn_SPC_AdvisorySpeed_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_AdvisorySpeed_specs_1
     * }
     */
    public static void asn_SPC_AdvisorySpeed_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_AdvisorySpeed_specs_1$constants.SEGMENT, 0L, asn_SPC_AdvisorySpeed_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_AdvisorySpeed_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(6, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_AdvisorySpeed_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 6 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AdvisorySpeed_1[6]
     * }
     */
    public static SequenceLayout asn_MBR_AdvisorySpeed_1$layout() {
        return asn_MBR_AdvisorySpeed_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AdvisorySpeed_1[6]
     * }
     */
    public static long[] asn_MBR_AdvisorySpeed_1$dimensions() {
        return asn_MBR_AdvisorySpeed_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AdvisorySpeed_1[6]
     * }
     */
    public static MemorySegment asn_MBR_AdvisorySpeed_1() {
        return asn_MBR_AdvisorySpeed_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AdvisorySpeed_1[6]
     * }
     */
    public static void asn_MBR_AdvisorySpeed_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_AdvisorySpeed_1$constants.SEGMENT, 0L, asn_MBR_AdvisorySpeed_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AdvisorySpeed_1[6]
     * }
     */
    public static MemorySegment asn_MBR_AdvisorySpeed_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_AdvisorySpeed_1$constants.HANDLE.invokeExact(asn_MBR_AdvisorySpeed_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AdvisorySpeed_1[6]
     * }
     */
    public static void asn_MBR_AdvisorySpeed_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_AdvisorySpeed_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_MovementState$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_MovementState").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_MovementState
     * }
     */
    public static GroupLayout asn_DEF_MovementState$layout() {
        return asn_DEF_MovementState$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_MovementState
     * }
     */
    public static MemorySegment asn_DEF_MovementState() {
        return asn_DEF_MovementState$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_MovementState
     * }
     */
    public static void asn_DEF_MovementState(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_MovementState$constants.SEGMENT, 0L, asn_DEF_MovementState$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_MovementState_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_MovementState_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_MovementState_specs_1
     * }
     */
    public static GroupLayout asn_SPC_MovementState_specs_1$layout() {
        return asn_SPC_MovementState_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_MovementState_specs_1
     * }
     */
    public static MemorySegment asn_SPC_MovementState_specs_1() {
        return asn_SPC_MovementState_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_MovementState_specs_1
     * }
     */
    public static void asn_SPC_MovementState_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_MovementState_specs_1$constants.SEGMENT, 0L, asn_SPC_MovementState_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_MovementState_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(5, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_MovementState_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 5 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementState_1[5]
     * }
     */
    public static SequenceLayout asn_MBR_MovementState_1$layout() {
        return asn_MBR_MovementState_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementState_1[5]
     * }
     */
    public static long[] asn_MBR_MovementState_1$dimensions() {
        return asn_MBR_MovementState_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementState_1[5]
     * }
     */
    public static MemorySegment asn_MBR_MovementState_1() {
        return asn_MBR_MovementState_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementState_1[5]
     * }
     */
    public static void asn_MBR_MovementState_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_MovementState_1$constants.SEGMENT, 0L, asn_MBR_MovementState_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementState_1[5]
     * }
     */
    public static MemorySegment asn_MBR_MovementState_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_MovementState_1$constants.HANDLE.invokeExact(asn_MBR_MovementState_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_MovementState_1[5]
     * }
     */
    public static void asn_MBR_MovementState_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_MovementState_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_ManeuverAssistList$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_ManeuverAssistList").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ManeuverAssistList
     * }
     */
    public static GroupLayout asn_DEF_ManeuverAssistList$layout() {
        return asn_DEF_ManeuverAssistList$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ManeuverAssistList
     * }
     */
    public static MemorySegment asn_DEF_ManeuverAssistList() {
        return asn_DEF_ManeuverAssistList$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ManeuverAssistList
     * }
     */
    public static void asn_DEF_ManeuverAssistList(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_ManeuverAssistList$constants.SEGMENT, 0L, asn_DEF_ManeuverAssistList$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_ManeuverAssistList_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SET_OF_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_ManeuverAssistList_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_ManeuverAssistList_specs_1
     * }
     */
    public static GroupLayout asn_SPC_ManeuverAssistList_specs_1$layout() {
        return asn_SPC_ManeuverAssistList_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_ManeuverAssistList_specs_1
     * }
     */
    public static MemorySegment asn_SPC_ManeuverAssistList_specs_1() {
        return asn_SPC_ManeuverAssistList_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_ManeuverAssistList_specs_1
     * }
     */
    public static void asn_SPC_ManeuverAssistList_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_ManeuverAssistList_specs_1$constants.SEGMENT, 0L, asn_SPC_ManeuverAssistList_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_ManeuverAssistList_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(1, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_ManeuverAssistList_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 1 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ManeuverAssistList_1[1]
     * }
     */
    public static SequenceLayout asn_MBR_ManeuverAssistList_1$layout() {
        return asn_MBR_ManeuverAssistList_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ManeuverAssistList_1[1]
     * }
     */
    public static long[] asn_MBR_ManeuverAssistList_1$dimensions() {
        return asn_MBR_ManeuverAssistList_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ManeuverAssistList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_ManeuverAssistList_1() {
        return asn_MBR_ManeuverAssistList_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ManeuverAssistList_1[1]
     * }
     */
    public static void asn_MBR_ManeuverAssistList_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_ManeuverAssistList_1$constants.SEGMENT, 0L, asn_MBR_ManeuverAssistList_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ManeuverAssistList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_ManeuverAssistList_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_ManeuverAssistList_1$constants.HANDLE.invokeExact(asn_MBR_ManeuverAssistList_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ManeuverAssistList_1[1]
     * }
     */
    public static void asn_MBR_ManeuverAssistList_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_ManeuverAssistList_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_ManeuverAssistList_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_ManeuverAssistList_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ManeuverAssistList_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_ManeuverAssistList_constr_1$layout() {
        return asn_PER_type_ManeuverAssistList_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ManeuverAssistList_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_ManeuverAssistList_constr_1() {
        return asn_PER_type_ManeuverAssistList_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ManeuverAssistList_constr_1
     * }
     */
    public static void asn_PER_type_ManeuverAssistList_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_ManeuverAssistList_constr_1$constants.SEGMENT, 0L, asn_PER_type_ManeuverAssistList_constr_1$constants.LAYOUT.byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef BOOLEAN_t WaitOnStopline_t
     * }
     */
    public static final OfInt WaitOnStopline_t = MessageFrame_h.C_INT;

    private static class asn_DEF_WaitOnStopline$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_WaitOnStopline").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_WaitOnStopline
     * }
     */
    public static GroupLayout asn_DEF_WaitOnStopline$layout() {
        return asn_DEF_WaitOnStopline$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_WaitOnStopline
     * }
     */
    public static MemorySegment asn_DEF_WaitOnStopline() {
        return asn_DEF_WaitOnStopline$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_WaitOnStopline
     * }
     */
    public static void asn_DEF_WaitOnStopline(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_WaitOnStopline$constants.SEGMENT, 0L, asn_DEF_WaitOnStopline$constants.LAYOUT.byteSize());
    }

    private static class WaitOnStopline_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("WaitOnStopline_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void WaitOnStopline_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor WaitOnStopline_free$descriptor() {
        return WaitOnStopline_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void WaitOnStopline_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle WaitOnStopline_free$handle() {
        return WaitOnStopline_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void WaitOnStopline_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment WaitOnStopline_free$address() {
        return WaitOnStopline_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void WaitOnStopline_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void WaitOnStopline_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = WaitOnStopline_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitOnStopline_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitOnStopline_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("WaitOnStopline_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WaitOnStopline_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor WaitOnStopline_print$descriptor() {
        return WaitOnStopline_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WaitOnStopline_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle WaitOnStopline_print$handle() {
        return WaitOnStopline_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int WaitOnStopline_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment WaitOnStopline_print$address() {
        return WaitOnStopline_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int WaitOnStopline_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int WaitOnStopline_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = WaitOnStopline_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitOnStopline_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitOnStopline_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("WaitOnStopline_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int WaitOnStopline_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor WaitOnStopline_constraint$descriptor() {
        return WaitOnStopline_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int WaitOnStopline_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle WaitOnStopline_constraint$handle() {
        return WaitOnStopline_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int WaitOnStopline_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment WaitOnStopline_constraint$address() {
        return WaitOnStopline_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int WaitOnStopline_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int WaitOnStopline_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = WaitOnStopline_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitOnStopline_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitOnStopline_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("WaitOnStopline_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t WaitOnStopline_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor WaitOnStopline_decode_ber$descriptor() {
        return WaitOnStopline_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t WaitOnStopline_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle WaitOnStopline_decode_ber$handle() {
        return WaitOnStopline_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t WaitOnStopline_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment WaitOnStopline_decode_ber$address() {
        return WaitOnStopline_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t WaitOnStopline_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment WaitOnStopline_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = WaitOnStopline_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitOnStopline_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitOnStopline_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("WaitOnStopline_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor WaitOnStopline_encode_der$descriptor() {
        return WaitOnStopline_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle WaitOnStopline_encode_der$handle() {
        return WaitOnStopline_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment WaitOnStopline_encode_der$address() {
        return WaitOnStopline_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment WaitOnStopline_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = WaitOnStopline_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitOnStopline_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitOnStopline_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("WaitOnStopline_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t WaitOnStopline_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor WaitOnStopline_decode_xer$descriptor() {
        return WaitOnStopline_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t WaitOnStopline_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle WaitOnStopline_decode_xer$handle() {
        return WaitOnStopline_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t WaitOnStopline_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment WaitOnStopline_decode_xer$address() {
        return WaitOnStopline_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t WaitOnStopline_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment WaitOnStopline_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = WaitOnStopline_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitOnStopline_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitOnStopline_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("WaitOnStopline_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor WaitOnStopline_encode_xer$descriptor() {
        return WaitOnStopline_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle WaitOnStopline_encode_xer$handle() {
        return WaitOnStopline_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment WaitOnStopline_encode_xer$address() {
        return WaitOnStopline_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment WaitOnStopline_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = WaitOnStopline_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitOnStopline_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitOnStopline_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("WaitOnStopline_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor WaitOnStopline_encode_jer$descriptor() {
        return WaitOnStopline_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle WaitOnStopline_encode_jer$handle() {
        return WaitOnStopline_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment WaitOnStopline_encode_jer$address() {
        return WaitOnStopline_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment WaitOnStopline_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = WaitOnStopline_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitOnStopline_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitOnStopline_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("WaitOnStopline_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t WaitOnStopline_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor WaitOnStopline_decode_oer$descriptor() {
        return WaitOnStopline_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t WaitOnStopline_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle WaitOnStopline_decode_oer$handle() {
        return WaitOnStopline_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t WaitOnStopline_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment WaitOnStopline_decode_oer$address() {
        return WaitOnStopline_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t WaitOnStopline_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment WaitOnStopline_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = WaitOnStopline_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitOnStopline_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitOnStopline_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("WaitOnStopline_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor WaitOnStopline_encode_oer$descriptor() {
        return WaitOnStopline_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle WaitOnStopline_encode_oer$handle() {
        return WaitOnStopline_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment WaitOnStopline_encode_oer$address() {
        return WaitOnStopline_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment WaitOnStopline_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = WaitOnStopline_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitOnStopline_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitOnStopline_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("WaitOnStopline_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t WaitOnStopline_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor WaitOnStopline_decode_uper$descriptor() {
        return WaitOnStopline_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t WaitOnStopline_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle WaitOnStopline_decode_uper$handle() {
        return WaitOnStopline_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t WaitOnStopline_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment WaitOnStopline_decode_uper$address() {
        return WaitOnStopline_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t WaitOnStopline_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment WaitOnStopline_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = WaitOnStopline_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitOnStopline_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitOnStopline_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("WaitOnStopline_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor WaitOnStopline_encode_uper$descriptor() {
        return WaitOnStopline_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle WaitOnStopline_encode_uper$handle() {
        return WaitOnStopline_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment WaitOnStopline_encode_uper$address() {
        return WaitOnStopline_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment WaitOnStopline_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = WaitOnStopline_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitOnStopline_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitOnStopline_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("WaitOnStopline_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t WaitOnStopline_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor WaitOnStopline_decode_aper$descriptor() {
        return WaitOnStopline_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t WaitOnStopline_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle WaitOnStopline_decode_aper$handle() {
        return WaitOnStopline_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t WaitOnStopline_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment WaitOnStopline_decode_aper$address() {
        return WaitOnStopline_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t WaitOnStopline_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment WaitOnStopline_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = WaitOnStopline_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitOnStopline_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class WaitOnStopline_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("WaitOnStopline_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor WaitOnStopline_encode_aper$descriptor() {
        return WaitOnStopline_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle WaitOnStopline_encode_aper$handle() {
        return WaitOnStopline_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment WaitOnStopline_encode_aper$address() {
        return WaitOnStopline_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t WaitOnStopline_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment WaitOnStopline_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = WaitOnStopline_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("WaitOnStopline_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef BOOLEAN_t PedestrianBicycleDetect_t
     * }
     */
    public static final OfInt PedestrianBicycleDetect_t = MessageFrame_h.C_INT;

    private static class asn_DEF_PedestrianBicycleDetect$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_PedestrianBicycleDetect").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PedestrianBicycleDetect
     * }
     */
    public static GroupLayout asn_DEF_PedestrianBicycleDetect$layout() {
        return asn_DEF_PedestrianBicycleDetect$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PedestrianBicycleDetect
     * }
     */
    public static MemorySegment asn_DEF_PedestrianBicycleDetect() {
        return asn_DEF_PedestrianBicycleDetect$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PedestrianBicycleDetect
     * }
     */
    public static void asn_DEF_PedestrianBicycleDetect(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_PedestrianBicycleDetect$constants.SEGMENT, 0L, asn_DEF_PedestrianBicycleDetect$constants.LAYOUT.byteSize());
    }

    private static class PedestrianBicycleDetect_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PedestrianBicycleDetect_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PedestrianBicycleDetect_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor PedestrianBicycleDetect_free$descriptor() {
        return PedestrianBicycleDetect_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PedestrianBicycleDetect_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle PedestrianBicycleDetect_free$handle() {
        return PedestrianBicycleDetect_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PedestrianBicycleDetect_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_free$address() {
        return PedestrianBicycleDetect_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PedestrianBicycleDetect_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void PedestrianBicycleDetect_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PedestrianBicycleDetect_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PedestrianBicycleDetect_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PedestrianBicycleDetect_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PedestrianBicycleDetect_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PedestrianBicycleDetect_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PedestrianBicycleDetect_print$descriptor() {
        return PedestrianBicycleDetect_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PedestrianBicycleDetect_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PedestrianBicycleDetect_print$handle() {
        return PedestrianBicycleDetect_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PedestrianBicycleDetect_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_print$address() {
        return PedestrianBicycleDetect_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PedestrianBicycleDetect_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int PedestrianBicycleDetect_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PedestrianBicycleDetect_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PedestrianBicycleDetect_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PedestrianBicycleDetect_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PedestrianBicycleDetect_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PedestrianBicycleDetect_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor PedestrianBicycleDetect_constraint$descriptor() {
        return PedestrianBicycleDetect_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PedestrianBicycleDetect_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle PedestrianBicycleDetect_constraint$handle() {
        return PedestrianBicycleDetect_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PedestrianBicycleDetect_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_constraint$address() {
        return PedestrianBicycleDetect_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PedestrianBicycleDetect_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int PedestrianBicycleDetect_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PedestrianBicycleDetect_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PedestrianBicycleDetect_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PedestrianBicycleDetect_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PedestrianBicycleDetect_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PedestrianBicycleDetect_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor PedestrianBicycleDetect_decode_ber$descriptor() {
        return PedestrianBicycleDetect_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PedestrianBicycleDetect_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle PedestrianBicycleDetect_decode_ber$handle() {
        return PedestrianBicycleDetect_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PedestrianBicycleDetect_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_decode_ber$address() {
        return PedestrianBicycleDetect_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PedestrianBicycleDetect_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = PedestrianBicycleDetect_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PedestrianBicycleDetect_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PedestrianBicycleDetect_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PedestrianBicycleDetect_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PedestrianBicycleDetect_encode_der$descriptor() {
        return PedestrianBicycleDetect_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PedestrianBicycleDetect_encode_der$handle() {
        return PedestrianBicycleDetect_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_encode_der$address() {
        return PedestrianBicycleDetect_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PedestrianBicycleDetect_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PedestrianBicycleDetect_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PedestrianBicycleDetect_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PedestrianBicycleDetect_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PedestrianBicycleDetect_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor PedestrianBicycleDetect_decode_xer$descriptor() {
        return PedestrianBicycleDetect_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PedestrianBicycleDetect_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle PedestrianBicycleDetect_decode_xer$handle() {
        return PedestrianBicycleDetect_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PedestrianBicycleDetect_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_decode_xer$address() {
        return PedestrianBicycleDetect_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PedestrianBicycleDetect_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = PedestrianBicycleDetect_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PedestrianBicycleDetect_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PedestrianBicycleDetect_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PedestrianBicycleDetect_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PedestrianBicycleDetect_encode_xer$descriptor() {
        return PedestrianBicycleDetect_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PedestrianBicycleDetect_encode_xer$handle() {
        return PedestrianBicycleDetect_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_encode_xer$address() {
        return PedestrianBicycleDetect_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PedestrianBicycleDetect_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PedestrianBicycleDetect_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PedestrianBicycleDetect_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PedestrianBicycleDetect_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PedestrianBicycleDetect_encode_jer$descriptor() {
        return PedestrianBicycleDetect_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PedestrianBicycleDetect_encode_jer$handle() {
        return PedestrianBicycleDetect_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_encode_jer$address() {
        return PedestrianBicycleDetect_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = PedestrianBicycleDetect_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PedestrianBicycleDetect_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PedestrianBicycleDetect_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PedestrianBicycleDetect_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PedestrianBicycleDetect_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor PedestrianBicycleDetect_decode_oer$descriptor() {
        return PedestrianBicycleDetect_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PedestrianBicycleDetect_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle PedestrianBicycleDetect_decode_oer$handle() {
        return PedestrianBicycleDetect_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PedestrianBicycleDetect_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_decode_oer$address() {
        return PedestrianBicycleDetect_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PedestrianBicycleDetect_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = PedestrianBicycleDetect_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PedestrianBicycleDetect_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PedestrianBicycleDetect_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PedestrianBicycleDetect_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PedestrianBicycleDetect_encode_oer$descriptor() {
        return PedestrianBicycleDetect_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PedestrianBicycleDetect_encode_oer$handle() {
        return PedestrianBicycleDetect_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_encode_oer$address() {
        return PedestrianBicycleDetect_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PedestrianBicycleDetect_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PedestrianBicycleDetect_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PedestrianBicycleDetect_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PedestrianBicycleDetect_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PedestrianBicycleDetect_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor PedestrianBicycleDetect_decode_uper$descriptor() {
        return PedestrianBicycleDetect_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PedestrianBicycleDetect_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle PedestrianBicycleDetect_decode_uper$handle() {
        return PedestrianBicycleDetect_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PedestrianBicycleDetect_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_decode_uper$address() {
        return PedestrianBicycleDetect_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PedestrianBicycleDetect_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PedestrianBicycleDetect_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PedestrianBicycleDetect_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PedestrianBicycleDetect_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PedestrianBicycleDetect_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor PedestrianBicycleDetect_encode_uper$descriptor() {
        return PedestrianBicycleDetect_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle PedestrianBicycleDetect_encode_uper$handle() {
        return PedestrianBicycleDetect_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_encode_uper$address() {
        return PedestrianBicycleDetect_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PedestrianBicycleDetect_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PedestrianBicycleDetect_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PedestrianBicycleDetect_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PedestrianBicycleDetect_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PedestrianBicycleDetect_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor PedestrianBicycleDetect_decode_aper$descriptor() {
        return PedestrianBicycleDetect_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PedestrianBicycleDetect_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle PedestrianBicycleDetect_decode_aper$handle() {
        return PedestrianBicycleDetect_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PedestrianBicycleDetect_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_decode_aper$address() {
        return PedestrianBicycleDetect_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PedestrianBicycleDetect_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PedestrianBicycleDetect_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PedestrianBicycleDetect_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PedestrianBicycleDetect_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PedestrianBicycleDetect_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor PedestrianBicycleDetect_encode_aper$descriptor() {
        return PedestrianBicycleDetect_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle PedestrianBicycleDetect_encode_aper$handle() {
        return PedestrianBicycleDetect_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_encode_aper$address() {
        return PedestrianBicycleDetect_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PedestrianBicycleDetect_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PedestrianBicycleDetect_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PedestrianBicycleDetect_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PedestrianBicycleDetect_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_ConnectionManeuverAssist$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_ConnectionManeuverAssist").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ConnectionManeuverAssist
     * }
     */
    public static GroupLayout asn_DEF_ConnectionManeuverAssist$layout() {
        return asn_DEF_ConnectionManeuverAssist$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ConnectionManeuverAssist
     * }
     */
    public static MemorySegment asn_DEF_ConnectionManeuverAssist() {
        return asn_DEF_ConnectionManeuverAssist$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ConnectionManeuverAssist
     * }
     */
    public static void asn_DEF_ConnectionManeuverAssist(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_ConnectionManeuverAssist$constants.SEGMENT, 0L, asn_DEF_ConnectionManeuverAssist$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_ConnectionManeuverAssist_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_ConnectionManeuverAssist_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_ConnectionManeuverAssist_specs_1
     * }
     */
    public static GroupLayout asn_SPC_ConnectionManeuverAssist_specs_1$layout() {
        return asn_SPC_ConnectionManeuverAssist_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_ConnectionManeuverAssist_specs_1
     * }
     */
    public static MemorySegment asn_SPC_ConnectionManeuverAssist_specs_1() {
        return asn_SPC_ConnectionManeuverAssist_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_ConnectionManeuverAssist_specs_1
     * }
     */
    public static void asn_SPC_ConnectionManeuverAssist_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_ConnectionManeuverAssist_specs_1$constants.SEGMENT, 0L, asn_SPC_ConnectionManeuverAssist_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_ConnectionManeuverAssist_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(6, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_ConnectionManeuverAssist_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 6 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ConnectionManeuverAssist_1[6]
     * }
     */
    public static SequenceLayout asn_MBR_ConnectionManeuverAssist_1$layout() {
        return asn_MBR_ConnectionManeuverAssist_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ConnectionManeuverAssist_1[6]
     * }
     */
    public static long[] asn_MBR_ConnectionManeuverAssist_1$dimensions() {
        return asn_MBR_ConnectionManeuverAssist_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ConnectionManeuverAssist_1[6]
     * }
     */
    public static MemorySegment asn_MBR_ConnectionManeuverAssist_1() {
        return asn_MBR_ConnectionManeuverAssist_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ConnectionManeuverAssist_1[6]
     * }
     */
    public static void asn_MBR_ConnectionManeuverAssist_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_ConnectionManeuverAssist_1$constants.SEGMENT, 0L, asn_MBR_ConnectionManeuverAssist_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ConnectionManeuverAssist_1[6]
     * }
     */
    public static MemorySegment asn_MBR_ConnectionManeuverAssist_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_ConnectionManeuverAssist_1$constants.HANDLE.invokeExact(asn_MBR_ConnectionManeuverAssist_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ConnectionManeuverAssist_1[6]
     * }
     */
    public static void asn_MBR_ConnectionManeuverAssist_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_ConnectionManeuverAssist_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_IntersectionState$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_IntersectionState").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_IntersectionState
     * }
     */
    public static GroupLayout asn_DEF_IntersectionState$layout() {
        return asn_DEF_IntersectionState$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_IntersectionState
     * }
     */
    public static MemorySegment asn_DEF_IntersectionState() {
        return asn_DEF_IntersectionState$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_IntersectionState
     * }
     */
    public static void asn_DEF_IntersectionState(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_IntersectionState$constants.SEGMENT, 0L, asn_DEF_IntersectionState$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_IntersectionState_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_IntersectionState_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_IntersectionState_specs_1
     * }
     */
    public static GroupLayout asn_SPC_IntersectionState_specs_1$layout() {
        return asn_SPC_IntersectionState_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_IntersectionState_specs_1
     * }
     */
    public static MemorySegment asn_SPC_IntersectionState_specs_1() {
        return asn_SPC_IntersectionState_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_IntersectionState_specs_1
     * }
     */
    public static void asn_SPC_IntersectionState_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_IntersectionState_specs_1$constants.SEGMENT, 0L, asn_SPC_IntersectionState_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_IntersectionState_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(11, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_IntersectionState_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 11 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_IntersectionState_1[11]
     * }
     */
    public static SequenceLayout asn_MBR_IntersectionState_1$layout() {
        return asn_MBR_IntersectionState_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_IntersectionState_1[11]
     * }
     */
    public static long[] asn_MBR_IntersectionState_1$dimensions() {
        return asn_MBR_IntersectionState_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_IntersectionState_1[11]
     * }
     */
    public static MemorySegment asn_MBR_IntersectionState_1() {
        return asn_MBR_IntersectionState_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_IntersectionState_1[11]
     * }
     */
    public static void asn_MBR_IntersectionState_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_IntersectionState_1$constants.SEGMENT, 0L, asn_MBR_IntersectionState_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_IntersectionState_1[11]
     * }
     */
    public static MemorySegment asn_MBR_IntersectionState_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_IntersectionState_1$constants.HANDLE.invokeExact(asn_MBR_IntersectionState_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_IntersectionState_1[11]
     * }
     */
    public static void asn_MBR_IntersectionState_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_IntersectionState_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_EnabledLaneList$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_EnabledLaneList").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_EnabledLaneList
     * }
     */
    public static GroupLayout asn_DEF_EnabledLaneList$layout() {
        return asn_DEF_EnabledLaneList$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_EnabledLaneList
     * }
     */
    public static MemorySegment asn_DEF_EnabledLaneList() {
        return asn_DEF_EnabledLaneList$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_EnabledLaneList
     * }
     */
    public static void asn_DEF_EnabledLaneList(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_EnabledLaneList$constants.SEGMENT, 0L, asn_DEF_EnabledLaneList$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_EnabledLaneList_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SET_OF_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_EnabledLaneList_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_EnabledLaneList_specs_1
     * }
     */
    public static GroupLayout asn_SPC_EnabledLaneList_specs_1$layout() {
        return asn_SPC_EnabledLaneList_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_EnabledLaneList_specs_1
     * }
     */
    public static MemorySegment asn_SPC_EnabledLaneList_specs_1() {
        return asn_SPC_EnabledLaneList_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_EnabledLaneList_specs_1
     * }
     */
    public static void asn_SPC_EnabledLaneList_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_EnabledLaneList_specs_1$constants.SEGMENT, 0L, asn_SPC_EnabledLaneList_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_EnabledLaneList_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(1, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_EnabledLaneList_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 1 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EnabledLaneList_1[1]
     * }
     */
    public static SequenceLayout asn_MBR_EnabledLaneList_1$layout() {
        return asn_MBR_EnabledLaneList_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EnabledLaneList_1[1]
     * }
     */
    public static long[] asn_MBR_EnabledLaneList_1$dimensions() {
        return asn_MBR_EnabledLaneList_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EnabledLaneList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_EnabledLaneList_1() {
        return asn_MBR_EnabledLaneList_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EnabledLaneList_1[1]
     * }
     */
    public static void asn_MBR_EnabledLaneList_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_EnabledLaneList_1$constants.SEGMENT, 0L, asn_MBR_EnabledLaneList_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EnabledLaneList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_EnabledLaneList_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_EnabledLaneList_1$constants.HANDLE.invokeExact(asn_MBR_EnabledLaneList_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EnabledLaneList_1[1]
     * }
     */
    public static void asn_MBR_EnabledLaneList_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_EnabledLaneList_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_EnabledLaneList_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_EnabledLaneList_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_EnabledLaneList_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_EnabledLaneList_constr_1$layout() {
        return asn_PER_type_EnabledLaneList_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_EnabledLaneList_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_EnabledLaneList_constr_1() {
        return asn_PER_type_EnabledLaneList_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_EnabledLaneList_constr_1
     * }
     */
    public static void asn_PER_type_EnabledLaneList_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_EnabledLaneList_constr_1$constants.SEGMENT, 0L, asn_PER_type_EnabledLaneList_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_SPAT$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_SPAT").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SPAT
     * }
     */
    public static GroupLayout asn_DEF_SPAT$layout() {
        return asn_DEF_SPAT$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SPAT
     * }
     */
    public static MemorySegment asn_DEF_SPAT() {
        return asn_DEF_SPAT$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SPAT
     * }
     */
    public static void asn_DEF_SPAT(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_SPAT$constants.SEGMENT, 0L, asn_DEF_SPAT$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_SPAT_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_SPAT_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_SPAT_specs_1
     * }
     */
    public static GroupLayout asn_SPC_SPAT_specs_1$layout() {
        return asn_SPC_SPAT_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_SPAT_specs_1
     * }
     */
    public static MemorySegment asn_SPC_SPAT_specs_1() {
        return asn_SPC_SPAT_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_SPAT_specs_1
     * }
     */
    public static void asn_SPC_SPAT_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_SPAT_specs_1$constants.SEGMENT, 0L, asn_SPC_SPAT_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_SPAT_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(4, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_SPAT_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 4 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SPAT_1[4]
     * }
     */
    public static SequenceLayout asn_MBR_SPAT_1$layout() {
        return asn_MBR_SPAT_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SPAT_1[4]
     * }
     */
    public static long[] asn_MBR_SPAT_1$dimensions() {
        return asn_MBR_SPAT_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SPAT_1[4]
     * }
     */
    public static MemorySegment asn_MBR_SPAT_1() {
        return asn_MBR_SPAT_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SPAT_1[4]
     * }
     */
    public static void asn_MBR_SPAT_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_SPAT_1$constants.SEGMENT, 0L, asn_MBR_SPAT_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SPAT_1[4]
     * }
     */
    public static MemorySegment asn_MBR_SPAT_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_SPAT_1$constants.HANDLE.invokeExact(asn_MBR_SPAT_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SPAT_1[4]
     * }
     */
    public static void asn_MBR_SPAT_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_SPAT_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    private static final int RequestedItem_reserved = (int)0L;
    /**
     * {@snippet lang=c :
     * enum RequestedItem.RequestedItem_reserved = 0
     * }
     */
    public static int RequestedItem_reserved() {
        return RequestedItem_reserved;
    }
    private static final int RequestedItem_itemA = (int)1L;
    /**
     * {@snippet lang=c :
     * enum RequestedItem.RequestedItem_itemA = 1
     * }
     */
    public static int RequestedItem_itemA() {
        return RequestedItem_itemA;
    }
    private static final int RequestedItem_itemB = (int)2L;
    /**
     * {@snippet lang=c :
     * enum RequestedItem.RequestedItem_itemB = 2
     * }
     */
    public static int RequestedItem_itemB() {
        return RequestedItem_itemB;
    }
    private static final int RequestedItem_itemC = (int)3L;
    /**
     * {@snippet lang=c :
     * enum RequestedItem.RequestedItem_itemC = 3
     * }
     */
    public static int RequestedItem_itemC() {
        return RequestedItem_itemC;
    }
    private static final int RequestedItem_itemD = (int)4L;
    /**
     * {@snippet lang=c :
     * enum RequestedItem.RequestedItem_itemD = 4
     * }
     */
    public static int RequestedItem_itemD() {
        return RequestedItem_itemD;
    }
    private static final int RequestedItem_itemE = (int)5L;
    /**
     * {@snippet lang=c :
     * enum RequestedItem.RequestedItem_itemE = 5
     * }
     */
    public static int RequestedItem_itemE() {
        return RequestedItem_itemE;
    }
    private static final int RequestedItem_itemF = (int)6L;
    /**
     * {@snippet lang=c :
     * enum RequestedItem.RequestedItem_itemF = 6
     * }
     */
    public static int RequestedItem_itemF() {
        return RequestedItem_itemF;
    }
    private static final int RequestedItem_itemG = (int)7L;
    /**
     * {@snippet lang=c :
     * enum RequestedItem.RequestedItem_itemG = 7
     * }
     */
    public static int RequestedItem_itemG() {
        return RequestedItem_itemG;
    }
    private static final int RequestedItem_itemI = (int)8L;
    /**
     * {@snippet lang=c :
     * enum RequestedItem.RequestedItem_itemI = 8
     * }
     */
    public static int RequestedItem_itemI() {
        return RequestedItem_itemI;
    }
    private static final int RequestedItem_itemJ = (int)9L;
    /**
     * {@snippet lang=c :
     * enum RequestedItem.RequestedItem_itemJ = 9
     * }
     */
    public static int RequestedItem_itemJ() {
        return RequestedItem_itemJ;
    }
    private static final int RequestedItem_itemK = (int)10L;
    /**
     * {@snippet lang=c :
     * enum RequestedItem.RequestedItem_itemK = 10
     * }
     */
    public static int RequestedItem_itemK() {
        return RequestedItem_itemK;
    }
    private static final int RequestedItem_itemL = (int)11L;
    /**
     * {@snippet lang=c :
     * enum RequestedItem.RequestedItem_itemL = 11
     * }
     */
    public static int RequestedItem_itemL() {
        return RequestedItem_itemL;
    }
    private static final int RequestedItem_itemM = (int)12L;
    /**
     * {@snippet lang=c :
     * enum RequestedItem.RequestedItem_itemM = 12
     * }
     */
    public static int RequestedItem_itemM() {
        return RequestedItem_itemM;
    }
    private static final int RequestedItem_itemN = (int)13L;
    /**
     * {@snippet lang=c :
     * enum RequestedItem.RequestedItem_itemN = 13
     * }
     */
    public static int RequestedItem_itemN() {
        return RequestedItem_itemN;
    }
    private static final int RequestedItem_itemO = (int)14L;
    /**
     * {@snippet lang=c :
     * enum RequestedItem.RequestedItem_itemO = 14
     * }
     */
    public static int RequestedItem_itemO() {
        return RequestedItem_itemO;
    }
    private static final int RequestedItem_itemP = (int)15L;
    /**
     * {@snippet lang=c :
     * enum RequestedItem.RequestedItem_itemP = 15
     * }
     */
    public static int RequestedItem_itemP() {
        return RequestedItem_itemP;
    }
    private static final int RequestedItem_itemQ = (int)16L;
    /**
     * {@snippet lang=c :
     * enum RequestedItem.RequestedItem_itemQ = 16
     * }
     */
    public static int RequestedItem_itemQ() {
        return RequestedItem_itemQ;
    }
    /**
     * {@snippet lang=c :
     * typedef long RequestedItem_t
     * }
     */
    public static final OfLong RequestedItem_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_RequestedItem_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_RequestedItem_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RequestedItem_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_RequestedItem_constr_1$layout() {
        return asn_PER_type_RequestedItem_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RequestedItem_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_RequestedItem_constr_1() {
        return asn_PER_type_RequestedItem_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RequestedItem_constr_1
     * }
     */
    public static void asn_PER_type_RequestedItem_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_RequestedItem_constr_1$constants.SEGMENT, 0L, asn_PER_type_RequestedItem_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_RequestedItem$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_RequestedItem").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RequestedItem
     * }
     */
    public static GroupLayout asn_DEF_RequestedItem$layout() {
        return asn_DEF_RequestedItem$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RequestedItem
     * }
     */
    public static MemorySegment asn_DEF_RequestedItem() {
        return asn_DEF_RequestedItem$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RequestedItem
     * }
     */
    public static void asn_DEF_RequestedItem(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_RequestedItem$constants.SEGMENT, 0L, asn_DEF_RequestedItem$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_RequestedItem_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_RequestedItem_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_RequestedItem_specs_1
     * }
     */
    public static GroupLayout asn_SPC_RequestedItem_specs_1$layout() {
        return asn_SPC_RequestedItem_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_RequestedItem_specs_1
     * }
     */
    public static MemorySegment asn_SPC_RequestedItem_specs_1() {
        return asn_SPC_RequestedItem_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_RequestedItem_specs_1
     * }
     */
    public static void asn_SPC_RequestedItem_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_RequestedItem_specs_1$constants.SEGMENT, 0L, asn_SPC_RequestedItem_specs_1$constants.LAYOUT.byteSize());
    }

    private static class RequestedItem_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RequestedItem_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RequestedItem_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor RequestedItem_free$descriptor() {
        return RequestedItem_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RequestedItem_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle RequestedItem_free$handle() {
        return RequestedItem_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RequestedItem_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment RequestedItem_free$address() {
        return RequestedItem_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RequestedItem_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void RequestedItem_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = RequestedItem_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RequestedItem_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RequestedItem_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RequestedItem_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int RequestedItem_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RequestedItem_print$descriptor() {
        return RequestedItem_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int RequestedItem_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RequestedItem_print$handle() {
        return RequestedItem_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int RequestedItem_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RequestedItem_print$address() {
        return RequestedItem_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int RequestedItem_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int RequestedItem_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = RequestedItem_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RequestedItem_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RequestedItem_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RequestedItem_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int RequestedItem_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor RequestedItem_constraint$descriptor() {
        return RequestedItem_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int RequestedItem_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle RequestedItem_constraint$handle() {
        return RequestedItem_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int RequestedItem_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment RequestedItem_constraint$address() {
        return RequestedItem_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int RequestedItem_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int RequestedItem_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = RequestedItem_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RequestedItem_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RequestedItem_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RequestedItem_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RequestedItem_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor RequestedItem_decode_ber$descriptor() {
        return RequestedItem_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RequestedItem_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle RequestedItem_decode_ber$handle() {
        return RequestedItem_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RequestedItem_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment RequestedItem_decode_ber$address() {
        return RequestedItem_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RequestedItem_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment RequestedItem_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = RequestedItem_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RequestedItem_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RequestedItem_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RequestedItem_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RequestedItem_encode_der$descriptor() {
        return RequestedItem_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RequestedItem_encode_der$handle() {
        return RequestedItem_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RequestedItem_encode_der$address() {
        return RequestedItem_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RequestedItem_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = RequestedItem_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RequestedItem_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RequestedItem_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RequestedItem_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RequestedItem_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor RequestedItem_decode_xer$descriptor() {
        return RequestedItem_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RequestedItem_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle RequestedItem_decode_xer$handle() {
        return RequestedItem_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RequestedItem_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment RequestedItem_decode_xer$address() {
        return RequestedItem_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RequestedItem_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment RequestedItem_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = RequestedItem_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RequestedItem_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RequestedItem_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RequestedItem_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RequestedItem_encode_xer$descriptor() {
        return RequestedItem_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RequestedItem_encode_xer$handle() {
        return RequestedItem_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RequestedItem_encode_xer$address() {
        return RequestedItem_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RequestedItem_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = RequestedItem_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RequestedItem_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RequestedItem_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RequestedItem_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RequestedItem_encode_jer$descriptor() {
        return RequestedItem_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RequestedItem_encode_jer$handle() {
        return RequestedItem_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RequestedItem_encode_jer$address() {
        return RequestedItem_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RequestedItem_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = RequestedItem_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RequestedItem_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RequestedItem_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RequestedItem_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RequestedItem_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor RequestedItem_decode_oer$descriptor() {
        return RequestedItem_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RequestedItem_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle RequestedItem_decode_oer$handle() {
        return RequestedItem_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RequestedItem_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment RequestedItem_decode_oer$address() {
        return RequestedItem_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RequestedItem_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment RequestedItem_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = RequestedItem_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RequestedItem_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RequestedItem_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RequestedItem_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RequestedItem_encode_oer$descriptor() {
        return RequestedItem_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RequestedItem_encode_oer$handle() {
        return RequestedItem_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RequestedItem_encode_oer$address() {
        return RequestedItem_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RequestedItem_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = RequestedItem_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RequestedItem_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RequestedItem_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RequestedItem_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RequestedItem_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor RequestedItem_decode_uper$descriptor() {
        return RequestedItem_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RequestedItem_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle RequestedItem_decode_uper$handle() {
        return RequestedItem_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RequestedItem_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment RequestedItem_decode_uper$address() {
        return RequestedItem_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RequestedItem_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment RequestedItem_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = RequestedItem_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RequestedItem_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RequestedItem_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RequestedItem_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor RequestedItem_encode_uper$descriptor() {
        return RequestedItem_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle RequestedItem_encode_uper$handle() {
        return RequestedItem_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment RequestedItem_encode_uper$address() {
        return RequestedItem_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment RequestedItem_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = RequestedItem_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RequestedItem_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RequestedItem_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RequestedItem_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RequestedItem_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor RequestedItem_decode_aper$descriptor() {
        return RequestedItem_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RequestedItem_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle RequestedItem_decode_aper$handle() {
        return RequestedItem_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RequestedItem_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment RequestedItem_decode_aper$address() {
        return RequestedItem_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RequestedItem_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment RequestedItem_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = RequestedItem_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RequestedItem_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RequestedItem_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RequestedItem_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor RequestedItem_encode_aper$descriptor() {
        return RequestedItem_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle RequestedItem_encode_aper$handle() {
        return RequestedItem_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment RequestedItem_encode_aper$address() {
        return RequestedItem_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RequestedItem_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment RequestedItem_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = RequestedItem_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RequestedItem_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_RequestedItemList$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_RequestedItemList").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RequestedItemList
     * }
     */
    public static GroupLayout asn_DEF_RequestedItemList$layout() {
        return asn_DEF_RequestedItemList$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RequestedItemList
     * }
     */
    public static MemorySegment asn_DEF_RequestedItemList() {
        return asn_DEF_RequestedItemList$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RequestedItemList
     * }
     */
    public static void asn_DEF_RequestedItemList(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_RequestedItemList$constants.SEGMENT, 0L, asn_DEF_RequestedItemList$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_RequestedItemList_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SET_OF_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_RequestedItemList_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_RequestedItemList_specs_1
     * }
     */
    public static GroupLayout asn_SPC_RequestedItemList_specs_1$layout() {
        return asn_SPC_RequestedItemList_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_RequestedItemList_specs_1
     * }
     */
    public static MemorySegment asn_SPC_RequestedItemList_specs_1() {
        return asn_SPC_RequestedItemList_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_RequestedItemList_specs_1
     * }
     */
    public static void asn_SPC_RequestedItemList_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_RequestedItemList_specs_1$constants.SEGMENT, 0L, asn_SPC_RequestedItemList_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_RequestedItemList_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(1, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_RequestedItemList_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 1 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RequestedItemList_1[1]
     * }
     */
    public static SequenceLayout asn_MBR_RequestedItemList_1$layout() {
        return asn_MBR_RequestedItemList_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RequestedItemList_1[1]
     * }
     */
    public static long[] asn_MBR_RequestedItemList_1$dimensions() {
        return asn_MBR_RequestedItemList_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RequestedItemList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_RequestedItemList_1() {
        return asn_MBR_RequestedItemList_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RequestedItemList_1[1]
     * }
     */
    public static void asn_MBR_RequestedItemList_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RequestedItemList_1$constants.SEGMENT, 0L, asn_MBR_RequestedItemList_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RequestedItemList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_RequestedItemList_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_RequestedItemList_1$constants.HANDLE.invokeExact(asn_MBR_RequestedItemList_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RequestedItemList_1[1]
     * }
     */
    public static void asn_MBR_RequestedItemList_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RequestedItemList_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_RequestedItemList_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_RequestedItemList_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RequestedItemList_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_RequestedItemList_constr_1$layout() {
        return asn_PER_type_RequestedItemList_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RequestedItemList_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_RequestedItemList_constr_1() {
        return asn_PER_type_RequestedItemList_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RequestedItemList_constr_1
     * }
     */
    public static void asn_PER_type_RequestedItemList_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_RequestedItemList_constr_1$constants.SEGMENT, 0L, asn_PER_type_RequestedItemList_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_CommonSafetyRequest$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_CommonSafetyRequest").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_CommonSafetyRequest
     * }
     */
    public static GroupLayout asn_DEF_CommonSafetyRequest$layout() {
        return asn_DEF_CommonSafetyRequest$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_CommonSafetyRequest
     * }
     */
    public static MemorySegment asn_DEF_CommonSafetyRequest() {
        return asn_DEF_CommonSafetyRequest$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_CommonSafetyRequest
     * }
     */
    public static void asn_DEF_CommonSafetyRequest(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_CommonSafetyRequest$constants.SEGMENT, 0L, asn_DEF_CommonSafetyRequest$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_CommonSafetyRequest_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_CommonSafetyRequest_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_CommonSafetyRequest_specs_1
     * }
     */
    public static GroupLayout asn_SPC_CommonSafetyRequest_specs_1$layout() {
        return asn_SPC_CommonSafetyRequest_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_CommonSafetyRequest_specs_1
     * }
     */
    public static MemorySegment asn_SPC_CommonSafetyRequest_specs_1() {
        return asn_SPC_CommonSafetyRequest_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_CommonSafetyRequest_specs_1
     * }
     */
    public static void asn_SPC_CommonSafetyRequest_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_CommonSafetyRequest_specs_1$constants.SEGMENT, 0L, asn_SPC_CommonSafetyRequest_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_CommonSafetyRequest_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(5, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_CommonSafetyRequest_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 5 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CommonSafetyRequest_1[5]
     * }
     */
    public static SequenceLayout asn_MBR_CommonSafetyRequest_1$layout() {
        return asn_MBR_CommonSafetyRequest_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CommonSafetyRequest_1[5]
     * }
     */
    public static long[] asn_MBR_CommonSafetyRequest_1$dimensions() {
        return asn_MBR_CommonSafetyRequest_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CommonSafetyRequest_1[5]
     * }
     */
    public static MemorySegment asn_MBR_CommonSafetyRequest_1() {
        return asn_MBR_CommonSafetyRequest_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CommonSafetyRequest_1[5]
     * }
     */
    public static void asn_MBR_CommonSafetyRequest_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_CommonSafetyRequest_1$constants.SEGMENT, 0L, asn_MBR_CommonSafetyRequest_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CommonSafetyRequest_1[5]
     * }
     */
    public static MemorySegment asn_MBR_CommonSafetyRequest_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_CommonSafetyRequest_1$constants.HANDLE.invokeExact(asn_MBR_CommonSafetyRequest_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_CommonSafetyRequest_1[5]
     * }
     */
    public static void asn_MBR_CommonSafetyRequest_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_CommonSafetyRequest_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_FurtherInfoID_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_FurtherInfoID_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_FurtherInfoID_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_FurtherInfoID_constr_1$layout() {
        return asn_PER_type_FurtherInfoID_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_FurtherInfoID_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_FurtherInfoID_constr_1() {
        return asn_PER_type_FurtherInfoID_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_FurtherInfoID_constr_1
     * }
     */
    public static void asn_PER_type_FurtherInfoID_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_FurtherInfoID_constr_1$constants.SEGMENT, 0L, asn_PER_type_FurtherInfoID_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_FurtherInfoID$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_FurtherInfoID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_FurtherInfoID
     * }
     */
    public static GroupLayout asn_DEF_FurtherInfoID$layout() {
        return asn_DEF_FurtherInfoID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_FurtherInfoID
     * }
     */
    public static MemorySegment asn_DEF_FurtherInfoID() {
        return asn_DEF_FurtherInfoID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_FurtherInfoID
     * }
     */
    public static void asn_DEF_FurtherInfoID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_FurtherInfoID$constants.SEGMENT, 0L, asn_DEF_FurtherInfoID$constants.LAYOUT.byteSize());
    }

    private static class FurtherInfoID_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("FurtherInfoID_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void FurtherInfoID_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor FurtherInfoID_free$descriptor() {
        return FurtherInfoID_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void FurtherInfoID_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle FurtherInfoID_free$handle() {
        return FurtherInfoID_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void FurtherInfoID_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment FurtherInfoID_free$address() {
        return FurtherInfoID_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void FurtherInfoID_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void FurtherInfoID_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = FurtherInfoID_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FurtherInfoID_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FurtherInfoID_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("FurtherInfoID_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int FurtherInfoID_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor FurtherInfoID_print$descriptor() {
        return FurtherInfoID_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int FurtherInfoID_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle FurtherInfoID_print$handle() {
        return FurtherInfoID_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int FurtherInfoID_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment FurtherInfoID_print$address() {
        return FurtherInfoID_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int FurtherInfoID_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int FurtherInfoID_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = FurtherInfoID_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FurtherInfoID_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FurtherInfoID_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("FurtherInfoID_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int FurtherInfoID_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor FurtherInfoID_constraint$descriptor() {
        return FurtherInfoID_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int FurtherInfoID_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle FurtherInfoID_constraint$handle() {
        return FurtherInfoID_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int FurtherInfoID_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment FurtherInfoID_constraint$address() {
        return FurtherInfoID_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int FurtherInfoID_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int FurtherInfoID_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = FurtherInfoID_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FurtherInfoID_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FurtherInfoID_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("FurtherInfoID_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t FurtherInfoID_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor FurtherInfoID_decode_ber$descriptor() {
        return FurtherInfoID_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t FurtherInfoID_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle FurtherInfoID_decode_ber$handle() {
        return FurtherInfoID_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t FurtherInfoID_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment FurtherInfoID_decode_ber$address() {
        return FurtherInfoID_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t FurtherInfoID_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment FurtherInfoID_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = FurtherInfoID_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FurtherInfoID_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FurtherInfoID_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("FurtherInfoID_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor FurtherInfoID_encode_der$descriptor() {
        return FurtherInfoID_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle FurtherInfoID_encode_der$handle() {
        return FurtherInfoID_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment FurtherInfoID_encode_der$address() {
        return FurtherInfoID_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment FurtherInfoID_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = FurtherInfoID_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FurtherInfoID_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FurtherInfoID_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("FurtherInfoID_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t FurtherInfoID_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor FurtherInfoID_decode_xer$descriptor() {
        return FurtherInfoID_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t FurtherInfoID_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle FurtherInfoID_decode_xer$handle() {
        return FurtherInfoID_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t FurtherInfoID_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment FurtherInfoID_decode_xer$address() {
        return FurtherInfoID_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t FurtherInfoID_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment FurtherInfoID_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = FurtherInfoID_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FurtherInfoID_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FurtherInfoID_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("FurtherInfoID_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor FurtherInfoID_encode_xer$descriptor() {
        return FurtherInfoID_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle FurtherInfoID_encode_xer$handle() {
        return FurtherInfoID_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment FurtherInfoID_encode_xer$address() {
        return FurtherInfoID_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment FurtherInfoID_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = FurtherInfoID_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FurtherInfoID_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FurtherInfoID_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("FurtherInfoID_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor FurtherInfoID_encode_jer$descriptor() {
        return FurtherInfoID_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle FurtherInfoID_encode_jer$handle() {
        return FurtherInfoID_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment FurtherInfoID_encode_jer$address() {
        return FurtherInfoID_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment FurtherInfoID_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = FurtherInfoID_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FurtherInfoID_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FurtherInfoID_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("FurtherInfoID_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t FurtherInfoID_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor FurtherInfoID_decode_oer$descriptor() {
        return FurtherInfoID_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t FurtherInfoID_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle FurtherInfoID_decode_oer$handle() {
        return FurtherInfoID_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t FurtherInfoID_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment FurtherInfoID_decode_oer$address() {
        return FurtherInfoID_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t FurtherInfoID_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment FurtherInfoID_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = FurtherInfoID_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FurtherInfoID_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FurtherInfoID_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("FurtherInfoID_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor FurtherInfoID_encode_oer$descriptor() {
        return FurtherInfoID_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle FurtherInfoID_encode_oer$handle() {
        return FurtherInfoID_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment FurtherInfoID_encode_oer$address() {
        return FurtherInfoID_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment FurtherInfoID_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = FurtherInfoID_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FurtherInfoID_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FurtherInfoID_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("FurtherInfoID_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t FurtherInfoID_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor FurtherInfoID_decode_uper$descriptor() {
        return FurtherInfoID_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t FurtherInfoID_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle FurtherInfoID_decode_uper$handle() {
        return FurtherInfoID_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t FurtherInfoID_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment FurtherInfoID_decode_uper$address() {
        return FurtherInfoID_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t FurtherInfoID_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment FurtherInfoID_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = FurtherInfoID_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FurtherInfoID_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FurtherInfoID_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("FurtherInfoID_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor FurtherInfoID_encode_uper$descriptor() {
        return FurtherInfoID_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle FurtherInfoID_encode_uper$handle() {
        return FurtherInfoID_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment FurtherInfoID_encode_uper$address() {
        return FurtherInfoID_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment FurtherInfoID_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = FurtherInfoID_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FurtherInfoID_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FurtherInfoID_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("FurtherInfoID_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t FurtherInfoID_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor FurtherInfoID_decode_aper$descriptor() {
        return FurtherInfoID_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t FurtherInfoID_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle FurtherInfoID_decode_aper$handle() {
        return FurtherInfoID_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t FurtherInfoID_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment FurtherInfoID_decode_aper$address() {
        return FurtherInfoID_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t FurtherInfoID_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment FurtherInfoID_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = FurtherInfoID_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FurtherInfoID_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class FurtherInfoID_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("FurtherInfoID_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor FurtherInfoID_encode_aper$descriptor() {
        return FurtherInfoID_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle FurtherInfoID_encode_aper$handle() {
        return FurtherInfoID_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment FurtherInfoID_encode_aper$address() {
        return FurtherInfoID_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t FurtherInfoID_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment FurtherInfoID_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = FurtherInfoID_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("FurtherInfoID_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_RoadSideAlert$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_RoadSideAlert").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadSideAlert
     * }
     */
    public static GroupLayout asn_DEF_RoadSideAlert$layout() {
        return asn_DEF_RoadSideAlert$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadSideAlert
     * }
     */
    public static MemorySegment asn_DEF_RoadSideAlert() {
        return asn_DEF_RoadSideAlert$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RoadSideAlert
     * }
     */
    public static void asn_DEF_RoadSideAlert(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_RoadSideAlert$constants.SEGMENT, 0L, asn_DEF_RoadSideAlert$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_RoadSideAlert_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_RoadSideAlert_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RoadSideAlert_specs_1
     * }
     */
    public static GroupLayout asn_SPC_RoadSideAlert_specs_1$layout() {
        return asn_SPC_RoadSideAlert_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RoadSideAlert_specs_1
     * }
     */
    public static MemorySegment asn_SPC_RoadSideAlert_specs_1() {
        return asn_SPC_RoadSideAlert_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_RoadSideAlert_specs_1
     * }
     */
    public static void asn_SPC_RoadSideAlert_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_RoadSideAlert_specs_1$constants.SEGMENT, 0L, asn_SPC_RoadSideAlert_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_RoadSideAlert_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(10, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_RoadSideAlert_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 10 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSideAlert_1[10]
     * }
     */
    public static SequenceLayout asn_MBR_RoadSideAlert_1$layout() {
        return asn_MBR_RoadSideAlert_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSideAlert_1[10]
     * }
     */
    public static long[] asn_MBR_RoadSideAlert_1$dimensions() {
        return asn_MBR_RoadSideAlert_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSideAlert_1[10]
     * }
     */
    public static MemorySegment asn_MBR_RoadSideAlert_1() {
        return asn_MBR_RoadSideAlert_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSideAlert_1[10]
     * }
     */
    public static void asn_MBR_RoadSideAlert_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RoadSideAlert_1$constants.SEGMENT, 0L, asn_MBR_RoadSideAlert_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSideAlert_1[10]
     * }
     */
    public static MemorySegment asn_MBR_RoadSideAlert_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_RoadSideAlert_1$constants.HANDLE.invokeExact(asn_MBR_RoadSideAlert_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_RoadSideAlert_1[10]
     * }
     */
    public static void asn_MBR_RoadSideAlert_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_RoadSideAlert_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_EmergencyVehicleAlert$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_EmergencyVehicleAlert").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_EmergencyVehicleAlert
     * }
     */
    public static GroupLayout asn_DEF_EmergencyVehicleAlert$layout() {
        return asn_DEF_EmergencyVehicleAlert$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_EmergencyVehicleAlert
     * }
     */
    public static MemorySegment asn_DEF_EmergencyVehicleAlert() {
        return asn_DEF_EmergencyVehicleAlert$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_EmergencyVehicleAlert
     * }
     */
    public static void asn_DEF_EmergencyVehicleAlert(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_EmergencyVehicleAlert$constants.SEGMENT, 0L, asn_DEF_EmergencyVehicleAlert$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_EmergencyVehicleAlert_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_EmergencyVehicleAlert_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_EmergencyVehicleAlert_specs_1
     * }
     */
    public static GroupLayout asn_SPC_EmergencyVehicleAlert_specs_1$layout() {
        return asn_SPC_EmergencyVehicleAlert_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_EmergencyVehicleAlert_specs_1
     * }
     */
    public static MemorySegment asn_SPC_EmergencyVehicleAlert_specs_1() {
        return asn_SPC_EmergencyVehicleAlert_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_EmergencyVehicleAlert_specs_1
     * }
     */
    public static void asn_SPC_EmergencyVehicleAlert_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_EmergencyVehicleAlert_specs_1$constants.SEGMENT, 0L, asn_SPC_EmergencyVehicleAlert_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_EmergencyVehicleAlert_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(11, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_EmergencyVehicleAlert_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 11 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EmergencyVehicleAlert_1[11]
     * }
     */
    public static SequenceLayout asn_MBR_EmergencyVehicleAlert_1$layout() {
        return asn_MBR_EmergencyVehicleAlert_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EmergencyVehicleAlert_1[11]
     * }
     */
    public static long[] asn_MBR_EmergencyVehicleAlert_1$dimensions() {
        return asn_MBR_EmergencyVehicleAlert_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EmergencyVehicleAlert_1[11]
     * }
     */
    public static MemorySegment asn_MBR_EmergencyVehicleAlert_1() {
        return asn_MBR_EmergencyVehicleAlert_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EmergencyVehicleAlert_1[11]
     * }
     */
    public static void asn_MBR_EmergencyVehicleAlert_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_EmergencyVehicleAlert_1$constants.SEGMENT, 0L, asn_MBR_EmergencyVehicleAlert_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EmergencyVehicleAlert_1[11]
     * }
     */
    public static MemorySegment asn_MBR_EmergencyVehicleAlert_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_EmergencyVehicleAlert_1$constants.HANDLE.invokeExact(asn_MBR_EmergencyVehicleAlert_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_EmergencyVehicleAlert_1[11]
     * }
     */
    public static void asn_MBR_EmergencyVehicleAlert_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_EmergencyVehicleAlert_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    private static final int ApproachOrLane_PR_NOTHING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ApproachOrLane_PR.ApproachOrLane_PR_NOTHING = 0
     * }
     */
    public static int ApproachOrLane_PR_NOTHING() {
        return ApproachOrLane_PR_NOTHING;
    }
    private static final int ApproachOrLane_PR_approach = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ApproachOrLane_PR.ApproachOrLane_PR_approach = 1
     * }
     */
    public static int ApproachOrLane_PR_approach() {
        return ApproachOrLane_PR_approach;
    }
    private static final int ApproachOrLane_PR_lane = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ApproachOrLane_PR.ApproachOrLane_PR_lane = 2
     * }
     */
    public static int ApproachOrLane_PR_lane() {
        return ApproachOrLane_PR_lane;
    }

    private static class asn_DEF_ApproachOrLane$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_ApproachOrLane").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ApproachOrLane
     * }
     */
    public static GroupLayout asn_DEF_ApproachOrLane$layout() {
        return asn_DEF_ApproachOrLane$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ApproachOrLane
     * }
     */
    public static MemorySegment asn_DEF_ApproachOrLane() {
        return asn_DEF_ApproachOrLane$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ApproachOrLane
     * }
     */
    public static void asn_DEF_ApproachOrLane(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_ApproachOrLane$constants.SEGMENT, 0L, asn_DEF_ApproachOrLane$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_ApproachOrLane_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_CHOICE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_ApproachOrLane_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_ApproachOrLane_specs_1
     * }
     */
    public static GroupLayout asn_SPC_ApproachOrLane_specs_1$layout() {
        return asn_SPC_ApproachOrLane_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_ApproachOrLane_specs_1
     * }
     */
    public static MemorySegment asn_SPC_ApproachOrLane_specs_1() {
        return asn_SPC_ApproachOrLane_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_ApproachOrLane_specs_1
     * }
     */
    public static void asn_SPC_ApproachOrLane_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_ApproachOrLane_specs_1$constants.SEGMENT, 0L, asn_SPC_ApproachOrLane_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_ApproachOrLane_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_ApproachOrLane_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ApproachOrLane_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_ApproachOrLane_1$layout() {
        return asn_MBR_ApproachOrLane_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ApproachOrLane_1[2]
     * }
     */
    public static long[] asn_MBR_ApproachOrLane_1$dimensions() {
        return asn_MBR_ApproachOrLane_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ApproachOrLane_1[2]
     * }
     */
    public static MemorySegment asn_MBR_ApproachOrLane_1() {
        return asn_MBR_ApproachOrLane_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ApproachOrLane_1[2]
     * }
     */
    public static void asn_MBR_ApproachOrLane_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_ApproachOrLane_1$constants.SEGMENT, 0L, asn_MBR_ApproachOrLane_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ApproachOrLane_1[2]
     * }
     */
    public static MemorySegment asn_MBR_ApproachOrLane_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_ApproachOrLane_1$constants.HANDLE.invokeExact(asn_MBR_ApproachOrLane_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ApproachOrLane_1[2]
     * }
     */
    public static void asn_MBR_ApproachOrLane_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_ApproachOrLane_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_ApproachOrLane_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_ApproachOrLane_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ApproachOrLane_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_ApproachOrLane_constr_1$layout() {
        return asn_PER_type_ApproachOrLane_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ApproachOrLane_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_ApproachOrLane_constr_1() {
        return asn_PER_type_ApproachOrLane_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ApproachOrLane_constr_1
     * }
     */
    public static void asn_PER_type_ApproachOrLane_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_ApproachOrLane_constr_1$constants.SEGMENT, 0L, asn_PER_type_ApproachOrLane_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_IntersectionCollision$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_IntersectionCollision").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_IntersectionCollision
     * }
     */
    public static GroupLayout asn_DEF_IntersectionCollision$layout() {
        return asn_DEF_IntersectionCollision$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_IntersectionCollision
     * }
     */
    public static MemorySegment asn_DEF_IntersectionCollision() {
        return asn_DEF_IntersectionCollision$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_IntersectionCollision
     * }
     */
    public static void asn_DEF_IntersectionCollision(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_IntersectionCollision$constants.SEGMENT, 0L, asn_DEF_IntersectionCollision$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_IntersectionCollision_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_IntersectionCollision_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_IntersectionCollision_specs_1
     * }
     */
    public static GroupLayout asn_SPC_IntersectionCollision_specs_1$layout() {
        return asn_SPC_IntersectionCollision_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_IntersectionCollision_specs_1
     * }
     */
    public static MemorySegment asn_SPC_IntersectionCollision_specs_1() {
        return asn_SPC_IntersectionCollision_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_IntersectionCollision_specs_1
     * }
     */
    public static void asn_SPC_IntersectionCollision_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_IntersectionCollision_specs_1$constants.SEGMENT, 0L, asn_SPC_IntersectionCollision_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_IntersectionCollision_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(10, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_IntersectionCollision_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 10 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_IntersectionCollision_1[10]
     * }
     */
    public static SequenceLayout asn_MBR_IntersectionCollision_1$layout() {
        return asn_MBR_IntersectionCollision_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_IntersectionCollision_1[10]
     * }
     */
    public static long[] asn_MBR_IntersectionCollision_1$dimensions() {
        return asn_MBR_IntersectionCollision_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_IntersectionCollision_1[10]
     * }
     */
    public static MemorySegment asn_MBR_IntersectionCollision_1() {
        return asn_MBR_IntersectionCollision_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_IntersectionCollision_1[10]
     * }
     */
    public static void asn_MBR_IntersectionCollision_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_IntersectionCollision_1$constants.SEGMENT, 0L, asn_MBR_IntersectionCollision_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_IntersectionCollision_1[10]
     * }
     */
    public static MemorySegment asn_MBR_IntersectionCollision_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_IntersectionCollision_1$constants.HANDLE.invokeExact(asn_MBR_IntersectionCollision_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_IntersectionCollision_1[10]
     * }
     */
    public static void asn_MBR_IntersectionCollision_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_IntersectionCollision_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    private static final int NMEA_Revision_unknown = (int)0L;
    /**
     * {@snippet lang=c :
     * enum NMEA_Revision.NMEA_Revision_unknown = 0
     * }
     */
    public static int NMEA_Revision_unknown() {
        return NMEA_Revision_unknown;
    }
    private static final int NMEA_Revision_reserved = (int)1L;
    /**
     * {@snippet lang=c :
     * enum NMEA_Revision.NMEA_Revision_reserved = 1
     * }
     */
    public static int NMEA_Revision_reserved() {
        return NMEA_Revision_reserved;
    }
    private static final int NMEA_Revision_rev1 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum NMEA_Revision.NMEA_Revision_rev1 = 2
     * }
     */
    public static int NMEA_Revision_rev1() {
        return NMEA_Revision_rev1;
    }
    private static final int NMEA_Revision_rev2 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum NMEA_Revision.NMEA_Revision_rev2 = 3
     * }
     */
    public static int NMEA_Revision_rev2() {
        return NMEA_Revision_rev2;
    }
    private static final int NMEA_Revision_rev3 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum NMEA_Revision.NMEA_Revision_rev3 = 4
     * }
     */
    public static int NMEA_Revision_rev3() {
        return NMEA_Revision_rev3;
    }
    private static final int NMEA_Revision_rev4 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum NMEA_Revision.NMEA_Revision_rev4 = 5
     * }
     */
    public static int NMEA_Revision_rev4() {
        return NMEA_Revision_rev4;
    }
    private static final int NMEA_Revision_rev5 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum NMEA_Revision.NMEA_Revision_rev5 = 6
     * }
     */
    public static int NMEA_Revision_rev5() {
        return NMEA_Revision_rev5;
    }
    /**
     * {@snippet lang=c :
     * typedef long NMEA_Revision_t
     * }
     */
    public static final OfLong NMEA_Revision_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_NMEA_Revision_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_NMEA_Revision_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NMEA_Revision_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_NMEA_Revision_constr_1$layout() {
        return asn_PER_type_NMEA_Revision_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NMEA_Revision_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_NMEA_Revision_constr_1() {
        return asn_PER_type_NMEA_Revision_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NMEA_Revision_constr_1
     * }
     */
    public static void asn_PER_type_NMEA_Revision_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_NMEA_Revision_constr_1$constants.SEGMENT, 0L, asn_PER_type_NMEA_Revision_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_NMEA_Revision$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_NMEA_Revision").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NMEA_Revision
     * }
     */
    public static GroupLayout asn_DEF_NMEA_Revision$layout() {
        return asn_DEF_NMEA_Revision$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NMEA_Revision
     * }
     */
    public static MemorySegment asn_DEF_NMEA_Revision() {
        return asn_DEF_NMEA_Revision$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NMEA_Revision
     * }
     */
    public static void asn_DEF_NMEA_Revision(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_NMEA_Revision$constants.SEGMENT, 0L, asn_DEF_NMEA_Revision$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_NMEA_Revision_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_NMEA_Revision_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_NMEA_Revision_specs_1
     * }
     */
    public static GroupLayout asn_SPC_NMEA_Revision_specs_1$layout() {
        return asn_SPC_NMEA_Revision_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_NMEA_Revision_specs_1
     * }
     */
    public static MemorySegment asn_SPC_NMEA_Revision_specs_1() {
        return asn_SPC_NMEA_Revision_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_NMEA_Revision_specs_1
     * }
     */
    public static void asn_SPC_NMEA_Revision_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_NMEA_Revision_specs_1$constants.SEGMENT, 0L, asn_SPC_NMEA_Revision_specs_1$constants.LAYOUT.byteSize());
    }

    private static class NMEA_Revision_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Revision_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NMEA_Revision_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor NMEA_Revision_free$descriptor() {
        return NMEA_Revision_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NMEA_Revision_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle NMEA_Revision_free$handle() {
        return NMEA_Revision_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NMEA_Revision_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment NMEA_Revision_free$address() {
        return NMEA_Revision_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NMEA_Revision_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void NMEA_Revision_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = NMEA_Revision_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Revision_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Revision_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Revision_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int NMEA_Revision_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NMEA_Revision_print$descriptor() {
        return NMEA_Revision_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int NMEA_Revision_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NMEA_Revision_print$handle() {
        return NMEA_Revision_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int NMEA_Revision_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_Revision_print$address() {
        return NMEA_Revision_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int NMEA_Revision_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int NMEA_Revision_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NMEA_Revision_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Revision_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Revision_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Revision_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int NMEA_Revision_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor NMEA_Revision_constraint$descriptor() {
        return NMEA_Revision_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int NMEA_Revision_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle NMEA_Revision_constraint$handle() {
        return NMEA_Revision_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int NMEA_Revision_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment NMEA_Revision_constraint$address() {
        return NMEA_Revision_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int NMEA_Revision_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int NMEA_Revision_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = NMEA_Revision_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Revision_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Revision_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Revision_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Revision_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor NMEA_Revision_decode_ber$descriptor() {
        return NMEA_Revision_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Revision_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle NMEA_Revision_decode_ber$handle() {
        return NMEA_Revision_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Revision_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment NMEA_Revision_decode_ber$address() {
        return NMEA_Revision_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Revision_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment NMEA_Revision_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = NMEA_Revision_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Revision_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Revision_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Revision_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NMEA_Revision_encode_der$descriptor() {
        return NMEA_Revision_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NMEA_Revision_encode_der$handle() {
        return NMEA_Revision_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_Revision_encode_der$address() {
        return NMEA_Revision_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_Revision_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = NMEA_Revision_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Revision_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Revision_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Revision_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Revision_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor NMEA_Revision_decode_xer$descriptor() {
        return NMEA_Revision_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Revision_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle NMEA_Revision_decode_xer$handle() {
        return NMEA_Revision_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Revision_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment NMEA_Revision_decode_xer$address() {
        return NMEA_Revision_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Revision_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment NMEA_Revision_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = NMEA_Revision_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Revision_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Revision_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Revision_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NMEA_Revision_encode_xer$descriptor() {
        return NMEA_Revision_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NMEA_Revision_encode_xer$handle() {
        return NMEA_Revision_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_Revision_encode_xer$address() {
        return NMEA_Revision_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_Revision_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = NMEA_Revision_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Revision_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Revision_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Revision_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NMEA_Revision_encode_jer$descriptor() {
        return NMEA_Revision_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NMEA_Revision_encode_jer$handle() {
        return NMEA_Revision_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_Revision_encode_jer$address() {
        return NMEA_Revision_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_Revision_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = NMEA_Revision_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Revision_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Revision_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Revision_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Revision_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor NMEA_Revision_decode_oer$descriptor() {
        return NMEA_Revision_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Revision_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle NMEA_Revision_decode_oer$handle() {
        return NMEA_Revision_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Revision_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment NMEA_Revision_decode_oer$address() {
        return NMEA_Revision_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Revision_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment NMEA_Revision_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = NMEA_Revision_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Revision_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Revision_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Revision_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NMEA_Revision_encode_oer$descriptor() {
        return NMEA_Revision_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NMEA_Revision_encode_oer$handle() {
        return NMEA_Revision_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_Revision_encode_oer$address() {
        return NMEA_Revision_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_Revision_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NMEA_Revision_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Revision_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Revision_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Revision_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Revision_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor NMEA_Revision_decode_uper$descriptor() {
        return NMEA_Revision_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Revision_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle NMEA_Revision_decode_uper$handle() {
        return NMEA_Revision_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Revision_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NMEA_Revision_decode_uper$address() {
        return NMEA_Revision_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Revision_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NMEA_Revision_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NMEA_Revision_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Revision_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Revision_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Revision_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor NMEA_Revision_encode_uper$descriptor() {
        return NMEA_Revision_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle NMEA_Revision_encode_uper$handle() {
        return NMEA_Revision_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NMEA_Revision_encode_uper$address() {
        return NMEA_Revision_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NMEA_Revision_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = NMEA_Revision_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Revision_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Revision_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Revision_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Revision_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor NMEA_Revision_decode_aper$descriptor() {
        return NMEA_Revision_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Revision_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle NMEA_Revision_decode_aper$handle() {
        return NMEA_Revision_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Revision_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NMEA_Revision_decode_aper$address() {
        return NMEA_Revision_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Revision_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NMEA_Revision_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NMEA_Revision_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Revision_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Revision_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Revision_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor NMEA_Revision_encode_aper$descriptor() {
        return NMEA_Revision_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle NMEA_Revision_encode_aper$handle() {
        return NMEA_Revision_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NMEA_Revision_encode_aper$address() {
        return NMEA_Revision_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Revision_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NMEA_Revision_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = NMEA_Revision_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Revision_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long NMEA_MsgType_t
     * }
     */
    public static final OfLong NMEA_MsgType_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_NMEA_MsgType_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_NMEA_MsgType_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NMEA_MsgType_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_NMEA_MsgType_constr_1$layout() {
        return asn_PER_type_NMEA_MsgType_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NMEA_MsgType_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_NMEA_MsgType_constr_1() {
        return asn_PER_type_NMEA_MsgType_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NMEA_MsgType_constr_1
     * }
     */
    public static void asn_PER_type_NMEA_MsgType_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_NMEA_MsgType_constr_1$constants.SEGMENT, 0L, asn_PER_type_NMEA_MsgType_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_NMEA_MsgType$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_NMEA_MsgType").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NMEA_MsgType
     * }
     */
    public static GroupLayout asn_DEF_NMEA_MsgType$layout() {
        return asn_DEF_NMEA_MsgType$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NMEA_MsgType
     * }
     */
    public static MemorySegment asn_DEF_NMEA_MsgType() {
        return asn_DEF_NMEA_MsgType$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NMEA_MsgType
     * }
     */
    public static void asn_DEF_NMEA_MsgType(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_NMEA_MsgType$constants.SEGMENT, 0L, asn_DEF_NMEA_MsgType$constants.LAYOUT.byteSize());
    }

    private static class NMEA_MsgType_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_MsgType_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NMEA_MsgType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor NMEA_MsgType_free$descriptor() {
        return NMEA_MsgType_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NMEA_MsgType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle NMEA_MsgType_free$handle() {
        return NMEA_MsgType_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NMEA_MsgType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment NMEA_MsgType_free$address() {
        return NMEA_MsgType_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NMEA_MsgType_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void NMEA_MsgType_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = NMEA_MsgType_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_MsgType_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_MsgType_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_MsgType_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int NMEA_MsgType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NMEA_MsgType_print$descriptor() {
        return NMEA_MsgType_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int NMEA_MsgType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NMEA_MsgType_print$handle() {
        return NMEA_MsgType_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int NMEA_MsgType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_MsgType_print$address() {
        return NMEA_MsgType_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int NMEA_MsgType_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int NMEA_MsgType_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NMEA_MsgType_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_MsgType_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_MsgType_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_MsgType_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int NMEA_MsgType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor NMEA_MsgType_constraint$descriptor() {
        return NMEA_MsgType_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int NMEA_MsgType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle NMEA_MsgType_constraint$handle() {
        return NMEA_MsgType_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int NMEA_MsgType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment NMEA_MsgType_constraint$address() {
        return NMEA_MsgType_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int NMEA_MsgType_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int NMEA_MsgType_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = NMEA_MsgType_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_MsgType_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_MsgType_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_MsgType_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_MsgType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor NMEA_MsgType_decode_ber$descriptor() {
        return NMEA_MsgType_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_MsgType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle NMEA_MsgType_decode_ber$handle() {
        return NMEA_MsgType_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_MsgType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment NMEA_MsgType_decode_ber$address() {
        return NMEA_MsgType_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_MsgType_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment NMEA_MsgType_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = NMEA_MsgType_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_MsgType_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_MsgType_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_MsgType_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NMEA_MsgType_encode_der$descriptor() {
        return NMEA_MsgType_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NMEA_MsgType_encode_der$handle() {
        return NMEA_MsgType_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_MsgType_encode_der$address() {
        return NMEA_MsgType_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_MsgType_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = NMEA_MsgType_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_MsgType_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_MsgType_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_MsgType_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_MsgType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor NMEA_MsgType_decode_xer$descriptor() {
        return NMEA_MsgType_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_MsgType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle NMEA_MsgType_decode_xer$handle() {
        return NMEA_MsgType_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_MsgType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment NMEA_MsgType_decode_xer$address() {
        return NMEA_MsgType_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_MsgType_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment NMEA_MsgType_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = NMEA_MsgType_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_MsgType_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_MsgType_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_MsgType_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NMEA_MsgType_encode_xer$descriptor() {
        return NMEA_MsgType_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NMEA_MsgType_encode_xer$handle() {
        return NMEA_MsgType_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_MsgType_encode_xer$address() {
        return NMEA_MsgType_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_MsgType_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = NMEA_MsgType_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_MsgType_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_MsgType_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_MsgType_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NMEA_MsgType_encode_jer$descriptor() {
        return NMEA_MsgType_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NMEA_MsgType_encode_jer$handle() {
        return NMEA_MsgType_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_MsgType_encode_jer$address() {
        return NMEA_MsgType_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_MsgType_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = NMEA_MsgType_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_MsgType_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_MsgType_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_MsgType_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_MsgType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor NMEA_MsgType_decode_oer$descriptor() {
        return NMEA_MsgType_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_MsgType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle NMEA_MsgType_decode_oer$handle() {
        return NMEA_MsgType_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_MsgType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment NMEA_MsgType_decode_oer$address() {
        return NMEA_MsgType_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_MsgType_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment NMEA_MsgType_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = NMEA_MsgType_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_MsgType_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_MsgType_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_MsgType_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NMEA_MsgType_encode_oer$descriptor() {
        return NMEA_MsgType_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NMEA_MsgType_encode_oer$handle() {
        return NMEA_MsgType_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_MsgType_encode_oer$address() {
        return NMEA_MsgType_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_MsgType_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NMEA_MsgType_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_MsgType_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_MsgType_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_MsgType_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_MsgType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor NMEA_MsgType_decode_uper$descriptor() {
        return NMEA_MsgType_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_MsgType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle NMEA_MsgType_decode_uper$handle() {
        return NMEA_MsgType_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_MsgType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NMEA_MsgType_decode_uper$address() {
        return NMEA_MsgType_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_MsgType_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NMEA_MsgType_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NMEA_MsgType_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_MsgType_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_MsgType_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_MsgType_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor NMEA_MsgType_encode_uper$descriptor() {
        return NMEA_MsgType_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle NMEA_MsgType_encode_uper$handle() {
        return NMEA_MsgType_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NMEA_MsgType_encode_uper$address() {
        return NMEA_MsgType_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NMEA_MsgType_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = NMEA_MsgType_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_MsgType_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_MsgType_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_MsgType_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_MsgType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor NMEA_MsgType_decode_aper$descriptor() {
        return NMEA_MsgType_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_MsgType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle NMEA_MsgType_decode_aper$handle() {
        return NMEA_MsgType_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_MsgType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NMEA_MsgType_decode_aper$address() {
        return NMEA_MsgType_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_MsgType_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NMEA_MsgType_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NMEA_MsgType_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_MsgType_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_MsgType_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_MsgType_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor NMEA_MsgType_encode_aper$descriptor() {
        return NMEA_MsgType_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle NMEA_MsgType_encode_aper$handle() {
        return NMEA_MsgType_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NMEA_MsgType_encode_aper$address() {
        return NMEA_MsgType_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_MsgType_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NMEA_MsgType_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = NMEA_MsgType_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_MsgType_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long ObjectCount_t
     * }
     */
    public static final OfLong ObjectCount_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_ObjectCount_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_ObjectCount_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ObjectCount_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_ObjectCount_constr_1$layout() {
        return asn_PER_type_ObjectCount_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ObjectCount_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_ObjectCount_constr_1() {
        return asn_PER_type_ObjectCount_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ObjectCount_constr_1
     * }
     */
    public static void asn_PER_type_ObjectCount_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_ObjectCount_constr_1$constants.SEGMENT, 0L, asn_PER_type_ObjectCount_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_ObjectCount$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_ObjectCount").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ObjectCount
     * }
     */
    public static GroupLayout asn_DEF_ObjectCount$layout() {
        return asn_DEF_ObjectCount$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ObjectCount
     * }
     */
    public static MemorySegment asn_DEF_ObjectCount() {
        return asn_DEF_ObjectCount$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ObjectCount
     * }
     */
    public static void asn_DEF_ObjectCount(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_ObjectCount$constants.SEGMENT, 0L, asn_DEF_ObjectCount$constants.LAYOUT.byteSize());
    }

    private static class ObjectCount_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ObjectCount_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ObjectCount_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor ObjectCount_free$descriptor() {
        return ObjectCount_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ObjectCount_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle ObjectCount_free$handle() {
        return ObjectCount_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ObjectCount_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment ObjectCount_free$address() {
        return ObjectCount_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ObjectCount_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void ObjectCount_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = ObjectCount_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectCount_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectCount_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ObjectCount_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ObjectCount_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ObjectCount_print$descriptor() {
        return ObjectCount_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ObjectCount_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ObjectCount_print$handle() {
        return ObjectCount_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ObjectCount_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ObjectCount_print$address() {
        return ObjectCount_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ObjectCount_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int ObjectCount_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ObjectCount_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectCount_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectCount_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ObjectCount_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ObjectCount_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor ObjectCount_constraint$descriptor() {
        return ObjectCount_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ObjectCount_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle ObjectCount_constraint$handle() {
        return ObjectCount_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ObjectCount_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment ObjectCount_constraint$address() {
        return ObjectCount_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ObjectCount_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int ObjectCount_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ObjectCount_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectCount_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectCount_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ObjectCount_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ObjectCount_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor ObjectCount_decode_ber$descriptor() {
        return ObjectCount_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ObjectCount_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle ObjectCount_decode_ber$handle() {
        return ObjectCount_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ObjectCount_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment ObjectCount_decode_ber$address() {
        return ObjectCount_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ObjectCount_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment ObjectCount_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = ObjectCount_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectCount_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectCount_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ObjectCount_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ObjectCount_encode_der$descriptor() {
        return ObjectCount_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ObjectCount_encode_der$handle() {
        return ObjectCount_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ObjectCount_encode_der$address() {
        return ObjectCount_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ObjectCount_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ObjectCount_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectCount_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectCount_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ObjectCount_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ObjectCount_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor ObjectCount_decode_xer$descriptor() {
        return ObjectCount_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ObjectCount_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle ObjectCount_decode_xer$handle() {
        return ObjectCount_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ObjectCount_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment ObjectCount_decode_xer$address() {
        return ObjectCount_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ObjectCount_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment ObjectCount_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = ObjectCount_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectCount_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectCount_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ObjectCount_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ObjectCount_encode_xer$descriptor() {
        return ObjectCount_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ObjectCount_encode_xer$handle() {
        return ObjectCount_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ObjectCount_encode_xer$address() {
        return ObjectCount_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ObjectCount_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ObjectCount_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectCount_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectCount_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ObjectCount_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ObjectCount_encode_jer$descriptor() {
        return ObjectCount_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ObjectCount_encode_jer$handle() {
        return ObjectCount_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ObjectCount_encode_jer$address() {
        return ObjectCount_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ObjectCount_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = ObjectCount_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectCount_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectCount_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ObjectCount_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ObjectCount_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor ObjectCount_decode_oer$descriptor() {
        return ObjectCount_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ObjectCount_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle ObjectCount_decode_oer$handle() {
        return ObjectCount_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ObjectCount_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ObjectCount_decode_oer$address() {
        return ObjectCount_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ObjectCount_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ObjectCount_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = ObjectCount_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectCount_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectCount_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ObjectCount_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ObjectCount_encode_oer$descriptor() {
        return ObjectCount_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ObjectCount_encode_oer$handle() {
        return ObjectCount_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ObjectCount_encode_oer$address() {
        return ObjectCount_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ObjectCount_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ObjectCount_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectCount_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectCount_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ObjectCount_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ObjectCount_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor ObjectCount_decode_uper$descriptor() {
        return ObjectCount_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ObjectCount_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle ObjectCount_decode_uper$handle() {
        return ObjectCount_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ObjectCount_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ObjectCount_decode_uper$address() {
        return ObjectCount_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ObjectCount_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ObjectCount_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ObjectCount_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectCount_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectCount_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ObjectCount_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor ObjectCount_encode_uper$descriptor() {
        return ObjectCount_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle ObjectCount_encode_uper$handle() {
        return ObjectCount_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ObjectCount_encode_uper$address() {
        return ObjectCount_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ObjectCount_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ObjectCount_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectCount_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectCount_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ObjectCount_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ObjectCount_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor ObjectCount_decode_aper$descriptor() {
        return ObjectCount_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ObjectCount_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle ObjectCount_decode_aper$handle() {
        return ObjectCount_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ObjectCount_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ObjectCount_decode_aper$address() {
        return ObjectCount_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ObjectCount_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ObjectCount_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ObjectCount_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectCount_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ObjectCount_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ObjectCount_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor ObjectCount_encode_aper$descriptor() {
        return ObjectCount_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle ObjectCount_encode_aper$handle() {
        return ObjectCount_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ObjectCount_encode_aper$address() {
        return ObjectCount_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ObjectCount_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ObjectCount_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ObjectCount_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ObjectCount_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_PER_type_NMEA_Payload_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_NMEA_Payload_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NMEA_Payload_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_NMEA_Payload_constr_1$layout() {
        return asn_PER_type_NMEA_Payload_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NMEA_Payload_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_NMEA_Payload_constr_1() {
        return asn_PER_type_NMEA_Payload_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_NMEA_Payload_constr_1
     * }
     */
    public static void asn_PER_type_NMEA_Payload_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_NMEA_Payload_constr_1$constants.SEGMENT, 0L, asn_PER_type_NMEA_Payload_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_NMEA_Payload$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_NMEA_Payload").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NMEA_Payload
     * }
     */
    public static GroupLayout asn_DEF_NMEA_Payload$layout() {
        return asn_DEF_NMEA_Payload$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NMEA_Payload
     * }
     */
    public static MemorySegment asn_DEF_NMEA_Payload() {
        return asn_DEF_NMEA_Payload$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NMEA_Payload
     * }
     */
    public static void asn_DEF_NMEA_Payload(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_NMEA_Payload$constants.SEGMENT, 0L, asn_DEF_NMEA_Payload$constants.LAYOUT.byteSize());
    }

    private static class NMEA_Payload_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Payload_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void NMEA_Payload_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor NMEA_Payload_free$descriptor() {
        return NMEA_Payload_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void NMEA_Payload_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle NMEA_Payload_free$handle() {
        return NMEA_Payload_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void NMEA_Payload_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment NMEA_Payload_free$address() {
        return NMEA_Payload_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void NMEA_Payload_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void NMEA_Payload_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = NMEA_Payload_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Payload_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Payload_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Payload_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int NMEA_Payload_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NMEA_Payload_print$descriptor() {
        return NMEA_Payload_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int NMEA_Payload_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NMEA_Payload_print$handle() {
        return NMEA_Payload_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int NMEA_Payload_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_Payload_print$address() {
        return NMEA_Payload_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int NMEA_Payload_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int NMEA_Payload_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NMEA_Payload_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Payload_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Payload_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Payload_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int NMEA_Payload_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor NMEA_Payload_constraint$descriptor() {
        return NMEA_Payload_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int NMEA_Payload_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle NMEA_Payload_constraint$handle() {
        return NMEA_Payload_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int NMEA_Payload_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment NMEA_Payload_constraint$address() {
        return NMEA_Payload_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int NMEA_Payload_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int NMEA_Payload_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = NMEA_Payload_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Payload_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Payload_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Payload_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Payload_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor NMEA_Payload_decode_ber$descriptor() {
        return NMEA_Payload_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Payload_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle NMEA_Payload_decode_ber$handle() {
        return NMEA_Payload_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Payload_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment NMEA_Payload_decode_ber$address() {
        return NMEA_Payload_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Payload_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment NMEA_Payload_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = NMEA_Payload_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Payload_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Payload_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Payload_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NMEA_Payload_encode_der$descriptor() {
        return NMEA_Payload_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NMEA_Payload_encode_der$handle() {
        return NMEA_Payload_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_Payload_encode_der$address() {
        return NMEA_Payload_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_Payload_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = NMEA_Payload_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Payload_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Payload_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Payload_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Payload_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor NMEA_Payload_decode_xer$descriptor() {
        return NMEA_Payload_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Payload_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle NMEA_Payload_decode_xer$handle() {
        return NMEA_Payload_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Payload_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment NMEA_Payload_decode_xer$address() {
        return NMEA_Payload_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Payload_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment NMEA_Payload_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = NMEA_Payload_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Payload_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Payload_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Payload_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NMEA_Payload_encode_xer$descriptor() {
        return NMEA_Payload_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NMEA_Payload_encode_xer$handle() {
        return NMEA_Payload_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_Payload_encode_xer$address() {
        return NMEA_Payload_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_Payload_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = NMEA_Payload_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Payload_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Payload_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Payload_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NMEA_Payload_encode_jer$descriptor() {
        return NMEA_Payload_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NMEA_Payload_encode_jer$handle() {
        return NMEA_Payload_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_Payload_encode_jer$address() {
        return NMEA_Payload_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_Payload_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = NMEA_Payload_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Payload_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Payload_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Payload_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Payload_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor NMEA_Payload_decode_oer$descriptor() {
        return NMEA_Payload_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Payload_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle NMEA_Payload_decode_oer$handle() {
        return NMEA_Payload_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Payload_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment NMEA_Payload_decode_oer$address() {
        return NMEA_Payload_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Payload_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment NMEA_Payload_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = NMEA_Payload_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Payload_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Payload_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Payload_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NMEA_Payload_encode_oer$descriptor() {
        return NMEA_Payload_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NMEA_Payload_encode_oer$handle() {
        return NMEA_Payload_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_Payload_encode_oer$address() {
        return NMEA_Payload_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NMEA_Payload_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NMEA_Payload_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Payload_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Payload_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Payload_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Payload_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor NMEA_Payload_decode_uper$descriptor() {
        return NMEA_Payload_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Payload_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle NMEA_Payload_decode_uper$handle() {
        return NMEA_Payload_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Payload_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NMEA_Payload_decode_uper$address() {
        return NMEA_Payload_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Payload_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NMEA_Payload_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NMEA_Payload_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Payload_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Payload_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Payload_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor NMEA_Payload_encode_uper$descriptor() {
        return NMEA_Payload_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle NMEA_Payload_encode_uper$handle() {
        return NMEA_Payload_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NMEA_Payload_encode_uper$address() {
        return NMEA_Payload_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NMEA_Payload_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = NMEA_Payload_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Payload_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Payload_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Payload_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Payload_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor NMEA_Payload_decode_aper$descriptor() {
        return NMEA_Payload_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Payload_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle NMEA_Payload_decode_aper$handle() {
        return NMEA_Payload_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Payload_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NMEA_Payload_decode_aper$address() {
        return NMEA_Payload_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NMEA_Payload_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NMEA_Payload_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NMEA_Payload_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Payload_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NMEA_Payload_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NMEA_Payload_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor NMEA_Payload_encode_aper$descriptor() {
        return NMEA_Payload_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle NMEA_Payload_encode_aper$handle() {
        return NMEA_Payload_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NMEA_Payload_encode_aper$address() {
        return NMEA_Payload_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NMEA_Payload_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NMEA_Payload_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = NMEA_Payload_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NMEA_Payload_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_NMEAcorrections$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_NMEAcorrections").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NMEAcorrections
     * }
     */
    public static GroupLayout asn_DEF_NMEAcorrections$layout() {
        return asn_DEF_NMEAcorrections$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NMEAcorrections
     * }
     */
    public static MemorySegment asn_DEF_NMEAcorrections() {
        return asn_DEF_NMEAcorrections$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NMEAcorrections
     * }
     */
    public static void asn_DEF_NMEAcorrections(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_NMEAcorrections$constants.SEGMENT, 0L, asn_DEF_NMEAcorrections$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_NMEAcorrections_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_NMEAcorrections_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_NMEAcorrections_specs_1
     * }
     */
    public static GroupLayout asn_SPC_NMEAcorrections_specs_1$layout() {
        return asn_SPC_NMEAcorrections_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_NMEAcorrections_specs_1
     * }
     */
    public static MemorySegment asn_SPC_NMEAcorrections_specs_1() {
        return asn_SPC_NMEAcorrections_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_NMEAcorrections_specs_1
     * }
     */
    public static void asn_SPC_NMEAcorrections_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_NMEAcorrections_specs_1$constants.SEGMENT, 0L, asn_SPC_NMEAcorrections_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_NMEAcorrections_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(6, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_NMEAcorrections_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 6 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NMEAcorrections_1[6]
     * }
     */
    public static SequenceLayout asn_MBR_NMEAcorrections_1$layout() {
        return asn_MBR_NMEAcorrections_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NMEAcorrections_1[6]
     * }
     */
    public static long[] asn_MBR_NMEAcorrections_1$dimensions() {
        return asn_MBR_NMEAcorrections_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NMEAcorrections_1[6]
     * }
     */
    public static MemorySegment asn_MBR_NMEAcorrections_1() {
        return asn_MBR_NMEAcorrections_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NMEAcorrections_1[6]
     * }
     */
    public static void asn_MBR_NMEAcorrections_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_NMEAcorrections_1$constants.SEGMENT, 0L, asn_MBR_NMEAcorrections_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NMEAcorrections_1[6]
     * }
     */
    public static MemorySegment asn_MBR_NMEAcorrections_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_NMEAcorrections_1$constants.HANDLE.invokeExact(asn_MBR_NMEAcorrections_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_NMEAcorrections_1[6]
     * }
     */
    public static void asn_MBR_NMEAcorrections_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_NMEAcorrections_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_Sample$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_Sample").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Sample
     * }
     */
    public static GroupLayout asn_DEF_Sample$layout() {
        return asn_DEF_Sample$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Sample
     * }
     */
    public static MemorySegment asn_DEF_Sample() {
        return asn_DEF_Sample$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Sample
     * }
     */
    public static void asn_DEF_Sample(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_Sample$constants.SEGMENT, 0L, asn_DEF_Sample$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_Sample_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_Sample_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Sample_specs_1
     * }
     */
    public static GroupLayout asn_SPC_Sample_specs_1$layout() {
        return asn_SPC_Sample_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Sample_specs_1
     * }
     */
    public static MemorySegment asn_SPC_Sample_specs_1() {
        return asn_SPC_Sample_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Sample_specs_1
     * }
     */
    public static void asn_SPC_Sample_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_Sample_specs_1$constants.SEGMENT, 0L, asn_SPC_Sample_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_Sample_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_Sample_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Sample_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_Sample_1$layout() {
        return asn_MBR_Sample_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Sample_1[2]
     * }
     */
    public static long[] asn_MBR_Sample_1$dimensions() {
        return asn_MBR_Sample_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Sample_1[2]
     * }
     */
    public static MemorySegment asn_MBR_Sample_1() {
        return asn_MBR_Sample_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Sample_1[2]
     * }
     */
    public static void asn_MBR_Sample_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_Sample_1$constants.SEGMENT, 0L, asn_MBR_Sample_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Sample_1[2]
     * }
     */
    public static MemorySegment asn_MBR_Sample_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_Sample_1$constants.HANDLE.invokeExact(asn_MBR_Sample_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Sample_1[2]
     * }
     */
    public static void asn_MBR_Sample_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_Sample_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef long SecondOfTime_t
     * }
     */
    public static final OfLong SecondOfTime_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_SecondOfTime_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_SecondOfTime_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SecondOfTime_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_SecondOfTime_constr_1$layout() {
        return asn_PER_type_SecondOfTime_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SecondOfTime_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_SecondOfTime_constr_1() {
        return asn_PER_type_SecondOfTime_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SecondOfTime_constr_1
     * }
     */
    public static void asn_PER_type_SecondOfTime_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_SecondOfTime_constr_1$constants.SEGMENT, 0L, asn_PER_type_SecondOfTime_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_SecondOfTime$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_SecondOfTime").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SecondOfTime
     * }
     */
    public static GroupLayout asn_DEF_SecondOfTime$layout() {
        return asn_DEF_SecondOfTime$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SecondOfTime
     * }
     */
    public static MemorySegment asn_DEF_SecondOfTime() {
        return asn_DEF_SecondOfTime$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SecondOfTime
     * }
     */
    public static void asn_DEF_SecondOfTime(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_SecondOfTime$constants.SEGMENT, 0L, asn_DEF_SecondOfTime$constants.LAYOUT.byteSize());
    }

    private static class SecondOfTime_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SecondOfTime_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SecondOfTime_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor SecondOfTime_free$descriptor() {
        return SecondOfTime_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SecondOfTime_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle SecondOfTime_free$handle() {
        return SecondOfTime_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SecondOfTime_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment SecondOfTime_free$address() {
        return SecondOfTime_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SecondOfTime_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void SecondOfTime_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = SecondOfTime_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SecondOfTime_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SecondOfTime_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SecondOfTime_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SecondOfTime_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SecondOfTime_print$descriptor() {
        return SecondOfTime_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SecondOfTime_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SecondOfTime_print$handle() {
        return SecondOfTime_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SecondOfTime_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SecondOfTime_print$address() {
        return SecondOfTime_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SecondOfTime_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int SecondOfTime_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SecondOfTime_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SecondOfTime_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SecondOfTime_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SecondOfTime_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SecondOfTime_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor SecondOfTime_constraint$descriptor() {
        return SecondOfTime_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SecondOfTime_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle SecondOfTime_constraint$handle() {
        return SecondOfTime_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SecondOfTime_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment SecondOfTime_constraint$address() {
        return SecondOfTime_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SecondOfTime_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int SecondOfTime_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SecondOfTime_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SecondOfTime_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SecondOfTime_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SecondOfTime_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SecondOfTime_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor SecondOfTime_decode_ber$descriptor() {
        return SecondOfTime_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SecondOfTime_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle SecondOfTime_decode_ber$handle() {
        return SecondOfTime_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SecondOfTime_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SecondOfTime_decode_ber$address() {
        return SecondOfTime_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SecondOfTime_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SecondOfTime_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = SecondOfTime_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SecondOfTime_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SecondOfTime_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SecondOfTime_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SecondOfTime_encode_der$descriptor() {
        return SecondOfTime_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SecondOfTime_encode_der$handle() {
        return SecondOfTime_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SecondOfTime_encode_der$address() {
        return SecondOfTime_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SecondOfTime_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SecondOfTime_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SecondOfTime_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SecondOfTime_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SecondOfTime_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SecondOfTime_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SecondOfTime_decode_xer$descriptor() {
        return SecondOfTime_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SecondOfTime_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle SecondOfTime_decode_xer$handle() {
        return SecondOfTime_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SecondOfTime_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SecondOfTime_decode_xer$address() {
        return SecondOfTime_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SecondOfTime_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SecondOfTime_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SecondOfTime_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SecondOfTime_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SecondOfTime_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SecondOfTime_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SecondOfTime_encode_xer$descriptor() {
        return SecondOfTime_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SecondOfTime_encode_xer$handle() {
        return SecondOfTime_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SecondOfTime_encode_xer$address() {
        return SecondOfTime_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SecondOfTime_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SecondOfTime_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SecondOfTime_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SecondOfTime_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SecondOfTime_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SecondOfTime_encode_jer$descriptor() {
        return SecondOfTime_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SecondOfTime_encode_jer$handle() {
        return SecondOfTime_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SecondOfTime_encode_jer$address() {
        return SecondOfTime_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SecondOfTime_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = SecondOfTime_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SecondOfTime_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SecondOfTime_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SecondOfTime_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SecondOfTime_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SecondOfTime_decode_oer$descriptor() {
        return SecondOfTime_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SecondOfTime_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle SecondOfTime_decode_oer$handle() {
        return SecondOfTime_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SecondOfTime_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SecondOfTime_decode_oer$address() {
        return SecondOfTime_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SecondOfTime_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SecondOfTime_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SecondOfTime_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SecondOfTime_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SecondOfTime_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SecondOfTime_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SecondOfTime_encode_oer$descriptor() {
        return SecondOfTime_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SecondOfTime_encode_oer$handle() {
        return SecondOfTime_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SecondOfTime_encode_oer$address() {
        return SecondOfTime_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SecondOfTime_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SecondOfTime_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SecondOfTime_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SecondOfTime_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SecondOfTime_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SecondOfTime_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SecondOfTime_decode_uper$descriptor() {
        return SecondOfTime_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SecondOfTime_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SecondOfTime_decode_uper$handle() {
        return SecondOfTime_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SecondOfTime_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SecondOfTime_decode_uper$address() {
        return SecondOfTime_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SecondOfTime_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SecondOfTime_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SecondOfTime_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SecondOfTime_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SecondOfTime_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SecondOfTime_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SecondOfTime_encode_uper$descriptor() {
        return SecondOfTime_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SecondOfTime_encode_uper$handle() {
        return SecondOfTime_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SecondOfTime_encode_uper$address() {
        return SecondOfTime_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SecondOfTime_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SecondOfTime_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SecondOfTime_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SecondOfTime_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SecondOfTime_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SecondOfTime_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SecondOfTime_decode_aper$descriptor() {
        return SecondOfTime_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SecondOfTime_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SecondOfTime_decode_aper$handle() {
        return SecondOfTime_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SecondOfTime_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SecondOfTime_decode_aper$address() {
        return SecondOfTime_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SecondOfTime_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SecondOfTime_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SecondOfTime_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SecondOfTime_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SecondOfTime_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SecondOfTime_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SecondOfTime_encode_aper$descriptor() {
        return SecondOfTime_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SecondOfTime_encode_aper$handle() {
        return SecondOfTime_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SecondOfTime_encode_aper$address() {
        return SecondOfTime_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SecondOfTime_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SecondOfTime_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SecondOfTime_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SecondOfTime_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long TermTime_t
     * }
     */
    public static final OfLong TermTime_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_TermTime_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_TermTime_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TermTime_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_TermTime_constr_1$layout() {
        return asn_PER_type_TermTime_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TermTime_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_TermTime_constr_1() {
        return asn_PER_type_TermTime_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TermTime_constr_1
     * }
     */
    public static void asn_PER_type_TermTime_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_TermTime_constr_1$constants.SEGMENT, 0L, asn_PER_type_TermTime_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_TermTime$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_TermTime").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TermTime
     * }
     */
    public static GroupLayout asn_DEF_TermTime$layout() {
        return asn_DEF_TermTime$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TermTime
     * }
     */
    public static MemorySegment asn_DEF_TermTime() {
        return asn_DEF_TermTime$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TermTime
     * }
     */
    public static void asn_DEF_TermTime(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_TermTime$constants.SEGMENT, 0L, asn_DEF_TermTime$constants.LAYOUT.byteSize());
    }

    private static class TermTime_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermTime_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void TermTime_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor TermTime_free$descriptor() {
        return TermTime_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void TermTime_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle TermTime_free$handle() {
        return TermTime_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void TermTime_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment TermTime_free$address() {
        return TermTime_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void TermTime_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void TermTime_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = TermTime_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermTime_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermTime_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermTime_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TermTime_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TermTime_print$descriptor() {
        return TermTime_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TermTime_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TermTime_print$handle() {
        return TermTime_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TermTime_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TermTime_print$address() {
        return TermTime_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TermTime_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int TermTime_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TermTime_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermTime_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermTime_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermTime_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TermTime_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor TermTime_constraint$descriptor() {
        return TermTime_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TermTime_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle TermTime_constraint$handle() {
        return TermTime_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TermTime_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment TermTime_constraint$address() {
        return TermTime_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TermTime_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int TermTime_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TermTime_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermTime_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermTime_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermTime_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermTime_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor TermTime_decode_ber$descriptor() {
        return TermTime_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermTime_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle TermTime_decode_ber$handle() {
        return TermTime_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermTime_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment TermTime_decode_ber$address() {
        return TermTime_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TermTime_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment TermTime_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = TermTime_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermTime_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermTime_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermTime_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TermTime_encode_der$descriptor() {
        return TermTime_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TermTime_encode_der$handle() {
        return TermTime_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TermTime_encode_der$address() {
        return TermTime_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TermTime_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = TermTime_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermTime_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermTime_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermTime_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermTime_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor TermTime_decode_xer$descriptor() {
        return TermTime_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermTime_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle TermTime_decode_xer$handle() {
        return TermTime_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermTime_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment TermTime_decode_xer$address() {
        return TermTime_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TermTime_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment TermTime_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = TermTime_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermTime_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermTime_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermTime_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TermTime_encode_xer$descriptor() {
        return TermTime_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TermTime_encode_xer$handle() {
        return TermTime_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TermTime_encode_xer$address() {
        return TermTime_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TermTime_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = TermTime_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermTime_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermTime_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermTime_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TermTime_encode_jer$descriptor() {
        return TermTime_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TermTime_encode_jer$handle() {
        return TermTime_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TermTime_encode_jer$address() {
        return TermTime_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TermTime_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = TermTime_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermTime_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermTime_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermTime_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermTime_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor TermTime_decode_oer$descriptor() {
        return TermTime_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermTime_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle TermTime_decode_oer$handle() {
        return TermTime_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermTime_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment TermTime_decode_oer$address() {
        return TermTime_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TermTime_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment TermTime_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = TermTime_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermTime_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermTime_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermTime_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TermTime_encode_oer$descriptor() {
        return TermTime_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TermTime_encode_oer$handle() {
        return TermTime_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TermTime_encode_oer$address() {
        return TermTime_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TermTime_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TermTime_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermTime_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermTime_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermTime_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermTime_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor TermTime_decode_uper$descriptor() {
        return TermTime_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermTime_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle TermTime_decode_uper$handle() {
        return TermTime_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermTime_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TermTime_decode_uper$address() {
        return TermTime_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TermTime_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TermTime_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TermTime_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermTime_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermTime_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermTime_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor TermTime_encode_uper$descriptor() {
        return TermTime_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle TermTime_encode_uper$handle() {
        return TermTime_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TermTime_encode_uper$address() {
        return TermTime_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TermTime_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TermTime_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermTime_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermTime_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermTime_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermTime_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor TermTime_decode_aper$descriptor() {
        return TermTime_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermTime_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle TermTime_decode_aper$handle() {
        return TermTime_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermTime_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TermTime_decode_aper$address() {
        return TermTime_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TermTime_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TermTime_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TermTime_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermTime_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermTime_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermTime_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor TermTime_encode_aper$descriptor() {
        return TermTime_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle TermTime_encode_aper$handle() {
        return TermTime_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TermTime_encode_aper$address() {
        return TermTime_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TermTime_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TermTime_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TermTime_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermTime_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long TermDistance_t
     * }
     */
    public static final OfLong TermDistance_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_TermDistance_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_TermDistance_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TermDistance_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_TermDistance_constr_1$layout() {
        return asn_PER_type_TermDistance_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TermDistance_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_TermDistance_constr_1() {
        return asn_PER_type_TermDistance_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TermDistance_constr_1
     * }
     */
    public static void asn_PER_type_TermDistance_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_TermDistance_constr_1$constants.SEGMENT, 0L, asn_PER_type_TermDistance_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_TermDistance$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_TermDistance").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TermDistance
     * }
     */
    public static GroupLayout asn_DEF_TermDistance$layout() {
        return asn_DEF_TermDistance$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TermDistance
     * }
     */
    public static MemorySegment asn_DEF_TermDistance() {
        return asn_DEF_TermDistance$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TermDistance
     * }
     */
    public static void asn_DEF_TermDistance(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_TermDistance$constants.SEGMENT, 0L, asn_DEF_TermDistance$constants.LAYOUT.byteSize());
    }

    private static class TermDistance_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermDistance_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void TermDistance_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor TermDistance_free$descriptor() {
        return TermDistance_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void TermDistance_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle TermDistance_free$handle() {
        return TermDistance_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void TermDistance_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment TermDistance_free$address() {
        return TermDistance_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void TermDistance_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void TermDistance_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = TermDistance_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermDistance_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermDistance_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermDistance_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TermDistance_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TermDistance_print$descriptor() {
        return TermDistance_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TermDistance_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TermDistance_print$handle() {
        return TermDistance_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TermDistance_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TermDistance_print$address() {
        return TermDistance_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TermDistance_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int TermDistance_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TermDistance_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermDistance_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermDistance_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermDistance_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TermDistance_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor TermDistance_constraint$descriptor() {
        return TermDistance_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TermDistance_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle TermDistance_constraint$handle() {
        return TermDistance_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TermDistance_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment TermDistance_constraint$address() {
        return TermDistance_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TermDistance_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int TermDistance_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TermDistance_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermDistance_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermDistance_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermDistance_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermDistance_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor TermDistance_decode_ber$descriptor() {
        return TermDistance_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermDistance_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle TermDistance_decode_ber$handle() {
        return TermDistance_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermDistance_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment TermDistance_decode_ber$address() {
        return TermDistance_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TermDistance_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment TermDistance_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = TermDistance_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermDistance_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermDistance_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermDistance_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TermDistance_encode_der$descriptor() {
        return TermDistance_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TermDistance_encode_der$handle() {
        return TermDistance_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TermDistance_encode_der$address() {
        return TermDistance_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TermDistance_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = TermDistance_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermDistance_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermDistance_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermDistance_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermDistance_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor TermDistance_decode_xer$descriptor() {
        return TermDistance_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermDistance_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle TermDistance_decode_xer$handle() {
        return TermDistance_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermDistance_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment TermDistance_decode_xer$address() {
        return TermDistance_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TermDistance_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment TermDistance_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = TermDistance_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermDistance_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermDistance_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermDistance_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TermDistance_encode_xer$descriptor() {
        return TermDistance_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TermDistance_encode_xer$handle() {
        return TermDistance_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TermDistance_encode_xer$address() {
        return TermDistance_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TermDistance_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = TermDistance_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermDistance_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermDistance_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermDistance_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TermDistance_encode_jer$descriptor() {
        return TermDistance_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TermDistance_encode_jer$handle() {
        return TermDistance_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TermDistance_encode_jer$address() {
        return TermDistance_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TermDistance_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = TermDistance_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermDistance_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermDistance_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermDistance_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermDistance_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor TermDistance_decode_oer$descriptor() {
        return TermDistance_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermDistance_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle TermDistance_decode_oer$handle() {
        return TermDistance_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermDistance_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment TermDistance_decode_oer$address() {
        return TermDistance_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TermDistance_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment TermDistance_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = TermDistance_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermDistance_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermDistance_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermDistance_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TermDistance_encode_oer$descriptor() {
        return TermDistance_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TermDistance_encode_oer$handle() {
        return TermDistance_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TermDistance_encode_oer$address() {
        return TermDistance_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TermDistance_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TermDistance_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermDistance_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermDistance_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermDistance_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermDistance_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor TermDistance_decode_uper$descriptor() {
        return TermDistance_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermDistance_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle TermDistance_decode_uper$handle() {
        return TermDistance_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermDistance_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TermDistance_decode_uper$address() {
        return TermDistance_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TermDistance_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TermDistance_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TermDistance_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermDistance_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermDistance_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermDistance_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor TermDistance_encode_uper$descriptor() {
        return TermDistance_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle TermDistance_encode_uper$handle() {
        return TermDistance_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TermDistance_encode_uper$address() {
        return TermDistance_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TermDistance_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TermDistance_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermDistance_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermDistance_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermDistance_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermDistance_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor TermDistance_decode_aper$descriptor() {
        return TermDistance_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermDistance_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle TermDistance_decode_aper$handle() {
        return TermDistance_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TermDistance_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TermDistance_decode_aper$address() {
        return TermDistance_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TermDistance_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TermDistance_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TermDistance_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermDistance_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TermDistance_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TermDistance_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor TermDistance_encode_aper$descriptor() {
        return TermDistance_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle TermDistance_encode_aper$handle() {
        return TermDistance_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TermDistance_encode_aper$address() {
        return TermDistance_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TermDistance_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TermDistance_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TermDistance_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TermDistance_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_SnapshotTime$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_SnapshotTime").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SnapshotTime
     * }
     */
    public static GroupLayout asn_DEF_SnapshotTime$layout() {
        return asn_DEF_SnapshotTime$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SnapshotTime
     * }
     */
    public static MemorySegment asn_DEF_SnapshotTime() {
        return asn_DEF_SnapshotTime$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SnapshotTime
     * }
     */
    public static void asn_DEF_SnapshotTime(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_SnapshotTime$constants.SEGMENT, 0L, asn_DEF_SnapshotTime$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_SnapshotTime_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_SnapshotTime_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_SnapshotTime_specs_1
     * }
     */
    public static GroupLayout asn_SPC_SnapshotTime_specs_1$layout() {
        return asn_SPC_SnapshotTime_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_SnapshotTime_specs_1
     * }
     */
    public static MemorySegment asn_SPC_SnapshotTime_specs_1() {
        return asn_SPC_SnapshotTime_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_SnapshotTime_specs_1
     * }
     */
    public static void asn_SPC_SnapshotTime_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_SnapshotTime_specs_1$constants.SEGMENT, 0L, asn_SPC_SnapshotTime_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_SnapshotTime_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(4, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_SnapshotTime_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 4 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SnapshotTime_1[4]
     * }
     */
    public static SequenceLayout asn_MBR_SnapshotTime_1$layout() {
        return asn_MBR_SnapshotTime_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SnapshotTime_1[4]
     * }
     */
    public static long[] asn_MBR_SnapshotTime_1$dimensions() {
        return asn_MBR_SnapshotTime_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SnapshotTime_1[4]
     * }
     */
    public static MemorySegment asn_MBR_SnapshotTime_1() {
        return asn_MBR_SnapshotTime_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SnapshotTime_1[4]
     * }
     */
    public static void asn_MBR_SnapshotTime_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_SnapshotTime_1$constants.SEGMENT, 0L, asn_MBR_SnapshotTime_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SnapshotTime_1[4]
     * }
     */
    public static MemorySegment asn_MBR_SnapshotTime_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_SnapshotTime_1$constants.HANDLE.invokeExact(asn_MBR_SnapshotTime_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SnapshotTime_1[4]
     * }
     */
    public static void asn_MBR_SnapshotTime_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_SnapshotTime_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef long GrossDistance_t
     * }
     */
    public static final OfLong GrossDistance_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_GrossDistance_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_GrossDistance_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_GrossDistance_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_GrossDistance_constr_1$layout() {
        return asn_PER_type_GrossDistance_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_GrossDistance_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_GrossDistance_constr_1() {
        return asn_PER_type_GrossDistance_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_GrossDistance_constr_1
     * }
     */
    public static void asn_PER_type_GrossDistance_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_GrossDistance_constr_1$constants.SEGMENT, 0L, asn_PER_type_GrossDistance_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_GrossDistance$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_GrossDistance").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_GrossDistance
     * }
     */
    public static GroupLayout asn_DEF_GrossDistance$layout() {
        return asn_DEF_GrossDistance$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_GrossDistance
     * }
     */
    public static MemorySegment asn_DEF_GrossDistance() {
        return asn_DEF_GrossDistance$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_GrossDistance
     * }
     */
    public static void asn_DEF_GrossDistance(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_GrossDistance$constants.SEGMENT, 0L, asn_DEF_GrossDistance$constants.LAYOUT.byteSize());
    }

    private static class GrossDistance_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GrossDistance_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GrossDistance_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor GrossDistance_free$descriptor() {
        return GrossDistance_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GrossDistance_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle GrossDistance_free$handle() {
        return GrossDistance_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GrossDistance_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment GrossDistance_free$address() {
        return GrossDistance_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GrossDistance_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void GrossDistance_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = GrossDistance_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GrossDistance_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GrossDistance_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GrossDistance_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GrossDistance_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor GrossDistance_print$descriptor() {
        return GrossDistance_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GrossDistance_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle GrossDistance_print$handle() {
        return GrossDistance_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GrossDistance_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment GrossDistance_print$address() {
        return GrossDistance_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GrossDistance_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int GrossDistance_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = GrossDistance_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GrossDistance_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GrossDistance_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GrossDistance_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GrossDistance_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor GrossDistance_constraint$descriptor() {
        return GrossDistance_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GrossDistance_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle GrossDistance_constraint$handle() {
        return GrossDistance_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GrossDistance_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment GrossDistance_constraint$address() {
        return GrossDistance_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GrossDistance_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int GrossDistance_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = GrossDistance_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GrossDistance_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GrossDistance_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GrossDistance_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t GrossDistance_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor GrossDistance_decode_ber$descriptor() {
        return GrossDistance_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t GrossDistance_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle GrossDistance_decode_ber$handle() {
        return GrossDistance_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t GrossDistance_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment GrossDistance_decode_ber$address() {
        return GrossDistance_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t GrossDistance_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment GrossDistance_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = GrossDistance_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GrossDistance_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GrossDistance_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GrossDistance_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor GrossDistance_encode_der$descriptor() {
        return GrossDistance_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle GrossDistance_encode_der$handle() {
        return GrossDistance_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment GrossDistance_encode_der$address() {
        return GrossDistance_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment GrossDistance_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = GrossDistance_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GrossDistance_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GrossDistance_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GrossDistance_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t GrossDistance_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor GrossDistance_decode_xer$descriptor() {
        return GrossDistance_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t GrossDistance_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle GrossDistance_decode_xer$handle() {
        return GrossDistance_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t GrossDistance_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment GrossDistance_decode_xer$address() {
        return GrossDistance_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t GrossDistance_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment GrossDistance_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = GrossDistance_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GrossDistance_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GrossDistance_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GrossDistance_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor GrossDistance_encode_xer$descriptor() {
        return GrossDistance_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle GrossDistance_encode_xer$handle() {
        return GrossDistance_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment GrossDistance_encode_xer$address() {
        return GrossDistance_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment GrossDistance_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = GrossDistance_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GrossDistance_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GrossDistance_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GrossDistance_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor GrossDistance_encode_jer$descriptor() {
        return GrossDistance_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle GrossDistance_encode_jer$handle() {
        return GrossDistance_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment GrossDistance_encode_jer$address() {
        return GrossDistance_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment GrossDistance_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = GrossDistance_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GrossDistance_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GrossDistance_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GrossDistance_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t GrossDistance_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor GrossDistance_decode_oer$descriptor() {
        return GrossDistance_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t GrossDistance_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle GrossDistance_decode_oer$handle() {
        return GrossDistance_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t GrossDistance_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment GrossDistance_decode_oer$address() {
        return GrossDistance_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t GrossDistance_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment GrossDistance_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = GrossDistance_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GrossDistance_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GrossDistance_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GrossDistance_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor GrossDistance_encode_oer$descriptor() {
        return GrossDistance_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle GrossDistance_encode_oer$handle() {
        return GrossDistance_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment GrossDistance_encode_oer$address() {
        return GrossDistance_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment GrossDistance_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = GrossDistance_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GrossDistance_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GrossDistance_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GrossDistance_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t GrossDistance_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor GrossDistance_decode_uper$descriptor() {
        return GrossDistance_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t GrossDistance_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle GrossDistance_decode_uper$handle() {
        return GrossDistance_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t GrossDistance_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment GrossDistance_decode_uper$address() {
        return GrossDistance_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t GrossDistance_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment GrossDistance_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = GrossDistance_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GrossDistance_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GrossDistance_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GrossDistance_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor GrossDistance_encode_uper$descriptor() {
        return GrossDistance_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle GrossDistance_encode_uper$handle() {
        return GrossDistance_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment GrossDistance_encode_uper$address() {
        return GrossDistance_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment GrossDistance_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = GrossDistance_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GrossDistance_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GrossDistance_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GrossDistance_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t GrossDistance_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor GrossDistance_decode_aper$descriptor() {
        return GrossDistance_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t GrossDistance_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle GrossDistance_decode_aper$handle() {
        return GrossDistance_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t GrossDistance_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment GrossDistance_decode_aper$address() {
        return GrossDistance_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t GrossDistance_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment GrossDistance_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = GrossDistance_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GrossDistance_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GrossDistance_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GrossDistance_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor GrossDistance_encode_aper$descriptor() {
        return GrossDistance_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle GrossDistance_encode_aper$handle() {
        return GrossDistance_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment GrossDistance_encode_aper$address() {
        return GrossDistance_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t GrossDistance_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment GrossDistance_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = GrossDistance_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GrossDistance_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_SnapshotDistance$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_SnapshotDistance").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SnapshotDistance
     * }
     */
    public static GroupLayout asn_DEF_SnapshotDistance$layout() {
        return asn_DEF_SnapshotDistance$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SnapshotDistance
     * }
     */
    public static MemorySegment asn_DEF_SnapshotDistance() {
        return asn_DEF_SnapshotDistance$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SnapshotDistance
     * }
     */
    public static void asn_DEF_SnapshotDistance(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_SnapshotDistance$constants.SEGMENT, 0L, asn_DEF_SnapshotDistance$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_SnapshotDistance_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_SnapshotDistance_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_SnapshotDistance_specs_1
     * }
     */
    public static GroupLayout asn_SPC_SnapshotDistance_specs_1$layout() {
        return asn_SPC_SnapshotDistance_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_SnapshotDistance_specs_1
     * }
     */
    public static MemorySegment asn_SPC_SnapshotDistance_specs_1() {
        return asn_SPC_SnapshotDistance_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_SnapshotDistance_specs_1
     * }
     */
    public static void asn_SPC_SnapshotDistance_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_SnapshotDistance_specs_1$constants.SEGMENT, 0L, asn_SPC_SnapshotDistance_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_SnapshotDistance_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(4, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_SnapshotDistance_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 4 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SnapshotDistance_1[4]
     * }
     */
    public static SequenceLayout asn_MBR_SnapshotDistance_1$layout() {
        return asn_MBR_SnapshotDistance_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SnapshotDistance_1[4]
     * }
     */
    public static long[] asn_MBR_SnapshotDistance_1$dimensions() {
        return asn_MBR_SnapshotDistance_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SnapshotDistance_1[4]
     * }
     */
    public static MemorySegment asn_MBR_SnapshotDistance_1() {
        return asn_MBR_SnapshotDistance_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SnapshotDistance_1[4]
     * }
     */
    public static void asn_MBR_SnapshotDistance_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_SnapshotDistance_1$constants.SEGMENT, 0L, asn_MBR_SnapshotDistance_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SnapshotDistance_1[4]
     * }
     */
    public static MemorySegment asn_MBR_SnapshotDistance_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_SnapshotDistance_1$constants.HANDLE.invokeExact(asn_MBR_SnapshotDistance_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_SnapshotDistance_1[4]
     * }
     */
    public static void asn_MBR_SnapshotDistance_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_SnapshotDistance_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    private static final int ProbeDataManagement__term_PR_NOTHING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ProbeDataManagement__term_PR.ProbeDataManagement__term_PR_NOTHING = 0
     * }
     */
    public static int ProbeDataManagement__term_PR_NOTHING() {
        return ProbeDataManagement__term_PR_NOTHING;
    }
    private static final int ProbeDataManagement__term_PR_termtime = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ProbeDataManagement__term_PR.ProbeDataManagement__term_PR_termtime = 1
     * }
     */
    public static int ProbeDataManagement__term_PR_termtime() {
        return ProbeDataManagement__term_PR_termtime;
    }
    private static final int ProbeDataManagement__term_PR_termDistance = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ProbeDataManagement__term_PR.ProbeDataManagement__term_PR_termDistance = 2
     * }
     */
    public static int ProbeDataManagement__term_PR_termDistance() {
        return ProbeDataManagement__term_PR_termDistance;
    }
    private static final int ProbeDataManagement__snapshot_PR_NOTHING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ProbeDataManagement__snapshot_PR.ProbeDataManagement__snapshot_PR_NOTHING = 0
     * }
     */
    public static int ProbeDataManagement__snapshot_PR_NOTHING() {
        return ProbeDataManagement__snapshot_PR_NOTHING;
    }
    private static final int ProbeDataManagement__snapshot_PR_snapshotTime = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ProbeDataManagement__snapshot_PR.ProbeDataManagement__snapshot_PR_snapshotTime = 1
     * }
     */
    public static int ProbeDataManagement__snapshot_PR_snapshotTime() {
        return ProbeDataManagement__snapshot_PR_snapshotTime;
    }
    private static final int ProbeDataManagement__snapshot_PR_snapshotDistance = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ProbeDataManagement__snapshot_PR.ProbeDataManagement__snapshot_PR_snapshotDistance = 2
     * }
     */
    public static int ProbeDataManagement__snapshot_PR_snapshotDistance() {
        return ProbeDataManagement__snapshot_PR_snapshotDistance;
    }

    private static class asn_DEF_ProbeDataManagement$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_ProbeDataManagement").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ProbeDataManagement
     * }
     */
    public static GroupLayout asn_DEF_ProbeDataManagement$layout() {
        return asn_DEF_ProbeDataManagement$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ProbeDataManagement
     * }
     */
    public static MemorySegment asn_DEF_ProbeDataManagement() {
        return asn_DEF_ProbeDataManagement$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ProbeDataManagement
     * }
     */
    public static void asn_DEF_ProbeDataManagement(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_ProbeDataManagement$constants.SEGMENT, 0L, asn_DEF_ProbeDataManagement$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_ProbeDataManagement_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_ProbeDataManagement_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_ProbeDataManagement_specs_1
     * }
     */
    public static GroupLayout asn_SPC_ProbeDataManagement_specs_1$layout() {
        return asn_SPC_ProbeDataManagement_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_ProbeDataManagement_specs_1
     * }
     */
    public static MemorySegment asn_SPC_ProbeDataManagement_specs_1() {
        return asn_SPC_ProbeDataManagement_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_ProbeDataManagement_specs_1
     * }
     */
    public static void asn_SPC_ProbeDataManagement_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_ProbeDataManagement_specs_1$constants.SEGMENT, 0L, asn_SPC_ProbeDataManagement_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_ProbeDataManagement_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(8, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_ProbeDataManagement_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 8 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ProbeDataManagement_1[8]
     * }
     */
    public static SequenceLayout asn_MBR_ProbeDataManagement_1$layout() {
        return asn_MBR_ProbeDataManagement_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ProbeDataManagement_1[8]
     * }
     */
    public static long[] asn_MBR_ProbeDataManagement_1$dimensions() {
        return asn_MBR_ProbeDataManagement_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ProbeDataManagement_1[8]
     * }
     */
    public static MemorySegment asn_MBR_ProbeDataManagement_1() {
        return asn_MBR_ProbeDataManagement_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ProbeDataManagement_1[8]
     * }
     */
    public static void asn_MBR_ProbeDataManagement_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_ProbeDataManagement_1$constants.SEGMENT, 0L, asn_MBR_ProbeDataManagement_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ProbeDataManagement_1[8]
     * }
     */
    public static MemorySegment asn_MBR_ProbeDataManagement_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_ProbeDataManagement_1$constants.HANDLE.invokeExact(asn_MBR_ProbeDataManagement_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ProbeDataManagement_1[8]
     * }
     */
    public static void asn_MBR_ProbeDataManagement_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_ProbeDataManagement_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_VehicleStatusRequestList$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_VehicleStatusRequestList").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleStatusRequestList
     * }
     */
    public static GroupLayout asn_DEF_VehicleStatusRequestList$layout() {
        return asn_DEF_VehicleStatusRequestList$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleStatusRequestList
     * }
     */
    public static MemorySegment asn_DEF_VehicleStatusRequestList() {
        return asn_DEF_VehicleStatusRequestList$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleStatusRequestList
     * }
     */
    public static void asn_DEF_VehicleStatusRequestList(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_VehicleStatusRequestList$constants.SEGMENT, 0L, asn_DEF_VehicleStatusRequestList$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_VehicleStatusRequestList_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SET_OF_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_VehicleStatusRequestList_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_VehicleStatusRequestList_specs_1
     * }
     */
    public static GroupLayout asn_SPC_VehicleStatusRequestList_specs_1$layout() {
        return asn_SPC_VehicleStatusRequestList_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_VehicleStatusRequestList_specs_1
     * }
     */
    public static MemorySegment asn_SPC_VehicleStatusRequestList_specs_1() {
        return asn_SPC_VehicleStatusRequestList_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_VehicleStatusRequestList_specs_1
     * }
     */
    public static void asn_SPC_VehicleStatusRequestList_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_VehicleStatusRequestList_specs_1$constants.SEGMENT, 0L, asn_SPC_VehicleStatusRequestList_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_VehicleStatusRequestList_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(1, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_VehicleStatusRequestList_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 1 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleStatusRequestList_1[1]
     * }
     */
    public static SequenceLayout asn_MBR_VehicleStatusRequestList_1$layout() {
        return asn_MBR_VehicleStatusRequestList_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleStatusRequestList_1[1]
     * }
     */
    public static long[] asn_MBR_VehicleStatusRequestList_1$dimensions() {
        return asn_MBR_VehicleStatusRequestList_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleStatusRequestList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_VehicleStatusRequestList_1() {
        return asn_MBR_VehicleStatusRequestList_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleStatusRequestList_1[1]
     * }
     */
    public static void asn_MBR_VehicleStatusRequestList_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_VehicleStatusRequestList_1$constants.SEGMENT, 0L, asn_MBR_VehicleStatusRequestList_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleStatusRequestList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_VehicleStatusRequestList_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_VehicleStatusRequestList_1$constants.HANDLE.invokeExact(asn_MBR_VehicleStatusRequestList_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleStatusRequestList_1[1]
     * }
     */
    public static void asn_MBR_VehicleStatusRequestList_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_VehicleStatusRequestList_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_VehicleStatusRequestList_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_VehicleStatusRequestList_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VehicleStatusRequestList_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_VehicleStatusRequestList_constr_1$layout() {
        return asn_PER_type_VehicleStatusRequestList_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VehicleStatusRequestList_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_VehicleStatusRequestList_constr_1() {
        return asn_PER_type_VehicleStatusRequestList_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VehicleStatusRequestList_constr_1
     * }
     */
    public static void asn_PER_type_VehicleStatusRequestList_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_VehicleStatusRequestList_constr_1$constants.SEGMENT, 0L, asn_PER_type_VehicleStatusRequestList_constr_1$constants.LAYOUT.byteSize());
    }
    private static final int VehicleStatusDeviceTypeTag_unknown = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_unknown = 0
     * }
     */
    public static int VehicleStatusDeviceTypeTag_unknown() {
        return VehicleStatusDeviceTypeTag_unknown;
    }
    private static final int VehicleStatusDeviceTypeTag_lights = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_lights = 1
     * }
     */
    public static int VehicleStatusDeviceTypeTag_lights() {
        return VehicleStatusDeviceTypeTag_lights;
    }
    private static final int VehicleStatusDeviceTypeTag_wipers = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_wipers = 2
     * }
     */
    public static int VehicleStatusDeviceTypeTag_wipers() {
        return VehicleStatusDeviceTypeTag_wipers;
    }
    private static final int VehicleStatusDeviceTypeTag_brakes = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_brakes = 3
     * }
     */
    public static int VehicleStatusDeviceTypeTag_brakes() {
        return VehicleStatusDeviceTypeTag_brakes;
    }
    private static final int VehicleStatusDeviceTypeTag_stab = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_stab = 4
     * }
     */
    public static int VehicleStatusDeviceTypeTag_stab() {
        return VehicleStatusDeviceTypeTag_stab;
    }
    private static final int VehicleStatusDeviceTypeTag_trac = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_trac = 5
     * }
     */
    public static int VehicleStatusDeviceTypeTag_trac() {
        return VehicleStatusDeviceTypeTag_trac;
    }
    private static final int VehicleStatusDeviceTypeTag_abs = (int)6L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_abs = 6
     * }
     */
    public static int VehicleStatusDeviceTypeTag_abs() {
        return VehicleStatusDeviceTypeTag_abs;
    }
    private static final int VehicleStatusDeviceTypeTag_sunS = (int)7L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_sunS = 7
     * }
     */
    public static int VehicleStatusDeviceTypeTag_sunS() {
        return VehicleStatusDeviceTypeTag_sunS;
    }
    private static final int VehicleStatusDeviceTypeTag_rainS = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_rainS = 8
     * }
     */
    public static int VehicleStatusDeviceTypeTag_rainS() {
        return VehicleStatusDeviceTypeTag_rainS;
    }
    private static final int VehicleStatusDeviceTypeTag_airTemp = (int)9L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_airTemp = 9
     * }
     */
    public static int VehicleStatusDeviceTypeTag_airTemp() {
        return VehicleStatusDeviceTypeTag_airTemp;
    }
    private static final int VehicleStatusDeviceTypeTag_steering = (int)10L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_steering = 10
     * }
     */
    public static int VehicleStatusDeviceTypeTag_steering() {
        return VehicleStatusDeviceTypeTag_steering;
    }
    private static final int VehicleStatusDeviceTypeTag_vertAccelThres = (int)11L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_vertAccelThres = 11
     * }
     */
    public static int VehicleStatusDeviceTypeTag_vertAccelThres() {
        return VehicleStatusDeviceTypeTag_vertAccelThres;
    }
    private static final int VehicleStatusDeviceTypeTag_vertAccel = (int)12L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_vertAccel = 12
     * }
     */
    public static int VehicleStatusDeviceTypeTag_vertAccel() {
        return VehicleStatusDeviceTypeTag_vertAccel;
    }
    private static final int VehicleStatusDeviceTypeTag_hozAccelLong = (int)13L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_hozAccelLong = 13
     * }
     */
    public static int VehicleStatusDeviceTypeTag_hozAccelLong() {
        return VehicleStatusDeviceTypeTag_hozAccelLong;
    }
    private static final int VehicleStatusDeviceTypeTag_hozAccelLat = (int)14L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_hozAccelLat = 14
     * }
     */
    public static int VehicleStatusDeviceTypeTag_hozAccelLat() {
        return VehicleStatusDeviceTypeTag_hozAccelLat;
    }
    private static final int VehicleStatusDeviceTypeTag_hozAccelCon = (int)15L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_hozAccelCon = 15
     * }
     */
    public static int VehicleStatusDeviceTypeTag_hozAccelCon() {
        return VehicleStatusDeviceTypeTag_hozAccelCon;
    }
    private static final int VehicleStatusDeviceTypeTag_accel4way = (int)16L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_accel4way = 16
     * }
     */
    public static int VehicleStatusDeviceTypeTag_accel4way() {
        return VehicleStatusDeviceTypeTag_accel4way;
    }
    private static final int VehicleStatusDeviceTypeTag_confidenceSet = (int)17L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_confidenceSet = 17
     * }
     */
    public static int VehicleStatusDeviceTypeTag_confidenceSet() {
        return VehicleStatusDeviceTypeTag_confidenceSet;
    }
    private static final int VehicleStatusDeviceTypeTag_obDist = (int)18L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_obDist = 18
     * }
     */
    public static int VehicleStatusDeviceTypeTag_obDist() {
        return VehicleStatusDeviceTypeTag_obDist;
    }
    private static final int VehicleStatusDeviceTypeTag_obDirect = (int)19L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_obDirect = 19
     * }
     */
    public static int VehicleStatusDeviceTypeTag_obDirect() {
        return VehicleStatusDeviceTypeTag_obDirect;
    }
    private static final int VehicleStatusDeviceTypeTag_yaw = (int)20L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_yaw = 20
     * }
     */
    public static int VehicleStatusDeviceTypeTag_yaw() {
        return VehicleStatusDeviceTypeTag_yaw;
    }
    private static final int VehicleStatusDeviceTypeTag_yawRateCon = (int)21L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_yawRateCon = 21
     * }
     */
    public static int VehicleStatusDeviceTypeTag_yawRateCon() {
        return VehicleStatusDeviceTypeTag_yawRateCon;
    }
    private static final int VehicleStatusDeviceTypeTag_dateTime = (int)22L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_dateTime = 22
     * }
     */
    public static int VehicleStatusDeviceTypeTag_dateTime() {
        return VehicleStatusDeviceTypeTag_dateTime;
    }
    private static final int VehicleStatusDeviceTypeTag_fullPos = (int)23L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_fullPos = 23
     * }
     */
    public static int VehicleStatusDeviceTypeTag_fullPos() {
        return VehicleStatusDeviceTypeTag_fullPos;
    }
    private static final int VehicleStatusDeviceTypeTag_position2D = (int)24L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_position2D = 24
     * }
     */
    public static int VehicleStatusDeviceTypeTag_position2D() {
        return VehicleStatusDeviceTypeTag_position2D;
    }
    private static final int VehicleStatusDeviceTypeTag_position3D = (int)25L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_position3D = 25
     * }
     */
    public static int VehicleStatusDeviceTypeTag_position3D() {
        return VehicleStatusDeviceTypeTag_position3D;
    }
    private static final int VehicleStatusDeviceTypeTag_vehicle = (int)26L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_vehicle = 26
     * }
     */
    public static int VehicleStatusDeviceTypeTag_vehicle() {
        return VehicleStatusDeviceTypeTag_vehicle;
    }
    private static final int VehicleStatusDeviceTypeTag_speedHeadC = (int)27L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_speedHeadC = 27
     * }
     */
    public static int VehicleStatusDeviceTypeTag_speedHeadC() {
        return VehicleStatusDeviceTypeTag_speedHeadC;
    }
    private static final int VehicleStatusDeviceTypeTag_speedC = (int)28L;
    /**
     * {@snippet lang=c :
     * enum VehicleStatusDeviceTypeTag.VehicleStatusDeviceTypeTag_speedC = 28
     * }
     */
    public static int VehicleStatusDeviceTypeTag_speedC() {
        return VehicleStatusDeviceTypeTag_speedC;
    }
    /**
     * {@snippet lang=c :
     * typedef long VehicleStatusDeviceTypeTag_t
     * }
     */
    public static final OfLong VehicleStatusDeviceTypeTag_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_VehicleStatusDeviceTypeTag_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_VehicleStatusDeviceTypeTag_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VehicleStatusDeviceTypeTag_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_VehicleStatusDeviceTypeTag_constr_1$layout() {
        return asn_PER_type_VehicleStatusDeviceTypeTag_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VehicleStatusDeviceTypeTag_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_VehicleStatusDeviceTypeTag_constr_1() {
        return asn_PER_type_VehicleStatusDeviceTypeTag_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VehicleStatusDeviceTypeTag_constr_1
     * }
     */
    public static void asn_PER_type_VehicleStatusDeviceTypeTag_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_VehicleStatusDeviceTypeTag_constr_1$constants.SEGMENT, 0L, asn_PER_type_VehicleStatusDeviceTypeTag_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_VehicleStatusDeviceTypeTag$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_VehicleStatusDeviceTypeTag").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleStatusDeviceTypeTag
     * }
     */
    public static GroupLayout asn_DEF_VehicleStatusDeviceTypeTag$layout() {
        return asn_DEF_VehicleStatusDeviceTypeTag$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleStatusDeviceTypeTag
     * }
     */
    public static MemorySegment asn_DEF_VehicleStatusDeviceTypeTag() {
        return asn_DEF_VehicleStatusDeviceTypeTag$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleStatusDeviceTypeTag
     * }
     */
    public static void asn_DEF_VehicleStatusDeviceTypeTag(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_VehicleStatusDeviceTypeTag$constants.SEGMENT, 0L, asn_DEF_VehicleStatusDeviceTypeTag$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_VehicleStatusDeviceTypeTag_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_VehicleStatusDeviceTypeTag_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_VehicleStatusDeviceTypeTag_specs_1
     * }
     */
    public static GroupLayout asn_SPC_VehicleStatusDeviceTypeTag_specs_1$layout() {
        return asn_SPC_VehicleStatusDeviceTypeTag_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_VehicleStatusDeviceTypeTag_specs_1
     * }
     */
    public static MemorySegment asn_SPC_VehicleStatusDeviceTypeTag_specs_1() {
        return asn_SPC_VehicleStatusDeviceTypeTag_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_VehicleStatusDeviceTypeTag_specs_1
     * }
     */
    public static void asn_SPC_VehicleStatusDeviceTypeTag_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_VehicleStatusDeviceTypeTag_specs_1$constants.SEGMENT, 0L, asn_SPC_VehicleStatusDeviceTypeTag_specs_1$constants.LAYOUT.byteSize());
    }

    private static class VehicleStatusDeviceTypeTag_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleStatusDeviceTypeTag_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void VehicleStatusDeviceTypeTag_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor VehicleStatusDeviceTypeTag_free$descriptor() {
        return VehicleStatusDeviceTypeTag_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void VehicleStatusDeviceTypeTag_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle VehicleStatusDeviceTypeTag_free$handle() {
        return VehicleStatusDeviceTypeTag_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void VehicleStatusDeviceTypeTag_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_free$address() {
        return VehicleStatusDeviceTypeTag_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void VehicleStatusDeviceTypeTag_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void VehicleStatusDeviceTypeTag_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = VehicleStatusDeviceTypeTag_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleStatusDeviceTypeTag_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleStatusDeviceTypeTag_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleStatusDeviceTypeTag_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int VehicleStatusDeviceTypeTag_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleStatusDeviceTypeTag_print$descriptor() {
        return VehicleStatusDeviceTypeTag_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int VehicleStatusDeviceTypeTag_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VehicleStatusDeviceTypeTag_print$handle() {
        return VehicleStatusDeviceTypeTag_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int VehicleStatusDeviceTypeTag_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_print$address() {
        return VehicleStatusDeviceTypeTag_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int VehicleStatusDeviceTypeTag_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int VehicleStatusDeviceTypeTag_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VehicleStatusDeviceTypeTag_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleStatusDeviceTypeTag_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleStatusDeviceTypeTag_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleStatusDeviceTypeTag_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int VehicleStatusDeviceTypeTag_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleStatusDeviceTypeTag_constraint$descriptor() {
        return VehicleStatusDeviceTypeTag_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int VehicleStatusDeviceTypeTag_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle VehicleStatusDeviceTypeTag_constraint$handle() {
        return VehicleStatusDeviceTypeTag_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int VehicleStatusDeviceTypeTag_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_constraint$address() {
        return VehicleStatusDeviceTypeTag_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int VehicleStatusDeviceTypeTag_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int VehicleStatusDeviceTypeTag_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = VehicleStatusDeviceTypeTag_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleStatusDeviceTypeTag_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleStatusDeviceTypeTag_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleStatusDeviceTypeTag_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleStatusDeviceTypeTag_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor VehicleStatusDeviceTypeTag_decode_ber$descriptor() {
        return VehicleStatusDeviceTypeTag_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleStatusDeviceTypeTag_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle VehicleStatusDeviceTypeTag_decode_ber$handle() {
        return VehicleStatusDeviceTypeTag_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleStatusDeviceTypeTag_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_decode_ber$address() {
        return VehicleStatusDeviceTypeTag_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleStatusDeviceTypeTag_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = VehicleStatusDeviceTypeTag_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleStatusDeviceTypeTag_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleStatusDeviceTypeTag_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleStatusDeviceTypeTag_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleStatusDeviceTypeTag_encode_der$descriptor() {
        return VehicleStatusDeviceTypeTag_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VehicleStatusDeviceTypeTag_encode_der$handle() {
        return VehicleStatusDeviceTypeTag_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_encode_der$address() {
        return VehicleStatusDeviceTypeTag_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = VehicleStatusDeviceTypeTag_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleStatusDeviceTypeTag_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleStatusDeviceTypeTag_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleStatusDeviceTypeTag_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleStatusDeviceTypeTag_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor VehicleStatusDeviceTypeTag_decode_xer$descriptor() {
        return VehicleStatusDeviceTypeTag_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleStatusDeviceTypeTag_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle VehicleStatusDeviceTypeTag_decode_xer$handle() {
        return VehicleStatusDeviceTypeTag_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleStatusDeviceTypeTag_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_decode_xer$address() {
        return VehicleStatusDeviceTypeTag_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleStatusDeviceTypeTag_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = VehicleStatusDeviceTypeTag_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleStatusDeviceTypeTag_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleStatusDeviceTypeTag_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleStatusDeviceTypeTag_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleStatusDeviceTypeTag_encode_xer$descriptor() {
        return VehicleStatusDeviceTypeTag_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VehicleStatusDeviceTypeTag_encode_xer$handle() {
        return VehicleStatusDeviceTypeTag_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_encode_xer$address() {
        return VehicleStatusDeviceTypeTag_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = VehicleStatusDeviceTypeTag_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleStatusDeviceTypeTag_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleStatusDeviceTypeTag_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleStatusDeviceTypeTag_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleStatusDeviceTypeTag_encode_jer$descriptor() {
        return VehicleStatusDeviceTypeTag_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VehicleStatusDeviceTypeTag_encode_jer$handle() {
        return VehicleStatusDeviceTypeTag_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_encode_jer$address() {
        return VehicleStatusDeviceTypeTag_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = VehicleStatusDeviceTypeTag_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleStatusDeviceTypeTag_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleStatusDeviceTypeTag_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleStatusDeviceTypeTag_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleStatusDeviceTypeTag_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor VehicleStatusDeviceTypeTag_decode_oer$descriptor() {
        return VehicleStatusDeviceTypeTag_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleStatusDeviceTypeTag_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle VehicleStatusDeviceTypeTag_decode_oer$handle() {
        return VehicleStatusDeviceTypeTag_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleStatusDeviceTypeTag_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_decode_oer$address() {
        return VehicleStatusDeviceTypeTag_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleStatusDeviceTypeTag_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = VehicleStatusDeviceTypeTag_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleStatusDeviceTypeTag_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleStatusDeviceTypeTag_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleStatusDeviceTypeTag_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleStatusDeviceTypeTag_encode_oer$descriptor() {
        return VehicleStatusDeviceTypeTag_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VehicleStatusDeviceTypeTag_encode_oer$handle() {
        return VehicleStatusDeviceTypeTag_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_encode_oer$address() {
        return VehicleStatusDeviceTypeTag_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VehicleStatusDeviceTypeTag_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleStatusDeviceTypeTag_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleStatusDeviceTypeTag_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleStatusDeviceTypeTag_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleStatusDeviceTypeTag_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor VehicleStatusDeviceTypeTag_decode_uper$descriptor() {
        return VehicleStatusDeviceTypeTag_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleStatusDeviceTypeTag_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle VehicleStatusDeviceTypeTag_decode_uper$handle() {
        return VehicleStatusDeviceTypeTag_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleStatusDeviceTypeTag_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_decode_uper$address() {
        return VehicleStatusDeviceTypeTag_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleStatusDeviceTypeTag_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VehicleStatusDeviceTypeTag_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleStatusDeviceTypeTag_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleStatusDeviceTypeTag_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleStatusDeviceTypeTag_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor VehicleStatusDeviceTypeTag_encode_uper$descriptor() {
        return VehicleStatusDeviceTypeTag_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle VehicleStatusDeviceTypeTag_encode_uper$handle() {
        return VehicleStatusDeviceTypeTag_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_encode_uper$address() {
        return VehicleStatusDeviceTypeTag_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = VehicleStatusDeviceTypeTag_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleStatusDeviceTypeTag_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleStatusDeviceTypeTag_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleStatusDeviceTypeTag_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleStatusDeviceTypeTag_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor VehicleStatusDeviceTypeTag_decode_aper$descriptor() {
        return VehicleStatusDeviceTypeTag_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleStatusDeviceTypeTag_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle VehicleStatusDeviceTypeTag_decode_aper$handle() {
        return VehicleStatusDeviceTypeTag_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleStatusDeviceTypeTag_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_decode_aper$address() {
        return VehicleStatusDeviceTypeTag_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleStatusDeviceTypeTag_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VehicleStatusDeviceTypeTag_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleStatusDeviceTypeTag_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleStatusDeviceTypeTag_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleStatusDeviceTypeTag_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor VehicleStatusDeviceTypeTag_encode_aper$descriptor() {
        return VehicleStatusDeviceTypeTag_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle VehicleStatusDeviceTypeTag_encode_aper$handle() {
        return VehicleStatusDeviceTypeTag_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_encode_aper$address() {
        return VehicleStatusDeviceTypeTag_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleStatusDeviceTypeTag_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VehicleStatusDeviceTypeTag_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = VehicleStatusDeviceTypeTag_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleStatusDeviceTypeTag_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_VehicleStatusRequest$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_VehicleStatusRequest").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleStatusRequest
     * }
     */
    public static GroupLayout asn_DEF_VehicleStatusRequest$layout() {
        return asn_DEF_VehicleStatusRequest$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleStatusRequest
     * }
     */
    public static MemorySegment asn_DEF_VehicleStatusRequest() {
        return asn_DEF_VehicleStatusRequest$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleStatusRequest
     * }
     */
    public static void asn_DEF_VehicleStatusRequest(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_VehicleStatusRequest$constants.SEGMENT, 0L, asn_DEF_VehicleStatusRequest$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_VehicleStatusRequest_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_VehicleStatusRequest_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_VehicleStatusRequest_specs_1
     * }
     */
    public static GroupLayout asn_SPC_VehicleStatusRequest_specs_1$layout() {
        return asn_SPC_VehicleStatusRequest_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_VehicleStatusRequest_specs_1
     * }
     */
    public static MemorySegment asn_SPC_VehicleStatusRequest_specs_1() {
        return asn_SPC_VehicleStatusRequest_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_VehicleStatusRequest_specs_1
     * }
     */
    public static void asn_SPC_VehicleStatusRequest_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_VehicleStatusRequest_specs_1$constants.SEGMENT, 0L, asn_SPC_VehicleStatusRequest_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_VehicleStatusRequest_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(5, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_VehicleStatusRequest_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 5 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleStatusRequest_1[5]
     * }
     */
    public static SequenceLayout asn_MBR_VehicleStatusRequest_1$layout() {
        return asn_MBR_VehicleStatusRequest_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleStatusRequest_1[5]
     * }
     */
    public static long[] asn_MBR_VehicleStatusRequest_1$dimensions() {
        return asn_MBR_VehicleStatusRequest_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleStatusRequest_1[5]
     * }
     */
    public static MemorySegment asn_MBR_VehicleStatusRequest_1() {
        return asn_MBR_VehicleStatusRequest_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleStatusRequest_1[5]
     * }
     */
    public static void asn_MBR_VehicleStatusRequest_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_VehicleStatusRequest_1$constants.SEGMENT, 0L, asn_MBR_VehicleStatusRequest_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleStatusRequest_1[5]
     * }
     */
    public static MemorySegment asn_MBR_VehicleStatusRequest_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_VehicleStatusRequest_1$constants.HANDLE.invokeExact(asn_MBR_VehicleStatusRequest_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleStatusRequest_1[5]
     * }
     */
    public static void asn_MBR_VehicleStatusRequest_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_VehicleStatusRequest_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef long ProbeSegmentNumber_t
     * }
     */
    public static final OfLong ProbeSegmentNumber_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_ProbeSegmentNumber_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_ProbeSegmentNumber_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ProbeSegmentNumber_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_ProbeSegmentNumber_constr_1$layout() {
        return asn_PER_type_ProbeSegmentNumber_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ProbeSegmentNumber_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_ProbeSegmentNumber_constr_1() {
        return asn_PER_type_ProbeSegmentNumber_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ProbeSegmentNumber_constr_1
     * }
     */
    public static void asn_PER_type_ProbeSegmentNumber_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_ProbeSegmentNumber_constr_1$constants.SEGMENT, 0L, asn_PER_type_ProbeSegmentNumber_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_ProbeSegmentNumber$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_ProbeSegmentNumber").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ProbeSegmentNumber
     * }
     */
    public static GroupLayout asn_DEF_ProbeSegmentNumber$layout() {
        return asn_DEF_ProbeSegmentNumber$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ProbeSegmentNumber
     * }
     */
    public static MemorySegment asn_DEF_ProbeSegmentNumber() {
        return asn_DEF_ProbeSegmentNumber$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ProbeSegmentNumber
     * }
     */
    public static void asn_DEF_ProbeSegmentNumber(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_ProbeSegmentNumber$constants.SEGMENT, 0L, asn_DEF_ProbeSegmentNumber$constants.LAYOUT.byteSize());
    }

    private static class ProbeSegmentNumber_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ProbeSegmentNumber_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ProbeSegmentNumber_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor ProbeSegmentNumber_free$descriptor() {
        return ProbeSegmentNumber_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ProbeSegmentNumber_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle ProbeSegmentNumber_free$handle() {
        return ProbeSegmentNumber_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ProbeSegmentNumber_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_free$address() {
        return ProbeSegmentNumber_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ProbeSegmentNumber_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void ProbeSegmentNumber_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = ProbeSegmentNumber_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ProbeSegmentNumber_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ProbeSegmentNumber_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ProbeSegmentNumber_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ProbeSegmentNumber_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ProbeSegmentNumber_print$descriptor() {
        return ProbeSegmentNumber_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ProbeSegmentNumber_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ProbeSegmentNumber_print$handle() {
        return ProbeSegmentNumber_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ProbeSegmentNumber_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_print$address() {
        return ProbeSegmentNumber_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ProbeSegmentNumber_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int ProbeSegmentNumber_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ProbeSegmentNumber_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ProbeSegmentNumber_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ProbeSegmentNumber_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ProbeSegmentNumber_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ProbeSegmentNumber_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor ProbeSegmentNumber_constraint$descriptor() {
        return ProbeSegmentNumber_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ProbeSegmentNumber_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle ProbeSegmentNumber_constraint$handle() {
        return ProbeSegmentNumber_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ProbeSegmentNumber_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_constraint$address() {
        return ProbeSegmentNumber_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ProbeSegmentNumber_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int ProbeSegmentNumber_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ProbeSegmentNumber_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ProbeSegmentNumber_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ProbeSegmentNumber_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ProbeSegmentNumber_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ProbeSegmentNumber_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor ProbeSegmentNumber_decode_ber$descriptor() {
        return ProbeSegmentNumber_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ProbeSegmentNumber_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle ProbeSegmentNumber_decode_ber$handle() {
        return ProbeSegmentNumber_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ProbeSegmentNumber_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_decode_ber$address() {
        return ProbeSegmentNumber_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ProbeSegmentNumber_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = ProbeSegmentNumber_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ProbeSegmentNumber_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ProbeSegmentNumber_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ProbeSegmentNumber_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ProbeSegmentNumber_encode_der$descriptor() {
        return ProbeSegmentNumber_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ProbeSegmentNumber_encode_der$handle() {
        return ProbeSegmentNumber_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_encode_der$address() {
        return ProbeSegmentNumber_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ProbeSegmentNumber_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ProbeSegmentNumber_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ProbeSegmentNumber_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ProbeSegmentNumber_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ProbeSegmentNumber_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor ProbeSegmentNumber_decode_xer$descriptor() {
        return ProbeSegmentNumber_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ProbeSegmentNumber_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle ProbeSegmentNumber_decode_xer$handle() {
        return ProbeSegmentNumber_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ProbeSegmentNumber_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_decode_xer$address() {
        return ProbeSegmentNumber_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ProbeSegmentNumber_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = ProbeSegmentNumber_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ProbeSegmentNumber_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ProbeSegmentNumber_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ProbeSegmentNumber_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ProbeSegmentNumber_encode_xer$descriptor() {
        return ProbeSegmentNumber_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ProbeSegmentNumber_encode_xer$handle() {
        return ProbeSegmentNumber_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_encode_xer$address() {
        return ProbeSegmentNumber_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ProbeSegmentNumber_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ProbeSegmentNumber_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ProbeSegmentNumber_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ProbeSegmentNumber_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ProbeSegmentNumber_encode_jer$descriptor() {
        return ProbeSegmentNumber_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ProbeSegmentNumber_encode_jer$handle() {
        return ProbeSegmentNumber_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_encode_jer$address() {
        return ProbeSegmentNumber_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = ProbeSegmentNumber_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ProbeSegmentNumber_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ProbeSegmentNumber_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ProbeSegmentNumber_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ProbeSegmentNumber_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor ProbeSegmentNumber_decode_oer$descriptor() {
        return ProbeSegmentNumber_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ProbeSegmentNumber_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle ProbeSegmentNumber_decode_oer$handle() {
        return ProbeSegmentNumber_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ProbeSegmentNumber_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_decode_oer$address() {
        return ProbeSegmentNumber_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ProbeSegmentNumber_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = ProbeSegmentNumber_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ProbeSegmentNumber_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ProbeSegmentNumber_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ProbeSegmentNumber_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ProbeSegmentNumber_encode_oer$descriptor() {
        return ProbeSegmentNumber_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ProbeSegmentNumber_encode_oer$handle() {
        return ProbeSegmentNumber_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_encode_oer$address() {
        return ProbeSegmentNumber_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ProbeSegmentNumber_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ProbeSegmentNumber_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ProbeSegmentNumber_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ProbeSegmentNumber_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ProbeSegmentNumber_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor ProbeSegmentNumber_decode_uper$descriptor() {
        return ProbeSegmentNumber_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ProbeSegmentNumber_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle ProbeSegmentNumber_decode_uper$handle() {
        return ProbeSegmentNumber_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ProbeSegmentNumber_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_decode_uper$address() {
        return ProbeSegmentNumber_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ProbeSegmentNumber_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ProbeSegmentNumber_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ProbeSegmentNumber_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ProbeSegmentNumber_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ProbeSegmentNumber_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor ProbeSegmentNumber_encode_uper$descriptor() {
        return ProbeSegmentNumber_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle ProbeSegmentNumber_encode_uper$handle() {
        return ProbeSegmentNumber_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_encode_uper$address() {
        return ProbeSegmentNumber_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ProbeSegmentNumber_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ProbeSegmentNumber_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ProbeSegmentNumber_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ProbeSegmentNumber_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ProbeSegmentNumber_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor ProbeSegmentNumber_decode_aper$descriptor() {
        return ProbeSegmentNumber_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ProbeSegmentNumber_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle ProbeSegmentNumber_decode_aper$handle() {
        return ProbeSegmentNumber_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ProbeSegmentNumber_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_decode_aper$address() {
        return ProbeSegmentNumber_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ProbeSegmentNumber_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ProbeSegmentNumber_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ProbeSegmentNumber_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ProbeSegmentNumber_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ProbeSegmentNumber_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor ProbeSegmentNumber_encode_aper$descriptor() {
        return ProbeSegmentNumber_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle ProbeSegmentNumber_encode_aper$handle() {
        return ProbeSegmentNumber_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_encode_aper$address() {
        return ProbeSegmentNumber_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ProbeSegmentNumber_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ProbeSegmentNumber_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ProbeSegmentNumber_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ProbeSegmentNumber_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_ProbeVehicleData$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_ProbeVehicleData").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ProbeVehicleData
     * }
     */
    public static GroupLayout asn_DEF_ProbeVehicleData$layout() {
        return asn_DEF_ProbeVehicleData$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ProbeVehicleData
     * }
     */
    public static MemorySegment asn_DEF_ProbeVehicleData() {
        return asn_DEF_ProbeVehicleData$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ProbeVehicleData
     * }
     */
    public static void asn_DEF_ProbeVehicleData(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_ProbeVehicleData$constants.SEGMENT, 0L, asn_DEF_ProbeVehicleData$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_ProbeVehicleData_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_ProbeVehicleData_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_ProbeVehicleData_specs_1
     * }
     */
    public static GroupLayout asn_SPC_ProbeVehicleData_specs_1$layout() {
        return asn_SPC_ProbeVehicleData_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_ProbeVehicleData_specs_1
     * }
     */
    public static MemorySegment asn_SPC_ProbeVehicleData_specs_1() {
        return asn_SPC_ProbeVehicleData_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_ProbeVehicleData_specs_1
     * }
     */
    public static void asn_SPC_ProbeVehicleData_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_ProbeVehicleData_specs_1$constants.SEGMENT, 0L, asn_SPC_ProbeVehicleData_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_ProbeVehicleData_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(7, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_ProbeVehicleData_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 7 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ProbeVehicleData_1[7]
     * }
     */
    public static SequenceLayout asn_MBR_ProbeVehicleData_1$layout() {
        return asn_MBR_ProbeVehicleData_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ProbeVehicleData_1[7]
     * }
     */
    public static long[] asn_MBR_ProbeVehicleData_1$dimensions() {
        return asn_MBR_ProbeVehicleData_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ProbeVehicleData_1[7]
     * }
     */
    public static MemorySegment asn_MBR_ProbeVehicleData_1() {
        return asn_MBR_ProbeVehicleData_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ProbeVehicleData_1[7]
     * }
     */
    public static void asn_MBR_ProbeVehicleData_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_ProbeVehicleData_1$constants.SEGMENT, 0L, asn_MBR_ProbeVehicleData_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ProbeVehicleData_1[7]
     * }
     */
    public static MemorySegment asn_MBR_ProbeVehicleData_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_ProbeVehicleData_1$constants.HANDLE.invokeExact(asn_MBR_ProbeVehicleData_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_ProbeVehicleData_1[7]
     * }
     */
    public static void asn_MBR_ProbeVehicleData_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_ProbeVehicleData_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_VINstring_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_VINstring_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VINstring_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_VINstring_constr_1$layout() {
        return asn_PER_type_VINstring_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VINstring_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_VINstring_constr_1() {
        return asn_PER_type_VINstring_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VINstring_constr_1
     * }
     */
    public static void asn_PER_type_VINstring_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_VINstring_constr_1$constants.SEGMENT, 0L, asn_PER_type_VINstring_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_VINstring$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_VINstring").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VINstring
     * }
     */
    public static GroupLayout asn_DEF_VINstring$layout() {
        return asn_DEF_VINstring$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VINstring
     * }
     */
    public static MemorySegment asn_DEF_VINstring() {
        return asn_DEF_VINstring$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VINstring
     * }
     */
    public static void asn_DEF_VINstring(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_VINstring$constants.SEGMENT, 0L, asn_DEF_VINstring$constants.LAYOUT.byteSize());
    }

    private static class VINstring_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VINstring_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void VINstring_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor VINstring_free$descriptor() {
        return VINstring_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void VINstring_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle VINstring_free$handle() {
        return VINstring_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void VINstring_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment VINstring_free$address() {
        return VINstring_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void VINstring_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void VINstring_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = VINstring_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VINstring_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VINstring_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VINstring_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int VINstring_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VINstring_print$descriptor() {
        return VINstring_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int VINstring_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VINstring_print$handle() {
        return VINstring_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int VINstring_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VINstring_print$address() {
        return VINstring_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int VINstring_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int VINstring_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VINstring_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VINstring_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VINstring_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VINstring_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int VINstring_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor VINstring_constraint$descriptor() {
        return VINstring_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int VINstring_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle VINstring_constraint$handle() {
        return VINstring_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int VINstring_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment VINstring_constraint$address() {
        return VINstring_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int VINstring_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int VINstring_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = VINstring_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VINstring_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VINstring_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VINstring_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VINstring_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor VINstring_decode_ber$descriptor() {
        return VINstring_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VINstring_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle VINstring_decode_ber$handle() {
        return VINstring_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VINstring_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment VINstring_decode_ber$address() {
        return VINstring_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VINstring_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment VINstring_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = VINstring_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VINstring_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VINstring_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VINstring_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VINstring_encode_der$descriptor() {
        return VINstring_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VINstring_encode_der$handle() {
        return VINstring_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VINstring_encode_der$address() {
        return VINstring_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VINstring_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = VINstring_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VINstring_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VINstring_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VINstring_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VINstring_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor VINstring_decode_xer$descriptor() {
        return VINstring_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VINstring_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle VINstring_decode_xer$handle() {
        return VINstring_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VINstring_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment VINstring_decode_xer$address() {
        return VINstring_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VINstring_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment VINstring_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = VINstring_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VINstring_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VINstring_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VINstring_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VINstring_encode_xer$descriptor() {
        return VINstring_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VINstring_encode_xer$handle() {
        return VINstring_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VINstring_encode_xer$address() {
        return VINstring_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VINstring_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = VINstring_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VINstring_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VINstring_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VINstring_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VINstring_encode_jer$descriptor() {
        return VINstring_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VINstring_encode_jer$handle() {
        return VINstring_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VINstring_encode_jer$address() {
        return VINstring_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VINstring_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = VINstring_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VINstring_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VINstring_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VINstring_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VINstring_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor VINstring_decode_oer$descriptor() {
        return VINstring_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VINstring_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle VINstring_decode_oer$handle() {
        return VINstring_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VINstring_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment VINstring_decode_oer$address() {
        return VINstring_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VINstring_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment VINstring_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = VINstring_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VINstring_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VINstring_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VINstring_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VINstring_encode_oer$descriptor() {
        return VINstring_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VINstring_encode_oer$handle() {
        return VINstring_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VINstring_encode_oer$address() {
        return VINstring_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VINstring_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VINstring_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VINstring_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VINstring_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VINstring_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VINstring_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor VINstring_decode_uper$descriptor() {
        return VINstring_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VINstring_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle VINstring_decode_uper$handle() {
        return VINstring_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VINstring_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VINstring_decode_uper$address() {
        return VINstring_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VINstring_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VINstring_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VINstring_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VINstring_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VINstring_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VINstring_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor VINstring_encode_uper$descriptor() {
        return VINstring_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle VINstring_encode_uper$handle() {
        return VINstring_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VINstring_encode_uper$address() {
        return VINstring_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VINstring_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = VINstring_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VINstring_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VINstring_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VINstring_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VINstring_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor VINstring_decode_aper$descriptor() {
        return VINstring_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VINstring_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle VINstring_decode_aper$handle() {
        return VINstring_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VINstring_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VINstring_decode_aper$address() {
        return VINstring_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VINstring_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VINstring_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VINstring_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VINstring_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VINstring_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VINstring_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor VINstring_encode_aper$descriptor() {
        return VINstring_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle VINstring_encode_aper$handle() {
        return VINstring_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VINstring_encode_aper$address() {
        return VINstring_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VINstring_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VINstring_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = VINstring_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VINstring_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VehicleIdent__vehicleClass_PR_NOTHING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VehicleIdent__vehicleClass_PR.VehicleIdent__vehicleClass_PR_NOTHING = 0
     * }
     */
    public static int VehicleIdent__vehicleClass_PR_NOTHING() {
        return VehicleIdent__vehicleClass_PR_NOTHING;
    }
    private static final int VehicleIdent__vehicleClass_PR_vGroup = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VehicleIdent__vehicleClass_PR.VehicleIdent__vehicleClass_PR_vGroup = 1
     * }
     */
    public static int VehicleIdent__vehicleClass_PR_vGroup() {
        return VehicleIdent__vehicleClass_PR_vGroup;
    }
    private static final int VehicleIdent__vehicleClass_PR_rGroup = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VehicleIdent__vehicleClass_PR.VehicleIdent__vehicleClass_PR_rGroup = 2
     * }
     */
    public static int VehicleIdent__vehicleClass_PR_rGroup() {
        return VehicleIdent__vehicleClass_PR_rGroup;
    }
    private static final int VehicleIdent__vehicleClass_PR_rEquip = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VehicleIdent__vehicleClass_PR.VehicleIdent__vehicleClass_PR_rEquip = 3
     * }
     */
    public static int VehicleIdent__vehicleClass_PR_rEquip() {
        return VehicleIdent__vehicleClass_PR_rEquip;
    }

    private static class asn_DEF_VehicleIdent$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_VehicleIdent").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleIdent
     * }
     */
    public static GroupLayout asn_DEF_VehicleIdent$layout() {
        return asn_DEF_VehicleIdent$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleIdent
     * }
     */
    public static MemorySegment asn_DEF_VehicleIdent() {
        return asn_DEF_VehicleIdent$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleIdent
     * }
     */
    public static void asn_DEF_VehicleIdent(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_VehicleIdent$constants.SEGMENT, 0L, asn_DEF_VehicleIdent$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_VehicleIdent_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_VehicleIdent_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_VehicleIdent_specs_1
     * }
     */
    public static GroupLayout asn_SPC_VehicleIdent_specs_1$layout() {
        return asn_SPC_VehicleIdent_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_VehicleIdent_specs_1
     * }
     */
    public static MemorySegment asn_SPC_VehicleIdent_specs_1() {
        return asn_SPC_VehicleIdent_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_VehicleIdent_specs_1
     * }
     */
    public static void asn_SPC_VehicleIdent_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_VehicleIdent_specs_1$constants.SEGMENT, 0L, asn_SPC_VehicleIdent_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_VehicleIdent_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(6, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_VehicleIdent_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 6 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleIdent_1[6]
     * }
     */
    public static SequenceLayout asn_MBR_VehicleIdent_1$layout() {
        return asn_MBR_VehicleIdent_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleIdent_1[6]
     * }
     */
    public static long[] asn_MBR_VehicleIdent_1$dimensions() {
        return asn_MBR_VehicleIdent_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleIdent_1[6]
     * }
     */
    public static MemorySegment asn_MBR_VehicleIdent_1() {
        return asn_MBR_VehicleIdent_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleIdent_1[6]
     * }
     */
    public static void asn_MBR_VehicleIdent_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_VehicleIdent_1$constants.SEGMENT, 0L, asn_MBR_VehicleIdent_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleIdent_1[6]
     * }
     */
    public static MemorySegment asn_MBR_VehicleIdent_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_VehicleIdent_1$constants.HANDLE.invokeExact(asn_MBR_VehicleIdent_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleIdent_1[6]
     * }
     */
    public static void asn_MBR_VehicleIdent_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_VehicleIdent_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    private static final int VehicleID_PR_NOTHING = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VehicleID_PR.VehicleID_PR_NOTHING = 0
     * }
     */
    public static int VehicleID_PR_NOTHING() {
        return VehicleID_PR_NOTHING;
    }
    private static final int VehicleID_PR_entityID = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VehicleID_PR.VehicleID_PR_entityID = 1
     * }
     */
    public static int VehicleID_PR_entityID() {
        return VehicleID_PR_entityID;
    }
    private static final int VehicleID_PR_stationID = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VehicleID_PR.VehicleID_PR_stationID = 2
     * }
     */
    public static int VehicleID_PR_stationID() {
        return VehicleID_PR_stationID;
    }

    private static class asn_DEF_VehicleID$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_VehicleID").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleID
     * }
     */
    public static GroupLayout asn_DEF_VehicleID$layout() {
        return asn_DEF_VehicleID$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleID
     * }
     */
    public static MemorySegment asn_DEF_VehicleID() {
        return asn_DEF_VehicleID$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleID
     * }
     */
    public static void asn_DEF_VehicleID(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_VehicleID$constants.SEGMENT, 0L, asn_DEF_VehicleID$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_VehicleID_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_CHOICE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_VehicleID_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_VehicleID_specs_1
     * }
     */
    public static GroupLayout asn_SPC_VehicleID_specs_1$layout() {
        return asn_SPC_VehicleID_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_VehicleID_specs_1
     * }
     */
    public static MemorySegment asn_SPC_VehicleID_specs_1() {
        return asn_SPC_VehicleID_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_CHOICE_specifics_t asn_SPC_VehicleID_specs_1
     * }
     */
    public static void asn_SPC_VehicleID_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_VehicleID_specs_1$constants.SEGMENT, 0L, asn_SPC_VehicleID_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_VehicleID_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_VehicleID_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleID_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_VehicleID_1$layout() {
        return asn_MBR_VehicleID_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleID_1[2]
     * }
     */
    public static long[] asn_MBR_VehicleID_1$dimensions() {
        return asn_MBR_VehicleID_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleID_1[2]
     * }
     */
    public static MemorySegment asn_MBR_VehicleID_1() {
        return asn_MBR_VehicleID_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleID_1[2]
     * }
     */
    public static void asn_MBR_VehicleID_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_VehicleID_1$constants.SEGMENT, 0L, asn_MBR_VehicleID_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleID_1[2]
     * }
     */
    public static MemorySegment asn_MBR_VehicleID_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_VehicleID_1$constants.HANDLE.invokeExact(asn_MBR_VehicleID_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleID_1[2]
     * }
     */
    public static void asn_MBR_VehicleID_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_VehicleID_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_VehicleID_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_VehicleID_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VehicleID_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_VehicleID_constr_1$layout() {
        return asn_PER_type_VehicleID_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VehicleID_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_VehicleID_constr_1() {
        return asn_PER_type_VehicleID_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VehicleID_constr_1
     * }
     */
    public static void asn_PER_type_VehicleID_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_VehicleID_constr_1$constants.SEGMENT, 0L, asn_PER_type_VehicleID_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_Snapshot$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_Snapshot").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Snapshot
     * }
     */
    public static GroupLayout asn_DEF_Snapshot$layout() {
        return asn_DEF_Snapshot$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Snapshot
     * }
     */
    public static MemorySegment asn_DEF_Snapshot() {
        return asn_DEF_Snapshot$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Snapshot
     * }
     */
    public static void asn_DEF_Snapshot(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_Snapshot$constants.SEGMENT, 0L, asn_DEF_Snapshot$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_Snapshot_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_Snapshot_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Snapshot_specs_1
     * }
     */
    public static GroupLayout asn_SPC_Snapshot_specs_1$layout() {
        return asn_SPC_Snapshot_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Snapshot_specs_1
     * }
     */
    public static MemorySegment asn_SPC_Snapshot_specs_1() {
        return asn_SPC_Snapshot_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_Snapshot_specs_1
     * }
     */
    public static void asn_SPC_Snapshot_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_Snapshot_specs_1$constants.SEGMENT, 0L, asn_SPC_Snapshot_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_Snapshot_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(3, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_Snapshot_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 3 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Snapshot_1[3]
     * }
     */
    public static SequenceLayout asn_MBR_Snapshot_1$layout() {
        return asn_MBR_Snapshot_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Snapshot_1[3]
     * }
     */
    public static long[] asn_MBR_Snapshot_1$dimensions() {
        return asn_MBR_Snapshot_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Snapshot_1[3]
     * }
     */
    public static MemorySegment asn_MBR_Snapshot_1() {
        return asn_MBR_Snapshot_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Snapshot_1[3]
     * }
     */
    public static void asn_MBR_Snapshot_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_Snapshot_1$constants.SEGMENT, 0L, asn_MBR_Snapshot_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Snapshot_1[3]
     * }
     */
    public static MemorySegment asn_MBR_Snapshot_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_Snapshot_1$constants.HANDLE.invokeExact(asn_MBR_Snapshot_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_Snapshot_1[3]
     * }
     */
    public static void asn_MBR_Snapshot_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_Snapshot_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    private static final int BrakeAppliedPressure_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum BrakeAppliedPressure.BrakeAppliedPressure_unavailable = 0
     * }
     */
    public static int BrakeAppliedPressure_unavailable() {
        return BrakeAppliedPressure_unavailable;
    }
    private static final int BrakeAppliedPressure_minPressure = (int)1L;
    /**
     * {@snippet lang=c :
     * enum BrakeAppliedPressure.BrakeAppliedPressure_minPressure = 1
     * }
     */
    public static int BrakeAppliedPressure_minPressure() {
        return BrakeAppliedPressure_minPressure;
    }
    private static final int BrakeAppliedPressure_bkLvl_2 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum BrakeAppliedPressure.BrakeAppliedPressure_bkLvl_2 = 2
     * }
     */
    public static int BrakeAppliedPressure_bkLvl_2() {
        return BrakeAppliedPressure_bkLvl_2;
    }
    private static final int BrakeAppliedPressure_bkLvl_3 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum BrakeAppliedPressure.BrakeAppliedPressure_bkLvl_3 = 3
     * }
     */
    public static int BrakeAppliedPressure_bkLvl_3() {
        return BrakeAppliedPressure_bkLvl_3;
    }
    private static final int BrakeAppliedPressure_bkLvl_4 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum BrakeAppliedPressure.BrakeAppliedPressure_bkLvl_4 = 4
     * }
     */
    public static int BrakeAppliedPressure_bkLvl_4() {
        return BrakeAppliedPressure_bkLvl_4;
    }
    private static final int BrakeAppliedPressure_bkLvl_5 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum BrakeAppliedPressure.BrakeAppliedPressure_bkLvl_5 = 5
     * }
     */
    public static int BrakeAppliedPressure_bkLvl_5() {
        return BrakeAppliedPressure_bkLvl_5;
    }
    private static final int BrakeAppliedPressure_bkLvl_6 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum BrakeAppliedPressure.BrakeAppliedPressure_bkLvl_6 = 6
     * }
     */
    public static int BrakeAppliedPressure_bkLvl_6() {
        return BrakeAppliedPressure_bkLvl_6;
    }
    private static final int BrakeAppliedPressure_bkLvl_7 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum BrakeAppliedPressure.BrakeAppliedPressure_bkLvl_7 = 7
     * }
     */
    public static int BrakeAppliedPressure_bkLvl_7() {
        return BrakeAppliedPressure_bkLvl_7;
    }
    private static final int BrakeAppliedPressure_bkLvl_8 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum BrakeAppliedPressure.BrakeAppliedPressure_bkLvl_8 = 8
     * }
     */
    public static int BrakeAppliedPressure_bkLvl_8() {
        return BrakeAppliedPressure_bkLvl_8;
    }
    private static final int BrakeAppliedPressure_bkLvl_9 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum BrakeAppliedPressure.BrakeAppliedPressure_bkLvl_9 = 9
     * }
     */
    public static int BrakeAppliedPressure_bkLvl_9() {
        return BrakeAppliedPressure_bkLvl_9;
    }
    private static final int BrakeAppliedPressure_bkLvl_10 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum BrakeAppliedPressure.BrakeAppliedPressure_bkLvl_10 = 10
     * }
     */
    public static int BrakeAppliedPressure_bkLvl_10() {
        return BrakeAppliedPressure_bkLvl_10;
    }
    private static final int BrakeAppliedPressure_bkLvl_11 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum BrakeAppliedPressure.BrakeAppliedPressure_bkLvl_11 = 11
     * }
     */
    public static int BrakeAppliedPressure_bkLvl_11() {
        return BrakeAppliedPressure_bkLvl_11;
    }
    private static final int BrakeAppliedPressure_bkLvl_12 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum BrakeAppliedPressure.BrakeAppliedPressure_bkLvl_12 = 12
     * }
     */
    public static int BrakeAppliedPressure_bkLvl_12() {
        return BrakeAppliedPressure_bkLvl_12;
    }
    private static final int BrakeAppliedPressure_bkLvl_13 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum BrakeAppliedPressure.BrakeAppliedPressure_bkLvl_13 = 13
     * }
     */
    public static int BrakeAppliedPressure_bkLvl_13() {
        return BrakeAppliedPressure_bkLvl_13;
    }
    private static final int BrakeAppliedPressure_bkLvl_14 = (int)14L;
    /**
     * {@snippet lang=c :
     * enum BrakeAppliedPressure.BrakeAppliedPressure_bkLvl_14 = 14
     * }
     */
    public static int BrakeAppliedPressure_bkLvl_14() {
        return BrakeAppliedPressure_bkLvl_14;
    }
    private static final int BrakeAppliedPressure_maxPressure = (int)15L;
    /**
     * {@snippet lang=c :
     * enum BrakeAppliedPressure.BrakeAppliedPressure_maxPressure = 15
     * }
     */
    public static int BrakeAppliedPressure_maxPressure() {
        return BrakeAppliedPressure_maxPressure;
    }
    /**
     * {@snippet lang=c :
     * typedef long BrakeAppliedPressure_t
     * }
     */
    public static final OfLong BrakeAppliedPressure_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_BrakeAppliedPressure_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_BrakeAppliedPressure_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_BrakeAppliedPressure_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_BrakeAppliedPressure_constr_1$layout() {
        return asn_PER_type_BrakeAppliedPressure_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_BrakeAppliedPressure_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_BrakeAppliedPressure_constr_1() {
        return asn_PER_type_BrakeAppliedPressure_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_BrakeAppliedPressure_constr_1
     * }
     */
    public static void asn_PER_type_BrakeAppliedPressure_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_BrakeAppliedPressure_constr_1$constants.SEGMENT, 0L, asn_PER_type_BrakeAppliedPressure_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_BrakeAppliedPressure$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_BrakeAppliedPressure").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BrakeAppliedPressure
     * }
     */
    public static GroupLayout asn_DEF_BrakeAppliedPressure$layout() {
        return asn_DEF_BrakeAppliedPressure$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BrakeAppliedPressure
     * }
     */
    public static MemorySegment asn_DEF_BrakeAppliedPressure() {
        return asn_DEF_BrakeAppliedPressure$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BrakeAppliedPressure
     * }
     */
    public static void asn_DEF_BrakeAppliedPressure(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_BrakeAppliedPressure$constants.SEGMENT, 0L, asn_DEF_BrakeAppliedPressure$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_BrakeAppliedPressure_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_BrakeAppliedPressure_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_BrakeAppliedPressure_specs_1
     * }
     */
    public static GroupLayout asn_SPC_BrakeAppliedPressure_specs_1$layout() {
        return asn_SPC_BrakeAppliedPressure_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_BrakeAppliedPressure_specs_1
     * }
     */
    public static MemorySegment asn_SPC_BrakeAppliedPressure_specs_1() {
        return asn_SPC_BrakeAppliedPressure_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_BrakeAppliedPressure_specs_1
     * }
     */
    public static void asn_SPC_BrakeAppliedPressure_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_BrakeAppliedPressure_specs_1$constants.SEGMENT, 0L, asn_SPC_BrakeAppliedPressure_specs_1$constants.LAYOUT.byteSize());
    }

    private static class BrakeAppliedPressure_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedPressure_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BrakeAppliedPressure_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor BrakeAppliedPressure_free$descriptor() {
        return BrakeAppliedPressure_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BrakeAppliedPressure_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle BrakeAppliedPressure_free$handle() {
        return BrakeAppliedPressure_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BrakeAppliedPressure_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_free$address() {
        return BrakeAppliedPressure_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BrakeAppliedPressure_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void BrakeAppliedPressure_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = BrakeAppliedPressure_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedPressure_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedPressure_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedPressure_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int BrakeAppliedPressure_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BrakeAppliedPressure_print$descriptor() {
        return BrakeAppliedPressure_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int BrakeAppliedPressure_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BrakeAppliedPressure_print$handle() {
        return BrakeAppliedPressure_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int BrakeAppliedPressure_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_print$address() {
        return BrakeAppliedPressure_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int BrakeAppliedPressure_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int BrakeAppliedPressure_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = BrakeAppliedPressure_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedPressure_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedPressure_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedPressure_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int BrakeAppliedPressure_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor BrakeAppliedPressure_constraint$descriptor() {
        return BrakeAppliedPressure_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int BrakeAppliedPressure_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle BrakeAppliedPressure_constraint$handle() {
        return BrakeAppliedPressure_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int BrakeAppliedPressure_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_constraint$address() {
        return BrakeAppliedPressure_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int BrakeAppliedPressure_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int BrakeAppliedPressure_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = BrakeAppliedPressure_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedPressure_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedPressure_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedPressure_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedPressure_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor BrakeAppliedPressure_decode_ber$descriptor() {
        return BrakeAppliedPressure_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedPressure_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle BrakeAppliedPressure_decode_ber$handle() {
        return BrakeAppliedPressure_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedPressure_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_decode_ber$address() {
        return BrakeAppliedPressure_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedPressure_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = BrakeAppliedPressure_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedPressure_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedPressure_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedPressure_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BrakeAppliedPressure_encode_der$descriptor() {
        return BrakeAppliedPressure_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BrakeAppliedPressure_encode_der$handle() {
        return BrakeAppliedPressure_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_encode_der$address() {
        return BrakeAppliedPressure_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = BrakeAppliedPressure_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedPressure_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedPressure_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedPressure_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedPressure_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor BrakeAppliedPressure_decode_xer$descriptor() {
        return BrakeAppliedPressure_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedPressure_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle BrakeAppliedPressure_decode_xer$handle() {
        return BrakeAppliedPressure_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedPressure_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_decode_xer$address() {
        return BrakeAppliedPressure_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedPressure_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = BrakeAppliedPressure_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedPressure_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedPressure_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedPressure_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BrakeAppliedPressure_encode_xer$descriptor() {
        return BrakeAppliedPressure_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BrakeAppliedPressure_encode_xer$handle() {
        return BrakeAppliedPressure_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_encode_xer$address() {
        return BrakeAppliedPressure_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = BrakeAppliedPressure_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedPressure_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedPressure_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedPressure_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BrakeAppliedPressure_encode_jer$descriptor() {
        return BrakeAppliedPressure_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BrakeAppliedPressure_encode_jer$handle() {
        return BrakeAppliedPressure_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_encode_jer$address() {
        return BrakeAppliedPressure_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = BrakeAppliedPressure_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedPressure_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedPressure_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedPressure_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedPressure_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor BrakeAppliedPressure_decode_oer$descriptor() {
        return BrakeAppliedPressure_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedPressure_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle BrakeAppliedPressure_decode_oer$handle() {
        return BrakeAppliedPressure_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedPressure_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_decode_oer$address() {
        return BrakeAppliedPressure_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedPressure_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = BrakeAppliedPressure_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedPressure_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedPressure_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedPressure_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BrakeAppliedPressure_encode_oer$descriptor() {
        return BrakeAppliedPressure_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BrakeAppliedPressure_encode_oer$handle() {
        return BrakeAppliedPressure_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_encode_oer$address() {
        return BrakeAppliedPressure_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = BrakeAppliedPressure_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedPressure_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedPressure_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedPressure_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedPressure_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor BrakeAppliedPressure_decode_uper$descriptor() {
        return BrakeAppliedPressure_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedPressure_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle BrakeAppliedPressure_decode_uper$handle() {
        return BrakeAppliedPressure_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedPressure_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_decode_uper$address() {
        return BrakeAppliedPressure_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedPressure_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = BrakeAppliedPressure_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedPressure_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedPressure_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedPressure_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor BrakeAppliedPressure_encode_uper$descriptor() {
        return BrakeAppliedPressure_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle BrakeAppliedPressure_encode_uper$handle() {
        return BrakeAppliedPressure_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_encode_uper$address() {
        return BrakeAppliedPressure_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = BrakeAppliedPressure_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedPressure_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedPressure_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedPressure_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedPressure_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor BrakeAppliedPressure_decode_aper$descriptor() {
        return BrakeAppliedPressure_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedPressure_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle BrakeAppliedPressure_decode_aper$handle() {
        return BrakeAppliedPressure_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedPressure_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_decode_aper$address() {
        return BrakeAppliedPressure_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedPressure_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = BrakeAppliedPressure_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedPressure_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedPressure_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedPressure_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor BrakeAppliedPressure_encode_aper$descriptor() {
        return BrakeAppliedPressure_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle BrakeAppliedPressure_encode_aper$handle() {
        return BrakeAppliedPressure_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_encode_aper$address() {
        return BrakeAppliedPressure_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedPressure_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment BrakeAppliedPressure_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = BrakeAppliedPressure_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedPressure_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long SunSensor_t
     * }
     */
    public static final OfLong SunSensor_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_SunSensor_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_SunSensor_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SunSensor_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_SunSensor_constr_1$layout() {
        return asn_PER_type_SunSensor_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SunSensor_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_SunSensor_constr_1() {
        return asn_PER_type_SunSensor_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SunSensor_constr_1
     * }
     */
    public static void asn_PER_type_SunSensor_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_SunSensor_constr_1$constants.SEGMENT, 0L, asn_PER_type_SunSensor_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_SunSensor$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_SunSensor").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SunSensor
     * }
     */
    public static GroupLayout asn_DEF_SunSensor$layout() {
        return asn_DEF_SunSensor$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SunSensor
     * }
     */
    public static MemorySegment asn_DEF_SunSensor() {
        return asn_DEF_SunSensor$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SunSensor
     * }
     */
    public static void asn_DEF_SunSensor(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_SunSensor$constants.SEGMENT, 0L, asn_DEF_SunSensor$constants.LAYOUT.byteSize());
    }

    private static class SunSensor_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SunSensor_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SunSensor_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor SunSensor_free$descriptor() {
        return SunSensor_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SunSensor_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle SunSensor_free$handle() {
        return SunSensor_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SunSensor_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment SunSensor_free$address() {
        return SunSensor_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SunSensor_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void SunSensor_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = SunSensor_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SunSensor_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SunSensor_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SunSensor_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SunSensor_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SunSensor_print$descriptor() {
        return SunSensor_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SunSensor_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SunSensor_print$handle() {
        return SunSensor_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SunSensor_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SunSensor_print$address() {
        return SunSensor_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SunSensor_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int SunSensor_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SunSensor_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SunSensor_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SunSensor_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SunSensor_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SunSensor_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor SunSensor_constraint$descriptor() {
        return SunSensor_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SunSensor_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle SunSensor_constraint$handle() {
        return SunSensor_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SunSensor_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment SunSensor_constraint$address() {
        return SunSensor_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SunSensor_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int SunSensor_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SunSensor_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SunSensor_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SunSensor_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SunSensor_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SunSensor_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor SunSensor_decode_ber$descriptor() {
        return SunSensor_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SunSensor_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle SunSensor_decode_ber$handle() {
        return SunSensor_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SunSensor_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SunSensor_decode_ber$address() {
        return SunSensor_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SunSensor_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SunSensor_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = SunSensor_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SunSensor_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SunSensor_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SunSensor_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SunSensor_encode_der$descriptor() {
        return SunSensor_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SunSensor_encode_der$handle() {
        return SunSensor_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SunSensor_encode_der$address() {
        return SunSensor_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SunSensor_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SunSensor_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SunSensor_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SunSensor_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SunSensor_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SunSensor_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SunSensor_decode_xer$descriptor() {
        return SunSensor_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SunSensor_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle SunSensor_decode_xer$handle() {
        return SunSensor_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SunSensor_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SunSensor_decode_xer$address() {
        return SunSensor_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SunSensor_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SunSensor_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SunSensor_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SunSensor_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SunSensor_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SunSensor_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SunSensor_encode_xer$descriptor() {
        return SunSensor_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SunSensor_encode_xer$handle() {
        return SunSensor_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SunSensor_encode_xer$address() {
        return SunSensor_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SunSensor_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SunSensor_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SunSensor_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SunSensor_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SunSensor_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SunSensor_encode_jer$descriptor() {
        return SunSensor_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SunSensor_encode_jer$handle() {
        return SunSensor_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SunSensor_encode_jer$address() {
        return SunSensor_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SunSensor_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = SunSensor_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SunSensor_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SunSensor_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SunSensor_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SunSensor_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SunSensor_decode_oer$descriptor() {
        return SunSensor_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SunSensor_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle SunSensor_decode_oer$handle() {
        return SunSensor_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SunSensor_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SunSensor_decode_oer$address() {
        return SunSensor_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SunSensor_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SunSensor_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SunSensor_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SunSensor_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SunSensor_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SunSensor_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SunSensor_encode_oer$descriptor() {
        return SunSensor_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SunSensor_encode_oer$handle() {
        return SunSensor_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SunSensor_encode_oer$address() {
        return SunSensor_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SunSensor_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SunSensor_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SunSensor_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SunSensor_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SunSensor_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SunSensor_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SunSensor_decode_uper$descriptor() {
        return SunSensor_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SunSensor_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SunSensor_decode_uper$handle() {
        return SunSensor_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SunSensor_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SunSensor_decode_uper$address() {
        return SunSensor_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SunSensor_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SunSensor_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SunSensor_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SunSensor_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SunSensor_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SunSensor_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SunSensor_encode_uper$descriptor() {
        return SunSensor_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SunSensor_encode_uper$handle() {
        return SunSensor_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SunSensor_encode_uper$address() {
        return SunSensor_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SunSensor_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SunSensor_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SunSensor_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SunSensor_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SunSensor_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SunSensor_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SunSensor_decode_aper$descriptor() {
        return SunSensor_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SunSensor_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SunSensor_decode_aper$handle() {
        return SunSensor_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SunSensor_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SunSensor_decode_aper$address() {
        return SunSensor_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SunSensor_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SunSensor_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SunSensor_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SunSensor_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SunSensor_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SunSensor_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SunSensor_encode_aper$descriptor() {
        return SunSensor_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SunSensor_encode_aper$handle() {
        return SunSensor_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SunSensor_encode_aper$address() {
        return SunSensor_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SunSensor_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SunSensor_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SunSensor_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SunSensor_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int RainSensor_none = (int)0L;
    /**
     * {@snippet lang=c :
     * enum RainSensor.RainSensor_none = 0
     * }
     */
    public static int RainSensor_none() {
        return RainSensor_none;
    }
    private static final int RainSensor_lightMist = (int)1L;
    /**
     * {@snippet lang=c :
     * enum RainSensor.RainSensor_lightMist = 1
     * }
     */
    public static int RainSensor_lightMist() {
        return RainSensor_lightMist;
    }
    private static final int RainSensor_heavyMist = (int)2L;
    /**
     * {@snippet lang=c :
     * enum RainSensor.RainSensor_heavyMist = 2
     * }
     */
    public static int RainSensor_heavyMist() {
        return RainSensor_heavyMist;
    }
    private static final int RainSensor_lightRainOrDrizzle = (int)3L;
    /**
     * {@snippet lang=c :
     * enum RainSensor.RainSensor_lightRainOrDrizzle = 3
     * }
     */
    public static int RainSensor_lightRainOrDrizzle() {
        return RainSensor_lightRainOrDrizzle;
    }
    private static final int RainSensor_rain = (int)4L;
    /**
     * {@snippet lang=c :
     * enum RainSensor.RainSensor_rain = 4
     * }
     */
    public static int RainSensor_rain() {
        return RainSensor_rain;
    }
    private static final int RainSensor_moderateRain = (int)5L;
    /**
     * {@snippet lang=c :
     * enum RainSensor.RainSensor_moderateRain = 5
     * }
     */
    public static int RainSensor_moderateRain() {
        return RainSensor_moderateRain;
    }
    private static final int RainSensor_heavyRain = (int)6L;
    /**
     * {@snippet lang=c :
     * enum RainSensor.RainSensor_heavyRain = 6
     * }
     */
    public static int RainSensor_heavyRain() {
        return RainSensor_heavyRain;
    }
    private static final int RainSensor_heavyDownpour = (int)7L;
    /**
     * {@snippet lang=c :
     * enum RainSensor.RainSensor_heavyDownpour = 7
     * }
     */
    public static int RainSensor_heavyDownpour() {
        return RainSensor_heavyDownpour;
    }
    /**
     * {@snippet lang=c :
     * typedef long RainSensor_t
     * }
     */
    public static final OfLong RainSensor_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_RainSensor_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_RainSensor_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RainSensor_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_RainSensor_constr_1$layout() {
        return asn_PER_type_RainSensor_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RainSensor_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_RainSensor_constr_1() {
        return asn_PER_type_RainSensor_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_RainSensor_constr_1
     * }
     */
    public static void asn_PER_type_RainSensor_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_RainSensor_constr_1$constants.SEGMENT, 0L, asn_PER_type_RainSensor_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_RainSensor$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_RainSensor").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RainSensor
     * }
     */
    public static GroupLayout asn_DEF_RainSensor$layout() {
        return asn_DEF_RainSensor$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RainSensor
     * }
     */
    public static MemorySegment asn_DEF_RainSensor() {
        return asn_DEF_RainSensor$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_RainSensor
     * }
     */
    public static void asn_DEF_RainSensor(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_RainSensor$constants.SEGMENT, 0L, asn_DEF_RainSensor$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_RainSensor_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_RainSensor_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_RainSensor_specs_1
     * }
     */
    public static GroupLayout asn_SPC_RainSensor_specs_1$layout() {
        return asn_SPC_RainSensor_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_RainSensor_specs_1
     * }
     */
    public static MemorySegment asn_SPC_RainSensor_specs_1() {
        return asn_SPC_RainSensor_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_RainSensor_specs_1
     * }
     */
    public static void asn_SPC_RainSensor_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_RainSensor_specs_1$constants.SEGMENT, 0L, asn_SPC_RainSensor_specs_1$constants.LAYOUT.byteSize());
    }

    private static class RainSensor_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RainSensor_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void RainSensor_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor RainSensor_free$descriptor() {
        return RainSensor_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void RainSensor_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle RainSensor_free$handle() {
        return RainSensor_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void RainSensor_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment RainSensor_free$address() {
        return RainSensor_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void RainSensor_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void RainSensor_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = RainSensor_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RainSensor_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RainSensor_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RainSensor_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int RainSensor_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RainSensor_print$descriptor() {
        return RainSensor_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int RainSensor_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RainSensor_print$handle() {
        return RainSensor_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int RainSensor_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RainSensor_print$address() {
        return RainSensor_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int RainSensor_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int RainSensor_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = RainSensor_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RainSensor_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RainSensor_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RainSensor_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int RainSensor_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor RainSensor_constraint$descriptor() {
        return RainSensor_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int RainSensor_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle RainSensor_constraint$handle() {
        return RainSensor_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int RainSensor_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment RainSensor_constraint$address() {
        return RainSensor_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int RainSensor_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int RainSensor_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = RainSensor_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RainSensor_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RainSensor_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RainSensor_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RainSensor_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor RainSensor_decode_ber$descriptor() {
        return RainSensor_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RainSensor_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle RainSensor_decode_ber$handle() {
        return RainSensor_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RainSensor_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment RainSensor_decode_ber$address() {
        return RainSensor_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RainSensor_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment RainSensor_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = RainSensor_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RainSensor_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RainSensor_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RainSensor_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RainSensor_encode_der$descriptor() {
        return RainSensor_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RainSensor_encode_der$handle() {
        return RainSensor_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RainSensor_encode_der$address() {
        return RainSensor_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RainSensor_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = RainSensor_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RainSensor_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RainSensor_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RainSensor_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RainSensor_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor RainSensor_decode_xer$descriptor() {
        return RainSensor_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RainSensor_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle RainSensor_decode_xer$handle() {
        return RainSensor_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RainSensor_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment RainSensor_decode_xer$address() {
        return RainSensor_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RainSensor_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment RainSensor_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = RainSensor_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RainSensor_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RainSensor_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RainSensor_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RainSensor_encode_xer$descriptor() {
        return RainSensor_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RainSensor_encode_xer$handle() {
        return RainSensor_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RainSensor_encode_xer$address() {
        return RainSensor_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RainSensor_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = RainSensor_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RainSensor_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RainSensor_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RainSensor_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RainSensor_encode_jer$descriptor() {
        return RainSensor_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RainSensor_encode_jer$handle() {
        return RainSensor_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RainSensor_encode_jer$address() {
        return RainSensor_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RainSensor_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = RainSensor_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RainSensor_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RainSensor_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RainSensor_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RainSensor_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor RainSensor_decode_oer$descriptor() {
        return RainSensor_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RainSensor_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle RainSensor_decode_oer$handle() {
        return RainSensor_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RainSensor_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment RainSensor_decode_oer$address() {
        return RainSensor_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RainSensor_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment RainSensor_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = RainSensor_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RainSensor_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RainSensor_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RainSensor_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor RainSensor_encode_oer$descriptor() {
        return RainSensor_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle RainSensor_encode_oer$handle() {
        return RainSensor_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RainSensor_encode_oer$address() {
        return RainSensor_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment RainSensor_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = RainSensor_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RainSensor_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RainSensor_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RainSensor_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RainSensor_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor RainSensor_decode_uper$descriptor() {
        return RainSensor_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RainSensor_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle RainSensor_decode_uper$handle() {
        return RainSensor_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RainSensor_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment RainSensor_decode_uper$address() {
        return RainSensor_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RainSensor_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment RainSensor_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = RainSensor_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RainSensor_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RainSensor_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RainSensor_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor RainSensor_encode_uper$descriptor() {
        return RainSensor_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle RainSensor_encode_uper$handle() {
        return RainSensor_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment RainSensor_encode_uper$address() {
        return RainSensor_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment RainSensor_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = RainSensor_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RainSensor_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RainSensor_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RainSensor_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t RainSensor_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor RainSensor_decode_aper$descriptor() {
        return RainSensor_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t RainSensor_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle RainSensor_decode_aper$handle() {
        return RainSensor_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t RainSensor_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment RainSensor_decode_aper$address() {
        return RainSensor_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t RainSensor_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment RainSensor_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = RainSensor_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RainSensor_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class RainSensor_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("RainSensor_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor RainSensor_encode_aper$descriptor() {
        return RainSensor_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle RainSensor_encode_aper$handle() {
        return RainSensor_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment RainSensor_encode_aper$address() {
        return RainSensor_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t RainSensor_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment RainSensor_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = RainSensor_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("RainSensor_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long ThrottlePosition_t
     * }
     */
    public static final OfLong ThrottlePosition_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_ThrottlePosition_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_ThrottlePosition_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ThrottlePosition_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_ThrottlePosition_constr_1$layout() {
        return asn_PER_type_ThrottlePosition_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ThrottlePosition_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_ThrottlePosition_constr_1() {
        return asn_PER_type_ThrottlePosition_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ThrottlePosition_constr_1
     * }
     */
    public static void asn_PER_type_ThrottlePosition_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_ThrottlePosition_constr_1$constants.SEGMENT, 0L, asn_PER_type_ThrottlePosition_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_ThrottlePosition$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_ThrottlePosition").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ThrottlePosition
     * }
     */
    public static GroupLayout asn_DEF_ThrottlePosition$layout() {
        return asn_DEF_ThrottlePosition$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ThrottlePosition
     * }
     */
    public static MemorySegment asn_DEF_ThrottlePosition() {
        return asn_DEF_ThrottlePosition$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ThrottlePosition
     * }
     */
    public static void asn_DEF_ThrottlePosition(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_ThrottlePosition$constants.SEGMENT, 0L, asn_DEF_ThrottlePosition$constants.LAYOUT.byteSize());
    }

    private static class ThrottlePosition_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ThrottlePosition_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ThrottlePosition_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor ThrottlePosition_free$descriptor() {
        return ThrottlePosition_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ThrottlePosition_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle ThrottlePosition_free$handle() {
        return ThrottlePosition_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ThrottlePosition_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment ThrottlePosition_free$address() {
        return ThrottlePosition_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ThrottlePosition_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void ThrottlePosition_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = ThrottlePosition_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ThrottlePosition_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ThrottlePosition_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ThrottlePosition_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ThrottlePosition_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ThrottlePosition_print$descriptor() {
        return ThrottlePosition_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ThrottlePosition_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ThrottlePosition_print$handle() {
        return ThrottlePosition_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ThrottlePosition_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ThrottlePosition_print$address() {
        return ThrottlePosition_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ThrottlePosition_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int ThrottlePosition_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ThrottlePosition_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ThrottlePosition_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ThrottlePosition_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ThrottlePosition_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ThrottlePosition_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor ThrottlePosition_constraint$descriptor() {
        return ThrottlePosition_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ThrottlePosition_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle ThrottlePosition_constraint$handle() {
        return ThrottlePosition_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ThrottlePosition_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment ThrottlePosition_constraint$address() {
        return ThrottlePosition_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ThrottlePosition_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int ThrottlePosition_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ThrottlePosition_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ThrottlePosition_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ThrottlePosition_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ThrottlePosition_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ThrottlePosition_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor ThrottlePosition_decode_ber$descriptor() {
        return ThrottlePosition_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ThrottlePosition_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle ThrottlePosition_decode_ber$handle() {
        return ThrottlePosition_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ThrottlePosition_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment ThrottlePosition_decode_ber$address() {
        return ThrottlePosition_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ThrottlePosition_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment ThrottlePosition_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = ThrottlePosition_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ThrottlePosition_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ThrottlePosition_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ThrottlePosition_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ThrottlePosition_encode_der$descriptor() {
        return ThrottlePosition_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ThrottlePosition_encode_der$handle() {
        return ThrottlePosition_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ThrottlePosition_encode_der$address() {
        return ThrottlePosition_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ThrottlePosition_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ThrottlePosition_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ThrottlePosition_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ThrottlePosition_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ThrottlePosition_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ThrottlePosition_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor ThrottlePosition_decode_xer$descriptor() {
        return ThrottlePosition_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ThrottlePosition_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle ThrottlePosition_decode_xer$handle() {
        return ThrottlePosition_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ThrottlePosition_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment ThrottlePosition_decode_xer$address() {
        return ThrottlePosition_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ThrottlePosition_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment ThrottlePosition_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = ThrottlePosition_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ThrottlePosition_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ThrottlePosition_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ThrottlePosition_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ThrottlePosition_encode_xer$descriptor() {
        return ThrottlePosition_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ThrottlePosition_encode_xer$handle() {
        return ThrottlePosition_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ThrottlePosition_encode_xer$address() {
        return ThrottlePosition_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ThrottlePosition_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ThrottlePosition_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ThrottlePosition_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ThrottlePosition_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ThrottlePosition_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ThrottlePosition_encode_jer$descriptor() {
        return ThrottlePosition_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ThrottlePosition_encode_jer$handle() {
        return ThrottlePosition_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ThrottlePosition_encode_jer$address() {
        return ThrottlePosition_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ThrottlePosition_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = ThrottlePosition_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ThrottlePosition_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ThrottlePosition_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ThrottlePosition_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ThrottlePosition_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor ThrottlePosition_decode_oer$descriptor() {
        return ThrottlePosition_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ThrottlePosition_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle ThrottlePosition_decode_oer$handle() {
        return ThrottlePosition_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ThrottlePosition_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ThrottlePosition_decode_oer$address() {
        return ThrottlePosition_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ThrottlePosition_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ThrottlePosition_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = ThrottlePosition_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ThrottlePosition_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ThrottlePosition_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ThrottlePosition_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ThrottlePosition_encode_oer$descriptor() {
        return ThrottlePosition_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ThrottlePosition_encode_oer$handle() {
        return ThrottlePosition_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ThrottlePosition_encode_oer$address() {
        return ThrottlePosition_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ThrottlePosition_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ThrottlePosition_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ThrottlePosition_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ThrottlePosition_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ThrottlePosition_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ThrottlePosition_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor ThrottlePosition_decode_uper$descriptor() {
        return ThrottlePosition_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ThrottlePosition_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle ThrottlePosition_decode_uper$handle() {
        return ThrottlePosition_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ThrottlePosition_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ThrottlePosition_decode_uper$address() {
        return ThrottlePosition_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ThrottlePosition_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ThrottlePosition_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ThrottlePosition_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ThrottlePosition_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ThrottlePosition_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ThrottlePosition_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor ThrottlePosition_encode_uper$descriptor() {
        return ThrottlePosition_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle ThrottlePosition_encode_uper$handle() {
        return ThrottlePosition_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ThrottlePosition_encode_uper$address() {
        return ThrottlePosition_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ThrottlePosition_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ThrottlePosition_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ThrottlePosition_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ThrottlePosition_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ThrottlePosition_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ThrottlePosition_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor ThrottlePosition_decode_aper$descriptor() {
        return ThrottlePosition_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ThrottlePosition_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle ThrottlePosition_decode_aper$handle() {
        return ThrottlePosition_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ThrottlePosition_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ThrottlePosition_decode_aper$address() {
        return ThrottlePosition_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ThrottlePosition_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ThrottlePosition_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ThrottlePosition_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ThrottlePosition_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ThrottlePosition_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ThrottlePosition_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor ThrottlePosition_encode_aper$descriptor() {
        return ThrottlePosition_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle ThrottlePosition_encode_aper$handle() {
        return ThrottlePosition_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ThrottlePosition_encode_aper$address() {
        return ThrottlePosition_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ThrottlePosition_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ThrottlePosition_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ThrottlePosition_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ThrottlePosition_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SteeringWheelAngleConfidence_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SteeringWheelAngleConfidence.SteeringWheelAngleConfidence_unavailable = 0
     * }
     */
    public static int SteeringWheelAngleConfidence_unavailable() {
        return SteeringWheelAngleConfidence_unavailable;
    }
    private static final int SteeringWheelAngleConfidence_prec2deg = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SteeringWheelAngleConfidence.SteeringWheelAngleConfidence_prec2deg = 1
     * }
     */
    public static int SteeringWheelAngleConfidence_prec2deg() {
        return SteeringWheelAngleConfidence_prec2deg;
    }
    private static final int SteeringWheelAngleConfidence_prec1deg = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SteeringWheelAngleConfidence.SteeringWheelAngleConfidence_prec1deg = 2
     * }
     */
    public static int SteeringWheelAngleConfidence_prec1deg() {
        return SteeringWheelAngleConfidence_prec1deg;
    }
    private static final int SteeringWheelAngleConfidence_prec0_02deg = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SteeringWheelAngleConfidence.SteeringWheelAngleConfidence_prec0_02deg = 3
     * }
     */
    public static int SteeringWheelAngleConfidence_prec0_02deg() {
        return SteeringWheelAngleConfidence_prec0_02deg;
    }
    /**
     * {@snippet lang=c :
     * typedef long SteeringWheelAngleConfidence_t
     * }
     */
    public static final OfLong SteeringWheelAngleConfidence_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_SteeringWheelAngleConfidence_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_SteeringWheelAngleConfidence_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SteeringWheelAngleConfidence_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_SteeringWheelAngleConfidence_constr_1$layout() {
        return asn_PER_type_SteeringWheelAngleConfidence_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SteeringWheelAngleConfidence_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_SteeringWheelAngleConfidence_constr_1() {
        return asn_PER_type_SteeringWheelAngleConfidence_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SteeringWheelAngleConfidence_constr_1
     * }
     */
    public static void asn_PER_type_SteeringWheelAngleConfidence_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_SteeringWheelAngleConfidence_constr_1$constants.SEGMENT, 0L, asn_PER_type_SteeringWheelAngleConfidence_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_SteeringWheelAngleConfidence$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_SteeringWheelAngleConfidence").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SteeringWheelAngleConfidence
     * }
     */
    public static GroupLayout asn_DEF_SteeringWheelAngleConfidence$layout() {
        return asn_DEF_SteeringWheelAngleConfidence$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SteeringWheelAngleConfidence
     * }
     */
    public static MemorySegment asn_DEF_SteeringWheelAngleConfidence() {
        return asn_DEF_SteeringWheelAngleConfidence$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SteeringWheelAngleConfidence
     * }
     */
    public static void asn_DEF_SteeringWheelAngleConfidence(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_SteeringWheelAngleConfidence$constants.SEGMENT, 0L, asn_DEF_SteeringWheelAngleConfidence$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_SteeringWheelAngleConfidence_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_SteeringWheelAngleConfidence_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_SteeringWheelAngleConfidence_specs_1
     * }
     */
    public static GroupLayout asn_SPC_SteeringWheelAngleConfidence_specs_1$layout() {
        return asn_SPC_SteeringWheelAngleConfidence_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_SteeringWheelAngleConfidence_specs_1
     * }
     */
    public static MemorySegment asn_SPC_SteeringWheelAngleConfidence_specs_1() {
        return asn_SPC_SteeringWheelAngleConfidence_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_SteeringWheelAngleConfidence_specs_1
     * }
     */
    public static void asn_SPC_SteeringWheelAngleConfidence_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_SteeringWheelAngleConfidence_specs_1$constants.SEGMENT, 0L, asn_SPC_SteeringWheelAngleConfidence_specs_1$constants.LAYOUT.byteSize());
    }

    private static class SteeringWheelAngleConfidence_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleConfidence_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SteeringWheelAngleConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleConfidence_free$descriptor() {
        return SteeringWheelAngleConfidence_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SteeringWheelAngleConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle SteeringWheelAngleConfidence_free$handle() {
        return SteeringWheelAngleConfidence_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SteeringWheelAngleConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_free$address() {
        return SteeringWheelAngleConfidence_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SteeringWheelAngleConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void SteeringWheelAngleConfidence_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = SteeringWheelAngleConfidence_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleConfidence_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleConfidence_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleConfidence_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SteeringWheelAngleConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleConfidence_print$descriptor() {
        return SteeringWheelAngleConfidence_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SteeringWheelAngleConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringWheelAngleConfidence_print$handle() {
        return SteeringWheelAngleConfidence_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SteeringWheelAngleConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_print$address() {
        return SteeringWheelAngleConfidence_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SteeringWheelAngleConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int SteeringWheelAngleConfidence_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SteeringWheelAngleConfidence_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleConfidence_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleConfidence_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleConfidence_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SteeringWheelAngleConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleConfidence_constraint$descriptor() {
        return SteeringWheelAngleConfidence_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SteeringWheelAngleConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle SteeringWheelAngleConfidence_constraint$handle() {
        return SteeringWheelAngleConfidence_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SteeringWheelAngleConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_constraint$address() {
        return SteeringWheelAngleConfidence_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SteeringWheelAngleConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int SteeringWheelAngleConfidence_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SteeringWheelAngleConfidence_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleConfidence_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleConfidence_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleConfidence_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleConfidence_decode_ber$descriptor() {
        return SteeringWheelAngleConfidence_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle SteeringWheelAngleConfidence_decode_ber$handle() {
        return SteeringWheelAngleConfidence_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_decode_ber$address() {
        return SteeringWheelAngleConfidence_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = SteeringWheelAngleConfidence_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleConfidence_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleConfidence_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleConfidence_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleConfidence_encode_der$descriptor() {
        return SteeringWheelAngleConfidence_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringWheelAngleConfidence_encode_der$handle() {
        return SteeringWheelAngleConfidence_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_encode_der$address() {
        return SteeringWheelAngleConfidence_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SteeringWheelAngleConfidence_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleConfidence_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleConfidence_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleConfidence_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleConfidence_decode_xer$descriptor() {
        return SteeringWheelAngleConfidence_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle SteeringWheelAngleConfidence_decode_xer$handle() {
        return SteeringWheelAngleConfidence_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_decode_xer$address() {
        return SteeringWheelAngleConfidence_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SteeringWheelAngleConfidence_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleConfidence_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleConfidence_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleConfidence_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleConfidence_encode_xer$descriptor() {
        return SteeringWheelAngleConfidence_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringWheelAngleConfidence_encode_xer$handle() {
        return SteeringWheelAngleConfidence_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_encode_xer$address() {
        return SteeringWheelAngleConfidence_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SteeringWheelAngleConfidence_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleConfidence_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleConfidence_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleConfidence_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleConfidence_encode_jer$descriptor() {
        return SteeringWheelAngleConfidence_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringWheelAngleConfidence_encode_jer$handle() {
        return SteeringWheelAngleConfidence_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_encode_jer$address() {
        return SteeringWheelAngleConfidence_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = SteeringWheelAngleConfidence_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleConfidence_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleConfidence_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleConfidence_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleConfidence_decode_oer$descriptor() {
        return SteeringWheelAngleConfidence_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle SteeringWheelAngleConfidence_decode_oer$handle() {
        return SteeringWheelAngleConfidence_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_decode_oer$address() {
        return SteeringWheelAngleConfidence_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SteeringWheelAngleConfidence_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleConfidence_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleConfidence_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleConfidence_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleConfidence_encode_oer$descriptor() {
        return SteeringWheelAngleConfidence_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringWheelAngleConfidence_encode_oer$handle() {
        return SteeringWheelAngleConfidence_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_encode_oer$address() {
        return SteeringWheelAngleConfidence_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SteeringWheelAngleConfidence_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleConfidence_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleConfidence_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleConfidence_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleConfidence_decode_uper$descriptor() {
        return SteeringWheelAngleConfidence_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SteeringWheelAngleConfidence_decode_uper$handle() {
        return SteeringWheelAngleConfidence_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_decode_uper$address() {
        return SteeringWheelAngleConfidence_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SteeringWheelAngleConfidence_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleConfidence_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleConfidence_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleConfidence_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleConfidence_encode_uper$descriptor() {
        return SteeringWheelAngleConfidence_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SteeringWheelAngleConfidence_encode_uper$handle() {
        return SteeringWheelAngleConfidence_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_encode_uper$address() {
        return SteeringWheelAngleConfidence_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SteeringWheelAngleConfidence_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleConfidence_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleConfidence_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleConfidence_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleConfidence_decode_aper$descriptor() {
        return SteeringWheelAngleConfidence_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SteeringWheelAngleConfidence_decode_aper$handle() {
        return SteeringWheelAngleConfidence_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_decode_aper$address() {
        return SteeringWheelAngleConfidence_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SteeringWheelAngleConfidence_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleConfidence_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleConfidence_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleConfidence_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleConfidence_encode_aper$descriptor() {
        return SteeringWheelAngleConfidence_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SteeringWheelAngleConfidence_encode_aper$handle() {
        return SteeringWheelAngleConfidence_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_encode_aper$address() {
        return SteeringWheelAngleConfidence_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngleConfidence_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SteeringWheelAngleConfidence_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleConfidence_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long SteeringWheelAngleRateOfChange_t
     * }
     */
    public static final OfLong SteeringWheelAngleRateOfChange_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_SteeringWheelAngleRateOfChange_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_SteeringWheelAngleRateOfChange_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SteeringWheelAngleRateOfChange_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_SteeringWheelAngleRateOfChange_constr_1$layout() {
        return asn_PER_type_SteeringWheelAngleRateOfChange_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SteeringWheelAngleRateOfChange_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_SteeringWheelAngleRateOfChange_constr_1() {
        return asn_PER_type_SteeringWheelAngleRateOfChange_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SteeringWheelAngleRateOfChange_constr_1
     * }
     */
    public static void asn_PER_type_SteeringWheelAngleRateOfChange_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_SteeringWheelAngleRateOfChange_constr_1$constants.SEGMENT, 0L, asn_PER_type_SteeringWheelAngleRateOfChange_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_SteeringWheelAngleRateOfChange$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_SteeringWheelAngleRateOfChange").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SteeringWheelAngleRateOfChange
     * }
     */
    public static GroupLayout asn_DEF_SteeringWheelAngleRateOfChange$layout() {
        return asn_DEF_SteeringWheelAngleRateOfChange$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SteeringWheelAngleRateOfChange
     * }
     */
    public static MemorySegment asn_DEF_SteeringWheelAngleRateOfChange() {
        return asn_DEF_SteeringWheelAngleRateOfChange$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SteeringWheelAngleRateOfChange
     * }
     */
    public static void asn_DEF_SteeringWheelAngleRateOfChange(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_SteeringWheelAngleRateOfChange$constants.SEGMENT, 0L, asn_DEF_SteeringWheelAngleRateOfChange$constants.LAYOUT.byteSize());
    }

    private static class SteeringWheelAngleRateOfChange_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleRateOfChange_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SteeringWheelAngleRateOfChange_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleRateOfChange_free$descriptor() {
        return SteeringWheelAngleRateOfChange_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SteeringWheelAngleRateOfChange_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle SteeringWheelAngleRateOfChange_free$handle() {
        return SteeringWheelAngleRateOfChange_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SteeringWheelAngleRateOfChange_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_free$address() {
        return SteeringWheelAngleRateOfChange_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SteeringWheelAngleRateOfChange_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void SteeringWheelAngleRateOfChange_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = SteeringWheelAngleRateOfChange_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleRateOfChange_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleRateOfChange_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleRateOfChange_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SteeringWheelAngleRateOfChange_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleRateOfChange_print$descriptor() {
        return SteeringWheelAngleRateOfChange_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SteeringWheelAngleRateOfChange_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringWheelAngleRateOfChange_print$handle() {
        return SteeringWheelAngleRateOfChange_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SteeringWheelAngleRateOfChange_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_print$address() {
        return SteeringWheelAngleRateOfChange_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SteeringWheelAngleRateOfChange_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int SteeringWheelAngleRateOfChange_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SteeringWheelAngleRateOfChange_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleRateOfChange_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleRateOfChange_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleRateOfChange_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SteeringWheelAngleRateOfChange_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleRateOfChange_constraint$descriptor() {
        return SteeringWheelAngleRateOfChange_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SteeringWheelAngleRateOfChange_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle SteeringWheelAngleRateOfChange_constraint$handle() {
        return SteeringWheelAngleRateOfChange_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SteeringWheelAngleRateOfChange_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_constraint$address() {
        return SteeringWheelAngleRateOfChange_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SteeringWheelAngleRateOfChange_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int SteeringWheelAngleRateOfChange_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SteeringWheelAngleRateOfChange_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleRateOfChange_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleRateOfChange_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleRateOfChange_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleRateOfChange_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleRateOfChange_decode_ber$descriptor() {
        return SteeringWheelAngleRateOfChange_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleRateOfChange_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle SteeringWheelAngleRateOfChange_decode_ber$handle() {
        return SteeringWheelAngleRateOfChange_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleRateOfChange_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_decode_ber$address() {
        return SteeringWheelAngleRateOfChange_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleRateOfChange_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = SteeringWheelAngleRateOfChange_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleRateOfChange_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleRateOfChange_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleRateOfChange_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleRateOfChange_encode_der$descriptor() {
        return SteeringWheelAngleRateOfChange_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringWheelAngleRateOfChange_encode_der$handle() {
        return SteeringWheelAngleRateOfChange_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_encode_der$address() {
        return SteeringWheelAngleRateOfChange_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SteeringWheelAngleRateOfChange_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleRateOfChange_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleRateOfChange_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleRateOfChange_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleRateOfChange_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleRateOfChange_decode_xer$descriptor() {
        return SteeringWheelAngleRateOfChange_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleRateOfChange_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle SteeringWheelAngleRateOfChange_decode_xer$handle() {
        return SteeringWheelAngleRateOfChange_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleRateOfChange_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_decode_xer$address() {
        return SteeringWheelAngleRateOfChange_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleRateOfChange_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SteeringWheelAngleRateOfChange_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleRateOfChange_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleRateOfChange_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleRateOfChange_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleRateOfChange_encode_xer$descriptor() {
        return SteeringWheelAngleRateOfChange_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringWheelAngleRateOfChange_encode_xer$handle() {
        return SteeringWheelAngleRateOfChange_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_encode_xer$address() {
        return SteeringWheelAngleRateOfChange_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SteeringWheelAngleRateOfChange_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleRateOfChange_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleRateOfChange_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleRateOfChange_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleRateOfChange_encode_jer$descriptor() {
        return SteeringWheelAngleRateOfChange_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringWheelAngleRateOfChange_encode_jer$handle() {
        return SteeringWheelAngleRateOfChange_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_encode_jer$address() {
        return SteeringWheelAngleRateOfChange_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = SteeringWheelAngleRateOfChange_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleRateOfChange_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleRateOfChange_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleRateOfChange_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleRateOfChange_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleRateOfChange_decode_oer$descriptor() {
        return SteeringWheelAngleRateOfChange_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleRateOfChange_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle SteeringWheelAngleRateOfChange_decode_oer$handle() {
        return SteeringWheelAngleRateOfChange_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleRateOfChange_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_decode_oer$address() {
        return SteeringWheelAngleRateOfChange_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleRateOfChange_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SteeringWheelAngleRateOfChange_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleRateOfChange_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleRateOfChange_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleRateOfChange_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleRateOfChange_encode_oer$descriptor() {
        return SteeringWheelAngleRateOfChange_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringWheelAngleRateOfChange_encode_oer$handle() {
        return SteeringWheelAngleRateOfChange_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_encode_oer$address() {
        return SteeringWheelAngleRateOfChange_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SteeringWheelAngleRateOfChange_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleRateOfChange_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleRateOfChange_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleRateOfChange_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleRateOfChange_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleRateOfChange_decode_uper$descriptor() {
        return SteeringWheelAngleRateOfChange_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleRateOfChange_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SteeringWheelAngleRateOfChange_decode_uper$handle() {
        return SteeringWheelAngleRateOfChange_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleRateOfChange_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_decode_uper$address() {
        return SteeringWheelAngleRateOfChange_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleRateOfChange_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SteeringWheelAngleRateOfChange_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleRateOfChange_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleRateOfChange_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleRateOfChange_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleRateOfChange_encode_uper$descriptor() {
        return SteeringWheelAngleRateOfChange_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SteeringWheelAngleRateOfChange_encode_uper$handle() {
        return SteeringWheelAngleRateOfChange_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_encode_uper$address() {
        return SteeringWheelAngleRateOfChange_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SteeringWheelAngleRateOfChange_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleRateOfChange_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleRateOfChange_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleRateOfChange_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleRateOfChange_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleRateOfChange_decode_aper$descriptor() {
        return SteeringWheelAngleRateOfChange_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleRateOfChange_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SteeringWheelAngleRateOfChange_decode_aper$handle() {
        return SteeringWheelAngleRateOfChange_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleRateOfChange_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_decode_aper$address() {
        return SteeringWheelAngleRateOfChange_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngleRateOfChange_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SteeringWheelAngleRateOfChange_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleRateOfChange_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngleRateOfChange_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngleRateOfChange_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngleRateOfChange_encode_aper$descriptor() {
        return SteeringWheelAngleRateOfChange_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SteeringWheelAngleRateOfChange_encode_aper$handle() {
        return SteeringWheelAngleRateOfChange_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_encode_aper$address() {
        return SteeringWheelAngleRateOfChange_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngleRateOfChange_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngleRateOfChange_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SteeringWheelAngleRateOfChange_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngleRateOfChange_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long DrivingWheelAngle_t
     * }
     */
    public static final OfLong DrivingWheelAngle_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_DrivingWheelAngle_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_DrivingWheelAngle_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DrivingWheelAngle_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_DrivingWheelAngle_constr_1$layout() {
        return asn_PER_type_DrivingWheelAngle_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DrivingWheelAngle_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_DrivingWheelAngle_constr_1() {
        return asn_PER_type_DrivingWheelAngle_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DrivingWheelAngle_constr_1
     * }
     */
    public static void asn_PER_type_DrivingWheelAngle_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_DrivingWheelAngle_constr_1$constants.SEGMENT, 0L, asn_PER_type_DrivingWheelAngle_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_DrivingWheelAngle$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_DrivingWheelAngle").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DrivingWheelAngle
     * }
     */
    public static GroupLayout asn_DEF_DrivingWheelAngle$layout() {
        return asn_DEF_DrivingWheelAngle$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DrivingWheelAngle
     * }
     */
    public static MemorySegment asn_DEF_DrivingWheelAngle() {
        return asn_DEF_DrivingWheelAngle$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DrivingWheelAngle
     * }
     */
    public static void asn_DEF_DrivingWheelAngle(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_DrivingWheelAngle$constants.SEGMENT, 0L, asn_DEF_DrivingWheelAngle$constants.LAYOUT.byteSize());
    }

    private static class DrivingWheelAngle_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DrivingWheelAngle_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DrivingWheelAngle_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor DrivingWheelAngle_free$descriptor() {
        return DrivingWheelAngle_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DrivingWheelAngle_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle DrivingWheelAngle_free$handle() {
        return DrivingWheelAngle_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DrivingWheelAngle_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment DrivingWheelAngle_free$address() {
        return DrivingWheelAngle_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DrivingWheelAngle_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void DrivingWheelAngle_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = DrivingWheelAngle_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrivingWheelAngle_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrivingWheelAngle_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DrivingWheelAngle_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DrivingWheelAngle_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DrivingWheelAngle_print$descriptor() {
        return DrivingWheelAngle_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DrivingWheelAngle_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DrivingWheelAngle_print$handle() {
        return DrivingWheelAngle_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DrivingWheelAngle_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DrivingWheelAngle_print$address() {
        return DrivingWheelAngle_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DrivingWheelAngle_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int DrivingWheelAngle_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DrivingWheelAngle_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrivingWheelAngle_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrivingWheelAngle_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DrivingWheelAngle_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DrivingWheelAngle_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor DrivingWheelAngle_constraint$descriptor() {
        return DrivingWheelAngle_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DrivingWheelAngle_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle DrivingWheelAngle_constraint$handle() {
        return DrivingWheelAngle_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DrivingWheelAngle_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment DrivingWheelAngle_constraint$address() {
        return DrivingWheelAngle_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DrivingWheelAngle_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int DrivingWheelAngle_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DrivingWheelAngle_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrivingWheelAngle_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrivingWheelAngle_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DrivingWheelAngle_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DrivingWheelAngle_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor DrivingWheelAngle_decode_ber$descriptor() {
        return DrivingWheelAngle_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DrivingWheelAngle_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle DrivingWheelAngle_decode_ber$handle() {
        return DrivingWheelAngle_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DrivingWheelAngle_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DrivingWheelAngle_decode_ber$address() {
        return DrivingWheelAngle_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DrivingWheelAngle_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DrivingWheelAngle_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = DrivingWheelAngle_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrivingWheelAngle_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrivingWheelAngle_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DrivingWheelAngle_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DrivingWheelAngle_encode_der$descriptor() {
        return DrivingWheelAngle_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DrivingWheelAngle_encode_der$handle() {
        return DrivingWheelAngle_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DrivingWheelAngle_encode_der$address() {
        return DrivingWheelAngle_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DrivingWheelAngle_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DrivingWheelAngle_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrivingWheelAngle_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrivingWheelAngle_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DrivingWheelAngle_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DrivingWheelAngle_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DrivingWheelAngle_decode_xer$descriptor() {
        return DrivingWheelAngle_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DrivingWheelAngle_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle DrivingWheelAngle_decode_xer$handle() {
        return DrivingWheelAngle_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DrivingWheelAngle_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DrivingWheelAngle_decode_xer$address() {
        return DrivingWheelAngle_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DrivingWheelAngle_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DrivingWheelAngle_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DrivingWheelAngle_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrivingWheelAngle_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrivingWheelAngle_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DrivingWheelAngle_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DrivingWheelAngle_encode_xer$descriptor() {
        return DrivingWheelAngle_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DrivingWheelAngle_encode_xer$handle() {
        return DrivingWheelAngle_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DrivingWheelAngle_encode_xer$address() {
        return DrivingWheelAngle_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DrivingWheelAngle_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DrivingWheelAngle_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrivingWheelAngle_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrivingWheelAngle_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DrivingWheelAngle_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DrivingWheelAngle_encode_jer$descriptor() {
        return DrivingWheelAngle_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DrivingWheelAngle_encode_jer$handle() {
        return DrivingWheelAngle_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DrivingWheelAngle_encode_jer$address() {
        return DrivingWheelAngle_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DrivingWheelAngle_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = DrivingWheelAngle_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrivingWheelAngle_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrivingWheelAngle_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DrivingWheelAngle_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DrivingWheelAngle_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DrivingWheelAngle_decode_oer$descriptor() {
        return DrivingWheelAngle_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DrivingWheelAngle_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle DrivingWheelAngle_decode_oer$handle() {
        return DrivingWheelAngle_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DrivingWheelAngle_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DrivingWheelAngle_decode_oer$address() {
        return DrivingWheelAngle_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DrivingWheelAngle_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DrivingWheelAngle_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DrivingWheelAngle_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrivingWheelAngle_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrivingWheelAngle_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DrivingWheelAngle_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DrivingWheelAngle_encode_oer$descriptor() {
        return DrivingWheelAngle_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DrivingWheelAngle_encode_oer$handle() {
        return DrivingWheelAngle_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DrivingWheelAngle_encode_oer$address() {
        return DrivingWheelAngle_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DrivingWheelAngle_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DrivingWheelAngle_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrivingWheelAngle_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrivingWheelAngle_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DrivingWheelAngle_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DrivingWheelAngle_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DrivingWheelAngle_decode_uper$descriptor() {
        return DrivingWheelAngle_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DrivingWheelAngle_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DrivingWheelAngle_decode_uper$handle() {
        return DrivingWheelAngle_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DrivingWheelAngle_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DrivingWheelAngle_decode_uper$address() {
        return DrivingWheelAngle_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DrivingWheelAngle_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DrivingWheelAngle_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DrivingWheelAngle_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrivingWheelAngle_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrivingWheelAngle_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DrivingWheelAngle_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DrivingWheelAngle_encode_uper$descriptor() {
        return DrivingWheelAngle_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DrivingWheelAngle_encode_uper$handle() {
        return DrivingWheelAngle_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DrivingWheelAngle_encode_uper$address() {
        return DrivingWheelAngle_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DrivingWheelAngle_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DrivingWheelAngle_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrivingWheelAngle_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrivingWheelAngle_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DrivingWheelAngle_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DrivingWheelAngle_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DrivingWheelAngle_decode_aper$descriptor() {
        return DrivingWheelAngle_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DrivingWheelAngle_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DrivingWheelAngle_decode_aper$handle() {
        return DrivingWheelAngle_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DrivingWheelAngle_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DrivingWheelAngle_decode_aper$address() {
        return DrivingWheelAngle_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DrivingWheelAngle_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DrivingWheelAngle_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DrivingWheelAngle_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrivingWheelAngle_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DrivingWheelAngle_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DrivingWheelAngle_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DrivingWheelAngle_encode_aper$descriptor() {
        return DrivingWheelAngle_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DrivingWheelAngle_encode_aper$handle() {
        return DrivingWheelAngle_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DrivingWheelAngle_encode_aper$address() {
        return DrivingWheelAngle_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DrivingWheelAngle_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DrivingWheelAngle_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DrivingWheelAngle_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DrivingWheelAngle_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int YawRateConfidence_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum YawRateConfidence.YawRateConfidence_unavailable = 0
     * }
     */
    public static int YawRateConfidence_unavailable() {
        return YawRateConfidence_unavailable;
    }
    private static final int YawRateConfidence_degSec_100_00 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum YawRateConfidence.YawRateConfidence_degSec_100_00 = 1
     * }
     */
    public static int YawRateConfidence_degSec_100_00() {
        return YawRateConfidence_degSec_100_00;
    }
    private static final int YawRateConfidence_degSec_010_00 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum YawRateConfidence.YawRateConfidence_degSec_010_00 = 2
     * }
     */
    public static int YawRateConfidence_degSec_010_00() {
        return YawRateConfidence_degSec_010_00;
    }
    private static final int YawRateConfidence_degSec_005_00 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum YawRateConfidence.YawRateConfidence_degSec_005_00 = 3
     * }
     */
    public static int YawRateConfidence_degSec_005_00() {
        return YawRateConfidence_degSec_005_00;
    }
    private static final int YawRateConfidence_degSec_001_00 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum YawRateConfidence.YawRateConfidence_degSec_001_00 = 4
     * }
     */
    public static int YawRateConfidence_degSec_001_00() {
        return YawRateConfidence_degSec_001_00;
    }
    private static final int YawRateConfidence_degSec_000_10 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum YawRateConfidence.YawRateConfidence_degSec_000_10 = 5
     * }
     */
    public static int YawRateConfidence_degSec_000_10() {
        return YawRateConfidence_degSec_000_10;
    }
    private static final int YawRateConfidence_degSec_000_05 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum YawRateConfidence.YawRateConfidence_degSec_000_05 = 6
     * }
     */
    public static int YawRateConfidence_degSec_000_05() {
        return YawRateConfidence_degSec_000_05;
    }
    private static final int YawRateConfidence_degSec_000_01 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum YawRateConfidence.YawRateConfidence_degSec_000_01 = 7
     * }
     */
    public static int YawRateConfidence_degSec_000_01() {
        return YawRateConfidence_degSec_000_01;
    }
    /**
     * {@snippet lang=c :
     * typedef long YawRateConfidence_t
     * }
     */
    public static final OfLong YawRateConfidence_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_YawRateConfidence_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_YawRateConfidence_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_YawRateConfidence_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_YawRateConfidence_constr_1$layout() {
        return asn_PER_type_YawRateConfidence_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_YawRateConfidence_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_YawRateConfidence_constr_1() {
        return asn_PER_type_YawRateConfidence_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_YawRateConfidence_constr_1
     * }
     */
    public static void asn_PER_type_YawRateConfidence_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_YawRateConfidence_constr_1$constants.SEGMENT, 0L, asn_PER_type_YawRateConfidence_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_YawRateConfidence$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_YawRateConfidence").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_YawRateConfidence
     * }
     */
    public static GroupLayout asn_DEF_YawRateConfidence$layout() {
        return asn_DEF_YawRateConfidence$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_YawRateConfidence
     * }
     */
    public static MemorySegment asn_DEF_YawRateConfidence() {
        return asn_DEF_YawRateConfidence$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_YawRateConfidence
     * }
     */
    public static void asn_DEF_YawRateConfidence(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_YawRateConfidence$constants.SEGMENT, 0L, asn_DEF_YawRateConfidence$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_YawRateConfidence_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_YawRateConfidence_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_YawRateConfidence_specs_1
     * }
     */
    public static GroupLayout asn_SPC_YawRateConfidence_specs_1$layout() {
        return asn_SPC_YawRateConfidence_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_YawRateConfidence_specs_1
     * }
     */
    public static MemorySegment asn_SPC_YawRateConfidence_specs_1() {
        return asn_SPC_YawRateConfidence_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_YawRateConfidence_specs_1
     * }
     */
    public static void asn_SPC_YawRateConfidence_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_YawRateConfidence_specs_1$constants.SEGMENT, 0L, asn_SPC_YawRateConfidence_specs_1$constants.LAYOUT.byteSize());
    }

    private static class YawRateConfidence_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRateConfidence_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void YawRateConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor YawRateConfidence_free$descriptor() {
        return YawRateConfidence_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void YawRateConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle YawRateConfidence_free$handle() {
        return YawRateConfidence_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void YawRateConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment YawRateConfidence_free$address() {
        return YawRateConfidence_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void YawRateConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void YawRateConfidence_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = YawRateConfidence_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRateConfidence_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRateConfidence_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRateConfidence_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int YawRateConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor YawRateConfidence_print$descriptor() {
        return YawRateConfidence_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int YawRateConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle YawRateConfidence_print$handle() {
        return YawRateConfidence_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int YawRateConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment YawRateConfidence_print$address() {
        return YawRateConfidence_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int YawRateConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int YawRateConfidence_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = YawRateConfidence_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRateConfidence_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRateConfidence_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRateConfidence_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int YawRateConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor YawRateConfidence_constraint$descriptor() {
        return YawRateConfidence_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int YawRateConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle YawRateConfidence_constraint$handle() {
        return YawRateConfidence_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int YawRateConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment YawRateConfidence_constraint$address() {
        return YawRateConfidence_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int YawRateConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int YawRateConfidence_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = YawRateConfidence_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRateConfidence_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRateConfidence_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRateConfidence_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRateConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor YawRateConfidence_decode_ber$descriptor() {
        return YawRateConfidence_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRateConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle YawRateConfidence_decode_ber$handle() {
        return YawRateConfidence_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRateConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment YawRateConfidence_decode_ber$address() {
        return YawRateConfidence_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t YawRateConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment YawRateConfidence_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = YawRateConfidence_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRateConfidence_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRateConfidence_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRateConfidence_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor YawRateConfidence_encode_der$descriptor() {
        return YawRateConfidence_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle YawRateConfidence_encode_der$handle() {
        return YawRateConfidence_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment YawRateConfidence_encode_der$address() {
        return YawRateConfidence_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment YawRateConfidence_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = YawRateConfidence_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRateConfidence_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRateConfidence_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRateConfidence_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRateConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor YawRateConfidence_decode_xer$descriptor() {
        return YawRateConfidence_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRateConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle YawRateConfidence_decode_xer$handle() {
        return YawRateConfidence_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRateConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment YawRateConfidence_decode_xer$address() {
        return YawRateConfidence_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t YawRateConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment YawRateConfidence_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = YawRateConfidence_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRateConfidence_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRateConfidence_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRateConfidence_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor YawRateConfidence_encode_xer$descriptor() {
        return YawRateConfidence_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle YawRateConfidence_encode_xer$handle() {
        return YawRateConfidence_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment YawRateConfidence_encode_xer$address() {
        return YawRateConfidence_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment YawRateConfidence_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = YawRateConfidence_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRateConfidence_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRateConfidence_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRateConfidence_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor YawRateConfidence_encode_jer$descriptor() {
        return YawRateConfidence_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle YawRateConfidence_encode_jer$handle() {
        return YawRateConfidence_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment YawRateConfidence_encode_jer$address() {
        return YawRateConfidence_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment YawRateConfidence_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = YawRateConfidence_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRateConfidence_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRateConfidence_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRateConfidence_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRateConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor YawRateConfidence_decode_oer$descriptor() {
        return YawRateConfidence_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRateConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle YawRateConfidence_decode_oer$handle() {
        return YawRateConfidence_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRateConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment YawRateConfidence_decode_oer$address() {
        return YawRateConfidence_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t YawRateConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment YawRateConfidence_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = YawRateConfidence_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRateConfidence_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRateConfidence_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRateConfidence_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor YawRateConfidence_encode_oer$descriptor() {
        return YawRateConfidence_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle YawRateConfidence_encode_oer$handle() {
        return YawRateConfidence_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment YawRateConfidence_encode_oer$address() {
        return YawRateConfidence_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment YawRateConfidence_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = YawRateConfidence_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRateConfidence_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRateConfidence_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRateConfidence_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRateConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor YawRateConfidence_decode_uper$descriptor() {
        return YawRateConfidence_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRateConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle YawRateConfidence_decode_uper$handle() {
        return YawRateConfidence_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRateConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment YawRateConfidence_decode_uper$address() {
        return YawRateConfidence_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t YawRateConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment YawRateConfidence_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = YawRateConfidence_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRateConfidence_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRateConfidence_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRateConfidence_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor YawRateConfidence_encode_uper$descriptor() {
        return YawRateConfidence_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle YawRateConfidence_encode_uper$handle() {
        return YawRateConfidence_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment YawRateConfidence_encode_uper$address() {
        return YawRateConfidence_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment YawRateConfidence_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = YawRateConfidence_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRateConfidence_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRateConfidence_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRateConfidence_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRateConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor YawRateConfidence_decode_aper$descriptor() {
        return YawRateConfidence_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRateConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle YawRateConfidence_decode_aper$handle() {
        return YawRateConfidence_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRateConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment YawRateConfidence_decode_aper$address() {
        return YawRateConfidence_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t YawRateConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment YawRateConfidence_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = YawRateConfidence_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRateConfidence_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRateConfidence_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRateConfidence_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor YawRateConfidence_encode_aper$descriptor() {
        return YawRateConfidence_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle YawRateConfidence_encode_aper$handle() {
        return YawRateConfidence_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment YawRateConfidence_encode_aper$address() {
        return YawRateConfidence_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t YawRateConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment YawRateConfidence_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = YawRateConfidence_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRateConfidence_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AccelerationConfidence_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AccelerationConfidence.AccelerationConfidence_unavailable = 0
     * }
     */
    public static int AccelerationConfidence_unavailable() {
        return AccelerationConfidence_unavailable;
    }
    private static final int AccelerationConfidence_accl_100_00 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AccelerationConfidence.AccelerationConfidence_accl_100_00 = 1
     * }
     */
    public static int AccelerationConfidence_accl_100_00() {
        return AccelerationConfidence_accl_100_00;
    }
    private static final int AccelerationConfidence_accl_010_00 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AccelerationConfidence.AccelerationConfidence_accl_010_00 = 2
     * }
     */
    public static int AccelerationConfidence_accl_010_00() {
        return AccelerationConfidence_accl_010_00;
    }
    private static final int AccelerationConfidence_accl_005_00 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AccelerationConfidence.AccelerationConfidence_accl_005_00 = 3
     * }
     */
    public static int AccelerationConfidence_accl_005_00() {
        return AccelerationConfidence_accl_005_00;
    }
    private static final int AccelerationConfidence_accl_001_00 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum AccelerationConfidence.AccelerationConfidence_accl_001_00 = 4
     * }
     */
    public static int AccelerationConfidence_accl_001_00() {
        return AccelerationConfidence_accl_001_00;
    }
    private static final int AccelerationConfidence_accl_000_10 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum AccelerationConfidence.AccelerationConfidence_accl_000_10 = 5
     * }
     */
    public static int AccelerationConfidence_accl_000_10() {
        return AccelerationConfidence_accl_000_10;
    }
    private static final int AccelerationConfidence_accl_000_05 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum AccelerationConfidence.AccelerationConfidence_accl_000_05 = 6
     * }
     */
    public static int AccelerationConfidence_accl_000_05() {
        return AccelerationConfidence_accl_000_05;
    }
    private static final int AccelerationConfidence_accl_000_01 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum AccelerationConfidence.AccelerationConfidence_accl_000_01 = 7
     * }
     */
    public static int AccelerationConfidence_accl_000_01() {
        return AccelerationConfidence_accl_000_01;
    }
    /**
     * {@snippet lang=c :
     * typedef long AccelerationConfidence_t
     * }
     */
    public static final OfLong AccelerationConfidence_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_AccelerationConfidence_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_AccelerationConfidence_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AccelerationConfidence_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_AccelerationConfidence_constr_1$layout() {
        return asn_PER_type_AccelerationConfidence_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AccelerationConfidence_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_AccelerationConfidence_constr_1() {
        return asn_PER_type_AccelerationConfidence_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AccelerationConfidence_constr_1
     * }
     */
    public static void asn_PER_type_AccelerationConfidence_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_AccelerationConfidence_constr_1$constants.SEGMENT, 0L, asn_PER_type_AccelerationConfidence_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_AccelerationConfidence$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_AccelerationConfidence").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AccelerationConfidence
     * }
     */
    public static GroupLayout asn_DEF_AccelerationConfidence$layout() {
        return asn_DEF_AccelerationConfidence$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AccelerationConfidence
     * }
     */
    public static MemorySegment asn_DEF_AccelerationConfidence() {
        return asn_DEF_AccelerationConfidence$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AccelerationConfidence
     * }
     */
    public static void asn_DEF_AccelerationConfidence(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_AccelerationConfidence$constants.SEGMENT, 0L, asn_DEF_AccelerationConfidence$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_AccelerationConfidence_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_AccelerationConfidence_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_AccelerationConfidence_specs_1
     * }
     */
    public static GroupLayout asn_SPC_AccelerationConfidence_specs_1$layout() {
        return asn_SPC_AccelerationConfidence_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_AccelerationConfidence_specs_1
     * }
     */
    public static MemorySegment asn_SPC_AccelerationConfidence_specs_1() {
        return asn_SPC_AccelerationConfidence_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_AccelerationConfidence_specs_1
     * }
     */
    public static void asn_SPC_AccelerationConfidence_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_AccelerationConfidence_specs_1$constants.SEGMENT, 0L, asn_SPC_AccelerationConfidence_specs_1$constants.LAYOUT.byteSize());
    }

    private static class AccelerationConfidence_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AccelerationConfidence_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void AccelerationConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor AccelerationConfidence_free$descriptor() {
        return AccelerationConfidence_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void AccelerationConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle AccelerationConfidence_free$handle() {
        return AccelerationConfidence_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void AccelerationConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment AccelerationConfidence_free$address() {
        return AccelerationConfidence_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void AccelerationConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void AccelerationConfidence_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = AccelerationConfidence_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccelerationConfidence_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccelerationConfidence_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AccelerationConfidence_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AccelerationConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AccelerationConfidence_print$descriptor() {
        return AccelerationConfidence_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AccelerationConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AccelerationConfidence_print$handle() {
        return AccelerationConfidence_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AccelerationConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AccelerationConfidence_print$address() {
        return AccelerationConfidence_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AccelerationConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int AccelerationConfidence_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AccelerationConfidence_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccelerationConfidence_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccelerationConfidence_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AccelerationConfidence_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AccelerationConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor AccelerationConfidence_constraint$descriptor() {
        return AccelerationConfidence_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AccelerationConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle AccelerationConfidence_constraint$handle() {
        return AccelerationConfidence_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AccelerationConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment AccelerationConfidence_constraint$address() {
        return AccelerationConfidence_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AccelerationConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int AccelerationConfidence_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = AccelerationConfidence_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccelerationConfidence_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccelerationConfidence_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AccelerationConfidence_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AccelerationConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor AccelerationConfidence_decode_ber$descriptor() {
        return AccelerationConfidence_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AccelerationConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle AccelerationConfidence_decode_ber$handle() {
        return AccelerationConfidence_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AccelerationConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment AccelerationConfidence_decode_ber$address() {
        return AccelerationConfidence_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AccelerationConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment AccelerationConfidence_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = AccelerationConfidence_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccelerationConfidence_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccelerationConfidence_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AccelerationConfidence_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AccelerationConfidence_encode_der$descriptor() {
        return AccelerationConfidence_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AccelerationConfidence_encode_der$handle() {
        return AccelerationConfidence_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AccelerationConfidence_encode_der$address() {
        return AccelerationConfidence_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AccelerationConfidence_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = AccelerationConfidence_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccelerationConfidence_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccelerationConfidence_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AccelerationConfidence_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AccelerationConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor AccelerationConfidence_decode_xer$descriptor() {
        return AccelerationConfidence_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AccelerationConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle AccelerationConfidence_decode_xer$handle() {
        return AccelerationConfidence_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AccelerationConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment AccelerationConfidence_decode_xer$address() {
        return AccelerationConfidence_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AccelerationConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment AccelerationConfidence_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = AccelerationConfidence_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccelerationConfidence_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccelerationConfidence_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AccelerationConfidence_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AccelerationConfidence_encode_xer$descriptor() {
        return AccelerationConfidence_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AccelerationConfidence_encode_xer$handle() {
        return AccelerationConfidence_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AccelerationConfidence_encode_xer$address() {
        return AccelerationConfidence_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AccelerationConfidence_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = AccelerationConfidence_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccelerationConfidence_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccelerationConfidence_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AccelerationConfidence_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AccelerationConfidence_encode_jer$descriptor() {
        return AccelerationConfidence_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AccelerationConfidence_encode_jer$handle() {
        return AccelerationConfidence_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AccelerationConfidence_encode_jer$address() {
        return AccelerationConfidence_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AccelerationConfidence_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = AccelerationConfidence_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccelerationConfidence_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccelerationConfidence_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AccelerationConfidence_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AccelerationConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor AccelerationConfidence_decode_oer$descriptor() {
        return AccelerationConfidence_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AccelerationConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle AccelerationConfidence_decode_oer$handle() {
        return AccelerationConfidence_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AccelerationConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment AccelerationConfidence_decode_oer$address() {
        return AccelerationConfidence_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AccelerationConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment AccelerationConfidence_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = AccelerationConfidence_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccelerationConfidence_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccelerationConfidence_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AccelerationConfidence_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AccelerationConfidence_encode_oer$descriptor() {
        return AccelerationConfidence_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AccelerationConfidence_encode_oer$handle() {
        return AccelerationConfidence_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AccelerationConfidence_encode_oer$address() {
        return AccelerationConfidence_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AccelerationConfidence_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AccelerationConfidence_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccelerationConfidence_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccelerationConfidence_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AccelerationConfidence_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AccelerationConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor AccelerationConfidence_decode_uper$descriptor() {
        return AccelerationConfidence_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AccelerationConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle AccelerationConfidence_decode_uper$handle() {
        return AccelerationConfidence_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AccelerationConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AccelerationConfidence_decode_uper$address() {
        return AccelerationConfidence_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AccelerationConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AccelerationConfidence_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AccelerationConfidence_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccelerationConfidence_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccelerationConfidence_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AccelerationConfidence_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor AccelerationConfidence_encode_uper$descriptor() {
        return AccelerationConfidence_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle AccelerationConfidence_encode_uper$handle() {
        return AccelerationConfidence_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AccelerationConfidence_encode_uper$address() {
        return AccelerationConfidence_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AccelerationConfidence_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = AccelerationConfidence_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccelerationConfidence_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccelerationConfidence_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AccelerationConfidence_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AccelerationConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor AccelerationConfidence_decode_aper$descriptor() {
        return AccelerationConfidence_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AccelerationConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle AccelerationConfidence_decode_aper$handle() {
        return AccelerationConfidence_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AccelerationConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AccelerationConfidence_decode_aper$address() {
        return AccelerationConfidence_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AccelerationConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AccelerationConfidence_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AccelerationConfidence_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccelerationConfidence_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AccelerationConfidence_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AccelerationConfidence_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor AccelerationConfidence_encode_aper$descriptor() {
        return AccelerationConfidence_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle AccelerationConfidence_encode_aper$handle() {
        return AccelerationConfidence_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AccelerationConfidence_encode_aper$address() {
        return AccelerationConfidence_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AccelerationConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AccelerationConfidence_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = AccelerationConfidence_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AccelerationConfidence_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_VehicleStatus$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_VehicleStatus").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleStatus
     * }
     */
    public static GroupLayout asn_DEF_VehicleStatus$layout() {
        return asn_DEF_VehicleStatus$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleStatus
     * }
     */
    public static MemorySegment asn_DEF_VehicleStatus() {
        return asn_DEF_VehicleStatus$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleStatus
     * }
     */
    public static void asn_DEF_VehicleStatus(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_VehicleStatus$constants.SEGMENT, 0L, asn_DEF_VehicleStatus$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_VehicleStatus_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_VehicleStatus_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_VehicleStatus_specs_1
     * }
     */
    public static GroupLayout asn_SPC_VehicleStatus_specs_1$layout() {
        return asn_SPC_VehicleStatus_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_VehicleStatus_specs_1
     * }
     */
    public static MemorySegment asn_SPC_VehicleStatus_specs_1() {
        return asn_SPC_VehicleStatus_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_VehicleStatus_specs_1
     * }
     */
    public static void asn_SPC_VehicleStatus_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_VehicleStatus_specs_1$constants.SEGMENT, 0L, asn_SPC_VehicleStatus_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_VehicleStatus_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(22, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_VehicleStatus_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 22 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleStatus_1[22]
     * }
     */
    public static SequenceLayout asn_MBR_VehicleStatus_1$layout() {
        return asn_MBR_VehicleStatus_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleStatus_1[22]
     * }
     */
    public static long[] asn_MBR_VehicleStatus_1$dimensions() {
        return asn_MBR_VehicleStatus_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleStatus_1[22]
     * }
     */
    public static MemorySegment asn_MBR_VehicleStatus_1() {
        return asn_MBR_VehicleStatus_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleStatus_1[22]
     * }
     */
    public static void asn_MBR_VehicleStatus_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_VehicleStatus_1$constants.SEGMENT, 0L, asn_MBR_VehicleStatus_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleStatus_1[22]
     * }
     */
    public static MemorySegment asn_MBR_VehicleStatus_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_VehicleStatus_1$constants.HANDLE.invokeExact(asn_MBR_VehicleStatus_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleStatus_1[22]
     * }
     */
    public static void asn_MBR_VehicleStatus_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_VehicleStatus_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef long CargoWeight_t
     * }
     */
    public static final OfLong CargoWeight_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_CargoWeight_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_CargoWeight_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_CargoWeight_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_CargoWeight_constr_1$layout() {
        return asn_PER_type_CargoWeight_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_CargoWeight_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_CargoWeight_constr_1() {
        return asn_PER_type_CargoWeight_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_CargoWeight_constr_1
     * }
     */
    public static void asn_PER_type_CargoWeight_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_CargoWeight_constr_1$constants.SEGMENT, 0L, asn_PER_type_CargoWeight_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_CargoWeight$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_CargoWeight").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_CargoWeight
     * }
     */
    public static GroupLayout asn_DEF_CargoWeight$layout() {
        return asn_DEF_CargoWeight$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_CargoWeight
     * }
     */
    public static MemorySegment asn_DEF_CargoWeight() {
        return asn_DEF_CargoWeight$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_CargoWeight
     * }
     */
    public static void asn_DEF_CargoWeight(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_CargoWeight$constants.SEGMENT, 0L, asn_DEF_CargoWeight$constants.LAYOUT.byteSize());
    }

    private static class CargoWeight_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CargoWeight_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CargoWeight_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor CargoWeight_free$descriptor() {
        return CargoWeight_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CargoWeight_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle CargoWeight_free$handle() {
        return CargoWeight_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CargoWeight_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment CargoWeight_free$address() {
        return CargoWeight_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CargoWeight_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void CargoWeight_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = CargoWeight_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CargoWeight_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CargoWeight_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CargoWeight_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CargoWeight_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor CargoWeight_print$descriptor() {
        return CargoWeight_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CargoWeight_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle CargoWeight_print$handle() {
        return CargoWeight_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int CargoWeight_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment CargoWeight_print$address() {
        return CargoWeight_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int CargoWeight_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int CargoWeight_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = CargoWeight_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CargoWeight_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CargoWeight_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CargoWeight_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CargoWeight_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor CargoWeight_constraint$descriptor() {
        return CargoWeight_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CargoWeight_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle CargoWeight_constraint$handle() {
        return CargoWeight_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int CargoWeight_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment CargoWeight_constraint$address() {
        return CargoWeight_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int CargoWeight_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int CargoWeight_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = CargoWeight_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CargoWeight_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CargoWeight_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CargoWeight_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t CargoWeight_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor CargoWeight_decode_ber$descriptor() {
        return CargoWeight_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t CargoWeight_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle CargoWeight_decode_ber$handle() {
        return CargoWeight_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t CargoWeight_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment CargoWeight_decode_ber$address() {
        return CargoWeight_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t CargoWeight_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment CargoWeight_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = CargoWeight_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CargoWeight_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CargoWeight_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CargoWeight_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor CargoWeight_encode_der$descriptor() {
        return CargoWeight_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle CargoWeight_encode_der$handle() {
        return CargoWeight_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment CargoWeight_encode_der$address() {
        return CargoWeight_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment CargoWeight_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = CargoWeight_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CargoWeight_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CargoWeight_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CargoWeight_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t CargoWeight_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor CargoWeight_decode_xer$descriptor() {
        return CargoWeight_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t CargoWeight_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle CargoWeight_decode_xer$handle() {
        return CargoWeight_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t CargoWeight_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment CargoWeight_decode_xer$address() {
        return CargoWeight_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t CargoWeight_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment CargoWeight_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = CargoWeight_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CargoWeight_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CargoWeight_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CargoWeight_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor CargoWeight_encode_xer$descriptor() {
        return CargoWeight_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle CargoWeight_encode_xer$handle() {
        return CargoWeight_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment CargoWeight_encode_xer$address() {
        return CargoWeight_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment CargoWeight_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = CargoWeight_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CargoWeight_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CargoWeight_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CargoWeight_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor CargoWeight_encode_jer$descriptor() {
        return CargoWeight_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle CargoWeight_encode_jer$handle() {
        return CargoWeight_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment CargoWeight_encode_jer$address() {
        return CargoWeight_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment CargoWeight_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = CargoWeight_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CargoWeight_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CargoWeight_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CargoWeight_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t CargoWeight_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor CargoWeight_decode_oer$descriptor() {
        return CargoWeight_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t CargoWeight_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle CargoWeight_decode_oer$handle() {
        return CargoWeight_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t CargoWeight_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment CargoWeight_decode_oer$address() {
        return CargoWeight_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t CargoWeight_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment CargoWeight_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = CargoWeight_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CargoWeight_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CargoWeight_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CargoWeight_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor CargoWeight_encode_oer$descriptor() {
        return CargoWeight_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle CargoWeight_encode_oer$handle() {
        return CargoWeight_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment CargoWeight_encode_oer$address() {
        return CargoWeight_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment CargoWeight_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = CargoWeight_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CargoWeight_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CargoWeight_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CargoWeight_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t CargoWeight_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor CargoWeight_decode_uper$descriptor() {
        return CargoWeight_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t CargoWeight_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle CargoWeight_decode_uper$handle() {
        return CargoWeight_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t CargoWeight_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment CargoWeight_decode_uper$address() {
        return CargoWeight_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t CargoWeight_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment CargoWeight_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = CargoWeight_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CargoWeight_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CargoWeight_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CargoWeight_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor CargoWeight_encode_uper$descriptor() {
        return CargoWeight_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle CargoWeight_encode_uper$handle() {
        return CargoWeight_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment CargoWeight_encode_uper$address() {
        return CargoWeight_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment CargoWeight_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = CargoWeight_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CargoWeight_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CargoWeight_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CargoWeight_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t CargoWeight_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor CargoWeight_decode_aper$descriptor() {
        return CargoWeight_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t CargoWeight_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle CargoWeight_decode_aper$handle() {
        return CargoWeight_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t CargoWeight_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment CargoWeight_decode_aper$address() {
        return CargoWeight_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t CargoWeight_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment CargoWeight_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = CargoWeight_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CargoWeight_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CargoWeight_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CargoWeight_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor CargoWeight_encode_aper$descriptor() {
        return CargoWeight_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle CargoWeight_encode_aper$handle() {
        return CargoWeight_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment CargoWeight_encode_aper$address() {
        return CargoWeight_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t CargoWeight_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment CargoWeight_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = CargoWeight_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CargoWeight_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long SteeringAxleTemperature_t
     * }
     */
    public static final OfLong SteeringAxleTemperature_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_SteeringAxleTemperature_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_SteeringAxleTemperature_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SteeringAxleTemperature_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_SteeringAxleTemperature_constr_1$layout() {
        return asn_PER_type_SteeringAxleTemperature_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SteeringAxleTemperature_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_SteeringAxleTemperature_constr_1() {
        return asn_PER_type_SteeringAxleTemperature_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SteeringAxleTemperature_constr_1
     * }
     */
    public static void asn_PER_type_SteeringAxleTemperature_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_SteeringAxleTemperature_constr_1$constants.SEGMENT, 0L, asn_PER_type_SteeringAxleTemperature_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_SteeringAxleTemperature$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_SteeringAxleTemperature").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SteeringAxleTemperature
     * }
     */
    public static GroupLayout asn_DEF_SteeringAxleTemperature$layout() {
        return asn_DEF_SteeringAxleTemperature$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SteeringAxleTemperature
     * }
     */
    public static MemorySegment asn_DEF_SteeringAxleTemperature() {
        return asn_DEF_SteeringAxleTemperature$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SteeringAxleTemperature
     * }
     */
    public static void asn_DEF_SteeringAxleTemperature(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_SteeringAxleTemperature$constants.SEGMENT, 0L, asn_DEF_SteeringAxleTemperature$constants.LAYOUT.byteSize());
    }

    private static class SteeringAxleTemperature_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleTemperature_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SteeringAxleTemperature_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor SteeringAxleTemperature_free$descriptor() {
        return SteeringAxleTemperature_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SteeringAxleTemperature_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle SteeringAxleTemperature_free$handle() {
        return SteeringAxleTemperature_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SteeringAxleTemperature_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_free$address() {
        return SteeringAxleTemperature_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SteeringAxleTemperature_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void SteeringAxleTemperature_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = SteeringAxleTemperature_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleTemperature_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleTemperature_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleTemperature_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SteeringAxleTemperature_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringAxleTemperature_print$descriptor() {
        return SteeringAxleTemperature_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SteeringAxleTemperature_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringAxleTemperature_print$handle() {
        return SteeringAxleTemperature_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SteeringAxleTemperature_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_print$address() {
        return SteeringAxleTemperature_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SteeringAxleTemperature_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int SteeringAxleTemperature_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SteeringAxleTemperature_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleTemperature_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleTemperature_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleTemperature_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SteeringAxleTemperature_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringAxleTemperature_constraint$descriptor() {
        return SteeringAxleTemperature_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SteeringAxleTemperature_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle SteeringAxleTemperature_constraint$handle() {
        return SteeringAxleTemperature_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SteeringAxleTemperature_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_constraint$address() {
        return SteeringAxleTemperature_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SteeringAxleTemperature_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int SteeringAxleTemperature_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SteeringAxleTemperature_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleTemperature_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleTemperature_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleTemperature_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleTemperature_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor SteeringAxleTemperature_decode_ber$descriptor() {
        return SteeringAxleTemperature_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleTemperature_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle SteeringAxleTemperature_decode_ber$handle() {
        return SteeringAxleTemperature_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleTemperature_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_decode_ber$address() {
        return SteeringAxleTemperature_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleTemperature_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = SteeringAxleTemperature_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleTemperature_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleTemperature_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleTemperature_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringAxleTemperature_encode_der$descriptor() {
        return SteeringAxleTemperature_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringAxleTemperature_encode_der$handle() {
        return SteeringAxleTemperature_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_encode_der$address() {
        return SteeringAxleTemperature_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SteeringAxleTemperature_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleTemperature_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleTemperature_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleTemperature_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleTemperature_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SteeringAxleTemperature_decode_xer$descriptor() {
        return SteeringAxleTemperature_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleTemperature_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle SteeringAxleTemperature_decode_xer$handle() {
        return SteeringAxleTemperature_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleTemperature_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_decode_xer$address() {
        return SteeringAxleTemperature_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleTemperature_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SteeringAxleTemperature_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleTemperature_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleTemperature_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleTemperature_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringAxleTemperature_encode_xer$descriptor() {
        return SteeringAxleTemperature_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringAxleTemperature_encode_xer$handle() {
        return SteeringAxleTemperature_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_encode_xer$address() {
        return SteeringAxleTemperature_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SteeringAxleTemperature_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleTemperature_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleTemperature_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleTemperature_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringAxleTemperature_encode_jer$descriptor() {
        return SteeringAxleTemperature_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringAxleTemperature_encode_jer$handle() {
        return SteeringAxleTemperature_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_encode_jer$address() {
        return SteeringAxleTemperature_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = SteeringAxleTemperature_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleTemperature_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleTemperature_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleTemperature_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleTemperature_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SteeringAxleTemperature_decode_oer$descriptor() {
        return SteeringAxleTemperature_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleTemperature_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle SteeringAxleTemperature_decode_oer$handle() {
        return SteeringAxleTemperature_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleTemperature_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_decode_oer$address() {
        return SteeringAxleTemperature_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleTemperature_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SteeringAxleTemperature_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleTemperature_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleTemperature_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleTemperature_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringAxleTemperature_encode_oer$descriptor() {
        return SteeringAxleTemperature_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringAxleTemperature_encode_oer$handle() {
        return SteeringAxleTemperature_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_encode_oer$address() {
        return SteeringAxleTemperature_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SteeringAxleTemperature_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleTemperature_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleTemperature_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleTemperature_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleTemperature_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SteeringAxleTemperature_decode_uper$descriptor() {
        return SteeringAxleTemperature_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleTemperature_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SteeringAxleTemperature_decode_uper$handle() {
        return SteeringAxleTemperature_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleTemperature_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_decode_uper$address() {
        return SteeringAxleTemperature_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleTemperature_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SteeringAxleTemperature_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleTemperature_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleTemperature_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleTemperature_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SteeringAxleTemperature_encode_uper$descriptor() {
        return SteeringAxleTemperature_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SteeringAxleTemperature_encode_uper$handle() {
        return SteeringAxleTemperature_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_encode_uper$address() {
        return SteeringAxleTemperature_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SteeringAxleTemperature_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleTemperature_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleTemperature_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleTemperature_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleTemperature_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SteeringAxleTemperature_decode_aper$descriptor() {
        return SteeringAxleTemperature_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleTemperature_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SteeringAxleTemperature_decode_aper$handle() {
        return SteeringAxleTemperature_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleTemperature_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_decode_aper$address() {
        return SteeringAxleTemperature_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleTemperature_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SteeringAxleTemperature_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleTemperature_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleTemperature_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleTemperature_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SteeringAxleTemperature_encode_aper$descriptor() {
        return SteeringAxleTemperature_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SteeringAxleTemperature_encode_aper$handle() {
        return SteeringAxleTemperature_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_encode_aper$address() {
        return SteeringAxleTemperature_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleTemperature_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SteeringAxleTemperature_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SteeringAxleTemperature_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleTemperature_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long DriveAxleLocation_t
     * }
     */
    public static final OfLong DriveAxleLocation_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_DriveAxleLocation_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_DriveAxleLocation_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DriveAxleLocation_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_DriveAxleLocation_constr_1$layout() {
        return asn_PER_type_DriveAxleLocation_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DriveAxleLocation_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_DriveAxleLocation_constr_1() {
        return asn_PER_type_DriveAxleLocation_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DriveAxleLocation_constr_1
     * }
     */
    public static void asn_PER_type_DriveAxleLocation_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_DriveAxleLocation_constr_1$constants.SEGMENT, 0L, asn_PER_type_DriveAxleLocation_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_DriveAxleLocation$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_DriveAxleLocation").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DriveAxleLocation
     * }
     */
    public static GroupLayout asn_DEF_DriveAxleLocation$layout() {
        return asn_DEF_DriveAxleLocation$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DriveAxleLocation
     * }
     */
    public static MemorySegment asn_DEF_DriveAxleLocation() {
        return asn_DEF_DriveAxleLocation$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DriveAxleLocation
     * }
     */
    public static void asn_DEF_DriveAxleLocation(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_DriveAxleLocation$constants.SEGMENT, 0L, asn_DEF_DriveAxleLocation$constants.LAYOUT.byteSize());
    }

    private static class DriveAxleLocation_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLocation_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DriveAxleLocation_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor DriveAxleLocation_free$descriptor() {
        return DriveAxleLocation_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DriveAxleLocation_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle DriveAxleLocation_free$handle() {
        return DriveAxleLocation_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DriveAxleLocation_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment DriveAxleLocation_free$address() {
        return DriveAxleLocation_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DriveAxleLocation_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void DriveAxleLocation_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = DriveAxleLocation_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLocation_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLocation_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLocation_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DriveAxleLocation_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleLocation_print$descriptor() {
        return DriveAxleLocation_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DriveAxleLocation_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleLocation_print$handle() {
        return DriveAxleLocation_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DriveAxleLocation_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLocation_print$address() {
        return DriveAxleLocation_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DriveAxleLocation_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int DriveAxleLocation_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DriveAxleLocation_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLocation_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLocation_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLocation_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DriveAxleLocation_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleLocation_constraint$descriptor() {
        return DriveAxleLocation_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DriveAxleLocation_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleLocation_constraint$handle() {
        return DriveAxleLocation_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DriveAxleLocation_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLocation_constraint$address() {
        return DriveAxleLocation_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DriveAxleLocation_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int DriveAxleLocation_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DriveAxleLocation_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLocation_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLocation_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLocation_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLocation_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor DriveAxleLocation_decode_ber$descriptor() {
        return DriveAxleLocation_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLocation_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle DriveAxleLocation_decode_ber$handle() {
        return DriveAxleLocation_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLocation_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DriveAxleLocation_decode_ber$address() {
        return DriveAxleLocation_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLocation_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DriveAxleLocation_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = DriveAxleLocation_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLocation_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLocation_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLocation_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleLocation_encode_der$descriptor() {
        return DriveAxleLocation_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleLocation_encode_der$handle() {
        return DriveAxleLocation_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLocation_encode_der$address() {
        return DriveAxleLocation_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLocation_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DriveAxleLocation_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLocation_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLocation_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLocation_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLocation_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DriveAxleLocation_decode_xer$descriptor() {
        return DriveAxleLocation_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLocation_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle DriveAxleLocation_decode_xer$handle() {
        return DriveAxleLocation_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLocation_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DriveAxleLocation_decode_xer$address() {
        return DriveAxleLocation_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLocation_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DriveAxleLocation_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DriveAxleLocation_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLocation_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLocation_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLocation_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleLocation_encode_xer$descriptor() {
        return DriveAxleLocation_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleLocation_encode_xer$handle() {
        return DriveAxleLocation_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLocation_encode_xer$address() {
        return DriveAxleLocation_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLocation_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DriveAxleLocation_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLocation_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLocation_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLocation_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleLocation_encode_jer$descriptor() {
        return DriveAxleLocation_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleLocation_encode_jer$handle() {
        return DriveAxleLocation_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLocation_encode_jer$address() {
        return DriveAxleLocation_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLocation_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = DriveAxleLocation_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLocation_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLocation_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLocation_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLocation_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DriveAxleLocation_decode_oer$descriptor() {
        return DriveAxleLocation_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLocation_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle DriveAxleLocation_decode_oer$handle() {
        return DriveAxleLocation_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLocation_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DriveAxleLocation_decode_oer$address() {
        return DriveAxleLocation_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLocation_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DriveAxleLocation_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DriveAxleLocation_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLocation_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLocation_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLocation_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleLocation_encode_oer$descriptor() {
        return DriveAxleLocation_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleLocation_encode_oer$handle() {
        return DriveAxleLocation_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLocation_encode_oer$address() {
        return DriveAxleLocation_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLocation_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DriveAxleLocation_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLocation_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLocation_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLocation_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLocation_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DriveAxleLocation_decode_uper$descriptor() {
        return DriveAxleLocation_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLocation_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DriveAxleLocation_decode_uper$handle() {
        return DriveAxleLocation_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLocation_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DriveAxleLocation_decode_uper$address() {
        return DriveAxleLocation_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLocation_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DriveAxleLocation_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DriveAxleLocation_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLocation_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLocation_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLocation_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DriveAxleLocation_encode_uper$descriptor() {
        return DriveAxleLocation_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DriveAxleLocation_encode_uper$handle() {
        return DriveAxleLocation_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DriveAxleLocation_encode_uper$address() {
        return DriveAxleLocation_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DriveAxleLocation_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DriveAxleLocation_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLocation_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLocation_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLocation_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLocation_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DriveAxleLocation_decode_aper$descriptor() {
        return DriveAxleLocation_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLocation_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DriveAxleLocation_decode_aper$handle() {
        return DriveAxleLocation_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLocation_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DriveAxleLocation_decode_aper$address() {
        return DriveAxleLocation_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLocation_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DriveAxleLocation_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DriveAxleLocation_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLocation_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLocation_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLocation_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DriveAxleLocation_encode_aper$descriptor() {
        return DriveAxleLocation_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DriveAxleLocation_encode_aper$handle() {
        return DriveAxleLocation_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DriveAxleLocation_encode_aper$address() {
        return DriveAxleLocation_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLocation_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DriveAxleLocation_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DriveAxleLocation_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLocation_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long DriveAxleLiftAirPressure_t
     * }
     */
    public static final OfLong DriveAxleLiftAirPressure_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_DriveAxleLiftAirPressure_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_DriveAxleLiftAirPressure_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DriveAxleLiftAirPressure_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_DriveAxleLiftAirPressure_constr_1$layout() {
        return asn_PER_type_DriveAxleLiftAirPressure_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DriveAxleLiftAirPressure_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_DriveAxleLiftAirPressure_constr_1() {
        return asn_PER_type_DriveAxleLiftAirPressure_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DriveAxleLiftAirPressure_constr_1
     * }
     */
    public static void asn_PER_type_DriveAxleLiftAirPressure_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_DriveAxleLiftAirPressure_constr_1$constants.SEGMENT, 0L, asn_PER_type_DriveAxleLiftAirPressure_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_DriveAxleLiftAirPressure$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_DriveAxleLiftAirPressure").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DriveAxleLiftAirPressure
     * }
     */
    public static GroupLayout asn_DEF_DriveAxleLiftAirPressure$layout() {
        return asn_DEF_DriveAxleLiftAirPressure$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DriveAxleLiftAirPressure
     * }
     */
    public static MemorySegment asn_DEF_DriveAxleLiftAirPressure() {
        return asn_DEF_DriveAxleLiftAirPressure$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DriveAxleLiftAirPressure
     * }
     */
    public static void asn_DEF_DriveAxleLiftAirPressure(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_DriveAxleLiftAirPressure$constants.SEGMENT, 0L, asn_DEF_DriveAxleLiftAirPressure$constants.LAYOUT.byteSize());
    }

    private static class DriveAxleLiftAirPressure_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLiftAirPressure_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DriveAxleLiftAirPressure_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor DriveAxleLiftAirPressure_free$descriptor() {
        return DriveAxleLiftAirPressure_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DriveAxleLiftAirPressure_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle DriveAxleLiftAirPressure_free$handle() {
        return DriveAxleLiftAirPressure_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DriveAxleLiftAirPressure_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_free$address() {
        return DriveAxleLiftAirPressure_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DriveAxleLiftAirPressure_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void DriveAxleLiftAirPressure_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = DriveAxleLiftAirPressure_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLiftAirPressure_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLiftAirPressure_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLiftAirPressure_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DriveAxleLiftAirPressure_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleLiftAirPressure_print$descriptor() {
        return DriveAxleLiftAirPressure_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DriveAxleLiftAirPressure_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleLiftAirPressure_print$handle() {
        return DriveAxleLiftAirPressure_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DriveAxleLiftAirPressure_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_print$address() {
        return DriveAxleLiftAirPressure_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DriveAxleLiftAirPressure_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int DriveAxleLiftAirPressure_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DriveAxleLiftAirPressure_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLiftAirPressure_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLiftAirPressure_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLiftAirPressure_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DriveAxleLiftAirPressure_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleLiftAirPressure_constraint$descriptor() {
        return DriveAxleLiftAirPressure_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DriveAxleLiftAirPressure_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleLiftAirPressure_constraint$handle() {
        return DriveAxleLiftAirPressure_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DriveAxleLiftAirPressure_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_constraint$address() {
        return DriveAxleLiftAirPressure_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DriveAxleLiftAirPressure_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int DriveAxleLiftAirPressure_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DriveAxleLiftAirPressure_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLiftAirPressure_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLiftAirPressure_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLiftAirPressure_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLiftAirPressure_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor DriveAxleLiftAirPressure_decode_ber$descriptor() {
        return DriveAxleLiftAirPressure_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLiftAirPressure_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle DriveAxleLiftAirPressure_decode_ber$handle() {
        return DriveAxleLiftAirPressure_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLiftAirPressure_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_decode_ber$address() {
        return DriveAxleLiftAirPressure_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLiftAirPressure_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = DriveAxleLiftAirPressure_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLiftAirPressure_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLiftAirPressure_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLiftAirPressure_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleLiftAirPressure_encode_der$descriptor() {
        return DriveAxleLiftAirPressure_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleLiftAirPressure_encode_der$handle() {
        return DriveAxleLiftAirPressure_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_encode_der$address() {
        return DriveAxleLiftAirPressure_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DriveAxleLiftAirPressure_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLiftAirPressure_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLiftAirPressure_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLiftAirPressure_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLiftAirPressure_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DriveAxleLiftAirPressure_decode_xer$descriptor() {
        return DriveAxleLiftAirPressure_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLiftAirPressure_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle DriveAxleLiftAirPressure_decode_xer$handle() {
        return DriveAxleLiftAirPressure_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLiftAirPressure_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_decode_xer$address() {
        return DriveAxleLiftAirPressure_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLiftAirPressure_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DriveAxleLiftAirPressure_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLiftAirPressure_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLiftAirPressure_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLiftAirPressure_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleLiftAirPressure_encode_xer$descriptor() {
        return DriveAxleLiftAirPressure_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleLiftAirPressure_encode_xer$handle() {
        return DriveAxleLiftAirPressure_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_encode_xer$address() {
        return DriveAxleLiftAirPressure_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DriveAxleLiftAirPressure_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLiftAirPressure_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLiftAirPressure_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLiftAirPressure_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleLiftAirPressure_encode_jer$descriptor() {
        return DriveAxleLiftAirPressure_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleLiftAirPressure_encode_jer$handle() {
        return DriveAxleLiftAirPressure_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_encode_jer$address() {
        return DriveAxleLiftAirPressure_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = DriveAxleLiftAirPressure_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLiftAirPressure_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLiftAirPressure_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLiftAirPressure_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLiftAirPressure_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DriveAxleLiftAirPressure_decode_oer$descriptor() {
        return DriveAxleLiftAirPressure_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLiftAirPressure_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle DriveAxleLiftAirPressure_decode_oer$handle() {
        return DriveAxleLiftAirPressure_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLiftAirPressure_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_decode_oer$address() {
        return DriveAxleLiftAirPressure_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLiftAirPressure_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DriveAxleLiftAirPressure_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLiftAirPressure_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLiftAirPressure_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLiftAirPressure_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleLiftAirPressure_encode_oer$descriptor() {
        return DriveAxleLiftAirPressure_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleLiftAirPressure_encode_oer$handle() {
        return DriveAxleLiftAirPressure_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_encode_oer$address() {
        return DriveAxleLiftAirPressure_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DriveAxleLiftAirPressure_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLiftAirPressure_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLiftAirPressure_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLiftAirPressure_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLiftAirPressure_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DriveAxleLiftAirPressure_decode_uper$descriptor() {
        return DriveAxleLiftAirPressure_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLiftAirPressure_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DriveAxleLiftAirPressure_decode_uper$handle() {
        return DriveAxleLiftAirPressure_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLiftAirPressure_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_decode_uper$address() {
        return DriveAxleLiftAirPressure_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLiftAirPressure_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DriveAxleLiftAirPressure_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLiftAirPressure_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLiftAirPressure_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLiftAirPressure_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DriveAxleLiftAirPressure_encode_uper$descriptor() {
        return DriveAxleLiftAirPressure_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DriveAxleLiftAirPressure_encode_uper$handle() {
        return DriveAxleLiftAirPressure_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_encode_uper$address() {
        return DriveAxleLiftAirPressure_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DriveAxleLiftAirPressure_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLiftAirPressure_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLiftAirPressure_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLiftAirPressure_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLiftAirPressure_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DriveAxleLiftAirPressure_decode_aper$descriptor() {
        return DriveAxleLiftAirPressure_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLiftAirPressure_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DriveAxleLiftAirPressure_decode_aper$handle() {
        return DriveAxleLiftAirPressure_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLiftAirPressure_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_decode_aper$address() {
        return DriveAxleLiftAirPressure_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLiftAirPressure_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DriveAxleLiftAirPressure_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLiftAirPressure_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLiftAirPressure_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLiftAirPressure_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DriveAxleLiftAirPressure_encode_aper$descriptor() {
        return DriveAxleLiftAirPressure_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DriveAxleLiftAirPressure_encode_aper$handle() {
        return DriveAxleLiftAirPressure_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_encode_aper$address() {
        return DriveAxleLiftAirPressure_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLiftAirPressure_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DriveAxleLiftAirPressure_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DriveAxleLiftAirPressure_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLiftAirPressure_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long DriveAxleTemperature_t
     * }
     */
    public static final OfLong DriveAxleTemperature_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_DriveAxleTemperature_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_DriveAxleTemperature_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DriveAxleTemperature_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_DriveAxleTemperature_constr_1$layout() {
        return asn_PER_type_DriveAxleTemperature_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DriveAxleTemperature_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_DriveAxleTemperature_constr_1() {
        return asn_PER_type_DriveAxleTemperature_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DriveAxleTemperature_constr_1
     * }
     */
    public static void asn_PER_type_DriveAxleTemperature_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_DriveAxleTemperature_constr_1$constants.SEGMENT, 0L, asn_PER_type_DriveAxleTemperature_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_DriveAxleTemperature$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_DriveAxleTemperature").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DriveAxleTemperature
     * }
     */
    public static GroupLayout asn_DEF_DriveAxleTemperature$layout() {
        return asn_DEF_DriveAxleTemperature$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DriveAxleTemperature
     * }
     */
    public static MemorySegment asn_DEF_DriveAxleTemperature() {
        return asn_DEF_DriveAxleTemperature$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DriveAxleTemperature
     * }
     */
    public static void asn_DEF_DriveAxleTemperature(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_DriveAxleTemperature$constants.SEGMENT, 0L, asn_DEF_DriveAxleTemperature$constants.LAYOUT.byteSize());
    }

    private static class DriveAxleTemperature_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleTemperature_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DriveAxleTemperature_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor DriveAxleTemperature_free$descriptor() {
        return DriveAxleTemperature_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DriveAxleTemperature_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle DriveAxleTemperature_free$handle() {
        return DriveAxleTemperature_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DriveAxleTemperature_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment DriveAxleTemperature_free$address() {
        return DriveAxleTemperature_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DriveAxleTemperature_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void DriveAxleTemperature_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = DriveAxleTemperature_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleTemperature_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleTemperature_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleTemperature_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DriveAxleTemperature_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleTemperature_print$descriptor() {
        return DriveAxleTemperature_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DriveAxleTemperature_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleTemperature_print$handle() {
        return DriveAxleTemperature_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DriveAxleTemperature_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleTemperature_print$address() {
        return DriveAxleTemperature_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DriveAxleTemperature_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int DriveAxleTemperature_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DriveAxleTemperature_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleTemperature_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleTemperature_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleTemperature_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DriveAxleTemperature_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleTemperature_constraint$descriptor() {
        return DriveAxleTemperature_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DriveAxleTemperature_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleTemperature_constraint$handle() {
        return DriveAxleTemperature_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DriveAxleTemperature_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleTemperature_constraint$address() {
        return DriveAxleTemperature_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DriveAxleTemperature_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int DriveAxleTemperature_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DriveAxleTemperature_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleTemperature_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleTemperature_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleTemperature_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleTemperature_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor DriveAxleTemperature_decode_ber$descriptor() {
        return DriveAxleTemperature_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleTemperature_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle DriveAxleTemperature_decode_ber$handle() {
        return DriveAxleTemperature_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleTemperature_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DriveAxleTemperature_decode_ber$address() {
        return DriveAxleTemperature_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleTemperature_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DriveAxleTemperature_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = DriveAxleTemperature_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleTemperature_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleTemperature_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleTemperature_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleTemperature_encode_der$descriptor() {
        return DriveAxleTemperature_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleTemperature_encode_der$handle() {
        return DriveAxleTemperature_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleTemperature_encode_der$address() {
        return DriveAxleTemperature_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleTemperature_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DriveAxleTemperature_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleTemperature_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleTemperature_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleTemperature_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleTemperature_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DriveAxleTemperature_decode_xer$descriptor() {
        return DriveAxleTemperature_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleTemperature_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle DriveAxleTemperature_decode_xer$handle() {
        return DriveAxleTemperature_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleTemperature_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DriveAxleTemperature_decode_xer$address() {
        return DriveAxleTemperature_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleTemperature_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DriveAxleTemperature_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DriveAxleTemperature_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleTemperature_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleTemperature_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleTemperature_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleTemperature_encode_xer$descriptor() {
        return DriveAxleTemperature_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleTemperature_encode_xer$handle() {
        return DriveAxleTemperature_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleTemperature_encode_xer$address() {
        return DriveAxleTemperature_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleTemperature_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DriveAxleTemperature_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleTemperature_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleTemperature_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleTemperature_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleTemperature_encode_jer$descriptor() {
        return DriveAxleTemperature_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleTemperature_encode_jer$handle() {
        return DriveAxleTemperature_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleTemperature_encode_jer$address() {
        return DriveAxleTemperature_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleTemperature_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = DriveAxleTemperature_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleTemperature_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleTemperature_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleTemperature_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleTemperature_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DriveAxleTemperature_decode_oer$descriptor() {
        return DriveAxleTemperature_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleTemperature_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle DriveAxleTemperature_decode_oer$handle() {
        return DriveAxleTemperature_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleTemperature_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DriveAxleTemperature_decode_oer$address() {
        return DriveAxleTemperature_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleTemperature_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DriveAxleTemperature_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DriveAxleTemperature_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleTemperature_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleTemperature_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleTemperature_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleTemperature_encode_oer$descriptor() {
        return DriveAxleTemperature_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleTemperature_encode_oer$handle() {
        return DriveAxleTemperature_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleTemperature_encode_oer$address() {
        return DriveAxleTemperature_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleTemperature_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DriveAxleTemperature_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleTemperature_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleTemperature_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleTemperature_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleTemperature_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DriveAxleTemperature_decode_uper$descriptor() {
        return DriveAxleTemperature_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleTemperature_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DriveAxleTemperature_decode_uper$handle() {
        return DriveAxleTemperature_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleTemperature_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DriveAxleTemperature_decode_uper$address() {
        return DriveAxleTemperature_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleTemperature_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DriveAxleTemperature_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DriveAxleTemperature_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleTemperature_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleTemperature_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleTemperature_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DriveAxleTemperature_encode_uper$descriptor() {
        return DriveAxleTemperature_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DriveAxleTemperature_encode_uper$handle() {
        return DriveAxleTemperature_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DriveAxleTemperature_encode_uper$address() {
        return DriveAxleTemperature_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DriveAxleTemperature_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DriveAxleTemperature_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleTemperature_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleTemperature_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleTemperature_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleTemperature_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DriveAxleTemperature_decode_aper$descriptor() {
        return DriveAxleTemperature_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleTemperature_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DriveAxleTemperature_decode_aper$handle() {
        return DriveAxleTemperature_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleTemperature_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DriveAxleTemperature_decode_aper$address() {
        return DriveAxleTemperature_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleTemperature_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DriveAxleTemperature_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DriveAxleTemperature_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleTemperature_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleTemperature_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleTemperature_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DriveAxleTemperature_encode_aper$descriptor() {
        return DriveAxleTemperature_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DriveAxleTemperature_encode_aper$handle() {
        return DriveAxleTemperature_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DriveAxleTemperature_encode_aper$address() {
        return DriveAxleTemperature_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleTemperature_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DriveAxleTemperature_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DriveAxleTemperature_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleTemperature_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long DriveAxleLubePressure_t
     * }
     */
    public static final OfLong DriveAxleLubePressure_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_DriveAxleLubePressure_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_DriveAxleLubePressure_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DriveAxleLubePressure_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_DriveAxleLubePressure_constr_1$layout() {
        return asn_PER_type_DriveAxleLubePressure_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DriveAxleLubePressure_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_DriveAxleLubePressure_constr_1() {
        return asn_PER_type_DriveAxleLubePressure_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DriveAxleLubePressure_constr_1
     * }
     */
    public static void asn_PER_type_DriveAxleLubePressure_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_DriveAxleLubePressure_constr_1$constants.SEGMENT, 0L, asn_PER_type_DriveAxleLubePressure_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_DriveAxleLubePressure$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_DriveAxleLubePressure").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DriveAxleLubePressure
     * }
     */
    public static GroupLayout asn_DEF_DriveAxleLubePressure$layout() {
        return asn_DEF_DriveAxleLubePressure$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DriveAxleLubePressure
     * }
     */
    public static MemorySegment asn_DEF_DriveAxleLubePressure() {
        return asn_DEF_DriveAxleLubePressure$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DriveAxleLubePressure
     * }
     */
    public static void asn_DEF_DriveAxleLubePressure(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_DriveAxleLubePressure$constants.SEGMENT, 0L, asn_DEF_DriveAxleLubePressure$constants.LAYOUT.byteSize());
    }

    private static class DriveAxleLubePressure_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLubePressure_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DriveAxleLubePressure_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor DriveAxleLubePressure_free$descriptor() {
        return DriveAxleLubePressure_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DriveAxleLubePressure_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle DriveAxleLubePressure_free$handle() {
        return DriveAxleLubePressure_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DriveAxleLubePressure_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_free$address() {
        return DriveAxleLubePressure_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DriveAxleLubePressure_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void DriveAxleLubePressure_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = DriveAxleLubePressure_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLubePressure_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLubePressure_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLubePressure_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DriveAxleLubePressure_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleLubePressure_print$descriptor() {
        return DriveAxleLubePressure_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DriveAxleLubePressure_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleLubePressure_print$handle() {
        return DriveAxleLubePressure_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DriveAxleLubePressure_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_print$address() {
        return DriveAxleLubePressure_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DriveAxleLubePressure_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int DriveAxleLubePressure_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DriveAxleLubePressure_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLubePressure_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLubePressure_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLubePressure_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DriveAxleLubePressure_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleLubePressure_constraint$descriptor() {
        return DriveAxleLubePressure_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DriveAxleLubePressure_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleLubePressure_constraint$handle() {
        return DriveAxleLubePressure_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DriveAxleLubePressure_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_constraint$address() {
        return DriveAxleLubePressure_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DriveAxleLubePressure_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int DriveAxleLubePressure_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DriveAxleLubePressure_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLubePressure_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLubePressure_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLubePressure_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLubePressure_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor DriveAxleLubePressure_decode_ber$descriptor() {
        return DriveAxleLubePressure_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLubePressure_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle DriveAxleLubePressure_decode_ber$handle() {
        return DriveAxleLubePressure_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLubePressure_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_decode_ber$address() {
        return DriveAxleLubePressure_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLubePressure_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = DriveAxleLubePressure_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLubePressure_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLubePressure_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLubePressure_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleLubePressure_encode_der$descriptor() {
        return DriveAxleLubePressure_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleLubePressure_encode_der$handle() {
        return DriveAxleLubePressure_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_encode_der$address() {
        return DriveAxleLubePressure_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DriveAxleLubePressure_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLubePressure_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLubePressure_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLubePressure_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLubePressure_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DriveAxleLubePressure_decode_xer$descriptor() {
        return DriveAxleLubePressure_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLubePressure_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle DriveAxleLubePressure_decode_xer$handle() {
        return DriveAxleLubePressure_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLubePressure_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_decode_xer$address() {
        return DriveAxleLubePressure_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLubePressure_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DriveAxleLubePressure_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLubePressure_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLubePressure_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLubePressure_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleLubePressure_encode_xer$descriptor() {
        return DriveAxleLubePressure_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleLubePressure_encode_xer$handle() {
        return DriveAxleLubePressure_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_encode_xer$address() {
        return DriveAxleLubePressure_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DriveAxleLubePressure_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLubePressure_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLubePressure_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLubePressure_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleLubePressure_encode_jer$descriptor() {
        return DriveAxleLubePressure_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleLubePressure_encode_jer$handle() {
        return DriveAxleLubePressure_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_encode_jer$address() {
        return DriveAxleLubePressure_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = DriveAxleLubePressure_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLubePressure_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLubePressure_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLubePressure_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLubePressure_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DriveAxleLubePressure_decode_oer$descriptor() {
        return DriveAxleLubePressure_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLubePressure_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle DriveAxleLubePressure_decode_oer$handle() {
        return DriveAxleLubePressure_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLubePressure_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_decode_oer$address() {
        return DriveAxleLubePressure_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLubePressure_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DriveAxleLubePressure_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLubePressure_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLubePressure_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLubePressure_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DriveAxleLubePressure_encode_oer$descriptor() {
        return DriveAxleLubePressure_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DriveAxleLubePressure_encode_oer$handle() {
        return DriveAxleLubePressure_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_encode_oer$address() {
        return DriveAxleLubePressure_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DriveAxleLubePressure_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLubePressure_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLubePressure_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLubePressure_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLubePressure_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DriveAxleLubePressure_decode_uper$descriptor() {
        return DriveAxleLubePressure_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLubePressure_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DriveAxleLubePressure_decode_uper$handle() {
        return DriveAxleLubePressure_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLubePressure_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_decode_uper$address() {
        return DriveAxleLubePressure_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLubePressure_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DriveAxleLubePressure_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLubePressure_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLubePressure_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLubePressure_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DriveAxleLubePressure_encode_uper$descriptor() {
        return DriveAxleLubePressure_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DriveAxleLubePressure_encode_uper$handle() {
        return DriveAxleLubePressure_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_encode_uper$address() {
        return DriveAxleLubePressure_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DriveAxleLubePressure_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLubePressure_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLubePressure_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLubePressure_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLubePressure_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DriveAxleLubePressure_decode_aper$descriptor() {
        return DriveAxleLubePressure_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLubePressure_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DriveAxleLubePressure_decode_aper$handle() {
        return DriveAxleLubePressure_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLubePressure_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_decode_aper$address() {
        return DriveAxleLubePressure_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DriveAxleLubePressure_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DriveAxleLubePressure_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLubePressure_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DriveAxleLubePressure_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DriveAxleLubePressure_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DriveAxleLubePressure_encode_aper$descriptor() {
        return DriveAxleLubePressure_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DriveAxleLubePressure_encode_aper$handle() {
        return DriveAxleLubePressure_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_encode_aper$address() {
        return DriveAxleLubePressure_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DriveAxleLubePressure_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DriveAxleLubePressure_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DriveAxleLubePressure_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DriveAxleLubePressure_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long SteeringAxleLubePressure_t
     * }
     */
    public static final OfLong SteeringAxleLubePressure_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_SteeringAxleLubePressure_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_SteeringAxleLubePressure_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SteeringAxleLubePressure_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_SteeringAxleLubePressure_constr_1$layout() {
        return asn_PER_type_SteeringAxleLubePressure_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SteeringAxleLubePressure_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_SteeringAxleLubePressure_constr_1() {
        return asn_PER_type_SteeringAxleLubePressure_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SteeringAxleLubePressure_constr_1
     * }
     */
    public static void asn_PER_type_SteeringAxleLubePressure_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_SteeringAxleLubePressure_constr_1$constants.SEGMENT, 0L, asn_PER_type_SteeringAxleLubePressure_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_SteeringAxleLubePressure$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_SteeringAxleLubePressure").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SteeringAxleLubePressure
     * }
     */
    public static GroupLayout asn_DEF_SteeringAxleLubePressure$layout() {
        return asn_DEF_SteeringAxleLubePressure$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SteeringAxleLubePressure
     * }
     */
    public static MemorySegment asn_DEF_SteeringAxleLubePressure() {
        return asn_DEF_SteeringAxleLubePressure$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SteeringAxleLubePressure
     * }
     */
    public static void asn_DEF_SteeringAxleLubePressure(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_SteeringAxleLubePressure$constants.SEGMENT, 0L, asn_DEF_SteeringAxleLubePressure$constants.LAYOUT.byteSize());
    }

    private static class SteeringAxleLubePressure_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleLubePressure_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SteeringAxleLubePressure_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor SteeringAxleLubePressure_free$descriptor() {
        return SteeringAxleLubePressure_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SteeringAxleLubePressure_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle SteeringAxleLubePressure_free$handle() {
        return SteeringAxleLubePressure_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SteeringAxleLubePressure_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_free$address() {
        return SteeringAxleLubePressure_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SteeringAxleLubePressure_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void SteeringAxleLubePressure_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = SteeringAxleLubePressure_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleLubePressure_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleLubePressure_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleLubePressure_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SteeringAxleLubePressure_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringAxleLubePressure_print$descriptor() {
        return SteeringAxleLubePressure_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SteeringAxleLubePressure_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringAxleLubePressure_print$handle() {
        return SteeringAxleLubePressure_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SteeringAxleLubePressure_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_print$address() {
        return SteeringAxleLubePressure_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SteeringAxleLubePressure_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int SteeringAxleLubePressure_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SteeringAxleLubePressure_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleLubePressure_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleLubePressure_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleLubePressure_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SteeringAxleLubePressure_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringAxleLubePressure_constraint$descriptor() {
        return SteeringAxleLubePressure_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SteeringAxleLubePressure_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle SteeringAxleLubePressure_constraint$handle() {
        return SteeringAxleLubePressure_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SteeringAxleLubePressure_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_constraint$address() {
        return SteeringAxleLubePressure_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SteeringAxleLubePressure_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int SteeringAxleLubePressure_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SteeringAxleLubePressure_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleLubePressure_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleLubePressure_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleLubePressure_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleLubePressure_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor SteeringAxleLubePressure_decode_ber$descriptor() {
        return SteeringAxleLubePressure_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleLubePressure_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle SteeringAxleLubePressure_decode_ber$handle() {
        return SteeringAxleLubePressure_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleLubePressure_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_decode_ber$address() {
        return SteeringAxleLubePressure_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleLubePressure_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = SteeringAxleLubePressure_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleLubePressure_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleLubePressure_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleLubePressure_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringAxleLubePressure_encode_der$descriptor() {
        return SteeringAxleLubePressure_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringAxleLubePressure_encode_der$handle() {
        return SteeringAxleLubePressure_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_encode_der$address() {
        return SteeringAxleLubePressure_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SteeringAxleLubePressure_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleLubePressure_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleLubePressure_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleLubePressure_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleLubePressure_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SteeringAxleLubePressure_decode_xer$descriptor() {
        return SteeringAxleLubePressure_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleLubePressure_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle SteeringAxleLubePressure_decode_xer$handle() {
        return SteeringAxleLubePressure_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleLubePressure_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_decode_xer$address() {
        return SteeringAxleLubePressure_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleLubePressure_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SteeringAxleLubePressure_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleLubePressure_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleLubePressure_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleLubePressure_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringAxleLubePressure_encode_xer$descriptor() {
        return SteeringAxleLubePressure_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringAxleLubePressure_encode_xer$handle() {
        return SteeringAxleLubePressure_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_encode_xer$address() {
        return SteeringAxleLubePressure_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SteeringAxleLubePressure_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleLubePressure_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleLubePressure_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleLubePressure_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringAxleLubePressure_encode_jer$descriptor() {
        return SteeringAxleLubePressure_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringAxleLubePressure_encode_jer$handle() {
        return SteeringAxleLubePressure_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_encode_jer$address() {
        return SteeringAxleLubePressure_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = SteeringAxleLubePressure_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleLubePressure_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleLubePressure_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleLubePressure_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleLubePressure_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SteeringAxleLubePressure_decode_oer$descriptor() {
        return SteeringAxleLubePressure_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleLubePressure_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle SteeringAxleLubePressure_decode_oer$handle() {
        return SteeringAxleLubePressure_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleLubePressure_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_decode_oer$address() {
        return SteeringAxleLubePressure_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleLubePressure_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SteeringAxleLubePressure_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleLubePressure_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleLubePressure_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleLubePressure_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringAxleLubePressure_encode_oer$descriptor() {
        return SteeringAxleLubePressure_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringAxleLubePressure_encode_oer$handle() {
        return SteeringAxleLubePressure_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_encode_oer$address() {
        return SteeringAxleLubePressure_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SteeringAxleLubePressure_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleLubePressure_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleLubePressure_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleLubePressure_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleLubePressure_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SteeringAxleLubePressure_decode_uper$descriptor() {
        return SteeringAxleLubePressure_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleLubePressure_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SteeringAxleLubePressure_decode_uper$handle() {
        return SteeringAxleLubePressure_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleLubePressure_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_decode_uper$address() {
        return SteeringAxleLubePressure_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleLubePressure_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SteeringAxleLubePressure_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleLubePressure_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleLubePressure_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleLubePressure_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SteeringAxleLubePressure_encode_uper$descriptor() {
        return SteeringAxleLubePressure_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SteeringAxleLubePressure_encode_uper$handle() {
        return SteeringAxleLubePressure_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_encode_uper$address() {
        return SteeringAxleLubePressure_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SteeringAxleLubePressure_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleLubePressure_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleLubePressure_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleLubePressure_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleLubePressure_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SteeringAxleLubePressure_decode_aper$descriptor() {
        return SteeringAxleLubePressure_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleLubePressure_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SteeringAxleLubePressure_decode_aper$handle() {
        return SteeringAxleLubePressure_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleLubePressure_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_decode_aper$address() {
        return SteeringAxleLubePressure_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringAxleLubePressure_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SteeringAxleLubePressure_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleLubePressure_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringAxleLubePressure_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringAxleLubePressure_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SteeringAxleLubePressure_encode_aper$descriptor() {
        return SteeringAxleLubePressure_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SteeringAxleLubePressure_encode_aper$handle() {
        return SteeringAxleLubePressure_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_encode_aper$address() {
        return SteeringAxleLubePressure_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringAxleLubePressure_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SteeringAxleLubePressure_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SteeringAxleLubePressure_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringAxleLubePressure_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_J1939data$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_J1939data").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_J1939data
     * }
     */
    public static GroupLayout asn_DEF_J1939data$layout() {
        return asn_DEF_J1939data$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_J1939data
     * }
     */
    public static MemorySegment asn_DEF_J1939data() {
        return asn_DEF_J1939data$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_J1939data
     * }
     */
    public static void asn_DEF_J1939data(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_J1939data$constants.SEGMENT, 0L, asn_DEF_J1939data$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_J1939data_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_J1939data_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_J1939data_specs_1
     * }
     */
    public static GroupLayout asn_SPC_J1939data_specs_1$layout() {
        return asn_SPC_J1939data_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_J1939data_specs_1
     * }
     */
    public static MemorySegment asn_SPC_J1939data_specs_1() {
        return asn_SPC_J1939data_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_J1939data_specs_1
     * }
     */
    public static void asn_SPC_J1939data_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_J1939data_specs_1$constants.SEGMENT, 0L, asn_SPC_J1939data_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_J1939data_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(10, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_J1939data_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 10 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_J1939data_1[10]
     * }
     */
    public static SequenceLayout asn_MBR_J1939data_1$layout() {
        return asn_MBR_J1939data_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_J1939data_1[10]
     * }
     */
    public static long[] asn_MBR_J1939data_1$dimensions() {
        return asn_MBR_J1939data_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_J1939data_1[10]
     * }
     */
    public static MemorySegment asn_MBR_J1939data_1() {
        return asn_MBR_J1939data_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_J1939data_1[10]
     * }
     */
    public static void asn_MBR_J1939data_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_J1939data_1$constants.SEGMENT, 0L, asn_MBR_J1939data_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_J1939data_1[10]
     * }
     */
    public static MemorySegment asn_MBR_J1939data_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_J1939data_1$constants.HANDLE.invokeExact(asn_MBR_J1939data_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_J1939data_1[10]
     * }
     */
    public static void asn_MBR_J1939data_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_J1939data_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_TireDataList$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_TireDataList").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TireDataList
     * }
     */
    public static GroupLayout asn_DEF_TireDataList$layout() {
        return asn_DEF_TireDataList$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TireDataList
     * }
     */
    public static MemorySegment asn_DEF_TireDataList() {
        return asn_DEF_TireDataList$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TireDataList
     * }
     */
    public static void asn_DEF_TireDataList(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_TireDataList$constants.SEGMENT, 0L, asn_DEF_TireDataList$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_TireDataList_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SET_OF_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_TireDataList_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_TireDataList_specs_1
     * }
     */
    public static GroupLayout asn_SPC_TireDataList_specs_1$layout() {
        return asn_SPC_TireDataList_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_TireDataList_specs_1
     * }
     */
    public static MemorySegment asn_SPC_TireDataList_specs_1() {
        return asn_SPC_TireDataList_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_TireDataList_specs_1
     * }
     */
    public static void asn_SPC_TireDataList_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_TireDataList_specs_1$constants.SEGMENT, 0L, asn_SPC_TireDataList_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_TireDataList_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(1, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_TireDataList_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 1 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TireDataList_1[1]
     * }
     */
    public static SequenceLayout asn_MBR_TireDataList_1$layout() {
        return asn_MBR_TireDataList_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TireDataList_1[1]
     * }
     */
    public static long[] asn_MBR_TireDataList_1$dimensions() {
        return asn_MBR_TireDataList_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TireDataList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_TireDataList_1() {
        return asn_MBR_TireDataList_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TireDataList_1[1]
     * }
     */
    public static void asn_MBR_TireDataList_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_TireDataList_1$constants.SEGMENT, 0L, asn_MBR_TireDataList_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TireDataList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_TireDataList_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_TireDataList_1$constants.HANDLE.invokeExact(asn_MBR_TireDataList_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TireDataList_1[1]
     * }
     */
    public static void asn_MBR_TireDataList_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_TireDataList_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_TireDataList_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_TireDataList_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TireDataList_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_TireDataList_constr_1$layout() {
        return asn_PER_type_TireDataList_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TireDataList_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_TireDataList_constr_1() {
        return asn_PER_type_TireDataList_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TireDataList_constr_1
     * }
     */
    public static void asn_PER_type_TireDataList_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_TireDataList_constr_1$constants.SEGMENT, 0L, asn_PER_type_TireDataList_constr_1$constants.LAYOUT.byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef long TireLocation_t
     * }
     */
    public static final OfLong TireLocation_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_TireLocation_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_TireLocation_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TireLocation_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_TireLocation_constr_1$layout() {
        return asn_PER_type_TireLocation_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TireLocation_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_TireLocation_constr_1() {
        return asn_PER_type_TireLocation_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TireLocation_constr_1
     * }
     */
    public static void asn_PER_type_TireLocation_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_TireLocation_constr_1$constants.SEGMENT, 0L, asn_PER_type_TireLocation_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_TireLocation$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_TireLocation").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TireLocation
     * }
     */
    public static GroupLayout asn_DEF_TireLocation$layout() {
        return asn_DEF_TireLocation$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TireLocation
     * }
     */
    public static MemorySegment asn_DEF_TireLocation() {
        return asn_DEF_TireLocation$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TireLocation
     * }
     */
    public static void asn_DEF_TireLocation(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_TireLocation$constants.SEGMENT, 0L, asn_DEF_TireLocation$constants.LAYOUT.byteSize());
    }

    private static class TireLocation_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TireLocation_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void TireLocation_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor TireLocation_free$descriptor() {
        return TireLocation_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void TireLocation_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle TireLocation_free$handle() {
        return TireLocation_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void TireLocation_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment TireLocation_free$address() {
        return TireLocation_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void TireLocation_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void TireLocation_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = TireLocation_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TireLocation_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TireLocation_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TireLocation_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TireLocation_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TireLocation_print$descriptor() {
        return TireLocation_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TireLocation_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TireLocation_print$handle() {
        return TireLocation_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TireLocation_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TireLocation_print$address() {
        return TireLocation_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TireLocation_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int TireLocation_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TireLocation_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TireLocation_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TireLocation_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TireLocation_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TireLocation_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor TireLocation_constraint$descriptor() {
        return TireLocation_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TireLocation_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle TireLocation_constraint$handle() {
        return TireLocation_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TireLocation_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment TireLocation_constraint$address() {
        return TireLocation_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TireLocation_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int TireLocation_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TireLocation_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TireLocation_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TireLocation_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TireLocation_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TireLocation_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor TireLocation_decode_ber$descriptor() {
        return TireLocation_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TireLocation_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle TireLocation_decode_ber$handle() {
        return TireLocation_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TireLocation_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment TireLocation_decode_ber$address() {
        return TireLocation_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TireLocation_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment TireLocation_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = TireLocation_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TireLocation_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TireLocation_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TireLocation_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TireLocation_encode_der$descriptor() {
        return TireLocation_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TireLocation_encode_der$handle() {
        return TireLocation_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TireLocation_encode_der$address() {
        return TireLocation_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TireLocation_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = TireLocation_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TireLocation_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TireLocation_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TireLocation_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TireLocation_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor TireLocation_decode_xer$descriptor() {
        return TireLocation_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TireLocation_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle TireLocation_decode_xer$handle() {
        return TireLocation_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TireLocation_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment TireLocation_decode_xer$address() {
        return TireLocation_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TireLocation_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment TireLocation_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = TireLocation_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TireLocation_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TireLocation_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TireLocation_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TireLocation_encode_xer$descriptor() {
        return TireLocation_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TireLocation_encode_xer$handle() {
        return TireLocation_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TireLocation_encode_xer$address() {
        return TireLocation_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TireLocation_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = TireLocation_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TireLocation_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TireLocation_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TireLocation_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TireLocation_encode_jer$descriptor() {
        return TireLocation_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TireLocation_encode_jer$handle() {
        return TireLocation_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TireLocation_encode_jer$address() {
        return TireLocation_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TireLocation_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = TireLocation_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TireLocation_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TireLocation_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TireLocation_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TireLocation_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor TireLocation_decode_oer$descriptor() {
        return TireLocation_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TireLocation_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle TireLocation_decode_oer$handle() {
        return TireLocation_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TireLocation_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment TireLocation_decode_oer$address() {
        return TireLocation_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TireLocation_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment TireLocation_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = TireLocation_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TireLocation_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TireLocation_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TireLocation_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TireLocation_encode_oer$descriptor() {
        return TireLocation_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TireLocation_encode_oer$handle() {
        return TireLocation_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TireLocation_encode_oer$address() {
        return TireLocation_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TireLocation_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TireLocation_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TireLocation_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TireLocation_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TireLocation_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TireLocation_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor TireLocation_decode_uper$descriptor() {
        return TireLocation_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TireLocation_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle TireLocation_decode_uper$handle() {
        return TireLocation_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TireLocation_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TireLocation_decode_uper$address() {
        return TireLocation_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TireLocation_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TireLocation_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TireLocation_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TireLocation_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TireLocation_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TireLocation_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor TireLocation_encode_uper$descriptor() {
        return TireLocation_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle TireLocation_encode_uper$handle() {
        return TireLocation_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TireLocation_encode_uper$address() {
        return TireLocation_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TireLocation_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TireLocation_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TireLocation_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TireLocation_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TireLocation_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TireLocation_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor TireLocation_decode_aper$descriptor() {
        return TireLocation_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TireLocation_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle TireLocation_decode_aper$handle() {
        return TireLocation_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TireLocation_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TireLocation_decode_aper$address() {
        return TireLocation_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TireLocation_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TireLocation_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TireLocation_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TireLocation_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TireLocation_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TireLocation_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor TireLocation_encode_aper$descriptor() {
        return TireLocation_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle TireLocation_encode_aper$handle() {
        return TireLocation_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TireLocation_encode_aper$address() {
        return TireLocation_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TireLocation_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TireLocation_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TireLocation_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TireLocation_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long TirePressure_t
     * }
     */
    public static final OfLong TirePressure_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_TirePressure_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_TirePressure_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TirePressure_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_TirePressure_constr_1$layout() {
        return asn_PER_type_TirePressure_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TirePressure_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_TirePressure_constr_1() {
        return asn_PER_type_TirePressure_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TirePressure_constr_1
     * }
     */
    public static void asn_PER_type_TirePressure_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_TirePressure_constr_1$constants.SEGMENT, 0L, asn_PER_type_TirePressure_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_TirePressure$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_TirePressure").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TirePressure
     * }
     */
    public static GroupLayout asn_DEF_TirePressure$layout() {
        return asn_DEF_TirePressure$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TirePressure
     * }
     */
    public static MemorySegment asn_DEF_TirePressure() {
        return asn_DEF_TirePressure$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TirePressure
     * }
     */
    public static void asn_DEF_TirePressure(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_TirePressure$constants.SEGMENT, 0L, asn_DEF_TirePressure$constants.LAYOUT.byteSize());
    }

    private static class TirePressure_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TirePressure_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void TirePressure_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor TirePressure_free$descriptor() {
        return TirePressure_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void TirePressure_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle TirePressure_free$handle() {
        return TirePressure_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void TirePressure_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment TirePressure_free$address() {
        return TirePressure_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void TirePressure_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void TirePressure_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = TirePressure_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TirePressure_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TirePressure_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TirePressure_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TirePressure_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TirePressure_print$descriptor() {
        return TirePressure_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TirePressure_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TirePressure_print$handle() {
        return TirePressure_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TirePressure_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TirePressure_print$address() {
        return TirePressure_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TirePressure_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int TirePressure_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TirePressure_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TirePressure_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TirePressure_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TirePressure_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TirePressure_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor TirePressure_constraint$descriptor() {
        return TirePressure_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TirePressure_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle TirePressure_constraint$handle() {
        return TirePressure_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TirePressure_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment TirePressure_constraint$address() {
        return TirePressure_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TirePressure_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int TirePressure_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TirePressure_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TirePressure_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
}

