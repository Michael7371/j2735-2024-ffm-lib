// Generated by jextract

package j2735_2024_MessageFrame;

import java.lang.foreign.*;
import java.util.function.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct asn_INTEGER_specifics_s {
 *     const asn_INTEGER_enum_map_t *value2enum;
 *     const unsigned int *enum2value;
 *     int map_count;
 *     int extension;
 *     int strict_enumeration;
 *     int field_width;
 *     int field_unsigned;
 * }
 * }
 */
public class asn_INTEGER_specifics_s {

    asn_INTEGER_specifics_s() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        MessageFrame_h.C_POINTER.withName("value2enum"),
        MessageFrame_h.C_POINTER.withName("enum2value"),
        MessageFrame_h.C_INT.withName("map_count"),
        MessageFrame_h.C_INT.withName("extension"),
        MessageFrame_h.C_INT.withName("strict_enumeration"),
        MessageFrame_h.C_INT.withName("field_width"),
        MessageFrame_h.C_INT.withName("field_unsigned"),
        MemoryLayout.paddingLayout(4)
    ).withName("asn_INTEGER_specifics_s");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final AddressLayout value2enum$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("value2enum"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const asn_INTEGER_enum_map_t *value2enum
     * }
     */
    public static final AddressLayout value2enum$layout() {
        return value2enum$LAYOUT;
    }

    private static final long value2enum$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const asn_INTEGER_enum_map_t *value2enum
     * }
     */
    public static final long value2enum$offset() {
        return value2enum$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const asn_INTEGER_enum_map_t *value2enum
     * }
     */
    public static MemorySegment value2enum(MemorySegment struct) {
        return struct.get(value2enum$LAYOUT, value2enum$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const asn_INTEGER_enum_map_t *value2enum
     * }
     */
    public static void value2enum(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(value2enum$LAYOUT, value2enum$OFFSET, fieldValue);
    }

    private static final AddressLayout enum2value$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("enum2value"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * const unsigned int *enum2value
     * }
     */
    public static final AddressLayout enum2value$layout() {
        return enum2value$LAYOUT;
    }

    private static final long enum2value$OFFSET = 8;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * const unsigned int *enum2value
     * }
     */
    public static final long enum2value$offset() {
        return enum2value$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * const unsigned int *enum2value
     * }
     */
    public static MemorySegment enum2value(MemorySegment struct) {
        return struct.get(enum2value$LAYOUT, enum2value$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * const unsigned int *enum2value
     * }
     */
    public static void enum2value(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(enum2value$LAYOUT, enum2value$OFFSET, fieldValue);
    }

    private static final OfInt map_count$LAYOUT = (OfInt)$LAYOUT.select(groupElement("map_count"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int map_count
     * }
     */
    public static final OfInt map_count$layout() {
        return map_count$LAYOUT;
    }

    private static final long map_count$OFFSET = 16;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int map_count
     * }
     */
    public static final long map_count$offset() {
        return map_count$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int map_count
     * }
     */
    public static int map_count(MemorySegment struct) {
        return struct.get(map_count$LAYOUT, map_count$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int map_count
     * }
     */
    public static void map_count(MemorySegment struct, int fieldValue) {
        struct.set(map_count$LAYOUT, map_count$OFFSET, fieldValue);
    }

    private static final OfInt extension$LAYOUT = (OfInt)$LAYOUT.select(groupElement("extension"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int extension
     * }
     */
    public static final OfInt extension$layout() {
        return extension$LAYOUT;
    }

    private static final long extension$OFFSET = 20;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int extension
     * }
     */
    public static final long extension$offset() {
        return extension$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int extension
     * }
     */
    public static int extension(MemorySegment struct) {
        return struct.get(extension$LAYOUT, extension$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int extension
     * }
     */
    public static void extension(MemorySegment struct, int fieldValue) {
        struct.set(extension$LAYOUT, extension$OFFSET, fieldValue);
    }

    private static final OfInt strict_enumeration$LAYOUT = (OfInt)$LAYOUT.select(groupElement("strict_enumeration"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int strict_enumeration
     * }
     */
    public static final OfInt strict_enumeration$layout() {
        return strict_enumeration$LAYOUT;
    }

    private static final long strict_enumeration$OFFSET = 24;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int strict_enumeration
     * }
     */
    public static final long strict_enumeration$offset() {
        return strict_enumeration$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int strict_enumeration
     * }
     */
    public static int strict_enumeration(MemorySegment struct) {
        return struct.get(strict_enumeration$LAYOUT, strict_enumeration$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int strict_enumeration
     * }
     */
    public static void strict_enumeration(MemorySegment struct, int fieldValue) {
        struct.set(strict_enumeration$LAYOUT, strict_enumeration$OFFSET, fieldValue);
    }

    private static final OfInt field_width$LAYOUT = (OfInt)$LAYOUT.select(groupElement("field_width"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int field_width
     * }
     */
    public static final OfInt field_width$layout() {
        return field_width$LAYOUT;
    }

    private static final long field_width$OFFSET = 28;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int field_width
     * }
     */
    public static final long field_width$offset() {
        return field_width$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int field_width
     * }
     */
    public static int field_width(MemorySegment struct) {
        return struct.get(field_width$LAYOUT, field_width$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int field_width
     * }
     */
    public static void field_width(MemorySegment struct, int fieldValue) {
        struct.set(field_width$LAYOUT, field_width$OFFSET, fieldValue);
    }

    private static final OfInt field_unsigned$LAYOUT = (OfInt)$LAYOUT.select(groupElement("field_unsigned"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * int field_unsigned
     * }
     */
    public static final OfInt field_unsigned$layout() {
        return field_unsigned$LAYOUT;
    }

    private static final long field_unsigned$OFFSET = 32;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * int field_unsigned
     * }
     */
    public static final long field_unsigned$offset() {
        return field_unsigned$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * int field_unsigned
     * }
     */
    public static int field_unsigned(MemorySegment struct) {
        return struct.get(field_unsigned$LAYOUT, field_unsigned$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * int field_unsigned
     * }
     */
    public static void field_unsigned(MemorySegment struct, int fieldValue) {
        struct.set(field_unsigned$LAYOUT, field_unsigned$OFFSET, fieldValue);
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

