// Generated by jextract

package j2735_2024_MessageFrame;

import java.lang.foreign.*;
import java.util.function.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

/**
 * {@snippet lang=c :
 * struct ManeuverSharingAndCoordinatingMessage {
 *     DDateTime_t mSCMTimestamp;
 *     struct Position3D *hVPos;
 *     struct PositionalAccuracy *hVPosXYConf;
 *     MSCMType_t mSCMType;
 *     TemporaryID_t sourceID;
 *     struct TemporaryIDList *destinationIDs;
 *     ManeuverSharingAndCoordinatingMessage_ManeuverID_t *maneuverID;
 *     struct Maneuver *maneuver;
 *     ResponseFlag_t *responseFlag;
 *     ReasonCode_t *reasonCode;
 *     ManeuverExecutionStatus_t *maneuverExecutionStatus;
 *     asn_struct_ctx_t _asn_ctx;
 * }
 * }
 */
public class ManeuverSharingAndCoordinatingMessage {

    ManeuverSharingAndCoordinatingMessage() {
        // Should not be called directly
    }

    private static final GroupLayout $LAYOUT = MemoryLayout.structLayout(
        DDateTime.layout().withName("mSCMTimestamp"),
        MessageFrame_h.C_POINTER.withName("hVPos"),
        MessageFrame_h.C_POINTER.withName("hVPosXYConf"),
        MessageFrame_h.C_LONG.withName("mSCMType"),
        OCTET_STRING.layout().withName("sourceID"),
        MessageFrame_h.C_POINTER.withName("destinationIDs"),
        MessageFrame_h.C_POINTER.withName("maneuverID"),
        MessageFrame_h.C_POINTER.withName("maneuver"),
        MessageFrame_h.C_POINTER.withName("responseFlag"),
        MessageFrame_h.C_POINTER.withName("reasonCode"),
        MessageFrame_h.C_POINTER.withName("maneuverExecutionStatus"),
        asn_struct_ctx_s.layout().withName("_asn_ctx")
    ).withName("ManeuverSharingAndCoordinatingMessage");

    /**
     * The layout of this struct
     */
    public static final GroupLayout layout() {
        return $LAYOUT;
    }

    private static final GroupLayout mSCMTimestamp$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("mSCMTimestamp"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * DDateTime_t mSCMTimestamp
     * }
     */
    public static final GroupLayout mSCMTimestamp$layout() {
        return mSCMTimestamp$LAYOUT;
    }

    private static final long mSCMTimestamp$OFFSET = 0;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * DDateTime_t mSCMTimestamp
     * }
     */
    public static final long mSCMTimestamp$offset() {
        return mSCMTimestamp$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * DDateTime_t mSCMTimestamp
     * }
     */
    public static MemorySegment mSCMTimestamp(MemorySegment struct) {
        return struct.asSlice(mSCMTimestamp$OFFSET, mSCMTimestamp$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * DDateTime_t mSCMTimestamp
     * }
     */
    public static void mSCMTimestamp(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, mSCMTimestamp$OFFSET, mSCMTimestamp$LAYOUT.byteSize());
    }

    private static final AddressLayout hVPos$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("hVPos"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct Position3D *hVPos
     * }
     */
    public static final AddressLayout hVPos$layout() {
        return hVPos$LAYOUT;
    }

    private static final long hVPos$OFFSET = 80;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct Position3D *hVPos
     * }
     */
    public static final long hVPos$offset() {
        return hVPos$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct Position3D *hVPos
     * }
     */
    public static MemorySegment hVPos(MemorySegment struct) {
        return struct.get(hVPos$LAYOUT, hVPos$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct Position3D *hVPos
     * }
     */
    public static void hVPos(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(hVPos$LAYOUT, hVPos$OFFSET, fieldValue);
    }

    private static final AddressLayout hVPosXYConf$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("hVPosXYConf"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct PositionalAccuracy *hVPosXYConf
     * }
     */
    public static final AddressLayout hVPosXYConf$layout() {
        return hVPosXYConf$LAYOUT;
    }

    private static final long hVPosXYConf$OFFSET = 88;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct PositionalAccuracy *hVPosXYConf
     * }
     */
    public static final long hVPosXYConf$offset() {
        return hVPosXYConf$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct PositionalAccuracy *hVPosXYConf
     * }
     */
    public static MemorySegment hVPosXYConf(MemorySegment struct) {
        return struct.get(hVPosXYConf$LAYOUT, hVPosXYConf$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct PositionalAccuracy *hVPosXYConf
     * }
     */
    public static void hVPosXYConf(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(hVPosXYConf$LAYOUT, hVPosXYConf$OFFSET, fieldValue);
    }

    private static final OfLong mSCMType$LAYOUT = (OfLong)$LAYOUT.select(groupElement("mSCMType"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * MSCMType_t mSCMType
     * }
     */
    public static final OfLong mSCMType$layout() {
        return mSCMType$LAYOUT;
    }

    private static final long mSCMType$OFFSET = 96;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * MSCMType_t mSCMType
     * }
     */
    public static final long mSCMType$offset() {
        return mSCMType$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * MSCMType_t mSCMType
     * }
     */
    public static long mSCMType(MemorySegment struct) {
        return struct.get(mSCMType$LAYOUT, mSCMType$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * MSCMType_t mSCMType
     * }
     */
    public static void mSCMType(MemorySegment struct, long fieldValue) {
        struct.set(mSCMType$LAYOUT, mSCMType$OFFSET, fieldValue);
    }

    private static final GroupLayout sourceID$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("sourceID"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * TemporaryID_t sourceID
     * }
     */
    public static final GroupLayout sourceID$layout() {
        return sourceID$LAYOUT;
    }

    private static final long sourceID$OFFSET = 104;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * TemporaryID_t sourceID
     * }
     */
    public static final long sourceID$offset() {
        return sourceID$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * TemporaryID_t sourceID
     * }
     */
    public static MemorySegment sourceID(MemorySegment struct) {
        return struct.asSlice(sourceID$OFFSET, sourceID$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * TemporaryID_t sourceID
     * }
     */
    public static void sourceID(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, sourceID$OFFSET, sourceID$LAYOUT.byteSize());
    }

    private static final AddressLayout destinationIDs$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("destinationIDs"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct TemporaryIDList *destinationIDs
     * }
     */
    public static final AddressLayout destinationIDs$layout() {
        return destinationIDs$LAYOUT;
    }

    private static final long destinationIDs$OFFSET = 144;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct TemporaryIDList *destinationIDs
     * }
     */
    public static final long destinationIDs$offset() {
        return destinationIDs$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct TemporaryIDList *destinationIDs
     * }
     */
    public static MemorySegment destinationIDs(MemorySegment struct) {
        return struct.get(destinationIDs$LAYOUT, destinationIDs$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct TemporaryIDList *destinationIDs
     * }
     */
    public static void destinationIDs(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(destinationIDs$LAYOUT, destinationIDs$OFFSET, fieldValue);
    }

    private static final AddressLayout maneuverID$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("maneuverID"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ManeuverSharingAndCoordinatingMessage_ManeuverID_t *maneuverID
     * }
     */
    public static final AddressLayout maneuverID$layout() {
        return maneuverID$LAYOUT;
    }

    private static final long maneuverID$OFFSET = 152;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ManeuverSharingAndCoordinatingMessage_ManeuverID_t *maneuverID
     * }
     */
    public static final long maneuverID$offset() {
        return maneuverID$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ManeuverSharingAndCoordinatingMessage_ManeuverID_t *maneuverID
     * }
     */
    public static MemorySegment maneuverID(MemorySegment struct) {
        return struct.get(maneuverID$LAYOUT, maneuverID$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ManeuverSharingAndCoordinatingMessage_ManeuverID_t *maneuverID
     * }
     */
    public static void maneuverID(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(maneuverID$LAYOUT, maneuverID$OFFSET, fieldValue);
    }

    private static final AddressLayout maneuver$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("maneuver"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * struct Maneuver *maneuver
     * }
     */
    public static final AddressLayout maneuver$layout() {
        return maneuver$LAYOUT;
    }

    private static final long maneuver$OFFSET = 160;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * struct Maneuver *maneuver
     * }
     */
    public static final long maneuver$offset() {
        return maneuver$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * struct Maneuver *maneuver
     * }
     */
    public static MemorySegment maneuver(MemorySegment struct) {
        return struct.get(maneuver$LAYOUT, maneuver$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * struct Maneuver *maneuver
     * }
     */
    public static void maneuver(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(maneuver$LAYOUT, maneuver$OFFSET, fieldValue);
    }

    private static final AddressLayout responseFlag$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("responseFlag"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ResponseFlag_t *responseFlag
     * }
     */
    public static final AddressLayout responseFlag$layout() {
        return responseFlag$LAYOUT;
    }

    private static final long responseFlag$OFFSET = 168;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ResponseFlag_t *responseFlag
     * }
     */
    public static final long responseFlag$offset() {
        return responseFlag$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ResponseFlag_t *responseFlag
     * }
     */
    public static MemorySegment responseFlag(MemorySegment struct) {
        return struct.get(responseFlag$LAYOUT, responseFlag$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ResponseFlag_t *responseFlag
     * }
     */
    public static void responseFlag(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(responseFlag$LAYOUT, responseFlag$OFFSET, fieldValue);
    }

    private static final AddressLayout reasonCode$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("reasonCode"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ReasonCode_t *reasonCode
     * }
     */
    public static final AddressLayout reasonCode$layout() {
        return reasonCode$LAYOUT;
    }

    private static final long reasonCode$OFFSET = 176;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ReasonCode_t *reasonCode
     * }
     */
    public static final long reasonCode$offset() {
        return reasonCode$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ReasonCode_t *reasonCode
     * }
     */
    public static MemorySegment reasonCode(MemorySegment struct) {
        return struct.get(reasonCode$LAYOUT, reasonCode$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ReasonCode_t *reasonCode
     * }
     */
    public static void reasonCode(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(reasonCode$LAYOUT, reasonCode$OFFSET, fieldValue);
    }

    private static final AddressLayout maneuverExecutionStatus$LAYOUT = (AddressLayout)$LAYOUT.select(groupElement("maneuverExecutionStatus"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * ManeuverExecutionStatus_t *maneuverExecutionStatus
     * }
     */
    public static final AddressLayout maneuverExecutionStatus$layout() {
        return maneuverExecutionStatus$LAYOUT;
    }

    private static final long maneuverExecutionStatus$OFFSET = 184;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * ManeuverExecutionStatus_t *maneuverExecutionStatus
     * }
     */
    public static final long maneuverExecutionStatus$offset() {
        return maneuverExecutionStatus$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * ManeuverExecutionStatus_t *maneuverExecutionStatus
     * }
     */
    public static MemorySegment maneuverExecutionStatus(MemorySegment struct) {
        return struct.get(maneuverExecutionStatus$LAYOUT, maneuverExecutionStatus$OFFSET);
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * ManeuverExecutionStatus_t *maneuverExecutionStatus
     * }
     */
    public static void maneuverExecutionStatus(MemorySegment struct, MemorySegment fieldValue) {
        struct.set(maneuverExecutionStatus$LAYOUT, maneuverExecutionStatus$OFFSET, fieldValue);
    }

    private static final GroupLayout _asn_ctx$LAYOUT = (GroupLayout)$LAYOUT.select(groupElement("_asn_ctx"));

    /**
     * Layout for field:
     * {@snippet lang=c :
     * asn_struct_ctx_t _asn_ctx
     * }
     */
    public static final GroupLayout _asn_ctx$layout() {
        return _asn_ctx$LAYOUT;
    }

    private static final long _asn_ctx$OFFSET = 192;

    /**
     * Offset for field:
     * {@snippet lang=c :
     * asn_struct_ctx_t _asn_ctx
     * }
     */
    public static final long _asn_ctx$offset() {
        return _asn_ctx$OFFSET;
    }

    /**
     * Getter for field:
     * {@snippet lang=c :
     * asn_struct_ctx_t _asn_ctx
     * }
     */
    public static MemorySegment _asn_ctx(MemorySegment struct) {
        return struct.asSlice(_asn_ctx$OFFSET, _asn_ctx$LAYOUT.byteSize());
    }

    /**
     * Setter for field:
     * {@snippet lang=c :
     * asn_struct_ctx_t _asn_ctx
     * }
     */
    public static void _asn_ctx(MemorySegment struct, MemorySegment fieldValue) {
        MemorySegment.copy(fieldValue, 0L, struct, _asn_ctx$OFFSET, _asn_ctx$LAYOUT.byteSize());
    }

    /**
     * Obtains a slice of {@code arrayParam} which selects the array element at {@code index}.
     * The returned segment has address {@code arrayParam.address() + index * layout().byteSize()}
     */
    public static MemorySegment asSlice(MemorySegment array, long index) {
        return array.asSlice(layout().byteSize() * index);
    }

    /**
     * The size (in bytes) of this struct
     */
    public static long sizeof() { return layout().byteSize(); }

    /**
     * Allocate a segment of size {@code layout().byteSize()} using {@code allocator}
     */
    public static MemorySegment allocate(SegmentAllocator allocator) {
        return allocator.allocate(layout());
    }

    /**
     * Allocate an array of size {@code elementCount} using {@code allocator}.
     * The returned segment has size {@code elementCount * layout().byteSize()}.
     */
    public static MemorySegment allocateArray(long elementCount, SegmentAllocator allocator) {
        return allocator.allocate(MemoryLayout.sequenceLayout(elementCount, layout()));
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, Arena arena, Consumer<MemorySegment> cleanup) {
        return reinterpret(addr, 1, arena, cleanup);
    }

    /**
     * Reinterprets {@code addr} using target {@code arena} and {@code cleanupAction} (if any).
     * The returned segment has size {@code elementCount * layout().byteSize()}
     */
    public static MemorySegment reinterpret(MemorySegment addr, long elementCount, Arena arena, Consumer<MemorySegment> cleanup) {
        return addr.reinterpret(layout().byteSize() * elementCount, arena, cleanup);
    }
}

