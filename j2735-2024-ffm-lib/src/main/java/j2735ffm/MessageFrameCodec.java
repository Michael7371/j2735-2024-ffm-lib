package j2735ffm;

import java.lang.foreign.Arena;
import java.lang.foreign.MemorySegment;
import java.lang.foreign.ValueLayout;
import java.nio.ByteBuffer;
import java.nio.charset.StandardCharsets;
import java.util.Arrays;
import java.util.Formatter;

import static j2735_2024_MessageFrame.MessageFrame_h.*;
import j2735_2024_MessageFrame.*;

/**
 * Functions for interconverting J2735 (2024) MessageFrames between XER, JER, and UPER encodings
 * by calling native functions generated by asn1c.
 *
 * @author Ivan Yourshaw
 */
public class MessageFrameCodec {

    /**
     * Buffer size for XER and JSON.  Messages larger than this, including whitespace, won't work.
     */
    public final long textBufferSize;

    /**
     * Buffer size for UPER binary and hex-encoded messages.  Messages larger than this won't work.
     */
    public final long uperBufferSize;

    /**
     * I'm unsure of the significance of this asn1c parameter or what an optimal value for it would be.
     * The default value is random, and seems to work.
     */
    public final long asnCodecCtxMaxStackSize;

    public MessageFrameCodec() {
        this.textBufferSize = 131072L;
        this.uperBufferSize = 8192L;
        this.asnCodecCtxMaxStackSize = 2048L;
    }

    public MessageFrameCodec(long textBufferSize, long uperBufferSize, int asnCodecCtxMaxStackSize) {
        this.textBufferSize = textBufferSize;
        this.uperBufferSize = uperBufferSize;
        this.asnCodecCtxMaxStackSize = asnCodecCtxMaxStackSize;
    }

    /**
     * Output to stdout text representing the ASN.1 object generated by the native 'asn_fprint' function.
     * @param xer An XER encoded MessageFrame
     * @return Summary and error information
     */
    public String xerAsnFprint(String xer) {
        String result;
        try (var arena = Arena.ofConfined()) {
            MemorySegment messageFrame = xerToMessageFrame(arena, xer);
            int printResult = asn_fprint(stdout(), asn_DEF_MessageFrame(), messageFrame);
            result = "Print result: " + printResult;
        }
        return result;
    }

    public byte[] xerToUper(String xer) {
        try (var arena = Arena.ofConfined()) {
            MemorySegment messageFrame = xerToMessageFrame(arena, xer);
            return messageFrameToUper(arena, messageFrame);
        }
    }

    public byte[] jerToUper(String jer) {
        try (var arena = Arena.ofConfined()) {
            MemorySegment messageFrame = jerToMessageFrame(arena, jer);
            return messageFrameToUper(arena, messageFrame);
        }
    }

    public String uperToXer(byte[] uper) {
        try (var arena = Arena.ofConfined()) {
            MemorySegment messageFrame = uperToMessageFrame(arena, uper);
            return messageFrameToXer(arena, messageFrame);
        }
    }

    public String uperToJer(byte[] uper) {
        try (var arena = Arena.ofConfined()) {
            MemorySegment messageFrame = uperToMessageFrame(arena, uper);
            return messageFrameToJer(arena, messageFrame);
        }
    }

    public String xerToJer(String xer) {
        try (var arena = Arena.ofConfined()) {
            MemorySegment messageFrame = xerToMessageFrame(arena, xer);
            return messageFrameToJer(arena, messageFrame);
        }
    }

    public String jerToXer(String jer) {
        try (var arena = Arena.ofConfined()) {
            MemorySegment messageFrame = jerToMessageFrame(arena, jer);
            return messageFrameToXer(arena, messageFrame);
        }
    }

    private MemorySegment encodedBytesToMessageFrame(Arena arena, final byte[] bytes, final int asnTransferSyntax) {
        MemorySegment heapBytes = MemorySegment.ofArray(bytes);
        MemorySegment optCodecParameters = optCodecParameters(arena);

        // The result Message Frame
        MemorySegment messageFrame = MessageFrame_t.allocate(arena);

        // Pointer to the result Message Frame
        MemorySegment structurePtr = arena.allocate(8);
        structurePtr.set(ValueLayout.JAVA_LONG, 0, messageFrame.address());

        MemorySegment buffer = arena.allocate(textBufferSize);
        buffer.copyFrom(heapBytes);
        MemorySegment er = asn_decode(arena, optCodecParameters, asnTransferSyntax, asn_DEF_MessageFrame(), structurePtr,
                buffer, textBufferSize);
        long retCode = asn_dec_rval_t.code(er);
        long consumed = asn_dec_rval_t.consumed(er);
        System.out.println("Ret code: " + retCode + ", Consumed: " + consumed);

        return messageFrame;
    }

    private MemorySegment xerToMessageFrame(Arena arena, String xer) {
        byte[] xmlBytes = xer.getBytes(StandardCharsets.UTF_8);
        return encodedBytesToMessageFrame(arena, xmlBytes, ATS_BASIC_XER());
    }

    private MemorySegment jerToMessageFrame(Arena arena, String jer) {
        byte[] jsonBytes = jer.getBytes(StandardCharsets.UTF_8);
        return encodedBytesToMessageFrame(arena, jsonBytes, ATS_JER());
    }

    private MemorySegment uperToMessageFrame(Arena arena, byte[] uper) {
        return encodedBytesToMessageFrame(arena, uper, ATS_UNALIGNED_BASIC_PER());
    }

    private byte[] messageFrameToEncodedBytes(Arena arena, MemorySegment messageFrame, final int asnTransferSyntax) {
        byte[] outputArray = new byte[(int) uperBufferSize];
        MemorySegment heapOutput = MemorySegment.ofArray(outputArray);
        MemorySegment outputBuffer = arena.allocate(uperBufferSize);
        MemorySegment optCodecParameters = optCodecParameters(arena);
        MemorySegment erEnc = asn_encode_to_buffer(arena, optCodecParameters, asnTransferSyntax,
                asn_DEF_MessageFrame(), messageFrame, outputBuffer, uperBufferSize);
        long encoded = asn_enc_rval_t.encoded(erEnc);
        if (encoded > -1) {
            System.out.printf("Encoded %s bytes%n", encoded);
            heapOutput.copyFrom(outputBuffer);
            return Arrays.copyOfRange(outputArray, 0, (int)encoded);
        } else {
            System.out.println("Error");
            throw new RuntimeException("Error encoding");
            // Check the error info
            // fprintf(stderr, ”Cannot encode %s: %s\n”, er.failed_type >name, strerror(errno))
            // Need c function to expose errno macro
        }
    }

    private byte[] messageFrameToUper(Arena arena, MemorySegment messageFrame) {
        return messageFrameToEncodedBytes(arena, messageFrame, ATS_UNALIGNED_BASIC_PER());
    }

    private String messageFrameToXer(Arena arena, MemorySegment messageFrame) {
        byte[] bytes = messageFrameToEncodedBytes(arena, messageFrame, ATS_BASIC_XER());
        return new String(bytes, StandardCharsets.UTF_8);
    }

    private String messageFrameToJer(Arena arena, MemorySegment messageFrame) {
        byte[] bytes = messageFrameToEncodedBytes(arena, messageFrame, ATS_JER());
        return new String(bytes, StandardCharsets.UTF_8);
    }

    private MemorySegment optCodecParameters(Arena arena) {
        MemorySegment optCodecParameters = asn_codec_ctx_t.allocate(arena);
        asn_codec_ctx_t.max_stack_size(optCodecParameters, asnCodecCtxMaxStackSize);
        return optCodecParameters;
    }


}
