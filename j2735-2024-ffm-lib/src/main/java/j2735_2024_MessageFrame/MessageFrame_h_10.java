// Generated by jextract

package j2735_2024_MessageFrame;

import java.lang.invoke.*;
import java.lang.foreign.*;

import static java.lang.foreign.ValueLayout.*;
import static java.lang.foreign.MemoryLayout.PathElement.*;

public class MessageFrame_h_10 extends MessageFrame_h_11 {

    MessageFrame_h_10() {
        // Should not be called directly
    }

    private static class DSecond_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSecond_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DSecond_encode_oer$descriptor() {
        return DSecond_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DSecond_encode_oer$handle() {
        return DSecond_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DSecond_encode_oer$address() {
        return DSecond_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DSecond_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DSecond_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSecond_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSecond_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSecond_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSecond_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DSecond_decode_uper$descriptor() {
        return DSecond_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSecond_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DSecond_decode_uper$handle() {
        return DSecond_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSecond_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DSecond_decode_uper$address() {
        return DSecond_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DSecond_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DSecond_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DSecond_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSecond_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSecond_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSecond_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DSecond_encode_uper$descriptor() {
        return DSecond_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DSecond_encode_uper$handle() {
        return DSecond_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DSecond_encode_uper$address() {
        return DSecond_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DSecond_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DSecond_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSecond_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSecond_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSecond_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSecond_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DSecond_decode_aper$descriptor() {
        return DSecond_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSecond_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DSecond_decode_aper$handle() {
        return DSecond_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DSecond_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DSecond_decode_aper$address() {
        return DSecond_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DSecond_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DSecond_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DSecond_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSecond_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DSecond_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DSecond_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DSecond_encode_aper$descriptor() {
        return DSecond_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DSecond_encode_aper$handle() {
        return DSecond_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DSecond_encode_aper$address() {
        return DSecond_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DSecond_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DSecond_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DSecond_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DSecond_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long Common_Latitude_t
     * }
     */
    public static final OfLong Common_Latitude_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_Common_Latitude_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_Common_Latitude_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Common_Latitude_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_Common_Latitude_constr_1$layout() {
        return asn_PER_type_Common_Latitude_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Common_Latitude_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_Common_Latitude_constr_1() {
        return asn_PER_type_Common_Latitude_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Common_Latitude_constr_1
     * }
     */
    public static void asn_PER_type_Common_Latitude_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_Common_Latitude_constr_1$constants.SEGMENT, 0L, asn_PER_type_Common_Latitude_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_Common_Latitude$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_Common_Latitude").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Common_Latitude
     * }
     */
    public static GroupLayout asn_DEF_Common_Latitude$layout() {
        return asn_DEF_Common_Latitude$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Common_Latitude
     * }
     */
    public static MemorySegment asn_DEF_Common_Latitude() {
        return asn_DEF_Common_Latitude$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Common_Latitude
     * }
     */
    public static void asn_DEF_Common_Latitude(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_Common_Latitude$constants.SEGMENT, 0L, asn_DEF_Common_Latitude$constants.LAYOUT.byteSize());
    }

    private static class Common_Latitude_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Latitude_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Common_Latitude_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor Common_Latitude_free$descriptor() {
        return Common_Latitude_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Common_Latitude_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle Common_Latitude_free$handle() {
        return Common_Latitude_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Common_Latitude_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment Common_Latitude_free$address() {
        return Common_Latitude_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Common_Latitude_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void Common_Latitude_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = Common_Latitude_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Latitude_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Latitude_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Latitude_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Common_Latitude_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_Latitude_print$descriptor() {
        return Common_Latitude_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Common_Latitude_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Common_Latitude_print$handle() {
        return Common_Latitude_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Common_Latitude_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Latitude_print$address() {
        return Common_Latitude_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Common_Latitude_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int Common_Latitude_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Common_Latitude_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Latitude_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Latitude_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Latitude_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Common_Latitude_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_Latitude_constraint$descriptor() {
        return Common_Latitude_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Common_Latitude_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle Common_Latitude_constraint$handle() {
        return Common_Latitude_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Common_Latitude_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment Common_Latitude_constraint$address() {
        return Common_Latitude_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Common_Latitude_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int Common_Latitude_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Common_Latitude_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Latitude_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Latitude_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Latitude_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Latitude_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor Common_Latitude_decode_ber$descriptor() {
        return Common_Latitude_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Latitude_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle Common_Latitude_decode_ber$handle() {
        return Common_Latitude_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Latitude_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Common_Latitude_decode_ber$address() {
        return Common_Latitude_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Latitude_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Common_Latitude_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = Common_Latitude_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Latitude_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Latitude_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Latitude_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_Latitude_encode_der$descriptor() {
        return Common_Latitude_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Common_Latitude_encode_der$handle() {
        return Common_Latitude_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Latitude_encode_der$address() {
        return Common_Latitude_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Latitude_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Common_Latitude_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Latitude_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Latitude_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Latitude_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Latitude_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Common_Latitude_decode_xer$descriptor() {
        return Common_Latitude_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Latitude_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle Common_Latitude_decode_xer$handle() {
        return Common_Latitude_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Latitude_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Common_Latitude_decode_xer$address() {
        return Common_Latitude_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Latitude_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Common_Latitude_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Common_Latitude_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Latitude_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Latitude_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Latitude_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_Latitude_encode_xer$descriptor() {
        return Common_Latitude_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Common_Latitude_encode_xer$handle() {
        return Common_Latitude_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Latitude_encode_xer$address() {
        return Common_Latitude_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Latitude_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Common_Latitude_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Latitude_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Latitude_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Latitude_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_Latitude_encode_jer$descriptor() {
        return Common_Latitude_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Common_Latitude_encode_jer$handle() {
        return Common_Latitude_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Latitude_encode_jer$address() {
        return Common_Latitude_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Latitude_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = Common_Latitude_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Latitude_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Latitude_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Latitude_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Latitude_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Common_Latitude_decode_oer$descriptor() {
        return Common_Latitude_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Latitude_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle Common_Latitude_decode_oer$handle() {
        return Common_Latitude_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Latitude_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Common_Latitude_decode_oer$address() {
        return Common_Latitude_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Latitude_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Common_Latitude_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Common_Latitude_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Latitude_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Latitude_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Latitude_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_Latitude_encode_oer$descriptor() {
        return Common_Latitude_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Common_Latitude_encode_oer$handle() {
        return Common_Latitude_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Latitude_encode_oer$address() {
        return Common_Latitude_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Latitude_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Common_Latitude_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Latitude_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Latitude_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Latitude_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Latitude_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Common_Latitude_decode_uper$descriptor() {
        return Common_Latitude_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Latitude_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Common_Latitude_decode_uper$handle() {
        return Common_Latitude_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Latitude_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Common_Latitude_decode_uper$address() {
        return Common_Latitude_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Latitude_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Common_Latitude_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Common_Latitude_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Latitude_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Latitude_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Latitude_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Common_Latitude_encode_uper$descriptor() {
        return Common_Latitude_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Common_Latitude_encode_uper$handle() {
        return Common_Latitude_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Common_Latitude_encode_uper$address() {
        return Common_Latitude_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Common_Latitude_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Common_Latitude_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Latitude_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Latitude_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Latitude_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Latitude_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Common_Latitude_decode_aper$descriptor() {
        return Common_Latitude_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Latitude_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Common_Latitude_decode_aper$handle() {
        return Common_Latitude_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Latitude_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Common_Latitude_decode_aper$address() {
        return Common_Latitude_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Latitude_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Common_Latitude_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Common_Latitude_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Latitude_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Latitude_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Latitude_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Common_Latitude_encode_aper$descriptor() {
        return Common_Latitude_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Common_Latitude_encode_aper$handle() {
        return Common_Latitude_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Common_Latitude_encode_aper$address() {
        return Common_Latitude_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Latitude_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Common_Latitude_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Common_Latitude_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Latitude_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long Common_Longitude_t
     * }
     */
    public static final OfLong Common_Longitude_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_Common_Longitude_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_Common_Longitude_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Common_Longitude_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_Common_Longitude_constr_1$layout() {
        return asn_PER_type_Common_Longitude_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Common_Longitude_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_Common_Longitude_constr_1() {
        return asn_PER_type_Common_Longitude_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Common_Longitude_constr_1
     * }
     */
    public static void asn_PER_type_Common_Longitude_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_Common_Longitude_constr_1$constants.SEGMENT, 0L, asn_PER_type_Common_Longitude_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_Common_Longitude$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_Common_Longitude").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Common_Longitude
     * }
     */
    public static GroupLayout asn_DEF_Common_Longitude$layout() {
        return asn_DEF_Common_Longitude$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Common_Longitude
     * }
     */
    public static MemorySegment asn_DEF_Common_Longitude() {
        return asn_DEF_Common_Longitude$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Common_Longitude
     * }
     */
    public static void asn_DEF_Common_Longitude(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_Common_Longitude$constants.SEGMENT, 0L, asn_DEF_Common_Longitude$constants.LAYOUT.byteSize());
    }

    private static class Common_Longitude_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Longitude_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Common_Longitude_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor Common_Longitude_free$descriptor() {
        return Common_Longitude_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Common_Longitude_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle Common_Longitude_free$handle() {
        return Common_Longitude_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Common_Longitude_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment Common_Longitude_free$address() {
        return Common_Longitude_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Common_Longitude_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void Common_Longitude_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = Common_Longitude_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Longitude_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Longitude_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Longitude_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Common_Longitude_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_Longitude_print$descriptor() {
        return Common_Longitude_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Common_Longitude_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Common_Longitude_print$handle() {
        return Common_Longitude_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Common_Longitude_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Longitude_print$address() {
        return Common_Longitude_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Common_Longitude_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int Common_Longitude_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Common_Longitude_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Longitude_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Longitude_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Longitude_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Common_Longitude_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_Longitude_constraint$descriptor() {
        return Common_Longitude_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Common_Longitude_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle Common_Longitude_constraint$handle() {
        return Common_Longitude_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Common_Longitude_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment Common_Longitude_constraint$address() {
        return Common_Longitude_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Common_Longitude_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int Common_Longitude_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Common_Longitude_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Longitude_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Longitude_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Longitude_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Longitude_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor Common_Longitude_decode_ber$descriptor() {
        return Common_Longitude_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Longitude_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle Common_Longitude_decode_ber$handle() {
        return Common_Longitude_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Longitude_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Common_Longitude_decode_ber$address() {
        return Common_Longitude_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Longitude_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Common_Longitude_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = Common_Longitude_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Longitude_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Longitude_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Longitude_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_Longitude_encode_der$descriptor() {
        return Common_Longitude_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Common_Longitude_encode_der$handle() {
        return Common_Longitude_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Longitude_encode_der$address() {
        return Common_Longitude_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Longitude_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Common_Longitude_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Longitude_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Longitude_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Longitude_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Longitude_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Common_Longitude_decode_xer$descriptor() {
        return Common_Longitude_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Longitude_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle Common_Longitude_decode_xer$handle() {
        return Common_Longitude_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Longitude_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Common_Longitude_decode_xer$address() {
        return Common_Longitude_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Longitude_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Common_Longitude_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Common_Longitude_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Longitude_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Longitude_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Longitude_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_Longitude_encode_xer$descriptor() {
        return Common_Longitude_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Common_Longitude_encode_xer$handle() {
        return Common_Longitude_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Longitude_encode_xer$address() {
        return Common_Longitude_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Longitude_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Common_Longitude_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Longitude_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Longitude_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Longitude_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_Longitude_encode_jer$descriptor() {
        return Common_Longitude_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Common_Longitude_encode_jer$handle() {
        return Common_Longitude_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Longitude_encode_jer$address() {
        return Common_Longitude_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Longitude_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = Common_Longitude_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Longitude_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Longitude_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Longitude_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Longitude_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Common_Longitude_decode_oer$descriptor() {
        return Common_Longitude_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Longitude_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle Common_Longitude_decode_oer$handle() {
        return Common_Longitude_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Longitude_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Common_Longitude_decode_oer$address() {
        return Common_Longitude_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Longitude_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Common_Longitude_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Common_Longitude_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Longitude_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Longitude_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Longitude_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_Longitude_encode_oer$descriptor() {
        return Common_Longitude_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Common_Longitude_encode_oer$handle() {
        return Common_Longitude_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Longitude_encode_oer$address() {
        return Common_Longitude_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Longitude_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Common_Longitude_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Longitude_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Longitude_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Longitude_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Longitude_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Common_Longitude_decode_uper$descriptor() {
        return Common_Longitude_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Longitude_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Common_Longitude_decode_uper$handle() {
        return Common_Longitude_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Longitude_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Common_Longitude_decode_uper$address() {
        return Common_Longitude_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Longitude_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Common_Longitude_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Common_Longitude_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Longitude_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Longitude_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Longitude_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Common_Longitude_encode_uper$descriptor() {
        return Common_Longitude_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Common_Longitude_encode_uper$handle() {
        return Common_Longitude_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Common_Longitude_encode_uper$address() {
        return Common_Longitude_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Common_Longitude_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Common_Longitude_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Longitude_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Longitude_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Longitude_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Longitude_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Common_Longitude_decode_aper$descriptor() {
        return Common_Longitude_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Longitude_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Common_Longitude_decode_aper$handle() {
        return Common_Longitude_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Longitude_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Common_Longitude_decode_aper$address() {
        return Common_Longitude_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Longitude_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Common_Longitude_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Common_Longitude_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Longitude_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Longitude_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Longitude_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Common_Longitude_encode_aper$descriptor() {
        return Common_Longitude_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Common_Longitude_encode_aper$handle() {
        return Common_Longitude_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Common_Longitude_encode_aper$address() {
        return Common_Longitude_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Longitude_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Common_Longitude_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Common_Longitude_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Longitude_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long Common_Elevation_t
     * }
     */
    public static final OfLong Common_Elevation_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_Common_Elevation_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_Common_Elevation_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Common_Elevation_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_Common_Elevation_constr_1$layout() {
        return asn_PER_type_Common_Elevation_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Common_Elevation_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_Common_Elevation_constr_1() {
        return asn_PER_type_Common_Elevation_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Common_Elevation_constr_1
     * }
     */
    public static void asn_PER_type_Common_Elevation_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_Common_Elevation_constr_1$constants.SEGMENT, 0L, asn_PER_type_Common_Elevation_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_Common_Elevation$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_Common_Elevation").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Common_Elevation
     * }
     */
    public static GroupLayout asn_DEF_Common_Elevation$layout() {
        return asn_DEF_Common_Elevation$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Common_Elevation
     * }
     */
    public static MemorySegment asn_DEF_Common_Elevation() {
        return asn_DEF_Common_Elevation$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Common_Elevation
     * }
     */
    public static void asn_DEF_Common_Elevation(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_Common_Elevation$constants.SEGMENT, 0L, asn_DEF_Common_Elevation$constants.LAYOUT.byteSize());
    }

    private static class Common_Elevation_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Elevation_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Common_Elevation_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor Common_Elevation_free$descriptor() {
        return Common_Elevation_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Common_Elevation_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle Common_Elevation_free$handle() {
        return Common_Elevation_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Common_Elevation_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment Common_Elevation_free$address() {
        return Common_Elevation_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Common_Elevation_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void Common_Elevation_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = Common_Elevation_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Elevation_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Elevation_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Elevation_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Common_Elevation_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_Elevation_print$descriptor() {
        return Common_Elevation_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Common_Elevation_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Common_Elevation_print$handle() {
        return Common_Elevation_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Common_Elevation_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Elevation_print$address() {
        return Common_Elevation_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Common_Elevation_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int Common_Elevation_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Common_Elevation_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Elevation_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Elevation_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Elevation_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Common_Elevation_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_Elevation_constraint$descriptor() {
        return Common_Elevation_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Common_Elevation_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle Common_Elevation_constraint$handle() {
        return Common_Elevation_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Common_Elevation_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment Common_Elevation_constraint$address() {
        return Common_Elevation_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Common_Elevation_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int Common_Elevation_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Common_Elevation_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Elevation_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Elevation_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Elevation_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Elevation_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor Common_Elevation_decode_ber$descriptor() {
        return Common_Elevation_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Elevation_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle Common_Elevation_decode_ber$handle() {
        return Common_Elevation_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Elevation_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Common_Elevation_decode_ber$address() {
        return Common_Elevation_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Elevation_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Common_Elevation_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = Common_Elevation_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Elevation_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Elevation_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Elevation_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_Elevation_encode_der$descriptor() {
        return Common_Elevation_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Common_Elevation_encode_der$handle() {
        return Common_Elevation_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Elevation_encode_der$address() {
        return Common_Elevation_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Elevation_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Common_Elevation_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Elevation_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Elevation_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Elevation_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Elevation_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Common_Elevation_decode_xer$descriptor() {
        return Common_Elevation_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Elevation_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle Common_Elevation_decode_xer$handle() {
        return Common_Elevation_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Elevation_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Common_Elevation_decode_xer$address() {
        return Common_Elevation_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Elevation_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Common_Elevation_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Common_Elevation_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Elevation_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Elevation_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Elevation_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_Elevation_encode_xer$descriptor() {
        return Common_Elevation_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Common_Elevation_encode_xer$handle() {
        return Common_Elevation_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Elevation_encode_xer$address() {
        return Common_Elevation_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Elevation_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Common_Elevation_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Elevation_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Elevation_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Elevation_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_Elevation_encode_jer$descriptor() {
        return Common_Elevation_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Common_Elevation_encode_jer$handle() {
        return Common_Elevation_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Elevation_encode_jer$address() {
        return Common_Elevation_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Elevation_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = Common_Elevation_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Elevation_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Elevation_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Elevation_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Elevation_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Common_Elevation_decode_oer$descriptor() {
        return Common_Elevation_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Elevation_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle Common_Elevation_decode_oer$handle() {
        return Common_Elevation_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Elevation_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Common_Elevation_decode_oer$address() {
        return Common_Elevation_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Elevation_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Common_Elevation_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Common_Elevation_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Elevation_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Elevation_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Elevation_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Common_Elevation_encode_oer$descriptor() {
        return Common_Elevation_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Common_Elevation_encode_oer$handle() {
        return Common_Elevation_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Elevation_encode_oer$address() {
        return Common_Elevation_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Common_Elevation_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Common_Elevation_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Elevation_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Elevation_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Elevation_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Elevation_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Common_Elevation_decode_uper$descriptor() {
        return Common_Elevation_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Elevation_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Common_Elevation_decode_uper$handle() {
        return Common_Elevation_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Elevation_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Common_Elevation_decode_uper$address() {
        return Common_Elevation_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Elevation_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Common_Elevation_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Common_Elevation_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Elevation_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Elevation_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Elevation_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Common_Elevation_encode_uper$descriptor() {
        return Common_Elevation_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Common_Elevation_encode_uper$handle() {
        return Common_Elevation_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Common_Elevation_encode_uper$address() {
        return Common_Elevation_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Common_Elevation_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Common_Elevation_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Elevation_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Elevation_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Elevation_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Elevation_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Common_Elevation_decode_aper$descriptor() {
        return Common_Elevation_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Elevation_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Common_Elevation_decode_aper$handle() {
        return Common_Elevation_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Elevation_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Common_Elevation_decode_aper$address() {
        return Common_Elevation_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Common_Elevation_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Common_Elevation_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Common_Elevation_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Elevation_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Common_Elevation_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Common_Elevation_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Common_Elevation_encode_aper$descriptor() {
        return Common_Elevation_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Common_Elevation_encode_aper$handle() {
        return Common_Elevation_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Common_Elevation_encode_aper$address() {
        return Common_Elevation_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Common_Elevation_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Common_Elevation_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Common_Elevation_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Common_Elevation_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long SemiMajorAxisAccuracy_t
     * }
     */
    public static final OfLong SemiMajorAxisAccuracy_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_SemiMajorAxisAccuracy_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_SemiMajorAxisAccuracy_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SemiMajorAxisAccuracy_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_SemiMajorAxisAccuracy_constr_1$layout() {
        return asn_PER_type_SemiMajorAxisAccuracy_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SemiMajorAxisAccuracy_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_SemiMajorAxisAccuracy_constr_1() {
        return asn_PER_type_SemiMajorAxisAccuracy_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SemiMajorAxisAccuracy_constr_1
     * }
     */
    public static void asn_PER_type_SemiMajorAxisAccuracy_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_SemiMajorAxisAccuracy_constr_1$constants.SEGMENT, 0L, asn_PER_type_SemiMajorAxisAccuracy_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_SemiMajorAxisAccuracy$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_SemiMajorAxisAccuracy").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SemiMajorAxisAccuracy
     * }
     */
    public static GroupLayout asn_DEF_SemiMajorAxisAccuracy$layout() {
        return asn_DEF_SemiMajorAxisAccuracy$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SemiMajorAxisAccuracy
     * }
     */
    public static MemorySegment asn_DEF_SemiMajorAxisAccuracy() {
        return asn_DEF_SemiMajorAxisAccuracy$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SemiMajorAxisAccuracy
     * }
     */
    public static void asn_DEF_SemiMajorAxisAccuracy(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_SemiMajorAxisAccuracy$constants.SEGMENT, 0L, asn_DEF_SemiMajorAxisAccuracy$constants.LAYOUT.byteSize());
    }

    private static class SemiMajorAxisAccuracy_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisAccuracy_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SemiMajorAxisAccuracy_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisAccuracy_free$descriptor() {
        return SemiMajorAxisAccuracy_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SemiMajorAxisAccuracy_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle SemiMajorAxisAccuracy_free$handle() {
        return SemiMajorAxisAccuracy_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SemiMajorAxisAccuracy_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_free$address() {
        return SemiMajorAxisAccuracy_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SemiMajorAxisAccuracy_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void SemiMajorAxisAccuracy_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = SemiMajorAxisAccuracy_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisAccuracy_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisAccuracy_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisAccuracy_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SemiMajorAxisAccuracy_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisAccuracy_print$descriptor() {
        return SemiMajorAxisAccuracy_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SemiMajorAxisAccuracy_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SemiMajorAxisAccuracy_print$handle() {
        return SemiMajorAxisAccuracy_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SemiMajorAxisAccuracy_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_print$address() {
        return SemiMajorAxisAccuracy_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SemiMajorAxisAccuracy_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int SemiMajorAxisAccuracy_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SemiMajorAxisAccuracy_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisAccuracy_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisAccuracy_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisAccuracy_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SemiMajorAxisAccuracy_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisAccuracy_constraint$descriptor() {
        return SemiMajorAxisAccuracy_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SemiMajorAxisAccuracy_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle SemiMajorAxisAccuracy_constraint$handle() {
        return SemiMajorAxisAccuracy_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SemiMajorAxisAccuracy_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_constraint$address() {
        return SemiMajorAxisAccuracy_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SemiMajorAxisAccuracy_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int SemiMajorAxisAccuracy_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SemiMajorAxisAccuracy_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisAccuracy_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisAccuracy_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisAccuracy_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisAccuracy_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisAccuracy_decode_ber$descriptor() {
        return SemiMajorAxisAccuracy_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisAccuracy_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle SemiMajorAxisAccuracy_decode_ber$handle() {
        return SemiMajorAxisAccuracy_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisAccuracy_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_decode_ber$address() {
        return SemiMajorAxisAccuracy_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisAccuracy_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = SemiMajorAxisAccuracy_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisAccuracy_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisAccuracy_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisAccuracy_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisAccuracy_encode_der$descriptor() {
        return SemiMajorAxisAccuracy_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SemiMajorAxisAccuracy_encode_der$handle() {
        return SemiMajorAxisAccuracy_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_encode_der$address() {
        return SemiMajorAxisAccuracy_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SemiMajorAxisAccuracy_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisAccuracy_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisAccuracy_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisAccuracy_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisAccuracy_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisAccuracy_decode_xer$descriptor() {
        return SemiMajorAxisAccuracy_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisAccuracy_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle SemiMajorAxisAccuracy_decode_xer$handle() {
        return SemiMajorAxisAccuracy_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisAccuracy_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_decode_xer$address() {
        return SemiMajorAxisAccuracy_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisAccuracy_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SemiMajorAxisAccuracy_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisAccuracy_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisAccuracy_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisAccuracy_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisAccuracy_encode_xer$descriptor() {
        return SemiMajorAxisAccuracy_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SemiMajorAxisAccuracy_encode_xer$handle() {
        return SemiMajorAxisAccuracy_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_encode_xer$address() {
        return SemiMajorAxisAccuracy_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SemiMajorAxisAccuracy_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisAccuracy_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisAccuracy_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisAccuracy_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisAccuracy_encode_jer$descriptor() {
        return SemiMajorAxisAccuracy_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SemiMajorAxisAccuracy_encode_jer$handle() {
        return SemiMajorAxisAccuracy_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_encode_jer$address() {
        return SemiMajorAxisAccuracy_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = SemiMajorAxisAccuracy_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisAccuracy_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisAccuracy_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisAccuracy_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisAccuracy_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisAccuracy_decode_oer$descriptor() {
        return SemiMajorAxisAccuracy_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisAccuracy_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle SemiMajorAxisAccuracy_decode_oer$handle() {
        return SemiMajorAxisAccuracy_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisAccuracy_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_decode_oer$address() {
        return SemiMajorAxisAccuracy_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisAccuracy_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SemiMajorAxisAccuracy_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisAccuracy_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisAccuracy_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisAccuracy_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisAccuracy_encode_oer$descriptor() {
        return SemiMajorAxisAccuracy_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SemiMajorAxisAccuracy_encode_oer$handle() {
        return SemiMajorAxisAccuracy_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_encode_oer$address() {
        return SemiMajorAxisAccuracy_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SemiMajorAxisAccuracy_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisAccuracy_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisAccuracy_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisAccuracy_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisAccuracy_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisAccuracy_decode_uper$descriptor() {
        return SemiMajorAxisAccuracy_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisAccuracy_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SemiMajorAxisAccuracy_decode_uper$handle() {
        return SemiMajorAxisAccuracy_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisAccuracy_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_decode_uper$address() {
        return SemiMajorAxisAccuracy_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisAccuracy_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SemiMajorAxisAccuracy_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisAccuracy_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisAccuracy_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisAccuracy_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisAccuracy_encode_uper$descriptor() {
        return SemiMajorAxisAccuracy_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SemiMajorAxisAccuracy_encode_uper$handle() {
        return SemiMajorAxisAccuracy_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_encode_uper$address() {
        return SemiMajorAxisAccuracy_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SemiMajorAxisAccuracy_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisAccuracy_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisAccuracy_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisAccuracy_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisAccuracy_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisAccuracy_decode_aper$descriptor() {
        return SemiMajorAxisAccuracy_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisAccuracy_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SemiMajorAxisAccuracy_decode_aper$handle() {
        return SemiMajorAxisAccuracy_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisAccuracy_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_decode_aper$address() {
        return SemiMajorAxisAccuracy_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisAccuracy_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SemiMajorAxisAccuracy_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisAccuracy_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisAccuracy_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisAccuracy_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisAccuracy_encode_aper$descriptor() {
        return SemiMajorAxisAccuracy_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SemiMajorAxisAccuracy_encode_aper$handle() {
        return SemiMajorAxisAccuracy_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_encode_aper$address() {
        return SemiMajorAxisAccuracy_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisAccuracy_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SemiMajorAxisAccuracy_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SemiMajorAxisAccuracy_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisAccuracy_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long SemiMinorAxisAccuracy_t
     * }
     */
    public static final OfLong SemiMinorAxisAccuracy_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_SemiMinorAxisAccuracy_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_SemiMinorAxisAccuracy_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SemiMinorAxisAccuracy_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_SemiMinorAxisAccuracy_constr_1$layout() {
        return asn_PER_type_SemiMinorAxisAccuracy_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SemiMinorAxisAccuracy_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_SemiMinorAxisAccuracy_constr_1() {
        return asn_PER_type_SemiMinorAxisAccuracy_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SemiMinorAxisAccuracy_constr_1
     * }
     */
    public static void asn_PER_type_SemiMinorAxisAccuracy_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_SemiMinorAxisAccuracy_constr_1$constants.SEGMENT, 0L, asn_PER_type_SemiMinorAxisAccuracy_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_SemiMinorAxisAccuracy$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_SemiMinorAxisAccuracy").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SemiMinorAxisAccuracy
     * }
     */
    public static GroupLayout asn_DEF_SemiMinorAxisAccuracy$layout() {
        return asn_DEF_SemiMinorAxisAccuracy$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SemiMinorAxisAccuracy
     * }
     */
    public static MemorySegment asn_DEF_SemiMinorAxisAccuracy() {
        return asn_DEF_SemiMinorAxisAccuracy$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SemiMinorAxisAccuracy
     * }
     */
    public static void asn_DEF_SemiMinorAxisAccuracy(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_SemiMinorAxisAccuracy$constants.SEGMENT, 0L, asn_DEF_SemiMinorAxisAccuracy$constants.LAYOUT.byteSize());
    }

    private static class SemiMinorAxisAccuracy_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMinorAxisAccuracy_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SemiMinorAxisAccuracy_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor SemiMinorAxisAccuracy_free$descriptor() {
        return SemiMinorAxisAccuracy_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SemiMinorAxisAccuracy_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle SemiMinorAxisAccuracy_free$handle() {
        return SemiMinorAxisAccuracy_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SemiMinorAxisAccuracy_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_free$address() {
        return SemiMinorAxisAccuracy_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SemiMinorAxisAccuracy_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void SemiMinorAxisAccuracy_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = SemiMinorAxisAccuracy_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMinorAxisAccuracy_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMinorAxisAccuracy_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMinorAxisAccuracy_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SemiMinorAxisAccuracy_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SemiMinorAxisAccuracy_print$descriptor() {
        return SemiMinorAxisAccuracy_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SemiMinorAxisAccuracy_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SemiMinorAxisAccuracy_print$handle() {
        return SemiMinorAxisAccuracy_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SemiMinorAxisAccuracy_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_print$address() {
        return SemiMinorAxisAccuracy_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SemiMinorAxisAccuracy_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int SemiMinorAxisAccuracy_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SemiMinorAxisAccuracy_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMinorAxisAccuracy_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMinorAxisAccuracy_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMinorAxisAccuracy_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SemiMinorAxisAccuracy_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor SemiMinorAxisAccuracy_constraint$descriptor() {
        return SemiMinorAxisAccuracy_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SemiMinorAxisAccuracy_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle SemiMinorAxisAccuracy_constraint$handle() {
        return SemiMinorAxisAccuracy_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SemiMinorAxisAccuracy_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_constraint$address() {
        return SemiMinorAxisAccuracy_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SemiMinorAxisAccuracy_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int SemiMinorAxisAccuracy_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SemiMinorAxisAccuracy_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMinorAxisAccuracy_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMinorAxisAccuracy_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMinorAxisAccuracy_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMinorAxisAccuracy_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor SemiMinorAxisAccuracy_decode_ber$descriptor() {
        return SemiMinorAxisAccuracy_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMinorAxisAccuracy_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle SemiMinorAxisAccuracy_decode_ber$handle() {
        return SemiMinorAxisAccuracy_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMinorAxisAccuracy_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_decode_ber$address() {
        return SemiMinorAxisAccuracy_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMinorAxisAccuracy_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = SemiMinorAxisAccuracy_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMinorAxisAccuracy_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMinorAxisAccuracy_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMinorAxisAccuracy_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SemiMinorAxisAccuracy_encode_der$descriptor() {
        return SemiMinorAxisAccuracy_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SemiMinorAxisAccuracy_encode_der$handle() {
        return SemiMinorAxisAccuracy_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_encode_der$address() {
        return SemiMinorAxisAccuracy_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SemiMinorAxisAccuracy_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMinorAxisAccuracy_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMinorAxisAccuracy_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMinorAxisAccuracy_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMinorAxisAccuracy_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SemiMinorAxisAccuracy_decode_xer$descriptor() {
        return SemiMinorAxisAccuracy_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMinorAxisAccuracy_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle SemiMinorAxisAccuracy_decode_xer$handle() {
        return SemiMinorAxisAccuracy_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMinorAxisAccuracy_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_decode_xer$address() {
        return SemiMinorAxisAccuracy_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMinorAxisAccuracy_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SemiMinorAxisAccuracy_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMinorAxisAccuracy_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMinorAxisAccuracy_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMinorAxisAccuracy_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SemiMinorAxisAccuracy_encode_xer$descriptor() {
        return SemiMinorAxisAccuracy_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SemiMinorAxisAccuracy_encode_xer$handle() {
        return SemiMinorAxisAccuracy_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_encode_xer$address() {
        return SemiMinorAxisAccuracy_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SemiMinorAxisAccuracy_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMinorAxisAccuracy_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMinorAxisAccuracy_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMinorAxisAccuracy_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SemiMinorAxisAccuracy_encode_jer$descriptor() {
        return SemiMinorAxisAccuracy_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SemiMinorAxisAccuracy_encode_jer$handle() {
        return SemiMinorAxisAccuracy_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_encode_jer$address() {
        return SemiMinorAxisAccuracy_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = SemiMinorAxisAccuracy_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMinorAxisAccuracy_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMinorAxisAccuracy_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMinorAxisAccuracy_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMinorAxisAccuracy_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SemiMinorAxisAccuracy_decode_oer$descriptor() {
        return SemiMinorAxisAccuracy_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMinorAxisAccuracy_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle SemiMinorAxisAccuracy_decode_oer$handle() {
        return SemiMinorAxisAccuracy_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMinorAxisAccuracy_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_decode_oer$address() {
        return SemiMinorAxisAccuracy_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMinorAxisAccuracy_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SemiMinorAxisAccuracy_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMinorAxisAccuracy_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMinorAxisAccuracy_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMinorAxisAccuracy_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SemiMinorAxisAccuracy_encode_oer$descriptor() {
        return SemiMinorAxisAccuracy_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SemiMinorAxisAccuracy_encode_oer$handle() {
        return SemiMinorAxisAccuracy_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_encode_oer$address() {
        return SemiMinorAxisAccuracy_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SemiMinorAxisAccuracy_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMinorAxisAccuracy_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMinorAxisAccuracy_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMinorAxisAccuracy_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMinorAxisAccuracy_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SemiMinorAxisAccuracy_decode_uper$descriptor() {
        return SemiMinorAxisAccuracy_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMinorAxisAccuracy_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SemiMinorAxisAccuracy_decode_uper$handle() {
        return SemiMinorAxisAccuracy_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMinorAxisAccuracy_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_decode_uper$address() {
        return SemiMinorAxisAccuracy_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMinorAxisAccuracy_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SemiMinorAxisAccuracy_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMinorAxisAccuracy_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMinorAxisAccuracy_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMinorAxisAccuracy_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SemiMinorAxisAccuracy_encode_uper$descriptor() {
        return SemiMinorAxisAccuracy_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SemiMinorAxisAccuracy_encode_uper$handle() {
        return SemiMinorAxisAccuracy_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_encode_uper$address() {
        return SemiMinorAxisAccuracy_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SemiMinorAxisAccuracy_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMinorAxisAccuracy_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMinorAxisAccuracy_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMinorAxisAccuracy_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMinorAxisAccuracy_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SemiMinorAxisAccuracy_decode_aper$descriptor() {
        return SemiMinorAxisAccuracy_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMinorAxisAccuracy_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SemiMinorAxisAccuracy_decode_aper$handle() {
        return SemiMinorAxisAccuracy_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMinorAxisAccuracy_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_decode_aper$address() {
        return SemiMinorAxisAccuracy_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMinorAxisAccuracy_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SemiMinorAxisAccuracy_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMinorAxisAccuracy_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMinorAxisAccuracy_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMinorAxisAccuracy_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SemiMinorAxisAccuracy_encode_aper$descriptor() {
        return SemiMinorAxisAccuracy_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SemiMinorAxisAccuracy_encode_aper$handle() {
        return SemiMinorAxisAccuracy_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_encode_aper$address() {
        return SemiMinorAxisAccuracy_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMinorAxisAccuracy_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SemiMinorAxisAccuracy_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SemiMinorAxisAccuracy_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMinorAxisAccuracy_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long SemiMajorAxisOrientation_t
     * }
     */
    public static final OfLong SemiMajorAxisOrientation_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_SemiMajorAxisOrientation_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_SemiMajorAxisOrientation_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SemiMajorAxisOrientation_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_SemiMajorAxisOrientation_constr_1$layout() {
        return asn_PER_type_SemiMajorAxisOrientation_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SemiMajorAxisOrientation_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_SemiMajorAxisOrientation_constr_1() {
        return asn_PER_type_SemiMajorAxisOrientation_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SemiMajorAxisOrientation_constr_1
     * }
     */
    public static void asn_PER_type_SemiMajorAxisOrientation_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_SemiMajorAxisOrientation_constr_1$constants.SEGMENT, 0L, asn_PER_type_SemiMajorAxisOrientation_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_SemiMajorAxisOrientation$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_SemiMajorAxisOrientation").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SemiMajorAxisOrientation
     * }
     */
    public static GroupLayout asn_DEF_SemiMajorAxisOrientation$layout() {
        return asn_DEF_SemiMajorAxisOrientation$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SemiMajorAxisOrientation
     * }
     */
    public static MemorySegment asn_DEF_SemiMajorAxisOrientation() {
        return asn_DEF_SemiMajorAxisOrientation$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SemiMajorAxisOrientation
     * }
     */
    public static void asn_DEF_SemiMajorAxisOrientation(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_SemiMajorAxisOrientation$constants.SEGMENT, 0L, asn_DEF_SemiMajorAxisOrientation$constants.LAYOUT.byteSize());
    }

    private static class SemiMajorAxisOrientation_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisOrientation_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SemiMajorAxisOrientation_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisOrientation_free$descriptor() {
        return SemiMajorAxisOrientation_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SemiMajorAxisOrientation_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle SemiMajorAxisOrientation_free$handle() {
        return SemiMajorAxisOrientation_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SemiMajorAxisOrientation_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_free$address() {
        return SemiMajorAxisOrientation_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SemiMajorAxisOrientation_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void SemiMajorAxisOrientation_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = SemiMajorAxisOrientation_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisOrientation_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisOrientation_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisOrientation_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SemiMajorAxisOrientation_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisOrientation_print$descriptor() {
        return SemiMajorAxisOrientation_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SemiMajorAxisOrientation_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SemiMajorAxisOrientation_print$handle() {
        return SemiMajorAxisOrientation_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SemiMajorAxisOrientation_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_print$address() {
        return SemiMajorAxisOrientation_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SemiMajorAxisOrientation_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int SemiMajorAxisOrientation_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SemiMajorAxisOrientation_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisOrientation_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisOrientation_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisOrientation_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SemiMajorAxisOrientation_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisOrientation_constraint$descriptor() {
        return SemiMajorAxisOrientation_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SemiMajorAxisOrientation_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle SemiMajorAxisOrientation_constraint$handle() {
        return SemiMajorAxisOrientation_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SemiMajorAxisOrientation_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_constraint$address() {
        return SemiMajorAxisOrientation_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SemiMajorAxisOrientation_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int SemiMajorAxisOrientation_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SemiMajorAxisOrientation_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisOrientation_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisOrientation_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisOrientation_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisOrientation_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisOrientation_decode_ber$descriptor() {
        return SemiMajorAxisOrientation_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisOrientation_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle SemiMajorAxisOrientation_decode_ber$handle() {
        return SemiMajorAxisOrientation_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisOrientation_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_decode_ber$address() {
        return SemiMajorAxisOrientation_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisOrientation_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = SemiMajorAxisOrientation_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisOrientation_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisOrientation_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisOrientation_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisOrientation_encode_der$descriptor() {
        return SemiMajorAxisOrientation_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SemiMajorAxisOrientation_encode_der$handle() {
        return SemiMajorAxisOrientation_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_encode_der$address() {
        return SemiMajorAxisOrientation_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SemiMajorAxisOrientation_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisOrientation_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisOrientation_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisOrientation_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisOrientation_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisOrientation_decode_xer$descriptor() {
        return SemiMajorAxisOrientation_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisOrientation_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle SemiMajorAxisOrientation_decode_xer$handle() {
        return SemiMajorAxisOrientation_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisOrientation_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_decode_xer$address() {
        return SemiMajorAxisOrientation_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisOrientation_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SemiMajorAxisOrientation_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisOrientation_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisOrientation_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisOrientation_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisOrientation_encode_xer$descriptor() {
        return SemiMajorAxisOrientation_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SemiMajorAxisOrientation_encode_xer$handle() {
        return SemiMajorAxisOrientation_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_encode_xer$address() {
        return SemiMajorAxisOrientation_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SemiMajorAxisOrientation_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisOrientation_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisOrientation_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisOrientation_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisOrientation_encode_jer$descriptor() {
        return SemiMajorAxisOrientation_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SemiMajorAxisOrientation_encode_jer$handle() {
        return SemiMajorAxisOrientation_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_encode_jer$address() {
        return SemiMajorAxisOrientation_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = SemiMajorAxisOrientation_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisOrientation_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisOrientation_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisOrientation_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisOrientation_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisOrientation_decode_oer$descriptor() {
        return SemiMajorAxisOrientation_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisOrientation_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle SemiMajorAxisOrientation_decode_oer$handle() {
        return SemiMajorAxisOrientation_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisOrientation_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_decode_oer$address() {
        return SemiMajorAxisOrientation_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisOrientation_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SemiMajorAxisOrientation_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisOrientation_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisOrientation_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisOrientation_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisOrientation_encode_oer$descriptor() {
        return SemiMajorAxisOrientation_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SemiMajorAxisOrientation_encode_oer$handle() {
        return SemiMajorAxisOrientation_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_encode_oer$address() {
        return SemiMajorAxisOrientation_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SemiMajorAxisOrientation_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisOrientation_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisOrientation_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisOrientation_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisOrientation_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisOrientation_decode_uper$descriptor() {
        return SemiMajorAxisOrientation_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisOrientation_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SemiMajorAxisOrientation_decode_uper$handle() {
        return SemiMajorAxisOrientation_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisOrientation_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_decode_uper$address() {
        return SemiMajorAxisOrientation_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisOrientation_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SemiMajorAxisOrientation_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisOrientation_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisOrientation_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisOrientation_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisOrientation_encode_uper$descriptor() {
        return SemiMajorAxisOrientation_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SemiMajorAxisOrientation_encode_uper$handle() {
        return SemiMajorAxisOrientation_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_encode_uper$address() {
        return SemiMajorAxisOrientation_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SemiMajorAxisOrientation_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisOrientation_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisOrientation_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisOrientation_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisOrientation_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisOrientation_decode_aper$descriptor() {
        return SemiMajorAxisOrientation_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisOrientation_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SemiMajorAxisOrientation_decode_aper$handle() {
        return SemiMajorAxisOrientation_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisOrientation_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_decode_aper$address() {
        return SemiMajorAxisOrientation_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SemiMajorAxisOrientation_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SemiMajorAxisOrientation_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisOrientation_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SemiMajorAxisOrientation_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SemiMajorAxisOrientation_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SemiMajorAxisOrientation_encode_aper$descriptor() {
        return SemiMajorAxisOrientation_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SemiMajorAxisOrientation_encode_aper$handle() {
        return SemiMajorAxisOrientation_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_encode_aper$address() {
        return SemiMajorAxisOrientation_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SemiMajorAxisOrientation_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SemiMajorAxisOrientation_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SemiMajorAxisOrientation_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SemiMajorAxisOrientation_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SEQUENCE_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor SEQUENCE_free$descriptor() {
        return SEQUENCE_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SEQUENCE_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle SEQUENCE_free$handle() {
        return SEQUENCE_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SEQUENCE_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment SEQUENCE_free$address() {
        return SEQUENCE_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SEQUENCE_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void SEQUENCE_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = SEQUENCE_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SEQUENCE_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SEQUENCE_print$descriptor() {
        return SEQUENCE_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SEQUENCE_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SEQUENCE_print$handle() {
        return SEQUENCE_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SEQUENCE_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SEQUENCE_print$address() {
        return SEQUENCE_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SEQUENCE_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int SEQUENCE_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SEQUENCE_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_compare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SEQUENCE_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static FunctionDescriptor SEQUENCE_compare$descriptor() {
        return SEQUENCE_compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SEQUENCE_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static MethodHandle SEQUENCE_compare$handle() {
        return SEQUENCE_compare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SEQUENCE_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static MemorySegment SEQUENCE_compare$address() {
        return SEQUENCE_compare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SEQUENCE_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static int SEQUENCE_compare(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = SEQUENCE_compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_compare", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SEQUENCE_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static FunctionDescriptor SEQUENCE_copy$descriptor() {
        return SEQUENCE_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SEQUENCE_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static MethodHandle SEQUENCE_copy$handle() {
        return SEQUENCE_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SEQUENCE_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static MemorySegment SEQUENCE_copy$address() {
        return SEQUENCE_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SEQUENCE_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static int SEQUENCE_copy(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = SEQUENCE_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_copy", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SEQUENCE_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor SEQUENCE_constraint$descriptor() {
        return SEQUENCE_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SEQUENCE_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle SEQUENCE_constraint$handle() {
        return SEQUENCE_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SEQUENCE_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment SEQUENCE_constraint$address() {
        return SEQUENCE_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SEQUENCE_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int SEQUENCE_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SEQUENCE_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor SEQUENCE_decode_ber$descriptor() {
        return SEQUENCE_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle SEQUENCE_decode_ber$handle() {
        return SEQUENCE_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SEQUENCE_decode_ber$address() {
        return SEQUENCE_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SEQUENCE_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = SEQUENCE_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SEQUENCE_encode_der$descriptor() {
        return SEQUENCE_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SEQUENCE_encode_der$handle() {
        return SEQUENCE_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SEQUENCE_encode_der$address() {
        return SEQUENCE_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SEQUENCE_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SEQUENCE_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SEQUENCE_decode_xer$descriptor() {
        return SEQUENCE_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle SEQUENCE_decode_xer$handle() {
        return SEQUENCE_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SEQUENCE_decode_xer$address() {
        return SEQUENCE_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SEQUENCE_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SEQUENCE_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SEQUENCE_encode_xer$descriptor() {
        return SEQUENCE_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SEQUENCE_encode_xer$handle() {
        return SEQUENCE_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SEQUENCE_encode_xer$address() {
        return SEQUENCE_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SEQUENCE_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SEQUENCE_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_decode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_decode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SEQUENCE_decode_jer$descriptor() {
        return SEQUENCE_decode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle SEQUENCE_decode_jer$handle() {
        return SEQUENCE_decode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SEQUENCE_decode_jer$address() {
        return SEQUENCE_decode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SEQUENCE_decode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SEQUENCE_decode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_decode_jer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SEQUENCE_encode_jer$descriptor() {
        return SEQUENCE_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SEQUENCE_encode_jer$handle() {
        return SEQUENCE_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SEQUENCE_encode_jer$address() {
        return SEQUENCE_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SEQUENCE_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = SEQUENCE_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SEQUENCE_decode_oer$descriptor() {
        return SEQUENCE_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle SEQUENCE_decode_oer$handle() {
        return SEQUENCE_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SEQUENCE_decode_oer$address() {
        return SEQUENCE_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SEQUENCE_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SEQUENCE_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SEQUENCE_encode_oer$descriptor() {
        return SEQUENCE_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SEQUENCE_encode_oer$handle() {
        return SEQUENCE_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SEQUENCE_encode_oer$address() {
        return SEQUENCE_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SEQUENCE_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SEQUENCE_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SEQUENCE_decode_uper$descriptor() {
        return SEQUENCE_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SEQUENCE_decode_uper$handle() {
        return SEQUENCE_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SEQUENCE_decode_uper$address() {
        return SEQUENCE_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SEQUENCE_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SEQUENCE_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SEQUENCE_encode_uper$descriptor() {
        return SEQUENCE_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SEQUENCE_encode_uper$handle() {
        return SEQUENCE_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SEQUENCE_encode_uper$address() {
        return SEQUENCE_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SEQUENCE_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SEQUENCE_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SEQUENCE_decode_aper$descriptor() {
        return SEQUENCE_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SEQUENCE_decode_aper$handle() {
        return SEQUENCE_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SEQUENCE_decode_aper$address() {
        return SEQUENCE_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SEQUENCE_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SEQUENCE_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SEQUENCE_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SEQUENCE_encode_aper$descriptor() {
        return SEQUENCE_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SEQUENCE_encode_aper$handle() {
        return SEQUENCE_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SEQUENCE_encode_aper$address() {
        return SEQUENCE_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SEQUENCE_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SEQUENCE_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_random_fill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_random_fill_result_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_random_fill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_random_fill_result_t SEQUENCE_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static FunctionDescriptor SEQUENCE_random_fill$descriptor() {
        return SEQUENCE_random_fill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_random_fill_result_t SEQUENCE_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static MethodHandle SEQUENCE_random_fill$handle() {
        return SEQUENCE_random_fill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_random_fill_result_t SEQUENCE_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static MemorySegment SEQUENCE_random_fill$address() {
        return SEQUENCE_random_fill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_random_fill_result_t SEQUENCE_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static MemorySegment SEQUENCE_random_fill(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = SEQUENCE_random_fill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_random_fill", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_OP_SEQUENCE$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_operation_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_OP_SEQUENCE").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_SEQUENCE
     * }
     */
    public static GroupLayout asn_OP_SEQUENCE$layout() {
        return asn_OP_SEQUENCE$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_SEQUENCE
     * }
     */
    public static MemorySegment asn_OP_SEQUENCE() {
        return asn_OP_SEQUENCE$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_SEQUENCE
     * }
     */
    public static void asn_OP_SEQUENCE(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_OP_SEQUENCE$constants.SEGMENT, 0L, asn_OP_SEQUENCE$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_PositionalAccuracy$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_PositionalAccuracy").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PositionalAccuracy
     * }
     */
    public static GroupLayout asn_DEF_PositionalAccuracy$layout() {
        return asn_DEF_PositionalAccuracy$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PositionalAccuracy
     * }
     */
    public static MemorySegment asn_DEF_PositionalAccuracy() {
        return asn_DEF_PositionalAccuracy$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PositionalAccuracy
     * }
     */
    public static void asn_DEF_PositionalAccuracy(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_PositionalAccuracy$constants.SEGMENT, 0L, asn_DEF_PositionalAccuracy$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_PositionalAccuracy_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_PositionalAccuracy_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_PositionalAccuracy_specs_1
     * }
     */
    public static GroupLayout asn_SPC_PositionalAccuracy_specs_1$layout() {
        return asn_SPC_PositionalAccuracy_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_PositionalAccuracy_specs_1
     * }
     */
    public static MemorySegment asn_SPC_PositionalAccuracy_specs_1() {
        return asn_SPC_PositionalAccuracy_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_PositionalAccuracy_specs_1
     * }
     */
    public static void asn_SPC_PositionalAccuracy_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_PositionalAccuracy_specs_1$constants.SEGMENT, 0L, asn_SPC_PositionalAccuracy_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_PositionalAccuracy_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(3, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_PositionalAccuracy_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 3 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PositionalAccuracy_1[3]
     * }
     */
    public static SequenceLayout asn_MBR_PositionalAccuracy_1$layout() {
        return asn_MBR_PositionalAccuracy_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PositionalAccuracy_1[3]
     * }
     */
    public static long[] asn_MBR_PositionalAccuracy_1$dimensions() {
        return asn_MBR_PositionalAccuracy_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PositionalAccuracy_1[3]
     * }
     */
    public static MemorySegment asn_MBR_PositionalAccuracy_1() {
        return asn_MBR_PositionalAccuracy_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PositionalAccuracy_1[3]
     * }
     */
    public static void asn_MBR_PositionalAccuracy_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_PositionalAccuracy_1$constants.SEGMENT, 0L, asn_MBR_PositionalAccuracy_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PositionalAccuracy_1[3]
     * }
     */
    public static MemorySegment asn_MBR_PositionalAccuracy_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_PositionalAccuracy_1$constants.HANDLE.invokeExact(asn_MBR_PositionalAccuracy_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PositionalAccuracy_1[3]
     * }
     */
    public static void asn_MBR_PositionalAccuracy_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_PositionalAccuracy_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_ENUMERATED$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_ENUMERATED").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ENUMERATED
     * }
     */
    public static GroupLayout asn_DEF_ENUMERATED$layout() {
        return asn_DEF_ENUMERATED$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ENUMERATED
     * }
     */
    public static MemorySegment asn_DEF_ENUMERATED() {
        return asn_DEF_ENUMERATED$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ENUMERATED
     * }
     */
    public static void asn_DEF_ENUMERATED(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_ENUMERATED$constants.SEGMENT, 0L, asn_DEF_ENUMERATED$constants.LAYOUT.byteSize());
    }

    private static class asn_OP_ENUMERATED$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_operation_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_OP_ENUMERATED").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_ENUMERATED
     * }
     */
    public static GroupLayout asn_OP_ENUMERATED$layout() {
        return asn_OP_ENUMERATED$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_ENUMERATED
     * }
     */
    public static MemorySegment asn_OP_ENUMERATED() {
        return asn_OP_ENUMERATED$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_ENUMERATED
     * }
     */
    public static void asn_OP_ENUMERATED(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_OP_ENUMERATED$constants.SEGMENT, 0L, asn_OP_ENUMERATED$constants.LAYOUT.byteSize());
    }

    private static class ENUMERATED_decode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ENUMERATED_decode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ENUMERATED_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor ENUMERATED_decode_jer$descriptor() {
        return ENUMERATED_decode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ENUMERATED_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle ENUMERATED_decode_jer$handle() {
        return ENUMERATED_decode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ENUMERATED_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ENUMERATED_decode_jer$address() {
        return ENUMERATED_decode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ENUMERATED_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ENUMERATED_decode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = ENUMERATED_decode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ENUMERATED_decode_jer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ENUMERATED_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ENUMERATED_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ENUMERATED_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor ENUMERATED_decode_oer$descriptor() {
        return ENUMERATED_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ENUMERATED_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle ENUMERATED_decode_oer$handle() {
        return ENUMERATED_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ENUMERATED_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ENUMERATED_decode_oer$address() {
        return ENUMERATED_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ENUMERATED_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ENUMERATED_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = ENUMERATED_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ENUMERATED_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ENUMERATED_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ENUMERATED_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ENUMERATED_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ENUMERATED_encode_oer$descriptor() {
        return ENUMERATED_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ENUMERATED_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ENUMERATED_encode_oer$handle() {
        return ENUMERATED_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ENUMERATED_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ENUMERATED_encode_oer$address() {
        return ENUMERATED_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ENUMERATED_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ENUMERATED_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ENUMERATED_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ENUMERATED_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ENUMERATED_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ENUMERATED_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ENUMERATED_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor ENUMERATED_decode_uper$descriptor() {
        return ENUMERATED_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ENUMERATED_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle ENUMERATED_decode_uper$handle() {
        return ENUMERATED_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ENUMERATED_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ENUMERATED_decode_uper$address() {
        return ENUMERATED_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ENUMERATED_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ENUMERATED_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ENUMERATED_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ENUMERATED_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ENUMERATED_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ENUMERATED_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ENUMERATED_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor ENUMERATED_encode_uper$descriptor() {
        return ENUMERATED_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ENUMERATED_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle ENUMERATED_encode_uper$handle() {
        return ENUMERATED_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ENUMERATED_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ENUMERATED_encode_uper$address() {
        return ENUMERATED_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ENUMERATED_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ENUMERATED_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ENUMERATED_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ENUMERATED_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ENUMERATED_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ENUMERATED_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ENUMERATED_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor ENUMERATED_decode_aper$descriptor() {
        return ENUMERATED_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ENUMERATED_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle ENUMERATED_decode_aper$handle() {
        return ENUMERATED_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ENUMERATED_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ENUMERATED_decode_aper$address() {
        return ENUMERATED_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ENUMERATED_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ENUMERATED_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ENUMERATED_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ENUMERATED_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ENUMERATED_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ENUMERATED_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ENUMERATED_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor ENUMERATED_encode_aper$descriptor() {
        return ENUMERATED_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ENUMERATED_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle ENUMERATED_encode_aper$handle() {
        return ENUMERATED_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ENUMERATED_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ENUMERATED_encode_aper$address() {
        return ENUMERATED_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ENUMERATED_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ENUMERATED_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ENUMERATED_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ENUMERATED_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_NativeEnumerated$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_NativeEnumerated").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NativeEnumerated
     * }
     */
    public static GroupLayout asn_DEF_NativeEnumerated$layout() {
        return asn_DEF_NativeEnumerated$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NativeEnumerated
     * }
     */
    public static MemorySegment asn_DEF_NativeEnumerated() {
        return asn_DEF_NativeEnumerated$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_NativeEnumerated
     * }
     */
    public static void asn_DEF_NativeEnumerated(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_NativeEnumerated$constants.SEGMENT, 0L, asn_DEF_NativeEnumerated$constants.LAYOUT.byteSize());
    }

    private static class asn_OP_NativeEnumerated$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_operation_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_OP_NativeEnumerated").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_NativeEnumerated
     * }
     */
    public static GroupLayout asn_OP_NativeEnumerated$layout() {
        return asn_OP_NativeEnumerated$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_NativeEnumerated
     * }
     */
    public static MemorySegment asn_OP_NativeEnumerated() {
        return asn_OP_NativeEnumerated$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_NativeEnumerated
     * }
     */
    public static void asn_OP_NativeEnumerated(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_OP_NativeEnumerated$constants.SEGMENT, 0L, asn_OP_NativeEnumerated$constants.LAYOUT.byteSize());
    }

    private static class NativeEnumerated_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeEnumerated_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeEnumerated_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NativeEnumerated_encode_xer$descriptor() {
        return NativeEnumerated_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeEnumerated_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NativeEnumerated_encode_xer$handle() {
        return NativeEnumerated_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeEnumerated_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NativeEnumerated_encode_xer$address() {
        return NativeEnumerated_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NativeEnumerated_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NativeEnumerated_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = NativeEnumerated_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeEnumerated_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeEnumerated_decode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeEnumerated_decode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeEnumerated_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor NativeEnumerated_decode_jer$descriptor() {
        return NativeEnumerated_decode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeEnumerated_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle NativeEnumerated_decode_jer$handle() {
        return NativeEnumerated_decode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeEnumerated_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment NativeEnumerated_decode_jer$address() {
        return NativeEnumerated_decode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NativeEnumerated_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment NativeEnumerated_decode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = NativeEnumerated_decode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeEnumerated_decode_jer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeEnumerated_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeEnumerated_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeEnumerated_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NativeEnumerated_encode_jer$descriptor() {
        return NativeEnumerated_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeEnumerated_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NativeEnumerated_encode_jer$handle() {
        return NativeEnumerated_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeEnumerated_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NativeEnumerated_encode_jer$address() {
        return NativeEnumerated_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NativeEnumerated_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NativeEnumerated_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = NativeEnumerated_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeEnumerated_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeEnumerated_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeEnumerated_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeEnumerated_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor NativeEnumerated_decode_oer$descriptor() {
        return NativeEnumerated_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeEnumerated_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle NativeEnumerated_decode_oer$handle() {
        return NativeEnumerated_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeEnumerated_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment NativeEnumerated_decode_oer$address() {
        return NativeEnumerated_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NativeEnumerated_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment NativeEnumerated_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = NativeEnumerated_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeEnumerated_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeEnumerated_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeEnumerated_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeEnumerated_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor NativeEnumerated_encode_oer$descriptor() {
        return NativeEnumerated_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeEnumerated_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle NativeEnumerated_encode_oer$handle() {
        return NativeEnumerated_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeEnumerated_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NativeEnumerated_encode_oer$address() {
        return NativeEnumerated_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NativeEnumerated_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment NativeEnumerated_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NativeEnumerated_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeEnumerated_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeEnumerated_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeEnumerated_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeEnumerated_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor NativeEnumerated_decode_uper$descriptor() {
        return NativeEnumerated_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeEnumerated_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle NativeEnumerated_decode_uper$handle() {
        return NativeEnumerated_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeEnumerated_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NativeEnumerated_decode_uper$address() {
        return NativeEnumerated_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NativeEnumerated_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NativeEnumerated_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NativeEnumerated_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeEnumerated_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeEnumerated_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeEnumerated_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeEnumerated_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor NativeEnumerated_encode_uper$descriptor() {
        return NativeEnumerated_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeEnumerated_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle NativeEnumerated_encode_uper$handle() {
        return NativeEnumerated_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeEnumerated_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NativeEnumerated_encode_uper$address() {
        return NativeEnumerated_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NativeEnumerated_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NativeEnumerated_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = NativeEnumerated_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeEnumerated_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeEnumerated_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeEnumerated_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeEnumerated_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor NativeEnumerated_decode_aper$descriptor() {
        return NativeEnumerated_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeEnumerated_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle NativeEnumerated_decode_aper$handle() {
        return NativeEnumerated_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t NativeEnumerated_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NativeEnumerated_decode_aper$address() {
        return NativeEnumerated_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t NativeEnumerated_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment NativeEnumerated_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = NativeEnumerated_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeEnumerated_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeEnumerated_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeEnumerated_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeEnumerated_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor NativeEnumerated_encode_aper$descriptor() {
        return NativeEnumerated_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeEnumerated_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle NativeEnumerated_encode_aper$handle() {
        return NativeEnumerated_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t NativeEnumerated_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NativeEnumerated_encode_aper$address() {
        return NativeEnumerated_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t NativeEnumerated_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment NativeEnumerated_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = NativeEnumerated_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeEnumerated_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class NativeEnumerated__compar_value2enum {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("NativeEnumerated__compar_value2enum");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int NativeEnumerated__compar_value2enum(const void *ap, const void *bp)
     * }
     */
    public static FunctionDescriptor NativeEnumerated__compar_value2enum$descriptor() {
        return NativeEnumerated__compar_value2enum.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int NativeEnumerated__compar_value2enum(const void *ap, const void *bp)
     * }
     */
    public static MethodHandle NativeEnumerated__compar_value2enum$handle() {
        return NativeEnumerated__compar_value2enum.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int NativeEnumerated__compar_value2enum(const void *ap, const void *bp)
     * }
     */
    public static MemorySegment NativeEnumerated__compar_value2enum$address() {
        return NativeEnumerated__compar_value2enum.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int NativeEnumerated__compar_value2enum(const void *ap, const void *bp)
     * }
     */
    public static int NativeEnumerated__compar_value2enum(MemorySegment ap, MemorySegment bp) {
        var mh$ = NativeEnumerated__compar_value2enum.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("NativeEnumerated__compar_value2enum", ap, bp);
            }
            return (int)mh$.invokeExact(ap, bp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int TransmissionState_neutral = (int)0L;
    /**
     * {@snippet lang=c :
     * enum TransmissionState.TransmissionState_neutral = 0
     * }
     */
    public static int TransmissionState_neutral() {
        return TransmissionState_neutral;
    }
    private static final int TransmissionState_park = (int)1L;
    /**
     * {@snippet lang=c :
     * enum TransmissionState.TransmissionState_park = 1
     * }
     */
    public static int TransmissionState_park() {
        return TransmissionState_park;
    }
    private static final int TransmissionState_forwardGears = (int)2L;
    /**
     * {@snippet lang=c :
     * enum TransmissionState.TransmissionState_forwardGears = 2
     * }
     */
    public static int TransmissionState_forwardGears() {
        return TransmissionState_forwardGears;
    }
    private static final int TransmissionState_reverseGears = (int)3L;
    /**
     * {@snippet lang=c :
     * enum TransmissionState.TransmissionState_reverseGears = 3
     * }
     */
    public static int TransmissionState_reverseGears() {
        return TransmissionState_reverseGears;
    }
    private static final int TransmissionState_reserved1 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum TransmissionState.TransmissionState_reserved1 = 4
     * }
     */
    public static int TransmissionState_reserved1() {
        return TransmissionState_reserved1;
    }
    private static final int TransmissionState_reserved2 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum TransmissionState.TransmissionState_reserved2 = 5
     * }
     */
    public static int TransmissionState_reserved2() {
        return TransmissionState_reserved2;
    }
    private static final int TransmissionState_reserved3 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum TransmissionState.TransmissionState_reserved3 = 6
     * }
     */
    public static int TransmissionState_reserved3() {
        return TransmissionState_reserved3;
    }
    private static final int TransmissionState_unavailable = (int)7L;
    /**
     * {@snippet lang=c :
     * enum TransmissionState.TransmissionState_unavailable = 7
     * }
     */
    public static int TransmissionState_unavailable() {
        return TransmissionState_unavailable;
    }
    /**
     * {@snippet lang=c :
     * typedef long TransmissionState_t
     * }
     */
    public static final OfLong TransmissionState_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_TransmissionState_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_TransmissionState_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TransmissionState_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_TransmissionState_constr_1$layout() {
        return asn_PER_type_TransmissionState_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TransmissionState_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_TransmissionState_constr_1() {
        return asn_PER_type_TransmissionState_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TransmissionState_constr_1
     * }
     */
    public static void asn_PER_type_TransmissionState_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_TransmissionState_constr_1$constants.SEGMENT, 0L, asn_PER_type_TransmissionState_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_TransmissionState$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_TransmissionState").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TransmissionState
     * }
     */
    public static GroupLayout asn_DEF_TransmissionState$layout() {
        return asn_DEF_TransmissionState$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TransmissionState
     * }
     */
    public static MemorySegment asn_DEF_TransmissionState() {
        return asn_DEF_TransmissionState$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TransmissionState
     * }
     */
    public static void asn_DEF_TransmissionState(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_TransmissionState$constants.SEGMENT, 0L, asn_DEF_TransmissionState$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_TransmissionState_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_TransmissionState_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_TransmissionState_specs_1
     * }
     */
    public static GroupLayout asn_SPC_TransmissionState_specs_1$layout() {
        return asn_SPC_TransmissionState_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_TransmissionState_specs_1
     * }
     */
    public static MemorySegment asn_SPC_TransmissionState_specs_1() {
        return asn_SPC_TransmissionState_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_TransmissionState_specs_1
     * }
     */
    public static void asn_SPC_TransmissionState_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_TransmissionState_specs_1$constants.SEGMENT, 0L, asn_SPC_TransmissionState_specs_1$constants.LAYOUT.byteSize());
    }

    private static class TransmissionState_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TransmissionState_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void TransmissionState_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor TransmissionState_free$descriptor() {
        return TransmissionState_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void TransmissionState_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle TransmissionState_free$handle() {
        return TransmissionState_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void TransmissionState_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment TransmissionState_free$address() {
        return TransmissionState_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void TransmissionState_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void TransmissionState_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = TransmissionState_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransmissionState_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransmissionState_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TransmissionState_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TransmissionState_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TransmissionState_print$descriptor() {
        return TransmissionState_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TransmissionState_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TransmissionState_print$handle() {
        return TransmissionState_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TransmissionState_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TransmissionState_print$address() {
        return TransmissionState_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TransmissionState_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int TransmissionState_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TransmissionState_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransmissionState_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransmissionState_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TransmissionState_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TransmissionState_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor TransmissionState_constraint$descriptor() {
        return TransmissionState_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TransmissionState_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle TransmissionState_constraint$handle() {
        return TransmissionState_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TransmissionState_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment TransmissionState_constraint$address() {
        return TransmissionState_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TransmissionState_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int TransmissionState_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TransmissionState_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransmissionState_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransmissionState_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TransmissionState_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TransmissionState_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor TransmissionState_decode_ber$descriptor() {
        return TransmissionState_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TransmissionState_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle TransmissionState_decode_ber$handle() {
        return TransmissionState_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TransmissionState_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment TransmissionState_decode_ber$address() {
        return TransmissionState_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TransmissionState_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment TransmissionState_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = TransmissionState_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransmissionState_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransmissionState_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TransmissionState_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TransmissionState_encode_der$descriptor() {
        return TransmissionState_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TransmissionState_encode_der$handle() {
        return TransmissionState_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TransmissionState_encode_der$address() {
        return TransmissionState_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TransmissionState_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = TransmissionState_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransmissionState_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransmissionState_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TransmissionState_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TransmissionState_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor TransmissionState_decode_xer$descriptor() {
        return TransmissionState_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TransmissionState_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle TransmissionState_decode_xer$handle() {
        return TransmissionState_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TransmissionState_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment TransmissionState_decode_xer$address() {
        return TransmissionState_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TransmissionState_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment TransmissionState_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = TransmissionState_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransmissionState_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransmissionState_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TransmissionState_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TransmissionState_encode_xer$descriptor() {
        return TransmissionState_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TransmissionState_encode_xer$handle() {
        return TransmissionState_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TransmissionState_encode_xer$address() {
        return TransmissionState_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TransmissionState_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = TransmissionState_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransmissionState_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransmissionState_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TransmissionState_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TransmissionState_encode_jer$descriptor() {
        return TransmissionState_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TransmissionState_encode_jer$handle() {
        return TransmissionState_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TransmissionState_encode_jer$address() {
        return TransmissionState_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TransmissionState_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = TransmissionState_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransmissionState_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransmissionState_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TransmissionState_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TransmissionState_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor TransmissionState_decode_oer$descriptor() {
        return TransmissionState_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TransmissionState_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle TransmissionState_decode_oer$handle() {
        return TransmissionState_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TransmissionState_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment TransmissionState_decode_oer$address() {
        return TransmissionState_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TransmissionState_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment TransmissionState_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = TransmissionState_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransmissionState_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransmissionState_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TransmissionState_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TransmissionState_encode_oer$descriptor() {
        return TransmissionState_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TransmissionState_encode_oer$handle() {
        return TransmissionState_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TransmissionState_encode_oer$address() {
        return TransmissionState_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TransmissionState_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TransmissionState_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransmissionState_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransmissionState_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TransmissionState_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TransmissionState_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor TransmissionState_decode_uper$descriptor() {
        return TransmissionState_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TransmissionState_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle TransmissionState_decode_uper$handle() {
        return TransmissionState_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TransmissionState_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TransmissionState_decode_uper$address() {
        return TransmissionState_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TransmissionState_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TransmissionState_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TransmissionState_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransmissionState_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransmissionState_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TransmissionState_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor TransmissionState_encode_uper$descriptor() {
        return TransmissionState_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle TransmissionState_encode_uper$handle() {
        return TransmissionState_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TransmissionState_encode_uper$address() {
        return TransmissionState_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TransmissionState_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TransmissionState_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransmissionState_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransmissionState_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TransmissionState_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TransmissionState_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor TransmissionState_decode_aper$descriptor() {
        return TransmissionState_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TransmissionState_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle TransmissionState_decode_aper$handle() {
        return TransmissionState_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TransmissionState_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TransmissionState_decode_aper$address() {
        return TransmissionState_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TransmissionState_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TransmissionState_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TransmissionState_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransmissionState_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TransmissionState_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TransmissionState_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor TransmissionState_encode_aper$descriptor() {
        return TransmissionState_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle TransmissionState_encode_aper$handle() {
        return TransmissionState_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TransmissionState_encode_aper$address() {
        return TransmissionState_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TransmissionState_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TransmissionState_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TransmissionState_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TransmissionState_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long Speed_t
     * }
     */
    public static final OfLong Speed_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_Speed_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_Speed_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Speed_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_Speed_constr_1$layout() {
        return asn_PER_type_Speed_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Speed_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_Speed_constr_1() {
        return asn_PER_type_Speed_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Speed_constr_1
     * }
     */
    public static void asn_PER_type_Speed_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_Speed_constr_1$constants.SEGMENT, 0L, asn_PER_type_Speed_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_Speed$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_Speed").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Speed
     * }
     */
    public static GroupLayout asn_DEF_Speed$layout() {
        return asn_DEF_Speed$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Speed
     * }
     */
    public static MemorySegment asn_DEF_Speed() {
        return asn_DEF_Speed$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Speed
     * }
     */
    public static void asn_DEF_Speed(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_Speed$constants.SEGMENT, 0L, asn_DEF_Speed$constants.LAYOUT.byteSize());
    }

    private static class Speed_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Speed_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Speed_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor Speed_free$descriptor() {
        return Speed_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Speed_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle Speed_free$handle() {
        return Speed_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Speed_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment Speed_free$address() {
        return Speed_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Speed_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void Speed_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = Speed_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Speed_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Speed_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Speed_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Speed_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Speed_print$descriptor() {
        return Speed_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Speed_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Speed_print$handle() {
        return Speed_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Speed_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Speed_print$address() {
        return Speed_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Speed_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int Speed_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Speed_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Speed_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Speed_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Speed_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Speed_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor Speed_constraint$descriptor() {
        return Speed_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Speed_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle Speed_constraint$handle() {
        return Speed_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Speed_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment Speed_constraint$address() {
        return Speed_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Speed_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int Speed_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Speed_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Speed_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Speed_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Speed_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Speed_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor Speed_decode_ber$descriptor() {
        return Speed_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Speed_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle Speed_decode_ber$handle() {
        return Speed_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Speed_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Speed_decode_ber$address() {
        return Speed_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Speed_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Speed_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = Speed_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Speed_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Speed_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Speed_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Speed_encode_der$descriptor() {
        return Speed_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Speed_encode_der$handle() {
        return Speed_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Speed_encode_der$address() {
        return Speed_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Speed_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Speed_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Speed_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Speed_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Speed_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Speed_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Speed_decode_xer$descriptor() {
        return Speed_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Speed_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle Speed_decode_xer$handle() {
        return Speed_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Speed_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Speed_decode_xer$address() {
        return Speed_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Speed_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Speed_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Speed_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Speed_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Speed_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Speed_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Speed_encode_xer$descriptor() {
        return Speed_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Speed_encode_xer$handle() {
        return Speed_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Speed_encode_xer$address() {
        return Speed_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Speed_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Speed_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Speed_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Speed_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Speed_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Speed_encode_jer$descriptor() {
        return Speed_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Speed_encode_jer$handle() {
        return Speed_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Speed_encode_jer$address() {
        return Speed_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Speed_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = Speed_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Speed_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Speed_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Speed_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Speed_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Speed_decode_oer$descriptor() {
        return Speed_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Speed_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle Speed_decode_oer$handle() {
        return Speed_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Speed_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Speed_decode_oer$address() {
        return Speed_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Speed_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Speed_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Speed_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Speed_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Speed_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Speed_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Speed_encode_oer$descriptor() {
        return Speed_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Speed_encode_oer$handle() {
        return Speed_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Speed_encode_oer$address() {
        return Speed_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Speed_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Speed_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Speed_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Speed_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Speed_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Speed_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Speed_decode_uper$descriptor() {
        return Speed_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Speed_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Speed_decode_uper$handle() {
        return Speed_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Speed_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Speed_decode_uper$address() {
        return Speed_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Speed_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Speed_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Speed_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Speed_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Speed_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Speed_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Speed_encode_uper$descriptor() {
        return Speed_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Speed_encode_uper$handle() {
        return Speed_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Speed_encode_uper$address() {
        return Speed_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Speed_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Speed_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Speed_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Speed_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Speed_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Speed_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Speed_decode_aper$descriptor() {
        return Speed_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Speed_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Speed_decode_aper$handle() {
        return Speed_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Speed_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Speed_decode_aper$address() {
        return Speed_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Speed_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Speed_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Speed_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Speed_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Speed_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Speed_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Speed_encode_aper$descriptor() {
        return Speed_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Speed_encode_aper$handle() {
        return Speed_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Speed_encode_aper$address() {
        return Speed_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Speed_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Speed_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Speed_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Speed_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long Heading_t
     * }
     */
    public static final OfLong Heading_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_Heading_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_Heading_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Heading_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_Heading_constr_1$layout() {
        return asn_PER_type_Heading_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Heading_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_Heading_constr_1() {
        return asn_PER_type_Heading_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Heading_constr_1
     * }
     */
    public static void asn_PER_type_Heading_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_Heading_constr_1$constants.SEGMENT, 0L, asn_PER_type_Heading_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_Heading$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_Heading").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Heading
     * }
     */
    public static GroupLayout asn_DEF_Heading$layout() {
        return asn_DEF_Heading$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Heading
     * }
     */
    public static MemorySegment asn_DEF_Heading() {
        return asn_DEF_Heading$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Heading
     * }
     */
    public static void asn_DEF_Heading(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_Heading$constants.SEGMENT, 0L, asn_DEF_Heading$constants.LAYOUT.byteSize());
    }

    private static class Heading_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Heading_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Heading_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor Heading_free$descriptor() {
        return Heading_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Heading_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle Heading_free$handle() {
        return Heading_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Heading_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment Heading_free$address() {
        return Heading_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Heading_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void Heading_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = Heading_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Heading_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Heading_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Heading_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Heading_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Heading_print$descriptor() {
        return Heading_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Heading_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Heading_print$handle() {
        return Heading_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Heading_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Heading_print$address() {
        return Heading_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Heading_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int Heading_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Heading_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Heading_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Heading_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Heading_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Heading_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor Heading_constraint$descriptor() {
        return Heading_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Heading_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle Heading_constraint$handle() {
        return Heading_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Heading_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment Heading_constraint$address() {
        return Heading_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Heading_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int Heading_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Heading_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Heading_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Heading_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Heading_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Heading_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor Heading_decode_ber$descriptor() {
        return Heading_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Heading_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle Heading_decode_ber$handle() {
        return Heading_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Heading_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Heading_decode_ber$address() {
        return Heading_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Heading_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Heading_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = Heading_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Heading_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Heading_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Heading_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Heading_encode_der$descriptor() {
        return Heading_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Heading_encode_der$handle() {
        return Heading_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Heading_encode_der$address() {
        return Heading_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Heading_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Heading_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Heading_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Heading_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Heading_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Heading_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Heading_decode_xer$descriptor() {
        return Heading_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Heading_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle Heading_decode_xer$handle() {
        return Heading_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Heading_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Heading_decode_xer$address() {
        return Heading_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Heading_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Heading_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Heading_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Heading_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Heading_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Heading_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Heading_encode_xer$descriptor() {
        return Heading_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Heading_encode_xer$handle() {
        return Heading_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Heading_encode_xer$address() {
        return Heading_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Heading_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Heading_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Heading_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Heading_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Heading_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Heading_encode_jer$descriptor() {
        return Heading_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Heading_encode_jer$handle() {
        return Heading_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Heading_encode_jer$address() {
        return Heading_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Heading_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = Heading_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Heading_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Heading_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Heading_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Heading_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Heading_decode_oer$descriptor() {
        return Heading_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Heading_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle Heading_decode_oer$handle() {
        return Heading_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Heading_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Heading_decode_oer$address() {
        return Heading_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Heading_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Heading_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Heading_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Heading_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Heading_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Heading_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Heading_encode_oer$descriptor() {
        return Heading_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Heading_encode_oer$handle() {
        return Heading_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Heading_encode_oer$address() {
        return Heading_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Heading_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Heading_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Heading_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Heading_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Heading_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Heading_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Heading_decode_uper$descriptor() {
        return Heading_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Heading_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Heading_decode_uper$handle() {
        return Heading_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Heading_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Heading_decode_uper$address() {
        return Heading_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Heading_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Heading_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Heading_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Heading_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Heading_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Heading_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Heading_encode_uper$descriptor() {
        return Heading_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Heading_encode_uper$handle() {
        return Heading_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Heading_encode_uper$address() {
        return Heading_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Heading_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Heading_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Heading_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Heading_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Heading_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Heading_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Heading_decode_aper$descriptor() {
        return Heading_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Heading_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Heading_decode_aper$handle() {
        return Heading_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Heading_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Heading_decode_aper$address() {
        return Heading_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Heading_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Heading_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Heading_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Heading_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Heading_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Heading_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Heading_encode_aper$descriptor() {
        return Heading_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Heading_encode_aper$handle() {
        return Heading_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Heading_encode_aper$address() {
        return Heading_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Heading_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Heading_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Heading_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Heading_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long SteeringWheelAngle_t
     * }
     */
    public static final OfLong SteeringWheelAngle_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_SteeringWheelAngle_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_SteeringWheelAngle_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SteeringWheelAngle_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_SteeringWheelAngle_constr_1$layout() {
        return asn_PER_type_SteeringWheelAngle_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SteeringWheelAngle_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_SteeringWheelAngle_constr_1() {
        return asn_PER_type_SteeringWheelAngle_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SteeringWheelAngle_constr_1
     * }
     */
    public static void asn_PER_type_SteeringWheelAngle_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_SteeringWheelAngle_constr_1$constants.SEGMENT, 0L, asn_PER_type_SteeringWheelAngle_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_SteeringWheelAngle$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_SteeringWheelAngle").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SteeringWheelAngle
     * }
     */
    public static GroupLayout asn_DEF_SteeringWheelAngle$layout() {
        return asn_DEF_SteeringWheelAngle$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SteeringWheelAngle
     * }
     */
    public static MemorySegment asn_DEF_SteeringWheelAngle() {
        return asn_DEF_SteeringWheelAngle$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SteeringWheelAngle
     * }
     */
    public static void asn_DEF_SteeringWheelAngle(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_SteeringWheelAngle$constants.SEGMENT, 0L, asn_DEF_SteeringWheelAngle$constants.LAYOUT.byteSize());
    }

    private static class SteeringWheelAngle_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngle_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SteeringWheelAngle_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngle_free$descriptor() {
        return SteeringWheelAngle_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SteeringWheelAngle_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle SteeringWheelAngle_free$handle() {
        return SteeringWheelAngle_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SteeringWheelAngle_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment SteeringWheelAngle_free$address() {
        return SteeringWheelAngle_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SteeringWheelAngle_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void SteeringWheelAngle_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = SteeringWheelAngle_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngle_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngle_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngle_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SteeringWheelAngle_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngle_print$descriptor() {
        return SteeringWheelAngle_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SteeringWheelAngle_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringWheelAngle_print$handle() {
        return SteeringWheelAngle_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SteeringWheelAngle_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngle_print$address() {
        return SteeringWheelAngle_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SteeringWheelAngle_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int SteeringWheelAngle_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SteeringWheelAngle_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngle_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngle_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngle_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SteeringWheelAngle_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngle_constraint$descriptor() {
        return SteeringWheelAngle_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SteeringWheelAngle_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle SteeringWheelAngle_constraint$handle() {
        return SteeringWheelAngle_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SteeringWheelAngle_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngle_constraint$address() {
        return SteeringWheelAngle_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SteeringWheelAngle_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int SteeringWheelAngle_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SteeringWheelAngle_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngle_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngle_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngle_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngle_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngle_decode_ber$descriptor() {
        return SteeringWheelAngle_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngle_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle SteeringWheelAngle_decode_ber$handle() {
        return SteeringWheelAngle_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngle_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SteeringWheelAngle_decode_ber$address() {
        return SteeringWheelAngle_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngle_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SteeringWheelAngle_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = SteeringWheelAngle_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngle_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngle_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngle_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngle_encode_der$descriptor() {
        return SteeringWheelAngle_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringWheelAngle_encode_der$handle() {
        return SteeringWheelAngle_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngle_encode_der$address() {
        return SteeringWheelAngle_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngle_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SteeringWheelAngle_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngle_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngle_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngle_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngle_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngle_decode_xer$descriptor() {
        return SteeringWheelAngle_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngle_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle SteeringWheelAngle_decode_xer$handle() {
        return SteeringWheelAngle_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngle_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SteeringWheelAngle_decode_xer$address() {
        return SteeringWheelAngle_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngle_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SteeringWheelAngle_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SteeringWheelAngle_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngle_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngle_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngle_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngle_encode_xer$descriptor() {
        return SteeringWheelAngle_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringWheelAngle_encode_xer$handle() {
        return SteeringWheelAngle_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngle_encode_xer$address() {
        return SteeringWheelAngle_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngle_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SteeringWheelAngle_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngle_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngle_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngle_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngle_encode_jer$descriptor() {
        return SteeringWheelAngle_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringWheelAngle_encode_jer$handle() {
        return SteeringWheelAngle_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngle_encode_jer$address() {
        return SteeringWheelAngle_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngle_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = SteeringWheelAngle_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngle_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngle_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngle_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngle_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngle_decode_oer$descriptor() {
        return SteeringWheelAngle_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngle_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle SteeringWheelAngle_decode_oer$handle() {
        return SteeringWheelAngle_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngle_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SteeringWheelAngle_decode_oer$address() {
        return SteeringWheelAngle_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngle_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SteeringWheelAngle_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SteeringWheelAngle_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngle_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngle_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngle_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngle_encode_oer$descriptor() {
        return SteeringWheelAngle_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SteeringWheelAngle_encode_oer$handle() {
        return SteeringWheelAngle_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngle_encode_oer$address() {
        return SteeringWheelAngle_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SteeringWheelAngle_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SteeringWheelAngle_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngle_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngle_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngle_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngle_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngle_decode_uper$descriptor() {
        return SteeringWheelAngle_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngle_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SteeringWheelAngle_decode_uper$handle() {
        return SteeringWheelAngle_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngle_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngle_decode_uper$address() {
        return SteeringWheelAngle_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngle_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngle_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SteeringWheelAngle_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngle_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngle_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngle_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngle_encode_uper$descriptor() {
        return SteeringWheelAngle_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SteeringWheelAngle_encode_uper$handle() {
        return SteeringWheelAngle_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngle_encode_uper$address() {
        return SteeringWheelAngle_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngle_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SteeringWheelAngle_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngle_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngle_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngle_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngle_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngle_decode_aper$descriptor() {
        return SteeringWheelAngle_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngle_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SteeringWheelAngle_decode_aper$handle() {
        return SteeringWheelAngle_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngle_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngle_decode_aper$address() {
        return SteeringWheelAngle_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SteeringWheelAngle_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngle_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SteeringWheelAngle_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngle_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SteeringWheelAngle_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SteeringWheelAngle_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SteeringWheelAngle_encode_aper$descriptor() {
        return SteeringWheelAngle_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SteeringWheelAngle_encode_aper$handle() {
        return SteeringWheelAngle_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngle_encode_aper$address() {
        return SteeringWheelAngle_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SteeringWheelAngle_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SteeringWheelAngle_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SteeringWheelAngle_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SteeringWheelAngle_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long Acceleration_t
     * }
     */
    public static final OfLong Acceleration_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_Acceleration_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_Acceleration_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Acceleration_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_Acceleration_constr_1$layout() {
        return asn_PER_type_Acceleration_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Acceleration_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_Acceleration_constr_1() {
        return asn_PER_type_Acceleration_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Acceleration_constr_1
     * }
     */
    public static void asn_PER_type_Acceleration_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_Acceleration_constr_1$constants.SEGMENT, 0L, asn_PER_type_Acceleration_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_Acceleration$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_Acceleration").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Acceleration
     * }
     */
    public static GroupLayout asn_DEF_Acceleration$layout() {
        return asn_DEF_Acceleration$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Acceleration
     * }
     */
    public static MemorySegment asn_DEF_Acceleration() {
        return asn_DEF_Acceleration$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Acceleration
     * }
     */
    public static void asn_DEF_Acceleration(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_Acceleration$constants.SEGMENT, 0L, asn_DEF_Acceleration$constants.LAYOUT.byteSize());
    }

    private static class Acceleration_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Acceleration_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Acceleration_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor Acceleration_free$descriptor() {
        return Acceleration_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Acceleration_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle Acceleration_free$handle() {
        return Acceleration_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Acceleration_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment Acceleration_free$address() {
        return Acceleration_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Acceleration_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void Acceleration_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = Acceleration_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Acceleration_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Acceleration_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Acceleration_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Acceleration_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Acceleration_print$descriptor() {
        return Acceleration_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Acceleration_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Acceleration_print$handle() {
        return Acceleration_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Acceleration_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Acceleration_print$address() {
        return Acceleration_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Acceleration_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int Acceleration_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Acceleration_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Acceleration_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Acceleration_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Acceleration_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Acceleration_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor Acceleration_constraint$descriptor() {
        return Acceleration_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Acceleration_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle Acceleration_constraint$handle() {
        return Acceleration_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Acceleration_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment Acceleration_constraint$address() {
        return Acceleration_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Acceleration_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int Acceleration_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Acceleration_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Acceleration_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Acceleration_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Acceleration_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Acceleration_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor Acceleration_decode_ber$descriptor() {
        return Acceleration_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Acceleration_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle Acceleration_decode_ber$handle() {
        return Acceleration_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Acceleration_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Acceleration_decode_ber$address() {
        return Acceleration_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Acceleration_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Acceleration_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = Acceleration_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Acceleration_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Acceleration_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Acceleration_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Acceleration_encode_der$descriptor() {
        return Acceleration_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Acceleration_encode_der$handle() {
        return Acceleration_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Acceleration_encode_der$address() {
        return Acceleration_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Acceleration_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Acceleration_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Acceleration_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Acceleration_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Acceleration_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Acceleration_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Acceleration_decode_xer$descriptor() {
        return Acceleration_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Acceleration_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle Acceleration_decode_xer$handle() {
        return Acceleration_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Acceleration_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Acceleration_decode_xer$address() {
        return Acceleration_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Acceleration_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Acceleration_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Acceleration_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Acceleration_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Acceleration_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Acceleration_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Acceleration_encode_xer$descriptor() {
        return Acceleration_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Acceleration_encode_xer$handle() {
        return Acceleration_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Acceleration_encode_xer$address() {
        return Acceleration_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Acceleration_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Acceleration_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Acceleration_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Acceleration_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Acceleration_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Acceleration_encode_jer$descriptor() {
        return Acceleration_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Acceleration_encode_jer$handle() {
        return Acceleration_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Acceleration_encode_jer$address() {
        return Acceleration_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Acceleration_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = Acceleration_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Acceleration_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Acceleration_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Acceleration_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Acceleration_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Acceleration_decode_oer$descriptor() {
        return Acceleration_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Acceleration_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle Acceleration_decode_oer$handle() {
        return Acceleration_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Acceleration_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Acceleration_decode_oer$address() {
        return Acceleration_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Acceleration_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Acceleration_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Acceleration_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Acceleration_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Acceleration_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Acceleration_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Acceleration_encode_oer$descriptor() {
        return Acceleration_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Acceleration_encode_oer$handle() {
        return Acceleration_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Acceleration_encode_oer$address() {
        return Acceleration_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Acceleration_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Acceleration_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Acceleration_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Acceleration_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Acceleration_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Acceleration_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Acceleration_decode_uper$descriptor() {
        return Acceleration_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Acceleration_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Acceleration_decode_uper$handle() {
        return Acceleration_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Acceleration_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Acceleration_decode_uper$address() {
        return Acceleration_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Acceleration_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Acceleration_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Acceleration_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Acceleration_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Acceleration_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Acceleration_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Acceleration_encode_uper$descriptor() {
        return Acceleration_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Acceleration_encode_uper$handle() {
        return Acceleration_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Acceleration_encode_uper$address() {
        return Acceleration_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Acceleration_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Acceleration_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Acceleration_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Acceleration_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Acceleration_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Acceleration_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Acceleration_decode_aper$descriptor() {
        return Acceleration_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Acceleration_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Acceleration_decode_aper$handle() {
        return Acceleration_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Acceleration_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Acceleration_decode_aper$address() {
        return Acceleration_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Acceleration_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Acceleration_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Acceleration_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Acceleration_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Acceleration_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Acceleration_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Acceleration_encode_aper$descriptor() {
        return Acceleration_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Acceleration_encode_aper$handle() {
        return Acceleration_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Acceleration_encode_aper$address() {
        return Acceleration_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Acceleration_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Acceleration_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Acceleration_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Acceleration_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long VerticalAcceleration_t
     * }
     */
    public static final OfLong VerticalAcceleration_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_VerticalAcceleration_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_VerticalAcceleration_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VerticalAcceleration_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_VerticalAcceleration_constr_1$layout() {
        return asn_PER_type_VerticalAcceleration_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VerticalAcceleration_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_VerticalAcceleration_constr_1() {
        return asn_PER_type_VerticalAcceleration_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VerticalAcceleration_constr_1
     * }
     */
    public static void asn_PER_type_VerticalAcceleration_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_VerticalAcceleration_constr_1$constants.SEGMENT, 0L, asn_PER_type_VerticalAcceleration_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_VerticalAcceleration$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_VerticalAcceleration").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VerticalAcceleration
     * }
     */
    public static GroupLayout asn_DEF_VerticalAcceleration$layout() {
        return asn_DEF_VerticalAcceleration$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VerticalAcceleration
     * }
     */
    public static MemorySegment asn_DEF_VerticalAcceleration() {
        return asn_DEF_VerticalAcceleration$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VerticalAcceleration
     * }
     */
    public static void asn_DEF_VerticalAcceleration(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_VerticalAcceleration$constants.SEGMENT, 0L, asn_DEF_VerticalAcceleration$constants.LAYOUT.byteSize());
    }

    private static class VerticalAcceleration_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VerticalAcceleration_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void VerticalAcceleration_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor VerticalAcceleration_free$descriptor() {
        return VerticalAcceleration_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void VerticalAcceleration_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle VerticalAcceleration_free$handle() {
        return VerticalAcceleration_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void VerticalAcceleration_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment VerticalAcceleration_free$address() {
        return VerticalAcceleration_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void VerticalAcceleration_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void VerticalAcceleration_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = VerticalAcceleration_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerticalAcceleration_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerticalAcceleration_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VerticalAcceleration_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int VerticalAcceleration_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VerticalAcceleration_print$descriptor() {
        return VerticalAcceleration_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int VerticalAcceleration_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VerticalAcceleration_print$handle() {
        return VerticalAcceleration_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int VerticalAcceleration_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VerticalAcceleration_print$address() {
        return VerticalAcceleration_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int VerticalAcceleration_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int VerticalAcceleration_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VerticalAcceleration_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerticalAcceleration_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerticalAcceleration_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VerticalAcceleration_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int VerticalAcceleration_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor VerticalAcceleration_constraint$descriptor() {
        return VerticalAcceleration_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int VerticalAcceleration_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle VerticalAcceleration_constraint$handle() {
        return VerticalAcceleration_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int VerticalAcceleration_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment VerticalAcceleration_constraint$address() {
        return VerticalAcceleration_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int VerticalAcceleration_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int VerticalAcceleration_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = VerticalAcceleration_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerticalAcceleration_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerticalAcceleration_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VerticalAcceleration_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VerticalAcceleration_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor VerticalAcceleration_decode_ber$descriptor() {
        return VerticalAcceleration_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VerticalAcceleration_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle VerticalAcceleration_decode_ber$handle() {
        return VerticalAcceleration_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VerticalAcceleration_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment VerticalAcceleration_decode_ber$address() {
        return VerticalAcceleration_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VerticalAcceleration_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment VerticalAcceleration_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = VerticalAcceleration_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerticalAcceleration_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerticalAcceleration_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VerticalAcceleration_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VerticalAcceleration_encode_der$descriptor() {
        return VerticalAcceleration_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VerticalAcceleration_encode_der$handle() {
        return VerticalAcceleration_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VerticalAcceleration_encode_der$address() {
        return VerticalAcceleration_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VerticalAcceleration_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = VerticalAcceleration_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerticalAcceleration_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerticalAcceleration_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VerticalAcceleration_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VerticalAcceleration_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor VerticalAcceleration_decode_xer$descriptor() {
        return VerticalAcceleration_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VerticalAcceleration_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle VerticalAcceleration_decode_xer$handle() {
        return VerticalAcceleration_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VerticalAcceleration_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment VerticalAcceleration_decode_xer$address() {
        return VerticalAcceleration_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VerticalAcceleration_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment VerticalAcceleration_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = VerticalAcceleration_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerticalAcceleration_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerticalAcceleration_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VerticalAcceleration_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VerticalAcceleration_encode_xer$descriptor() {
        return VerticalAcceleration_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VerticalAcceleration_encode_xer$handle() {
        return VerticalAcceleration_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VerticalAcceleration_encode_xer$address() {
        return VerticalAcceleration_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VerticalAcceleration_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = VerticalAcceleration_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerticalAcceleration_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerticalAcceleration_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VerticalAcceleration_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VerticalAcceleration_encode_jer$descriptor() {
        return VerticalAcceleration_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VerticalAcceleration_encode_jer$handle() {
        return VerticalAcceleration_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VerticalAcceleration_encode_jer$address() {
        return VerticalAcceleration_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VerticalAcceleration_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = VerticalAcceleration_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerticalAcceleration_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerticalAcceleration_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VerticalAcceleration_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VerticalAcceleration_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor VerticalAcceleration_decode_oer$descriptor() {
        return VerticalAcceleration_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VerticalAcceleration_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle VerticalAcceleration_decode_oer$handle() {
        return VerticalAcceleration_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VerticalAcceleration_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment VerticalAcceleration_decode_oer$address() {
        return VerticalAcceleration_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VerticalAcceleration_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment VerticalAcceleration_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = VerticalAcceleration_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerticalAcceleration_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerticalAcceleration_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VerticalAcceleration_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VerticalAcceleration_encode_oer$descriptor() {
        return VerticalAcceleration_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VerticalAcceleration_encode_oer$handle() {
        return VerticalAcceleration_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VerticalAcceleration_encode_oer$address() {
        return VerticalAcceleration_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VerticalAcceleration_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VerticalAcceleration_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerticalAcceleration_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerticalAcceleration_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VerticalAcceleration_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VerticalAcceleration_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor VerticalAcceleration_decode_uper$descriptor() {
        return VerticalAcceleration_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VerticalAcceleration_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle VerticalAcceleration_decode_uper$handle() {
        return VerticalAcceleration_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VerticalAcceleration_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VerticalAcceleration_decode_uper$address() {
        return VerticalAcceleration_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VerticalAcceleration_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VerticalAcceleration_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VerticalAcceleration_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerticalAcceleration_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerticalAcceleration_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VerticalAcceleration_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor VerticalAcceleration_encode_uper$descriptor() {
        return VerticalAcceleration_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle VerticalAcceleration_encode_uper$handle() {
        return VerticalAcceleration_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VerticalAcceleration_encode_uper$address() {
        return VerticalAcceleration_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VerticalAcceleration_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = VerticalAcceleration_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerticalAcceleration_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerticalAcceleration_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VerticalAcceleration_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VerticalAcceleration_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor VerticalAcceleration_decode_aper$descriptor() {
        return VerticalAcceleration_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VerticalAcceleration_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle VerticalAcceleration_decode_aper$handle() {
        return VerticalAcceleration_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VerticalAcceleration_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VerticalAcceleration_decode_aper$address() {
        return VerticalAcceleration_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VerticalAcceleration_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VerticalAcceleration_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VerticalAcceleration_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerticalAcceleration_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VerticalAcceleration_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VerticalAcceleration_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor VerticalAcceleration_encode_aper$descriptor() {
        return VerticalAcceleration_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle VerticalAcceleration_encode_aper$handle() {
        return VerticalAcceleration_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VerticalAcceleration_encode_aper$address() {
        return VerticalAcceleration_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VerticalAcceleration_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VerticalAcceleration_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = VerticalAcceleration_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VerticalAcceleration_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long YawRate_t
     * }
     */
    public static final OfLong YawRate_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_YawRate_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_YawRate_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_YawRate_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_YawRate_constr_1$layout() {
        return asn_PER_type_YawRate_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_YawRate_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_YawRate_constr_1() {
        return asn_PER_type_YawRate_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_YawRate_constr_1
     * }
     */
    public static void asn_PER_type_YawRate_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_YawRate_constr_1$constants.SEGMENT, 0L, asn_PER_type_YawRate_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_YawRate$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_YawRate").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_YawRate
     * }
     */
    public static GroupLayout asn_DEF_YawRate$layout() {
        return asn_DEF_YawRate$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_YawRate
     * }
     */
    public static MemorySegment asn_DEF_YawRate() {
        return asn_DEF_YawRate$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_YawRate
     * }
     */
    public static void asn_DEF_YawRate(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_YawRate$constants.SEGMENT, 0L, asn_DEF_YawRate$constants.LAYOUT.byteSize());
    }

    private static class YawRate_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRate_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void YawRate_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor YawRate_free$descriptor() {
        return YawRate_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void YawRate_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle YawRate_free$handle() {
        return YawRate_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void YawRate_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment YawRate_free$address() {
        return YawRate_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void YawRate_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void YawRate_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = YawRate_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRate_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRate_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRate_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int YawRate_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor YawRate_print$descriptor() {
        return YawRate_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int YawRate_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle YawRate_print$handle() {
        return YawRate_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int YawRate_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment YawRate_print$address() {
        return YawRate_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int YawRate_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int YawRate_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = YawRate_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRate_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRate_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRate_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int YawRate_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor YawRate_constraint$descriptor() {
        return YawRate_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int YawRate_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle YawRate_constraint$handle() {
        return YawRate_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int YawRate_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment YawRate_constraint$address() {
        return YawRate_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int YawRate_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int YawRate_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = YawRate_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRate_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRate_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRate_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRate_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor YawRate_decode_ber$descriptor() {
        return YawRate_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRate_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle YawRate_decode_ber$handle() {
        return YawRate_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRate_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment YawRate_decode_ber$address() {
        return YawRate_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t YawRate_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment YawRate_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = YawRate_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRate_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRate_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRate_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor YawRate_encode_der$descriptor() {
        return YawRate_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle YawRate_encode_der$handle() {
        return YawRate_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment YawRate_encode_der$address() {
        return YawRate_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment YawRate_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = YawRate_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRate_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRate_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRate_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRate_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor YawRate_decode_xer$descriptor() {
        return YawRate_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRate_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle YawRate_decode_xer$handle() {
        return YawRate_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRate_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment YawRate_decode_xer$address() {
        return YawRate_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t YawRate_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment YawRate_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = YawRate_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRate_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRate_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRate_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor YawRate_encode_xer$descriptor() {
        return YawRate_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle YawRate_encode_xer$handle() {
        return YawRate_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment YawRate_encode_xer$address() {
        return YawRate_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment YawRate_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = YawRate_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRate_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRate_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRate_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor YawRate_encode_jer$descriptor() {
        return YawRate_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle YawRate_encode_jer$handle() {
        return YawRate_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment YawRate_encode_jer$address() {
        return YawRate_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment YawRate_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = YawRate_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRate_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRate_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRate_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRate_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor YawRate_decode_oer$descriptor() {
        return YawRate_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRate_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle YawRate_decode_oer$handle() {
        return YawRate_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRate_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment YawRate_decode_oer$address() {
        return YawRate_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t YawRate_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment YawRate_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = YawRate_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRate_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRate_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRate_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor YawRate_encode_oer$descriptor() {
        return YawRate_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle YawRate_encode_oer$handle() {
        return YawRate_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment YawRate_encode_oer$address() {
        return YawRate_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment YawRate_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = YawRate_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRate_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRate_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRate_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRate_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor YawRate_decode_uper$descriptor() {
        return YawRate_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRate_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle YawRate_decode_uper$handle() {
        return YawRate_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRate_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment YawRate_decode_uper$address() {
        return YawRate_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t YawRate_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment YawRate_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = YawRate_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRate_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRate_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRate_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor YawRate_encode_uper$descriptor() {
        return YawRate_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle YawRate_encode_uper$handle() {
        return YawRate_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment YawRate_encode_uper$address() {
        return YawRate_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment YawRate_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = YawRate_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRate_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRate_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRate_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRate_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor YawRate_decode_aper$descriptor() {
        return YawRate_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRate_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle YawRate_decode_aper$handle() {
        return YawRate_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t YawRate_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment YawRate_decode_aper$address() {
        return YawRate_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t YawRate_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment YawRate_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = YawRate_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRate_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class YawRate_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("YawRate_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor YawRate_encode_aper$descriptor() {
        return YawRate_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle YawRate_encode_aper$handle() {
        return YawRate_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment YawRate_encode_aper$address() {
        return YawRate_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t YawRate_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment YawRate_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = YawRate_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("YawRate_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_AccelerationSet4Way$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_AccelerationSet4Way").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AccelerationSet4Way
     * }
     */
    public static GroupLayout asn_DEF_AccelerationSet4Way$layout() {
        return asn_DEF_AccelerationSet4Way$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AccelerationSet4Way
     * }
     */
    public static MemorySegment asn_DEF_AccelerationSet4Way() {
        return asn_DEF_AccelerationSet4Way$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AccelerationSet4Way
     * }
     */
    public static void asn_DEF_AccelerationSet4Way(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_AccelerationSet4Way$constants.SEGMENT, 0L, asn_DEF_AccelerationSet4Way$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_AccelerationSet4Way_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_AccelerationSet4Way_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_AccelerationSet4Way_specs_1
     * }
     */
    public static GroupLayout asn_SPC_AccelerationSet4Way_specs_1$layout() {
        return asn_SPC_AccelerationSet4Way_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_AccelerationSet4Way_specs_1
     * }
     */
    public static MemorySegment asn_SPC_AccelerationSet4Way_specs_1() {
        return asn_SPC_AccelerationSet4Way_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_AccelerationSet4Way_specs_1
     * }
     */
    public static void asn_SPC_AccelerationSet4Way_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_AccelerationSet4Way_specs_1$constants.SEGMENT, 0L, asn_SPC_AccelerationSet4Way_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_AccelerationSet4Way_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(4, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_AccelerationSet4Way_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 4 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AccelerationSet4Way_1[4]
     * }
     */
    public static SequenceLayout asn_MBR_AccelerationSet4Way_1$layout() {
        return asn_MBR_AccelerationSet4Way_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AccelerationSet4Way_1[4]
     * }
     */
    public static long[] asn_MBR_AccelerationSet4Way_1$dimensions() {
        return asn_MBR_AccelerationSet4Way_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AccelerationSet4Way_1[4]
     * }
     */
    public static MemorySegment asn_MBR_AccelerationSet4Way_1() {
        return asn_MBR_AccelerationSet4Way_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AccelerationSet4Way_1[4]
     * }
     */
    public static void asn_MBR_AccelerationSet4Way_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_AccelerationSet4Way_1$constants.SEGMENT, 0L, asn_MBR_AccelerationSet4Way_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AccelerationSet4Way_1[4]
     * }
     */
    public static MemorySegment asn_MBR_AccelerationSet4Way_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_AccelerationSet4Way_1$constants.HANDLE.invokeExact(asn_MBR_AccelerationSet4Way_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_AccelerationSet4Way_1[4]
     * }
     */
    public static void asn_MBR_AccelerationSet4Way_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_AccelerationSet4Way_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_BIT_STRING$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_BIT_STRING").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BIT_STRING
     * }
     */
    public static GroupLayout asn_DEF_BIT_STRING$layout() {
        return asn_DEF_BIT_STRING$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BIT_STRING
     * }
     */
    public static MemorySegment asn_DEF_BIT_STRING() {
        return asn_DEF_BIT_STRING$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BIT_STRING
     * }
     */
    public static void asn_DEF_BIT_STRING(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_BIT_STRING$constants.SEGMENT, 0L, asn_DEF_BIT_STRING$constants.LAYOUT.byteSize());
    }

    private static class asn_OP_BIT_STRING$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_operation_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_OP_BIT_STRING").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_BIT_STRING
     * }
     */
    public static GroupLayout asn_OP_BIT_STRING$layout() {
        return asn_OP_BIT_STRING$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_BIT_STRING
     * }
     */
    public static MemorySegment asn_OP_BIT_STRING() {
        return asn_OP_BIT_STRING$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_BIT_STRING
     * }
     */
    public static void asn_OP_BIT_STRING(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_OP_BIT_STRING$constants.SEGMENT, 0L, asn_OP_BIT_STRING$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_BIT_STRING_specs$constants {
        public static final GroupLayout LAYOUT = asn_OCTET_STRING_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_BIT_STRING_specs").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_OCTET_STRING_specifics_t asn_SPC_BIT_STRING_specs
     * }
     */
    public static GroupLayout asn_SPC_BIT_STRING_specs$layout() {
        return asn_SPC_BIT_STRING_specs$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_OCTET_STRING_specifics_t asn_SPC_BIT_STRING_specs
     * }
     */
    public static MemorySegment asn_SPC_BIT_STRING_specs() {
        return asn_SPC_BIT_STRING_specs$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_OCTET_STRING_specifics_t asn_SPC_BIT_STRING_specs
     * }
     */
    public static void asn_SPC_BIT_STRING_specs(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_BIT_STRING_specs$constants.SEGMENT, 0L, asn_SPC_BIT_STRING_specs$constants.LAYOUT.byteSize());
    }

    private static class BIT_STRING_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BIT_STRING_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int BIT_STRING_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BIT_STRING_print$descriptor() {
        return BIT_STRING_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int BIT_STRING_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BIT_STRING_print$handle() {
        return BIT_STRING_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int BIT_STRING_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BIT_STRING_print$address() {
        return BIT_STRING_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int BIT_STRING_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int BIT_STRING_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = BIT_STRING_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BIT_STRING_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BIT_STRING_compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BIT_STRING_compare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int BIT_STRING_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static FunctionDescriptor BIT_STRING_compare$descriptor() {
        return BIT_STRING_compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int BIT_STRING_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static MethodHandle BIT_STRING_compare$handle() {
        return BIT_STRING_compare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int BIT_STRING_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static MemorySegment BIT_STRING_compare$address() {
        return BIT_STRING_compare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int BIT_STRING_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static int BIT_STRING_compare(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = BIT_STRING_compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BIT_STRING_compare", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BIT_STRING_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BIT_STRING_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int BIT_STRING_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static FunctionDescriptor BIT_STRING_copy$descriptor() {
        return BIT_STRING_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int BIT_STRING_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static MethodHandle BIT_STRING_copy$handle() {
        return BIT_STRING_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int BIT_STRING_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static MemorySegment BIT_STRING_copy$address() {
        return BIT_STRING_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int BIT_STRING_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static int BIT_STRING_copy(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = BIT_STRING_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BIT_STRING_copy", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BIT_STRING_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BIT_STRING_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int BIT_STRING_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor BIT_STRING_constraint$descriptor() {
        return BIT_STRING_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int BIT_STRING_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle BIT_STRING_constraint$handle() {
        return BIT_STRING_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int BIT_STRING_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment BIT_STRING_constraint$address() {
        return BIT_STRING_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int BIT_STRING_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int BIT_STRING_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = BIT_STRING_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BIT_STRING_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BIT_STRING_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BIT_STRING_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BIT_STRING_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BIT_STRING_encode_xer$descriptor() {
        return BIT_STRING_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BIT_STRING_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BIT_STRING_encode_xer$handle() {
        return BIT_STRING_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BIT_STRING_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BIT_STRING_encode_xer$address() {
        return BIT_STRING_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BIT_STRING_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BIT_STRING_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = BIT_STRING_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BIT_STRING_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BIT_STRING_decode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BIT_STRING_decode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BIT_STRING_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor BIT_STRING_decode_jer$descriptor() {
        return BIT_STRING_decode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BIT_STRING_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle BIT_STRING_decode_jer$handle() {
        return BIT_STRING_decode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BIT_STRING_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment BIT_STRING_decode_jer$address() {
        return BIT_STRING_decode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BIT_STRING_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment BIT_STRING_decode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = BIT_STRING_decode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BIT_STRING_decode_jer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BIT_STRING_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BIT_STRING_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BIT_STRING_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BIT_STRING_encode_jer$descriptor() {
        return BIT_STRING_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BIT_STRING_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BIT_STRING_encode_jer$handle() {
        return BIT_STRING_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BIT_STRING_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BIT_STRING_encode_jer$address() {
        return BIT_STRING_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BIT_STRING_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BIT_STRING_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = BIT_STRING_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BIT_STRING_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BIT_STRING_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BIT_STRING_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BIT_STRING_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor BIT_STRING_decode_oer$descriptor() {
        return BIT_STRING_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BIT_STRING_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle BIT_STRING_decode_oer$handle() {
        return BIT_STRING_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BIT_STRING_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment BIT_STRING_decode_oer$address() {
        return BIT_STRING_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BIT_STRING_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment BIT_STRING_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = BIT_STRING_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BIT_STRING_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BIT_STRING_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BIT_STRING_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BIT_STRING_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BIT_STRING_encode_oer$descriptor() {
        return BIT_STRING_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BIT_STRING_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BIT_STRING_encode_oer$handle() {
        return BIT_STRING_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BIT_STRING_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BIT_STRING_encode_oer$address() {
        return BIT_STRING_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BIT_STRING_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BIT_STRING_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = BIT_STRING_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BIT_STRING_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BIT_STRING_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BIT_STRING_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BIT_STRING_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor BIT_STRING_decode_uper$descriptor() {
        return BIT_STRING_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BIT_STRING_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle BIT_STRING_decode_uper$handle() {
        return BIT_STRING_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BIT_STRING_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment BIT_STRING_decode_uper$address() {
        return BIT_STRING_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BIT_STRING_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment BIT_STRING_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = BIT_STRING_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BIT_STRING_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BIT_STRING_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BIT_STRING_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BIT_STRING_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor BIT_STRING_encode_uper$descriptor() {
        return BIT_STRING_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BIT_STRING_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle BIT_STRING_encode_uper$handle() {
        return BIT_STRING_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BIT_STRING_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment BIT_STRING_encode_uper$address() {
        return BIT_STRING_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BIT_STRING_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment BIT_STRING_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = BIT_STRING_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BIT_STRING_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BIT_STRING_random_fill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_random_fill_result_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BIT_STRING_random_fill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_random_fill_result_t BIT_STRING_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static FunctionDescriptor BIT_STRING_random_fill$descriptor() {
        return BIT_STRING_random_fill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_random_fill_result_t BIT_STRING_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static MethodHandle BIT_STRING_random_fill$handle() {
        return BIT_STRING_random_fill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_random_fill_result_t BIT_STRING_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static MemorySegment BIT_STRING_random_fill$address() {
        return BIT_STRING_random_fill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_random_fill_result_t BIT_STRING_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static MemorySegment BIT_STRING_random_fill(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = BIT_STRING_random_fill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BIT_STRING_random_fill", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BIT_STRING__compactify {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BIT_STRING__compactify");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * const BIT_STRING_t *BIT_STRING__compactify(const BIT_STRING_t *st, BIT_STRING_t *tmp)
     * }
     */
    public static FunctionDescriptor BIT_STRING__compactify$descriptor() {
        return BIT_STRING__compactify.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * const BIT_STRING_t *BIT_STRING__compactify(const BIT_STRING_t *st, BIT_STRING_t *tmp)
     * }
     */
    public static MethodHandle BIT_STRING__compactify$handle() {
        return BIT_STRING__compactify.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * const BIT_STRING_t *BIT_STRING__compactify(const BIT_STRING_t *st, BIT_STRING_t *tmp)
     * }
     */
    public static MemorySegment BIT_STRING__compactify$address() {
        return BIT_STRING__compactify.ADDR;
    }

    /**
     * {@snippet lang=c :
     * const BIT_STRING_t *BIT_STRING__compactify(const BIT_STRING_t *st, BIT_STRING_t *tmp)
     * }
     */
    public static MemorySegment BIT_STRING__compactify(MemorySegment st, MemorySegment tmp) {
        var mh$ = BIT_STRING__compactify.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BIT_STRING__compactify", st, tmp);
            }
            return (MemorySegment)mh$.invokeExact(st, tmp);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int BrakeAppliedStatus_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum BrakeAppliedStatus.BrakeAppliedStatus_unavailable = 0
     * }
     */
    public static int BrakeAppliedStatus_unavailable() {
        return BrakeAppliedStatus_unavailable;
    }
    private static final int BrakeAppliedStatus_leftFront = (int)1L;
    /**
     * {@snippet lang=c :
     * enum BrakeAppliedStatus.BrakeAppliedStatus_leftFront = 1
     * }
     */
    public static int BrakeAppliedStatus_leftFront() {
        return BrakeAppliedStatus_leftFront;
    }
    private static final int BrakeAppliedStatus_leftRear = (int)2L;
    /**
     * {@snippet lang=c :
     * enum BrakeAppliedStatus.BrakeAppliedStatus_leftRear = 2
     * }
     */
    public static int BrakeAppliedStatus_leftRear() {
        return BrakeAppliedStatus_leftRear;
    }
    private static final int BrakeAppliedStatus_rightFront = (int)3L;
    /**
     * {@snippet lang=c :
     * enum BrakeAppliedStatus.BrakeAppliedStatus_rightFront = 3
     * }
     */
    public static int BrakeAppliedStatus_rightFront() {
        return BrakeAppliedStatus_rightFront;
    }
    private static final int BrakeAppliedStatus_rightRear = (int)4L;
    /**
     * {@snippet lang=c :
     * enum BrakeAppliedStatus.BrakeAppliedStatus_rightRear = 4
     * }
     */
    public static int BrakeAppliedStatus_rightRear() {
        return BrakeAppliedStatus_rightRear;
    }

    private static class asn_PER_type_BrakeAppliedStatus_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_BrakeAppliedStatus_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_BrakeAppliedStatus_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_BrakeAppliedStatus_constr_1$layout() {
        return asn_PER_type_BrakeAppliedStatus_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_BrakeAppliedStatus_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_BrakeAppliedStatus_constr_1() {
        return asn_PER_type_BrakeAppliedStatus_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_BrakeAppliedStatus_constr_1
     * }
     */
    public static void asn_PER_type_BrakeAppliedStatus_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_BrakeAppliedStatus_constr_1$constants.SEGMENT, 0L, asn_PER_type_BrakeAppliedStatus_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_BrakeAppliedStatus$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_BrakeAppliedStatus").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BrakeAppliedStatus
     * }
     */
    public static GroupLayout asn_DEF_BrakeAppliedStatus$layout() {
        return asn_DEF_BrakeAppliedStatus$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BrakeAppliedStatus
     * }
     */
    public static MemorySegment asn_DEF_BrakeAppliedStatus() {
        return asn_DEF_BrakeAppliedStatus$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BrakeAppliedStatus
     * }
     */
    public static void asn_DEF_BrakeAppliedStatus(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_BrakeAppliedStatus$constants.SEGMENT, 0L, asn_DEF_BrakeAppliedStatus$constants.LAYOUT.byteSize());
    }

    private static class BrakeAppliedStatus_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedStatus_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BrakeAppliedStatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor BrakeAppliedStatus_free$descriptor() {
        return BrakeAppliedStatus_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BrakeAppliedStatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle BrakeAppliedStatus_free$handle() {
        return BrakeAppliedStatus_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BrakeAppliedStatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_free$address() {
        return BrakeAppliedStatus_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BrakeAppliedStatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void BrakeAppliedStatus_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = BrakeAppliedStatus_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedStatus_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedStatus_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedStatus_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int BrakeAppliedStatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BrakeAppliedStatus_print$descriptor() {
        return BrakeAppliedStatus_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int BrakeAppliedStatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BrakeAppliedStatus_print$handle() {
        return BrakeAppliedStatus_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int BrakeAppliedStatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_print$address() {
        return BrakeAppliedStatus_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int BrakeAppliedStatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int BrakeAppliedStatus_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = BrakeAppliedStatus_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedStatus_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedStatus_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedStatus_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int BrakeAppliedStatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor BrakeAppliedStatus_constraint$descriptor() {
        return BrakeAppliedStatus_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int BrakeAppliedStatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle BrakeAppliedStatus_constraint$handle() {
        return BrakeAppliedStatus_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int BrakeAppliedStatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_constraint$address() {
        return BrakeAppliedStatus_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int BrakeAppliedStatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int BrakeAppliedStatus_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = BrakeAppliedStatus_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedStatus_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedStatus_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedStatus_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedStatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor BrakeAppliedStatus_decode_ber$descriptor() {
        return BrakeAppliedStatus_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedStatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle BrakeAppliedStatus_decode_ber$handle() {
        return BrakeAppliedStatus_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedStatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_decode_ber$address() {
        return BrakeAppliedStatus_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedStatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = BrakeAppliedStatus_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedStatus_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedStatus_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedStatus_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BrakeAppliedStatus_encode_der$descriptor() {
        return BrakeAppliedStatus_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BrakeAppliedStatus_encode_der$handle() {
        return BrakeAppliedStatus_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_encode_der$address() {
        return BrakeAppliedStatus_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = BrakeAppliedStatus_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedStatus_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedStatus_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedStatus_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedStatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor BrakeAppliedStatus_decode_xer$descriptor() {
        return BrakeAppliedStatus_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedStatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle BrakeAppliedStatus_decode_xer$handle() {
        return BrakeAppliedStatus_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedStatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_decode_xer$address() {
        return BrakeAppliedStatus_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedStatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = BrakeAppliedStatus_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedStatus_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedStatus_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedStatus_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BrakeAppliedStatus_encode_xer$descriptor() {
        return BrakeAppliedStatus_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BrakeAppliedStatus_encode_xer$handle() {
        return BrakeAppliedStatus_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_encode_xer$address() {
        return BrakeAppliedStatus_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = BrakeAppliedStatus_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedStatus_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedStatus_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedStatus_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BrakeAppliedStatus_encode_jer$descriptor() {
        return BrakeAppliedStatus_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BrakeAppliedStatus_encode_jer$handle() {
        return BrakeAppliedStatus_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_encode_jer$address() {
        return BrakeAppliedStatus_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = BrakeAppliedStatus_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedStatus_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedStatus_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedStatus_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedStatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor BrakeAppliedStatus_decode_oer$descriptor() {
        return BrakeAppliedStatus_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedStatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle BrakeAppliedStatus_decode_oer$handle() {
        return BrakeAppliedStatus_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedStatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_decode_oer$address() {
        return BrakeAppliedStatus_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedStatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = BrakeAppliedStatus_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedStatus_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedStatus_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedStatus_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BrakeAppliedStatus_encode_oer$descriptor() {
        return BrakeAppliedStatus_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BrakeAppliedStatus_encode_oer$handle() {
        return BrakeAppliedStatus_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_encode_oer$address() {
        return BrakeAppliedStatus_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = BrakeAppliedStatus_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedStatus_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedStatus_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedStatus_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedStatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor BrakeAppliedStatus_decode_uper$descriptor() {
        return BrakeAppliedStatus_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedStatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle BrakeAppliedStatus_decode_uper$handle() {
        return BrakeAppliedStatus_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedStatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_decode_uper$address() {
        return BrakeAppliedStatus_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedStatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = BrakeAppliedStatus_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedStatus_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedStatus_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedStatus_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor BrakeAppliedStatus_encode_uper$descriptor() {
        return BrakeAppliedStatus_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle BrakeAppliedStatus_encode_uper$handle() {
        return BrakeAppliedStatus_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_encode_uper$address() {
        return BrakeAppliedStatus_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = BrakeAppliedStatus_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedStatus_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedStatus_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedStatus_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedStatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor BrakeAppliedStatus_decode_aper$descriptor() {
        return BrakeAppliedStatus_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedStatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle BrakeAppliedStatus_decode_aper$handle() {
        return BrakeAppliedStatus_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedStatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_decode_aper$address() {
        return BrakeAppliedStatus_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeAppliedStatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = BrakeAppliedStatus_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedStatus_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeAppliedStatus_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeAppliedStatus_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor BrakeAppliedStatus_encode_aper$descriptor() {
        return BrakeAppliedStatus_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle BrakeAppliedStatus_encode_aper$handle() {
        return BrakeAppliedStatus_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_encode_aper$address() {
        return BrakeAppliedStatus_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeAppliedStatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment BrakeAppliedStatus_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = BrakeAppliedStatus_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeAppliedStatus_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int TractionControlStatus_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum TractionControlStatus.TractionControlStatus_unavailable = 0
     * }
     */
    public static int TractionControlStatus_unavailable() {
        return TractionControlStatus_unavailable;
    }
    private static final int TractionControlStatus_off = (int)1L;
    /**
     * {@snippet lang=c :
     * enum TractionControlStatus.TractionControlStatus_off = 1
     * }
     */
    public static int TractionControlStatus_off() {
        return TractionControlStatus_off;
    }
    private static final int TractionControlStatus_on = (int)2L;
    /**
     * {@snippet lang=c :
     * enum TractionControlStatus.TractionControlStatus_on = 2
     * }
     */
    public static int TractionControlStatus_on() {
        return TractionControlStatus_on;
    }
    private static final int TractionControlStatus_engaged = (int)3L;
    /**
     * {@snippet lang=c :
     * enum TractionControlStatus.TractionControlStatus_engaged = 3
     * }
     */
    public static int TractionControlStatus_engaged() {
        return TractionControlStatus_engaged;
    }
    /**
     * {@snippet lang=c :
     * typedef long TractionControlStatus_t
     * }
     */
    public static final OfLong TractionControlStatus_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_TractionControlStatus_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_TractionControlStatus_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TractionControlStatus_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_TractionControlStatus_constr_1$layout() {
        return asn_PER_type_TractionControlStatus_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TractionControlStatus_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_TractionControlStatus_constr_1() {
        return asn_PER_type_TractionControlStatus_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TractionControlStatus_constr_1
     * }
     */
    public static void asn_PER_type_TractionControlStatus_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_TractionControlStatus_constr_1$constants.SEGMENT, 0L, asn_PER_type_TractionControlStatus_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_TractionControlStatus$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_TractionControlStatus").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TractionControlStatus
     * }
     */
    public static GroupLayout asn_DEF_TractionControlStatus$layout() {
        return asn_DEF_TractionControlStatus$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TractionControlStatus
     * }
     */
    public static MemorySegment asn_DEF_TractionControlStatus() {
        return asn_DEF_TractionControlStatus$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TractionControlStatus
     * }
     */
    public static void asn_DEF_TractionControlStatus(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_TractionControlStatus$constants.SEGMENT, 0L, asn_DEF_TractionControlStatus$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_TractionControlStatus_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_TractionControlStatus_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_TractionControlStatus_specs_1
     * }
     */
    public static GroupLayout asn_SPC_TractionControlStatus_specs_1$layout() {
        return asn_SPC_TractionControlStatus_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_TractionControlStatus_specs_1
     * }
     */
    public static MemorySegment asn_SPC_TractionControlStatus_specs_1() {
        return asn_SPC_TractionControlStatus_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_TractionControlStatus_specs_1
     * }
     */
    public static void asn_SPC_TractionControlStatus_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_TractionControlStatus_specs_1$constants.SEGMENT, 0L, asn_SPC_TractionControlStatus_specs_1$constants.LAYOUT.byteSize());
    }

    private static class TractionControlStatus_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TractionControlStatus_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void TractionControlStatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor TractionControlStatus_free$descriptor() {
        return TractionControlStatus_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void TractionControlStatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle TractionControlStatus_free$handle() {
        return TractionControlStatus_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void TractionControlStatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment TractionControlStatus_free$address() {
        return TractionControlStatus_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void TractionControlStatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void TractionControlStatus_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = TractionControlStatus_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TractionControlStatus_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TractionControlStatus_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TractionControlStatus_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TractionControlStatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TractionControlStatus_print$descriptor() {
        return TractionControlStatus_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TractionControlStatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TractionControlStatus_print$handle() {
        return TractionControlStatus_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TractionControlStatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TractionControlStatus_print$address() {
        return TractionControlStatus_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TractionControlStatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int TractionControlStatus_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TractionControlStatus_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TractionControlStatus_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TractionControlStatus_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TractionControlStatus_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TractionControlStatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor TractionControlStatus_constraint$descriptor() {
        return TractionControlStatus_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TractionControlStatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle TractionControlStatus_constraint$handle() {
        return TractionControlStatus_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TractionControlStatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment TractionControlStatus_constraint$address() {
        return TractionControlStatus_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TractionControlStatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int TractionControlStatus_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TractionControlStatus_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TractionControlStatus_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TractionControlStatus_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TractionControlStatus_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TractionControlStatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor TractionControlStatus_decode_ber$descriptor() {
        return TractionControlStatus_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TractionControlStatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle TractionControlStatus_decode_ber$handle() {
        return TractionControlStatus_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TractionControlStatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment TractionControlStatus_decode_ber$address() {
        return TractionControlStatus_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TractionControlStatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment TractionControlStatus_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = TractionControlStatus_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TractionControlStatus_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TractionControlStatus_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TractionControlStatus_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TractionControlStatus_encode_der$descriptor() {
        return TractionControlStatus_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TractionControlStatus_encode_der$handle() {
        return TractionControlStatus_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TractionControlStatus_encode_der$address() {
        return TractionControlStatus_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TractionControlStatus_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = TractionControlStatus_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TractionControlStatus_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TractionControlStatus_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TractionControlStatus_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TractionControlStatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor TractionControlStatus_decode_xer$descriptor() {
        return TractionControlStatus_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TractionControlStatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle TractionControlStatus_decode_xer$handle() {
        return TractionControlStatus_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TractionControlStatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment TractionControlStatus_decode_xer$address() {
        return TractionControlStatus_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TractionControlStatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment TractionControlStatus_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = TractionControlStatus_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TractionControlStatus_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TractionControlStatus_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TractionControlStatus_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TractionControlStatus_encode_xer$descriptor() {
        return TractionControlStatus_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TractionControlStatus_encode_xer$handle() {
        return TractionControlStatus_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TractionControlStatus_encode_xer$address() {
        return TractionControlStatus_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TractionControlStatus_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = TractionControlStatus_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TractionControlStatus_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TractionControlStatus_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TractionControlStatus_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TractionControlStatus_encode_jer$descriptor() {
        return TractionControlStatus_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TractionControlStatus_encode_jer$handle() {
        return TractionControlStatus_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TractionControlStatus_encode_jer$address() {
        return TractionControlStatus_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TractionControlStatus_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = TractionControlStatus_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TractionControlStatus_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TractionControlStatus_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TractionControlStatus_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TractionControlStatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor TractionControlStatus_decode_oer$descriptor() {
        return TractionControlStatus_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TractionControlStatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle TractionControlStatus_decode_oer$handle() {
        return TractionControlStatus_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TractionControlStatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment TractionControlStatus_decode_oer$address() {
        return TractionControlStatus_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TractionControlStatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment TractionControlStatus_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = TractionControlStatus_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TractionControlStatus_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TractionControlStatus_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TractionControlStatus_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TractionControlStatus_encode_oer$descriptor() {
        return TractionControlStatus_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TractionControlStatus_encode_oer$handle() {
        return TractionControlStatus_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TractionControlStatus_encode_oer$address() {
        return TractionControlStatus_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TractionControlStatus_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TractionControlStatus_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TractionControlStatus_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TractionControlStatus_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TractionControlStatus_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TractionControlStatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor TractionControlStatus_decode_uper$descriptor() {
        return TractionControlStatus_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TractionControlStatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle TractionControlStatus_decode_uper$handle() {
        return TractionControlStatus_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TractionControlStatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TractionControlStatus_decode_uper$address() {
        return TractionControlStatus_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TractionControlStatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TractionControlStatus_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TractionControlStatus_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TractionControlStatus_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TractionControlStatus_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TractionControlStatus_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor TractionControlStatus_encode_uper$descriptor() {
        return TractionControlStatus_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle TractionControlStatus_encode_uper$handle() {
        return TractionControlStatus_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TractionControlStatus_encode_uper$address() {
        return TractionControlStatus_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TractionControlStatus_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TractionControlStatus_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TractionControlStatus_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TractionControlStatus_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TractionControlStatus_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TractionControlStatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor TractionControlStatus_decode_aper$descriptor() {
        return TractionControlStatus_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TractionControlStatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle TractionControlStatus_decode_aper$handle() {
        return TractionControlStatus_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TractionControlStatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TractionControlStatus_decode_aper$address() {
        return TractionControlStatus_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TractionControlStatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TractionControlStatus_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TractionControlStatus_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TractionControlStatus_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TractionControlStatus_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TractionControlStatus_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor TractionControlStatus_encode_aper$descriptor() {
        return TractionControlStatus_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle TractionControlStatus_encode_aper$handle() {
        return TractionControlStatus_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TractionControlStatus_encode_aper$address() {
        return TractionControlStatus_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TractionControlStatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TractionControlStatus_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TractionControlStatus_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TractionControlStatus_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AntiLockBrakeStatus_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AntiLockBrakeStatus.AntiLockBrakeStatus_unavailable = 0
     * }
     */
    public static int AntiLockBrakeStatus_unavailable() {
        return AntiLockBrakeStatus_unavailable;
    }
    private static final int AntiLockBrakeStatus_off = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AntiLockBrakeStatus.AntiLockBrakeStatus_off = 1
     * }
     */
    public static int AntiLockBrakeStatus_off() {
        return AntiLockBrakeStatus_off;
    }
    private static final int AntiLockBrakeStatus_on = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AntiLockBrakeStatus.AntiLockBrakeStatus_on = 2
     * }
     */
    public static int AntiLockBrakeStatus_on() {
        return AntiLockBrakeStatus_on;
    }
    private static final int AntiLockBrakeStatus_engaged = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AntiLockBrakeStatus.AntiLockBrakeStatus_engaged = 3
     * }
     */
    public static int AntiLockBrakeStatus_engaged() {
        return AntiLockBrakeStatus_engaged;
    }
    /**
     * {@snippet lang=c :
     * typedef long AntiLockBrakeStatus_t
     * }
     */
    public static final OfLong AntiLockBrakeStatus_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_AntiLockBrakeStatus_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_AntiLockBrakeStatus_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AntiLockBrakeStatus_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_AntiLockBrakeStatus_constr_1$layout() {
        return asn_PER_type_AntiLockBrakeStatus_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AntiLockBrakeStatus_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_AntiLockBrakeStatus_constr_1() {
        return asn_PER_type_AntiLockBrakeStatus_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AntiLockBrakeStatus_constr_1
     * }
     */
    public static void asn_PER_type_AntiLockBrakeStatus_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_AntiLockBrakeStatus_constr_1$constants.SEGMENT, 0L, asn_PER_type_AntiLockBrakeStatus_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_AntiLockBrakeStatus$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_AntiLockBrakeStatus").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AntiLockBrakeStatus
     * }
     */
    public static GroupLayout asn_DEF_AntiLockBrakeStatus$layout() {
        return asn_DEF_AntiLockBrakeStatus$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AntiLockBrakeStatus
     * }
     */
    public static MemorySegment asn_DEF_AntiLockBrakeStatus() {
        return asn_DEF_AntiLockBrakeStatus$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AntiLockBrakeStatus
     * }
     */
    public static void asn_DEF_AntiLockBrakeStatus(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_AntiLockBrakeStatus$constants.SEGMENT, 0L, asn_DEF_AntiLockBrakeStatus$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_AntiLockBrakeStatus_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_AntiLockBrakeStatus_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_AntiLockBrakeStatus_specs_1
     * }
     */
    public static GroupLayout asn_SPC_AntiLockBrakeStatus_specs_1$layout() {
        return asn_SPC_AntiLockBrakeStatus_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_AntiLockBrakeStatus_specs_1
     * }
     */
    public static MemorySegment asn_SPC_AntiLockBrakeStatus_specs_1() {
        return asn_SPC_AntiLockBrakeStatus_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_AntiLockBrakeStatus_specs_1
     * }
     */
    public static void asn_SPC_AntiLockBrakeStatus_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_AntiLockBrakeStatus_specs_1$constants.SEGMENT, 0L, asn_SPC_AntiLockBrakeStatus_specs_1$constants.LAYOUT.byteSize());
    }

    private static class AntiLockBrakeStatus_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AntiLockBrakeStatus_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void AntiLockBrakeStatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor AntiLockBrakeStatus_free$descriptor() {
        return AntiLockBrakeStatus_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void AntiLockBrakeStatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle AntiLockBrakeStatus_free$handle() {
        return AntiLockBrakeStatus_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void AntiLockBrakeStatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_free$address() {
        return AntiLockBrakeStatus_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void AntiLockBrakeStatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void AntiLockBrakeStatus_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = AntiLockBrakeStatus_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AntiLockBrakeStatus_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AntiLockBrakeStatus_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AntiLockBrakeStatus_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AntiLockBrakeStatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AntiLockBrakeStatus_print$descriptor() {
        return AntiLockBrakeStatus_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AntiLockBrakeStatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AntiLockBrakeStatus_print$handle() {
        return AntiLockBrakeStatus_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AntiLockBrakeStatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_print$address() {
        return AntiLockBrakeStatus_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AntiLockBrakeStatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int AntiLockBrakeStatus_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AntiLockBrakeStatus_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AntiLockBrakeStatus_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AntiLockBrakeStatus_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AntiLockBrakeStatus_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AntiLockBrakeStatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor AntiLockBrakeStatus_constraint$descriptor() {
        return AntiLockBrakeStatus_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AntiLockBrakeStatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle AntiLockBrakeStatus_constraint$handle() {
        return AntiLockBrakeStatus_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AntiLockBrakeStatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_constraint$address() {
        return AntiLockBrakeStatus_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AntiLockBrakeStatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int AntiLockBrakeStatus_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = AntiLockBrakeStatus_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AntiLockBrakeStatus_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AntiLockBrakeStatus_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AntiLockBrakeStatus_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AntiLockBrakeStatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor AntiLockBrakeStatus_decode_ber$descriptor() {
        return AntiLockBrakeStatus_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AntiLockBrakeStatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle AntiLockBrakeStatus_decode_ber$handle() {
        return AntiLockBrakeStatus_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AntiLockBrakeStatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_decode_ber$address() {
        return AntiLockBrakeStatus_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AntiLockBrakeStatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = AntiLockBrakeStatus_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AntiLockBrakeStatus_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AntiLockBrakeStatus_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AntiLockBrakeStatus_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AntiLockBrakeStatus_encode_der$descriptor() {
        return AntiLockBrakeStatus_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AntiLockBrakeStatus_encode_der$handle() {
        return AntiLockBrakeStatus_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_encode_der$address() {
        return AntiLockBrakeStatus_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = AntiLockBrakeStatus_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AntiLockBrakeStatus_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AntiLockBrakeStatus_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AntiLockBrakeStatus_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AntiLockBrakeStatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor AntiLockBrakeStatus_decode_xer$descriptor() {
        return AntiLockBrakeStatus_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AntiLockBrakeStatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle AntiLockBrakeStatus_decode_xer$handle() {
        return AntiLockBrakeStatus_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AntiLockBrakeStatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_decode_xer$address() {
        return AntiLockBrakeStatus_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AntiLockBrakeStatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = AntiLockBrakeStatus_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AntiLockBrakeStatus_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AntiLockBrakeStatus_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AntiLockBrakeStatus_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AntiLockBrakeStatus_encode_xer$descriptor() {
        return AntiLockBrakeStatus_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AntiLockBrakeStatus_encode_xer$handle() {
        return AntiLockBrakeStatus_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_encode_xer$address() {
        return AntiLockBrakeStatus_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = AntiLockBrakeStatus_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AntiLockBrakeStatus_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AntiLockBrakeStatus_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AntiLockBrakeStatus_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AntiLockBrakeStatus_encode_jer$descriptor() {
        return AntiLockBrakeStatus_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AntiLockBrakeStatus_encode_jer$handle() {
        return AntiLockBrakeStatus_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_encode_jer$address() {
        return AntiLockBrakeStatus_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = AntiLockBrakeStatus_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AntiLockBrakeStatus_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AntiLockBrakeStatus_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AntiLockBrakeStatus_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AntiLockBrakeStatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor AntiLockBrakeStatus_decode_oer$descriptor() {
        return AntiLockBrakeStatus_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AntiLockBrakeStatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle AntiLockBrakeStatus_decode_oer$handle() {
        return AntiLockBrakeStatus_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AntiLockBrakeStatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_decode_oer$address() {
        return AntiLockBrakeStatus_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AntiLockBrakeStatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = AntiLockBrakeStatus_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AntiLockBrakeStatus_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AntiLockBrakeStatus_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AntiLockBrakeStatus_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AntiLockBrakeStatus_encode_oer$descriptor() {
        return AntiLockBrakeStatus_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AntiLockBrakeStatus_encode_oer$handle() {
        return AntiLockBrakeStatus_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_encode_oer$address() {
        return AntiLockBrakeStatus_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AntiLockBrakeStatus_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AntiLockBrakeStatus_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AntiLockBrakeStatus_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AntiLockBrakeStatus_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AntiLockBrakeStatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor AntiLockBrakeStatus_decode_uper$descriptor() {
        return AntiLockBrakeStatus_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AntiLockBrakeStatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle AntiLockBrakeStatus_decode_uper$handle() {
        return AntiLockBrakeStatus_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AntiLockBrakeStatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_decode_uper$address() {
        return AntiLockBrakeStatus_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AntiLockBrakeStatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AntiLockBrakeStatus_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AntiLockBrakeStatus_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AntiLockBrakeStatus_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AntiLockBrakeStatus_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor AntiLockBrakeStatus_encode_uper$descriptor() {
        return AntiLockBrakeStatus_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle AntiLockBrakeStatus_encode_uper$handle() {
        return AntiLockBrakeStatus_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_encode_uper$address() {
        return AntiLockBrakeStatus_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = AntiLockBrakeStatus_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AntiLockBrakeStatus_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AntiLockBrakeStatus_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AntiLockBrakeStatus_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AntiLockBrakeStatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor AntiLockBrakeStatus_decode_aper$descriptor() {
        return AntiLockBrakeStatus_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AntiLockBrakeStatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle AntiLockBrakeStatus_decode_aper$handle() {
        return AntiLockBrakeStatus_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AntiLockBrakeStatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_decode_aper$address() {
        return AntiLockBrakeStatus_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AntiLockBrakeStatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AntiLockBrakeStatus_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AntiLockBrakeStatus_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AntiLockBrakeStatus_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AntiLockBrakeStatus_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor AntiLockBrakeStatus_encode_aper$descriptor() {
        return AntiLockBrakeStatus_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle AntiLockBrakeStatus_encode_aper$handle() {
        return AntiLockBrakeStatus_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_encode_aper$address() {
        return AntiLockBrakeStatus_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AntiLockBrakeStatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AntiLockBrakeStatus_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = AntiLockBrakeStatus_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AntiLockBrakeStatus_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int StabilityControlStatus_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum StabilityControlStatus.StabilityControlStatus_unavailable = 0
     * }
     */
    public static int StabilityControlStatus_unavailable() {
        return StabilityControlStatus_unavailable;
    }
    private static final int StabilityControlStatus_off = (int)1L;
    /**
     * {@snippet lang=c :
     * enum StabilityControlStatus.StabilityControlStatus_off = 1
     * }
     */
    public static int StabilityControlStatus_off() {
        return StabilityControlStatus_off;
    }
    private static final int StabilityControlStatus_on = (int)2L;
    /**
     * {@snippet lang=c :
     * enum StabilityControlStatus.StabilityControlStatus_on = 2
     * }
     */
    public static int StabilityControlStatus_on() {
        return StabilityControlStatus_on;
    }
    private static final int StabilityControlStatus_engaged = (int)3L;
    /**
     * {@snippet lang=c :
     * enum StabilityControlStatus.StabilityControlStatus_engaged = 3
     * }
     */
    public static int StabilityControlStatus_engaged() {
        return StabilityControlStatus_engaged;
    }
    /**
     * {@snippet lang=c :
     * typedef long StabilityControlStatus_t
     * }
     */
    public static final OfLong StabilityControlStatus_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_StabilityControlStatus_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_StabilityControlStatus_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_StabilityControlStatus_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_StabilityControlStatus_constr_1$layout() {
        return asn_PER_type_StabilityControlStatus_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_StabilityControlStatus_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_StabilityControlStatus_constr_1() {
        return asn_PER_type_StabilityControlStatus_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_StabilityControlStatus_constr_1
     * }
     */
    public static void asn_PER_type_StabilityControlStatus_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_StabilityControlStatus_constr_1$constants.SEGMENT, 0L, asn_PER_type_StabilityControlStatus_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_StabilityControlStatus$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_StabilityControlStatus").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_StabilityControlStatus
     * }
     */
    public static GroupLayout asn_DEF_StabilityControlStatus$layout() {
        return asn_DEF_StabilityControlStatus$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_StabilityControlStatus
     * }
     */
    public static MemorySegment asn_DEF_StabilityControlStatus() {
        return asn_DEF_StabilityControlStatus$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_StabilityControlStatus
     * }
     */
    public static void asn_DEF_StabilityControlStatus(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_StabilityControlStatus$constants.SEGMENT, 0L, asn_DEF_StabilityControlStatus$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_StabilityControlStatus_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_StabilityControlStatus_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_StabilityControlStatus_specs_1
     * }
     */
    public static GroupLayout asn_SPC_StabilityControlStatus_specs_1$layout() {
        return asn_SPC_StabilityControlStatus_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_StabilityControlStatus_specs_1
     * }
     */
    public static MemorySegment asn_SPC_StabilityControlStatus_specs_1() {
        return asn_SPC_StabilityControlStatus_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_StabilityControlStatus_specs_1
     * }
     */
    public static void asn_SPC_StabilityControlStatus_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_StabilityControlStatus_specs_1$constants.SEGMENT, 0L, asn_SPC_StabilityControlStatus_specs_1$constants.LAYOUT.byteSize());
    }

    private static class StabilityControlStatus_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("StabilityControlStatus_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void StabilityControlStatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor StabilityControlStatus_free$descriptor() {
        return StabilityControlStatus_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void StabilityControlStatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle StabilityControlStatus_free$handle() {
        return StabilityControlStatus_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void StabilityControlStatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment StabilityControlStatus_free$address() {
        return StabilityControlStatus_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void StabilityControlStatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void StabilityControlStatus_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = StabilityControlStatus_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StabilityControlStatus_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StabilityControlStatus_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("StabilityControlStatus_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int StabilityControlStatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor StabilityControlStatus_print$descriptor() {
        return StabilityControlStatus_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int StabilityControlStatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle StabilityControlStatus_print$handle() {
        return StabilityControlStatus_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int StabilityControlStatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment StabilityControlStatus_print$address() {
        return StabilityControlStatus_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int StabilityControlStatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int StabilityControlStatus_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = StabilityControlStatus_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StabilityControlStatus_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StabilityControlStatus_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("StabilityControlStatus_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int StabilityControlStatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor StabilityControlStatus_constraint$descriptor() {
        return StabilityControlStatus_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int StabilityControlStatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle StabilityControlStatus_constraint$handle() {
        return StabilityControlStatus_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int StabilityControlStatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment StabilityControlStatus_constraint$address() {
        return StabilityControlStatus_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int StabilityControlStatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int StabilityControlStatus_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = StabilityControlStatus_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StabilityControlStatus_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StabilityControlStatus_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("StabilityControlStatus_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t StabilityControlStatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor StabilityControlStatus_decode_ber$descriptor() {
        return StabilityControlStatus_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t StabilityControlStatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle StabilityControlStatus_decode_ber$handle() {
        return StabilityControlStatus_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t StabilityControlStatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment StabilityControlStatus_decode_ber$address() {
        return StabilityControlStatus_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t StabilityControlStatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment StabilityControlStatus_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = StabilityControlStatus_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StabilityControlStatus_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StabilityControlStatus_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("StabilityControlStatus_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor StabilityControlStatus_encode_der$descriptor() {
        return StabilityControlStatus_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle StabilityControlStatus_encode_der$handle() {
        return StabilityControlStatus_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment StabilityControlStatus_encode_der$address() {
        return StabilityControlStatus_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment StabilityControlStatus_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = StabilityControlStatus_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StabilityControlStatus_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StabilityControlStatus_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("StabilityControlStatus_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t StabilityControlStatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor StabilityControlStatus_decode_xer$descriptor() {
        return StabilityControlStatus_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t StabilityControlStatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle StabilityControlStatus_decode_xer$handle() {
        return StabilityControlStatus_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t StabilityControlStatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment StabilityControlStatus_decode_xer$address() {
        return StabilityControlStatus_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t StabilityControlStatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment StabilityControlStatus_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = StabilityControlStatus_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StabilityControlStatus_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StabilityControlStatus_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("StabilityControlStatus_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor StabilityControlStatus_encode_xer$descriptor() {
        return StabilityControlStatus_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle StabilityControlStatus_encode_xer$handle() {
        return StabilityControlStatus_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment StabilityControlStatus_encode_xer$address() {
        return StabilityControlStatus_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment StabilityControlStatus_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = StabilityControlStatus_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StabilityControlStatus_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StabilityControlStatus_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("StabilityControlStatus_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor StabilityControlStatus_encode_jer$descriptor() {
        return StabilityControlStatus_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle StabilityControlStatus_encode_jer$handle() {
        return StabilityControlStatus_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment StabilityControlStatus_encode_jer$address() {
        return StabilityControlStatus_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment StabilityControlStatus_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = StabilityControlStatus_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StabilityControlStatus_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StabilityControlStatus_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("StabilityControlStatus_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t StabilityControlStatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor StabilityControlStatus_decode_oer$descriptor() {
        return StabilityControlStatus_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t StabilityControlStatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle StabilityControlStatus_decode_oer$handle() {
        return StabilityControlStatus_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t StabilityControlStatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment StabilityControlStatus_decode_oer$address() {
        return StabilityControlStatus_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t StabilityControlStatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment StabilityControlStatus_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = StabilityControlStatus_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StabilityControlStatus_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StabilityControlStatus_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("StabilityControlStatus_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor StabilityControlStatus_encode_oer$descriptor() {
        return StabilityControlStatus_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle StabilityControlStatus_encode_oer$handle() {
        return StabilityControlStatus_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment StabilityControlStatus_encode_oer$address() {
        return StabilityControlStatus_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment StabilityControlStatus_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = StabilityControlStatus_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StabilityControlStatus_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StabilityControlStatus_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("StabilityControlStatus_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t StabilityControlStatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor StabilityControlStatus_decode_uper$descriptor() {
        return StabilityControlStatus_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t StabilityControlStatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle StabilityControlStatus_decode_uper$handle() {
        return StabilityControlStatus_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t StabilityControlStatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment StabilityControlStatus_decode_uper$address() {
        return StabilityControlStatus_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t StabilityControlStatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment StabilityControlStatus_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = StabilityControlStatus_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StabilityControlStatus_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StabilityControlStatus_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("StabilityControlStatus_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor StabilityControlStatus_encode_uper$descriptor() {
        return StabilityControlStatus_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle StabilityControlStatus_encode_uper$handle() {
        return StabilityControlStatus_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment StabilityControlStatus_encode_uper$address() {
        return StabilityControlStatus_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment StabilityControlStatus_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = StabilityControlStatus_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StabilityControlStatus_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StabilityControlStatus_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("StabilityControlStatus_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t StabilityControlStatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor StabilityControlStatus_decode_aper$descriptor() {
        return StabilityControlStatus_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t StabilityControlStatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle StabilityControlStatus_decode_aper$handle() {
        return StabilityControlStatus_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t StabilityControlStatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment StabilityControlStatus_decode_aper$address() {
        return StabilityControlStatus_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t StabilityControlStatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment StabilityControlStatus_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = StabilityControlStatus_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StabilityControlStatus_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class StabilityControlStatus_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("StabilityControlStatus_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor StabilityControlStatus_encode_aper$descriptor() {
        return StabilityControlStatus_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle StabilityControlStatus_encode_aper$handle() {
        return StabilityControlStatus_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment StabilityControlStatus_encode_aper$address() {
        return StabilityControlStatus_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t StabilityControlStatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment StabilityControlStatus_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = StabilityControlStatus_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("StabilityControlStatus_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int BrakeBoostApplied_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum BrakeBoostApplied.BrakeBoostApplied_unavailable = 0
     * }
     */
    public static int BrakeBoostApplied_unavailable() {
        return BrakeBoostApplied_unavailable;
    }
    private static final int BrakeBoostApplied_off = (int)1L;
    /**
     * {@snippet lang=c :
     * enum BrakeBoostApplied.BrakeBoostApplied_off = 1
     * }
     */
    public static int BrakeBoostApplied_off() {
        return BrakeBoostApplied_off;
    }
    private static final int BrakeBoostApplied_on = (int)2L;
    /**
     * {@snippet lang=c :
     * enum BrakeBoostApplied.BrakeBoostApplied_on = 2
     * }
     */
    public static int BrakeBoostApplied_on() {
        return BrakeBoostApplied_on;
    }
    /**
     * {@snippet lang=c :
     * typedef long BrakeBoostApplied_t
     * }
     */
    public static final OfLong BrakeBoostApplied_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_BrakeBoostApplied_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_BrakeBoostApplied_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_BrakeBoostApplied_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_BrakeBoostApplied_constr_1$layout() {
        return asn_PER_type_BrakeBoostApplied_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_BrakeBoostApplied_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_BrakeBoostApplied_constr_1() {
        return asn_PER_type_BrakeBoostApplied_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_BrakeBoostApplied_constr_1
     * }
     */
    public static void asn_PER_type_BrakeBoostApplied_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_BrakeBoostApplied_constr_1$constants.SEGMENT, 0L, asn_PER_type_BrakeBoostApplied_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_BrakeBoostApplied$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_BrakeBoostApplied").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BrakeBoostApplied
     * }
     */
    public static GroupLayout asn_DEF_BrakeBoostApplied$layout() {
        return asn_DEF_BrakeBoostApplied$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BrakeBoostApplied
     * }
     */
    public static MemorySegment asn_DEF_BrakeBoostApplied() {
        return asn_DEF_BrakeBoostApplied$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BrakeBoostApplied
     * }
     */
    public static void asn_DEF_BrakeBoostApplied(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_BrakeBoostApplied$constants.SEGMENT, 0L, asn_DEF_BrakeBoostApplied$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_BrakeBoostApplied_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_BrakeBoostApplied_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_BrakeBoostApplied_specs_1
     * }
     */
    public static GroupLayout asn_SPC_BrakeBoostApplied_specs_1$layout() {
        return asn_SPC_BrakeBoostApplied_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_BrakeBoostApplied_specs_1
     * }
     */
    public static MemorySegment asn_SPC_BrakeBoostApplied_specs_1() {
        return asn_SPC_BrakeBoostApplied_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_BrakeBoostApplied_specs_1
     * }
     */
    public static void asn_SPC_BrakeBoostApplied_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_BrakeBoostApplied_specs_1$constants.SEGMENT, 0L, asn_SPC_BrakeBoostApplied_specs_1$constants.LAYOUT.byteSize());
    }

    private static class BrakeBoostApplied_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeBoostApplied_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BrakeBoostApplied_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor BrakeBoostApplied_free$descriptor() {
        return BrakeBoostApplied_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BrakeBoostApplied_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle BrakeBoostApplied_free$handle() {
        return BrakeBoostApplied_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BrakeBoostApplied_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment BrakeBoostApplied_free$address() {
        return BrakeBoostApplied_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BrakeBoostApplied_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void BrakeBoostApplied_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = BrakeBoostApplied_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeBoostApplied_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeBoostApplied_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeBoostApplied_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int BrakeBoostApplied_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BrakeBoostApplied_print$descriptor() {
        return BrakeBoostApplied_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int BrakeBoostApplied_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BrakeBoostApplied_print$handle() {
        return BrakeBoostApplied_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int BrakeBoostApplied_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeBoostApplied_print$address() {
        return BrakeBoostApplied_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int BrakeBoostApplied_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int BrakeBoostApplied_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = BrakeBoostApplied_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeBoostApplied_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeBoostApplied_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeBoostApplied_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int BrakeBoostApplied_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor BrakeBoostApplied_constraint$descriptor() {
        return BrakeBoostApplied_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int BrakeBoostApplied_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle BrakeBoostApplied_constraint$handle() {
        return BrakeBoostApplied_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int BrakeBoostApplied_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment BrakeBoostApplied_constraint$address() {
        return BrakeBoostApplied_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int BrakeBoostApplied_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int BrakeBoostApplied_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = BrakeBoostApplied_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeBoostApplied_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeBoostApplied_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeBoostApplied_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeBoostApplied_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor BrakeBoostApplied_decode_ber$descriptor() {
        return BrakeBoostApplied_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeBoostApplied_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle BrakeBoostApplied_decode_ber$handle() {
        return BrakeBoostApplied_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeBoostApplied_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment BrakeBoostApplied_decode_ber$address() {
        return BrakeBoostApplied_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeBoostApplied_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment BrakeBoostApplied_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = BrakeBoostApplied_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeBoostApplied_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeBoostApplied_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeBoostApplied_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BrakeBoostApplied_encode_der$descriptor() {
        return BrakeBoostApplied_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BrakeBoostApplied_encode_der$handle() {
        return BrakeBoostApplied_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeBoostApplied_encode_der$address() {
        return BrakeBoostApplied_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeBoostApplied_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = BrakeBoostApplied_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeBoostApplied_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeBoostApplied_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeBoostApplied_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeBoostApplied_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor BrakeBoostApplied_decode_xer$descriptor() {
        return BrakeBoostApplied_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeBoostApplied_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle BrakeBoostApplied_decode_xer$handle() {
        return BrakeBoostApplied_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeBoostApplied_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment BrakeBoostApplied_decode_xer$address() {
        return BrakeBoostApplied_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeBoostApplied_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment BrakeBoostApplied_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = BrakeBoostApplied_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeBoostApplied_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeBoostApplied_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeBoostApplied_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BrakeBoostApplied_encode_xer$descriptor() {
        return BrakeBoostApplied_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BrakeBoostApplied_encode_xer$handle() {
        return BrakeBoostApplied_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeBoostApplied_encode_xer$address() {
        return BrakeBoostApplied_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeBoostApplied_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = BrakeBoostApplied_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeBoostApplied_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeBoostApplied_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeBoostApplied_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BrakeBoostApplied_encode_jer$descriptor() {
        return BrakeBoostApplied_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BrakeBoostApplied_encode_jer$handle() {
        return BrakeBoostApplied_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeBoostApplied_encode_jer$address() {
        return BrakeBoostApplied_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeBoostApplied_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = BrakeBoostApplied_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeBoostApplied_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeBoostApplied_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeBoostApplied_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeBoostApplied_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor BrakeBoostApplied_decode_oer$descriptor() {
        return BrakeBoostApplied_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeBoostApplied_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle BrakeBoostApplied_decode_oer$handle() {
        return BrakeBoostApplied_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeBoostApplied_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment BrakeBoostApplied_decode_oer$address() {
        return BrakeBoostApplied_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeBoostApplied_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment BrakeBoostApplied_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = BrakeBoostApplied_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeBoostApplied_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeBoostApplied_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeBoostApplied_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BrakeBoostApplied_encode_oer$descriptor() {
        return BrakeBoostApplied_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BrakeBoostApplied_encode_oer$handle() {
        return BrakeBoostApplied_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeBoostApplied_encode_oer$address() {
        return BrakeBoostApplied_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BrakeBoostApplied_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = BrakeBoostApplied_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeBoostApplied_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeBoostApplied_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeBoostApplied_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeBoostApplied_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor BrakeBoostApplied_decode_uper$descriptor() {
        return BrakeBoostApplied_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeBoostApplied_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle BrakeBoostApplied_decode_uper$handle() {
        return BrakeBoostApplied_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeBoostApplied_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment BrakeBoostApplied_decode_uper$address() {
        return BrakeBoostApplied_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeBoostApplied_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment BrakeBoostApplied_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = BrakeBoostApplied_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeBoostApplied_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeBoostApplied_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeBoostApplied_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor BrakeBoostApplied_encode_uper$descriptor() {
        return BrakeBoostApplied_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle BrakeBoostApplied_encode_uper$handle() {
        return BrakeBoostApplied_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment BrakeBoostApplied_encode_uper$address() {
        return BrakeBoostApplied_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment BrakeBoostApplied_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = BrakeBoostApplied_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeBoostApplied_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeBoostApplied_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeBoostApplied_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeBoostApplied_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor BrakeBoostApplied_decode_aper$descriptor() {
        return BrakeBoostApplied_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeBoostApplied_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle BrakeBoostApplied_decode_aper$handle() {
        return BrakeBoostApplied_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeBoostApplied_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment BrakeBoostApplied_decode_aper$address() {
        return BrakeBoostApplied_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BrakeBoostApplied_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment BrakeBoostApplied_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = BrakeBoostApplied_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeBoostApplied_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BrakeBoostApplied_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BrakeBoostApplied_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor BrakeBoostApplied_encode_aper$descriptor() {
        return BrakeBoostApplied_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle BrakeBoostApplied_encode_aper$handle() {
        return BrakeBoostApplied_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment BrakeBoostApplied_encode_aper$address() {
        return BrakeBoostApplied_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BrakeBoostApplied_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment BrakeBoostApplied_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = BrakeBoostApplied_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BrakeBoostApplied_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int AuxiliaryBrakeStatus_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum AuxiliaryBrakeStatus.AuxiliaryBrakeStatus_unavailable = 0
     * }
     */
    public static int AuxiliaryBrakeStatus_unavailable() {
        return AuxiliaryBrakeStatus_unavailable;
    }
    private static final int AuxiliaryBrakeStatus_off = (int)1L;
    /**
     * {@snippet lang=c :
     * enum AuxiliaryBrakeStatus.AuxiliaryBrakeStatus_off = 1
     * }
     */
    public static int AuxiliaryBrakeStatus_off() {
        return AuxiliaryBrakeStatus_off;
    }
    private static final int AuxiliaryBrakeStatus_on = (int)2L;
    /**
     * {@snippet lang=c :
     * enum AuxiliaryBrakeStatus.AuxiliaryBrakeStatus_on = 2
     * }
     */
    public static int AuxiliaryBrakeStatus_on() {
        return AuxiliaryBrakeStatus_on;
    }
    private static final int AuxiliaryBrakeStatus_reserved = (int)3L;
    /**
     * {@snippet lang=c :
     * enum AuxiliaryBrakeStatus.AuxiliaryBrakeStatus_reserved = 3
     * }
     */
    public static int AuxiliaryBrakeStatus_reserved() {
        return AuxiliaryBrakeStatus_reserved;
    }
    /**
     * {@snippet lang=c :
     * typedef long AuxiliaryBrakeStatus_t
     * }
     */
    public static final OfLong AuxiliaryBrakeStatus_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_AuxiliaryBrakeStatus_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_AuxiliaryBrakeStatus_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AuxiliaryBrakeStatus_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_AuxiliaryBrakeStatus_constr_1$layout() {
        return asn_PER_type_AuxiliaryBrakeStatus_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AuxiliaryBrakeStatus_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_AuxiliaryBrakeStatus_constr_1() {
        return asn_PER_type_AuxiliaryBrakeStatus_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_AuxiliaryBrakeStatus_constr_1
     * }
     */
    public static void asn_PER_type_AuxiliaryBrakeStatus_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_AuxiliaryBrakeStatus_constr_1$constants.SEGMENT, 0L, asn_PER_type_AuxiliaryBrakeStatus_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_AuxiliaryBrakeStatus$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_AuxiliaryBrakeStatus").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AuxiliaryBrakeStatus
     * }
     */
    public static GroupLayout asn_DEF_AuxiliaryBrakeStatus$layout() {
        return asn_DEF_AuxiliaryBrakeStatus$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AuxiliaryBrakeStatus
     * }
     */
    public static MemorySegment asn_DEF_AuxiliaryBrakeStatus() {
        return asn_DEF_AuxiliaryBrakeStatus$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_AuxiliaryBrakeStatus
     * }
     */
    public static void asn_DEF_AuxiliaryBrakeStatus(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_AuxiliaryBrakeStatus$constants.SEGMENT, 0L, asn_DEF_AuxiliaryBrakeStatus$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_AuxiliaryBrakeStatus_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_AuxiliaryBrakeStatus_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_AuxiliaryBrakeStatus_specs_1
     * }
     */
    public static GroupLayout asn_SPC_AuxiliaryBrakeStatus_specs_1$layout() {
        return asn_SPC_AuxiliaryBrakeStatus_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_AuxiliaryBrakeStatus_specs_1
     * }
     */
    public static MemorySegment asn_SPC_AuxiliaryBrakeStatus_specs_1() {
        return asn_SPC_AuxiliaryBrakeStatus_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_AuxiliaryBrakeStatus_specs_1
     * }
     */
    public static void asn_SPC_AuxiliaryBrakeStatus_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_AuxiliaryBrakeStatus_specs_1$constants.SEGMENT, 0L, asn_SPC_AuxiliaryBrakeStatus_specs_1$constants.LAYOUT.byteSize());
    }

    private static class AuxiliaryBrakeStatus_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AuxiliaryBrakeStatus_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void AuxiliaryBrakeStatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor AuxiliaryBrakeStatus_free$descriptor() {
        return AuxiliaryBrakeStatus_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void AuxiliaryBrakeStatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle AuxiliaryBrakeStatus_free$handle() {
        return AuxiliaryBrakeStatus_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void AuxiliaryBrakeStatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_free$address() {
        return AuxiliaryBrakeStatus_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void AuxiliaryBrakeStatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void AuxiliaryBrakeStatus_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = AuxiliaryBrakeStatus_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AuxiliaryBrakeStatus_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AuxiliaryBrakeStatus_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AuxiliaryBrakeStatus_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AuxiliaryBrakeStatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AuxiliaryBrakeStatus_print$descriptor() {
        return AuxiliaryBrakeStatus_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AuxiliaryBrakeStatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AuxiliaryBrakeStatus_print$handle() {
        return AuxiliaryBrakeStatus_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AuxiliaryBrakeStatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_print$address() {
        return AuxiliaryBrakeStatus_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AuxiliaryBrakeStatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int AuxiliaryBrakeStatus_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AuxiliaryBrakeStatus_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AuxiliaryBrakeStatus_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AuxiliaryBrakeStatus_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AuxiliaryBrakeStatus_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int AuxiliaryBrakeStatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor AuxiliaryBrakeStatus_constraint$descriptor() {
        return AuxiliaryBrakeStatus_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int AuxiliaryBrakeStatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle AuxiliaryBrakeStatus_constraint$handle() {
        return AuxiliaryBrakeStatus_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int AuxiliaryBrakeStatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_constraint$address() {
        return AuxiliaryBrakeStatus_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int AuxiliaryBrakeStatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int AuxiliaryBrakeStatus_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = AuxiliaryBrakeStatus_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AuxiliaryBrakeStatus_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AuxiliaryBrakeStatus_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AuxiliaryBrakeStatus_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AuxiliaryBrakeStatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor AuxiliaryBrakeStatus_decode_ber$descriptor() {
        return AuxiliaryBrakeStatus_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AuxiliaryBrakeStatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle AuxiliaryBrakeStatus_decode_ber$handle() {
        return AuxiliaryBrakeStatus_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AuxiliaryBrakeStatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_decode_ber$address() {
        return AuxiliaryBrakeStatus_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AuxiliaryBrakeStatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = AuxiliaryBrakeStatus_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AuxiliaryBrakeStatus_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AuxiliaryBrakeStatus_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AuxiliaryBrakeStatus_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AuxiliaryBrakeStatus_encode_der$descriptor() {
        return AuxiliaryBrakeStatus_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AuxiliaryBrakeStatus_encode_der$handle() {
        return AuxiliaryBrakeStatus_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_encode_der$address() {
        return AuxiliaryBrakeStatus_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = AuxiliaryBrakeStatus_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AuxiliaryBrakeStatus_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AuxiliaryBrakeStatus_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AuxiliaryBrakeStatus_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AuxiliaryBrakeStatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor AuxiliaryBrakeStatus_decode_xer$descriptor() {
        return AuxiliaryBrakeStatus_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AuxiliaryBrakeStatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle AuxiliaryBrakeStatus_decode_xer$handle() {
        return AuxiliaryBrakeStatus_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AuxiliaryBrakeStatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_decode_xer$address() {
        return AuxiliaryBrakeStatus_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AuxiliaryBrakeStatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = AuxiliaryBrakeStatus_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AuxiliaryBrakeStatus_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AuxiliaryBrakeStatus_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AuxiliaryBrakeStatus_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AuxiliaryBrakeStatus_encode_xer$descriptor() {
        return AuxiliaryBrakeStatus_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AuxiliaryBrakeStatus_encode_xer$handle() {
        return AuxiliaryBrakeStatus_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_encode_xer$address() {
        return AuxiliaryBrakeStatus_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = AuxiliaryBrakeStatus_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AuxiliaryBrakeStatus_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AuxiliaryBrakeStatus_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AuxiliaryBrakeStatus_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AuxiliaryBrakeStatus_encode_jer$descriptor() {
        return AuxiliaryBrakeStatus_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AuxiliaryBrakeStatus_encode_jer$handle() {
        return AuxiliaryBrakeStatus_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_encode_jer$address() {
        return AuxiliaryBrakeStatus_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = AuxiliaryBrakeStatus_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AuxiliaryBrakeStatus_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AuxiliaryBrakeStatus_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AuxiliaryBrakeStatus_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AuxiliaryBrakeStatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor AuxiliaryBrakeStatus_decode_oer$descriptor() {
        return AuxiliaryBrakeStatus_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AuxiliaryBrakeStatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle AuxiliaryBrakeStatus_decode_oer$handle() {
        return AuxiliaryBrakeStatus_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AuxiliaryBrakeStatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_decode_oer$address() {
        return AuxiliaryBrakeStatus_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AuxiliaryBrakeStatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = AuxiliaryBrakeStatus_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AuxiliaryBrakeStatus_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AuxiliaryBrakeStatus_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AuxiliaryBrakeStatus_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor AuxiliaryBrakeStatus_encode_oer$descriptor() {
        return AuxiliaryBrakeStatus_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle AuxiliaryBrakeStatus_encode_oer$handle() {
        return AuxiliaryBrakeStatus_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_encode_oer$address() {
        return AuxiliaryBrakeStatus_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AuxiliaryBrakeStatus_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AuxiliaryBrakeStatus_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AuxiliaryBrakeStatus_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AuxiliaryBrakeStatus_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AuxiliaryBrakeStatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor AuxiliaryBrakeStatus_decode_uper$descriptor() {
        return AuxiliaryBrakeStatus_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AuxiliaryBrakeStatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle AuxiliaryBrakeStatus_decode_uper$handle() {
        return AuxiliaryBrakeStatus_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AuxiliaryBrakeStatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_decode_uper$address() {
        return AuxiliaryBrakeStatus_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AuxiliaryBrakeStatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AuxiliaryBrakeStatus_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AuxiliaryBrakeStatus_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AuxiliaryBrakeStatus_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AuxiliaryBrakeStatus_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor AuxiliaryBrakeStatus_encode_uper$descriptor() {
        return AuxiliaryBrakeStatus_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle AuxiliaryBrakeStatus_encode_uper$handle() {
        return AuxiliaryBrakeStatus_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_encode_uper$address() {
        return AuxiliaryBrakeStatus_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = AuxiliaryBrakeStatus_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AuxiliaryBrakeStatus_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AuxiliaryBrakeStatus_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AuxiliaryBrakeStatus_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t AuxiliaryBrakeStatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor AuxiliaryBrakeStatus_decode_aper$descriptor() {
        return AuxiliaryBrakeStatus_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t AuxiliaryBrakeStatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle AuxiliaryBrakeStatus_decode_aper$handle() {
        return AuxiliaryBrakeStatus_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t AuxiliaryBrakeStatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_decode_aper$address() {
        return AuxiliaryBrakeStatus_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t AuxiliaryBrakeStatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = AuxiliaryBrakeStatus_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AuxiliaryBrakeStatus_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class AuxiliaryBrakeStatus_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("AuxiliaryBrakeStatus_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor AuxiliaryBrakeStatus_encode_aper$descriptor() {
        return AuxiliaryBrakeStatus_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle AuxiliaryBrakeStatus_encode_aper$handle() {
        return AuxiliaryBrakeStatus_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_encode_aper$address() {
        return AuxiliaryBrakeStatus_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t AuxiliaryBrakeStatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment AuxiliaryBrakeStatus_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = AuxiliaryBrakeStatus_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("AuxiliaryBrakeStatus_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_BrakeSystemStatus$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_BrakeSystemStatus").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BrakeSystemStatus
     * }
     */
    public static GroupLayout asn_DEF_BrakeSystemStatus$layout() {
        return asn_DEF_BrakeSystemStatus$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BrakeSystemStatus
     * }
     */
    public static MemorySegment asn_DEF_BrakeSystemStatus() {
        return asn_DEF_BrakeSystemStatus$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BrakeSystemStatus
     * }
     */
    public static void asn_DEF_BrakeSystemStatus(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_BrakeSystemStatus$constants.SEGMENT, 0L, asn_DEF_BrakeSystemStatus$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_BrakeSystemStatus_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_BrakeSystemStatus_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_BrakeSystemStatus_specs_1
     * }
     */
    public static GroupLayout asn_SPC_BrakeSystemStatus_specs_1$layout() {
        return asn_SPC_BrakeSystemStatus_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_BrakeSystemStatus_specs_1
     * }
     */
    public static MemorySegment asn_SPC_BrakeSystemStatus_specs_1() {
        return asn_SPC_BrakeSystemStatus_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_BrakeSystemStatus_specs_1
     * }
     */
    public static void asn_SPC_BrakeSystemStatus_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_BrakeSystemStatus_specs_1$constants.SEGMENT, 0L, asn_SPC_BrakeSystemStatus_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_BrakeSystemStatus_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(6, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_BrakeSystemStatus_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 6 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BrakeSystemStatus_1[6]
     * }
     */
    public static SequenceLayout asn_MBR_BrakeSystemStatus_1$layout() {
        return asn_MBR_BrakeSystemStatus_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BrakeSystemStatus_1[6]
     * }
     */
    public static long[] asn_MBR_BrakeSystemStatus_1$dimensions() {
        return asn_MBR_BrakeSystemStatus_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BrakeSystemStatus_1[6]
     * }
     */
    public static MemorySegment asn_MBR_BrakeSystemStatus_1() {
        return asn_MBR_BrakeSystemStatus_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BrakeSystemStatus_1[6]
     * }
     */
    public static void asn_MBR_BrakeSystemStatus_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_BrakeSystemStatus_1$constants.SEGMENT, 0L, asn_MBR_BrakeSystemStatus_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BrakeSystemStatus_1[6]
     * }
     */
    public static MemorySegment asn_MBR_BrakeSystemStatus_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_BrakeSystemStatus_1$constants.HANDLE.invokeExact(asn_MBR_BrakeSystemStatus_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BrakeSystemStatus_1[6]
     * }
     */
    public static void asn_MBR_BrakeSystemStatus_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_BrakeSystemStatus_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef long VehicleWidth_t
     * }
     */
    public static final OfLong VehicleWidth_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_VehicleWidth_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_VehicleWidth_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VehicleWidth_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_VehicleWidth_constr_1$layout() {
        return asn_PER_type_VehicleWidth_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VehicleWidth_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_VehicleWidth_constr_1() {
        return asn_PER_type_VehicleWidth_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VehicleWidth_constr_1
     * }
     */
    public static void asn_PER_type_VehicleWidth_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_VehicleWidth_constr_1$constants.SEGMENT, 0L, asn_PER_type_VehicleWidth_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_VehicleWidth$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_VehicleWidth").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleWidth
     * }
     */
    public static GroupLayout asn_DEF_VehicleWidth$layout() {
        return asn_DEF_VehicleWidth$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleWidth
     * }
     */
    public static MemorySegment asn_DEF_VehicleWidth() {
        return asn_DEF_VehicleWidth$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleWidth
     * }
     */
    public static void asn_DEF_VehicleWidth(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_VehicleWidth$constants.SEGMENT, 0L, asn_DEF_VehicleWidth$constants.LAYOUT.byteSize());
    }

    private static class VehicleWidth_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleWidth_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void VehicleWidth_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor VehicleWidth_free$descriptor() {
        return VehicleWidth_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void VehicleWidth_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle VehicleWidth_free$handle() {
        return VehicleWidth_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void VehicleWidth_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment VehicleWidth_free$address() {
        return VehicleWidth_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void VehicleWidth_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void VehicleWidth_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = VehicleWidth_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleWidth_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleWidth_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleWidth_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int VehicleWidth_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleWidth_print$descriptor() {
        return VehicleWidth_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int VehicleWidth_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VehicleWidth_print$handle() {
        return VehicleWidth_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int VehicleWidth_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleWidth_print$address() {
        return VehicleWidth_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int VehicleWidth_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int VehicleWidth_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VehicleWidth_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleWidth_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleWidth_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleWidth_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int VehicleWidth_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleWidth_constraint$descriptor() {
        return VehicleWidth_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int VehicleWidth_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle VehicleWidth_constraint$handle() {
        return VehicleWidth_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int VehicleWidth_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment VehicleWidth_constraint$address() {
        return VehicleWidth_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int VehicleWidth_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int VehicleWidth_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = VehicleWidth_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleWidth_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleWidth_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleWidth_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleWidth_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor VehicleWidth_decode_ber$descriptor() {
        return VehicleWidth_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleWidth_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle VehicleWidth_decode_ber$handle() {
        return VehicleWidth_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleWidth_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment VehicleWidth_decode_ber$address() {
        return VehicleWidth_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleWidth_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment VehicleWidth_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = VehicleWidth_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleWidth_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleWidth_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleWidth_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleWidth_encode_der$descriptor() {
        return VehicleWidth_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VehicleWidth_encode_der$handle() {
        return VehicleWidth_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleWidth_encode_der$address() {
        return VehicleWidth_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleWidth_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = VehicleWidth_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleWidth_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleWidth_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleWidth_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleWidth_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor VehicleWidth_decode_xer$descriptor() {
        return VehicleWidth_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleWidth_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle VehicleWidth_decode_xer$handle() {
        return VehicleWidth_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleWidth_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment VehicleWidth_decode_xer$address() {
        return VehicleWidth_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleWidth_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment VehicleWidth_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = VehicleWidth_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleWidth_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleWidth_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleWidth_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleWidth_encode_xer$descriptor() {
        return VehicleWidth_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VehicleWidth_encode_xer$handle() {
        return VehicleWidth_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleWidth_encode_xer$address() {
        return VehicleWidth_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleWidth_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = VehicleWidth_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleWidth_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleWidth_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleWidth_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleWidth_encode_jer$descriptor() {
        return VehicleWidth_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VehicleWidth_encode_jer$handle() {
        return VehicleWidth_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleWidth_encode_jer$address() {
        return VehicleWidth_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleWidth_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = VehicleWidth_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleWidth_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleWidth_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleWidth_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleWidth_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor VehicleWidth_decode_oer$descriptor() {
        return VehicleWidth_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleWidth_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle VehicleWidth_decode_oer$handle() {
        return VehicleWidth_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleWidth_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment VehicleWidth_decode_oer$address() {
        return VehicleWidth_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleWidth_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment VehicleWidth_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = VehicleWidth_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleWidth_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleWidth_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleWidth_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleWidth_encode_oer$descriptor() {
        return VehicleWidth_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VehicleWidth_encode_oer$handle() {
        return VehicleWidth_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleWidth_encode_oer$address() {
        return VehicleWidth_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleWidth_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VehicleWidth_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleWidth_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleWidth_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleWidth_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleWidth_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor VehicleWidth_decode_uper$descriptor() {
        return VehicleWidth_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleWidth_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle VehicleWidth_decode_uper$handle() {
        return VehicleWidth_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleWidth_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VehicleWidth_decode_uper$address() {
        return VehicleWidth_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleWidth_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VehicleWidth_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VehicleWidth_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleWidth_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleWidth_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleWidth_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor VehicleWidth_encode_uper$descriptor() {
        return VehicleWidth_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle VehicleWidth_encode_uper$handle() {
        return VehicleWidth_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VehicleWidth_encode_uper$address() {
        return VehicleWidth_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VehicleWidth_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = VehicleWidth_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleWidth_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleWidth_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleWidth_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleWidth_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor VehicleWidth_decode_aper$descriptor() {
        return VehicleWidth_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleWidth_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle VehicleWidth_decode_aper$handle() {
        return VehicleWidth_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleWidth_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VehicleWidth_decode_aper$address() {
        return VehicleWidth_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleWidth_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VehicleWidth_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VehicleWidth_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleWidth_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleWidth_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleWidth_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor VehicleWidth_encode_aper$descriptor() {
        return VehicleWidth_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle VehicleWidth_encode_aper$handle() {
        return VehicleWidth_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VehicleWidth_encode_aper$address() {
        return VehicleWidth_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleWidth_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VehicleWidth_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = VehicleWidth_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleWidth_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long VehicleLength_t
     * }
     */
    public static final OfLong VehicleLength_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_VehicleLength_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_VehicleLength_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VehicleLength_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_VehicleLength_constr_1$layout() {
        return asn_PER_type_VehicleLength_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VehicleLength_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_VehicleLength_constr_1() {
        return asn_PER_type_VehicleLength_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VehicleLength_constr_1
     * }
     */
    public static void asn_PER_type_VehicleLength_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_VehicleLength_constr_1$constants.SEGMENT, 0L, asn_PER_type_VehicleLength_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_VehicleLength$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_VehicleLength").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleLength
     * }
     */
    public static GroupLayout asn_DEF_VehicleLength$layout() {
        return asn_DEF_VehicleLength$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleLength
     * }
     */
    public static MemorySegment asn_DEF_VehicleLength() {
        return asn_DEF_VehicleLength$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleLength
     * }
     */
    public static void asn_DEF_VehicleLength(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_VehicleLength$constants.SEGMENT, 0L, asn_DEF_VehicleLength$constants.LAYOUT.byteSize());
    }

    private static class VehicleLength_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleLength_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void VehicleLength_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor VehicleLength_free$descriptor() {
        return VehicleLength_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void VehicleLength_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle VehicleLength_free$handle() {
        return VehicleLength_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void VehicleLength_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment VehicleLength_free$address() {
        return VehicleLength_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void VehicleLength_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void VehicleLength_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = VehicleLength_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleLength_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleLength_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleLength_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int VehicleLength_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleLength_print$descriptor() {
        return VehicleLength_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int VehicleLength_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VehicleLength_print$handle() {
        return VehicleLength_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int VehicleLength_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleLength_print$address() {
        return VehicleLength_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int VehicleLength_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int VehicleLength_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VehicleLength_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleLength_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleLength_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleLength_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int VehicleLength_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleLength_constraint$descriptor() {
        return VehicleLength_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int VehicleLength_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle VehicleLength_constraint$handle() {
        return VehicleLength_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int VehicleLength_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment VehicleLength_constraint$address() {
        return VehicleLength_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int VehicleLength_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int VehicleLength_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = VehicleLength_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleLength_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleLength_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleLength_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleLength_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor VehicleLength_decode_ber$descriptor() {
        return VehicleLength_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleLength_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle VehicleLength_decode_ber$handle() {
        return VehicleLength_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleLength_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment VehicleLength_decode_ber$address() {
        return VehicleLength_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleLength_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment VehicleLength_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = VehicleLength_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleLength_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleLength_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleLength_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleLength_encode_der$descriptor() {
        return VehicleLength_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VehicleLength_encode_der$handle() {
        return VehicleLength_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleLength_encode_der$address() {
        return VehicleLength_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleLength_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = VehicleLength_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleLength_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleLength_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleLength_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleLength_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor VehicleLength_decode_xer$descriptor() {
        return VehicleLength_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleLength_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle VehicleLength_decode_xer$handle() {
        return VehicleLength_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleLength_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment VehicleLength_decode_xer$address() {
        return VehicleLength_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleLength_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment VehicleLength_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = VehicleLength_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleLength_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleLength_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleLength_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleLength_encode_xer$descriptor() {
        return VehicleLength_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VehicleLength_encode_xer$handle() {
        return VehicleLength_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleLength_encode_xer$address() {
        return VehicleLength_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleLength_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = VehicleLength_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleLength_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleLength_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleLength_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleLength_encode_jer$descriptor() {
        return VehicleLength_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VehicleLength_encode_jer$handle() {
        return VehicleLength_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleLength_encode_jer$address() {
        return VehicleLength_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleLength_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = VehicleLength_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleLength_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleLength_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleLength_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleLength_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor VehicleLength_decode_oer$descriptor() {
        return VehicleLength_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleLength_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle VehicleLength_decode_oer$handle() {
        return VehicleLength_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleLength_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment VehicleLength_decode_oer$address() {
        return VehicleLength_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleLength_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment VehicleLength_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = VehicleLength_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleLength_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleLength_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleLength_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleLength_encode_oer$descriptor() {
        return VehicleLength_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VehicleLength_encode_oer$handle() {
        return VehicleLength_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleLength_encode_oer$address() {
        return VehicleLength_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleLength_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VehicleLength_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleLength_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleLength_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleLength_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleLength_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor VehicleLength_decode_uper$descriptor() {
        return VehicleLength_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleLength_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle VehicleLength_decode_uper$handle() {
        return VehicleLength_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleLength_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VehicleLength_decode_uper$address() {
        return VehicleLength_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleLength_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VehicleLength_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VehicleLength_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleLength_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleLength_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleLength_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor VehicleLength_encode_uper$descriptor() {
        return VehicleLength_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle VehicleLength_encode_uper$handle() {
        return VehicleLength_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VehicleLength_encode_uper$address() {
        return VehicleLength_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VehicleLength_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = VehicleLength_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleLength_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleLength_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleLength_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleLength_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor VehicleLength_decode_aper$descriptor() {
        return VehicleLength_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleLength_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle VehicleLength_decode_aper$handle() {
        return VehicleLength_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleLength_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VehicleLength_decode_aper$address() {
        return VehicleLength_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleLength_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VehicleLength_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VehicleLength_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleLength_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleLength_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleLength_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor VehicleLength_encode_aper$descriptor() {
        return VehicleLength_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle VehicleLength_encode_aper$handle() {
        return VehicleLength_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VehicleLength_encode_aper$address() {
        return VehicleLength_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleLength_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VehicleLength_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = VehicleLength_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleLength_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_VehicleSize$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_VehicleSize").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleSize
     * }
     */
    public static GroupLayout asn_DEF_VehicleSize$layout() {
        return asn_DEF_VehicleSize$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleSize
     * }
     */
    public static MemorySegment asn_DEF_VehicleSize() {
        return asn_DEF_VehicleSize$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleSize
     * }
     */
    public static void asn_DEF_VehicleSize(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_VehicleSize$constants.SEGMENT, 0L, asn_DEF_VehicleSize$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_VehicleSize_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_VehicleSize_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_VehicleSize_specs_1
     * }
     */
    public static GroupLayout asn_SPC_VehicleSize_specs_1$layout() {
        return asn_SPC_VehicleSize_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_VehicleSize_specs_1
     * }
     */
    public static MemorySegment asn_SPC_VehicleSize_specs_1() {
        return asn_SPC_VehicleSize_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_VehicleSize_specs_1
     * }
     */
    public static void asn_SPC_VehicleSize_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_VehicleSize_specs_1$constants.SEGMENT, 0L, asn_SPC_VehicleSize_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_VehicleSize_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_VehicleSize_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleSize_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_VehicleSize_1$layout() {
        return asn_MBR_VehicleSize_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleSize_1[2]
     * }
     */
    public static long[] asn_MBR_VehicleSize_1$dimensions() {
        return asn_MBR_VehicleSize_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleSize_1[2]
     * }
     */
    public static MemorySegment asn_MBR_VehicleSize_1() {
        return asn_MBR_VehicleSize_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleSize_1[2]
     * }
     */
    public static void asn_MBR_VehicleSize_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_VehicleSize_1$constants.SEGMENT, 0L, asn_MBR_VehicleSize_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleSize_1[2]
     * }
     */
    public static MemorySegment asn_MBR_VehicleSize_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_VehicleSize_1$constants.HANDLE.invokeExact(asn_MBR_VehicleSize_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleSize_1[2]
     * }
     */
    public static void asn_MBR_VehicleSize_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_VehicleSize_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_BSMcoreData$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_BSMcoreData").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BSMcoreData
     * }
     */
    public static GroupLayout asn_DEF_BSMcoreData$layout() {
        return asn_DEF_BSMcoreData$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BSMcoreData
     * }
     */
    public static MemorySegment asn_DEF_BSMcoreData() {
        return asn_DEF_BSMcoreData$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BSMcoreData
     * }
     */
    public static void asn_DEF_BSMcoreData(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_BSMcoreData$constants.SEGMENT, 0L, asn_DEF_BSMcoreData$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_BSMcoreData_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_BSMcoreData_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_BSMcoreData_specs_1
     * }
     */
    public static GroupLayout asn_SPC_BSMcoreData_specs_1$layout() {
        return asn_SPC_BSMcoreData_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_BSMcoreData_specs_1
     * }
     */
    public static MemorySegment asn_SPC_BSMcoreData_specs_1() {
        return asn_SPC_BSMcoreData_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_BSMcoreData_specs_1
     * }
     */
    public static void asn_SPC_BSMcoreData_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_BSMcoreData_specs_1$constants.SEGMENT, 0L, asn_SPC_BSMcoreData_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_BSMcoreData_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(14, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_BSMcoreData_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 14 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BSMcoreData_1[14]
     * }
     */
    public static SequenceLayout asn_MBR_BSMcoreData_1$layout() {
        return asn_MBR_BSMcoreData_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BSMcoreData_1[14]
     * }
     */
    public static long[] asn_MBR_BSMcoreData_1$dimensions() {
        return asn_MBR_BSMcoreData_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BSMcoreData_1[14]
     * }
     */
    public static MemorySegment asn_MBR_BSMcoreData_1() {
        return asn_MBR_BSMcoreData_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BSMcoreData_1[14]
     * }
     */
    public static void asn_MBR_BSMcoreData_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_BSMcoreData_1$constants.SEGMENT, 0L, asn_MBR_BSMcoreData_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BSMcoreData_1[14]
     * }
     */
    public static MemorySegment asn_MBR_BSMcoreData_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_BSMcoreData_1$constants.HANDLE.invokeExact(asn_MBR_BSMcoreData_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BSMcoreData_1[14]
     * }
     */
    public static void asn_MBR_BSMcoreData_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_BSMcoreData_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_set_add {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_set_add");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int asn_set_add(void *asn_set_of_x, void *ptr)
     * }
     */
    public static FunctionDescriptor asn_set_add$descriptor() {
        return asn_set_add.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int asn_set_add(void *asn_set_of_x, void *ptr)
     * }
     */
    public static MethodHandle asn_set_add$handle() {
        return asn_set_add.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int asn_set_add(void *asn_set_of_x, void *ptr)
     * }
     */
    public static MemorySegment asn_set_add$address() {
        return asn_set_add.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int asn_set_add(void *asn_set_of_x, void *ptr)
     * }
     */
    public static int asn_set_add(MemorySegment asn_set_of_x, MemorySegment ptr) {
        var mh$ = asn_set_add.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_set_add", asn_set_of_x, ptr);
            }
            return (int)mh$.invokeExact(asn_set_of_x, ptr);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_set_del {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_set_del");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void asn_set_del(void *asn_set_of_x, int number, int _do_free)
     * }
     */
    public static FunctionDescriptor asn_set_del$descriptor() {
        return asn_set_del.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void asn_set_del(void *asn_set_of_x, int number, int _do_free)
     * }
     */
    public static MethodHandle asn_set_del$handle() {
        return asn_set_del.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void asn_set_del(void *asn_set_of_x, int number, int _do_free)
     * }
     */
    public static MemorySegment asn_set_del$address() {
        return asn_set_del.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void asn_set_del(void *asn_set_of_x, int number, int _do_free)
     * }
     */
    public static void asn_set_del(MemorySegment asn_set_of_x, int number, int _do_free) {
        var mh$ = asn_set_del.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_set_del", asn_set_of_x, number, _do_free);
            }
            mh$.invokeExact(asn_set_of_x, number, _do_free);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_set_empty {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_set_empty");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void asn_set_empty(void *asn_set_of_x)
     * }
     */
    public static FunctionDescriptor asn_set_empty$descriptor() {
        return asn_set_empty.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void asn_set_empty(void *asn_set_of_x)
     * }
     */
    public static MethodHandle asn_set_empty$handle() {
        return asn_set_empty.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void asn_set_empty(void *asn_set_of_x)
     * }
     */
    public static MemorySegment asn_set_empty$address() {
        return asn_set_empty.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void asn_set_empty(void *asn_set_of_x)
     * }
     */
    public static void asn_set_empty(MemorySegment asn_set_of_x) {
        var mh$ = asn_set_empty.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_set_empty", asn_set_of_x);
            }
            mh$.invokeExact(asn_set_of_x);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_sequence_del {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("asn_sequence_del");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void asn_sequence_del(void *asn_sequence_of_x, int number, int _do_free)
     * }
     */
    public static FunctionDescriptor asn_sequence_del$descriptor() {
        return asn_sequence_del.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void asn_sequence_del(void *asn_sequence_of_x, int number, int _do_free)
     * }
     */
    public static MethodHandle asn_sequence_del$handle() {
        return asn_sequence_del.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void asn_sequence_del(void *asn_sequence_of_x, int number, int _do_free)
     * }
     */
    public static MemorySegment asn_sequence_del$address() {
        return asn_sequence_del.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void asn_sequence_del(void *asn_sequence_of_x, int number, int _do_free)
     * }
     */
    public static void asn_sequence_del(MemorySegment asn_sequence_of_x, int number, int _do_free) {
        var mh$ = asn_sequence_del.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("asn_sequence_del", asn_sequence_of_x, number, _do_free);
            }
            mh$.invokeExact(asn_sequence_of_x, number, _do_free);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SET_OF_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SET_OF_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SET_OF_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor SET_OF_free$descriptor() {
        return SET_OF_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SET_OF_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle SET_OF_free$handle() {
        return SET_OF_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SET_OF_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment SET_OF_free$address() {
        return SET_OF_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SET_OF_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void SET_OF_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = SET_OF_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SET_OF_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SET_OF_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SET_OF_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SET_OF_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SET_OF_print$descriptor() {
        return SET_OF_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SET_OF_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SET_OF_print$handle() {
        return SET_OF_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SET_OF_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SET_OF_print$address() {
        return SET_OF_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SET_OF_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int SET_OF_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SET_OF_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SET_OF_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SET_OF_compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SET_OF_compare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SET_OF_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static FunctionDescriptor SET_OF_compare$descriptor() {
        return SET_OF_compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SET_OF_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static MethodHandle SET_OF_compare$handle() {
        return SET_OF_compare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SET_OF_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static MemorySegment SET_OF_compare$address() {
        return SET_OF_compare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SET_OF_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static int SET_OF_compare(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = SET_OF_compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SET_OF_compare", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SET_OF_copy {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SET_OF_copy");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SET_OF_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static FunctionDescriptor SET_OF_copy$descriptor() {
        return SET_OF_copy.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SET_OF_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static MethodHandle SET_OF_copy$handle() {
        return SET_OF_copy.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SET_OF_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static MemorySegment SET_OF_copy$address() {
        return SET_OF_copy.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SET_OF_copy(const struct asn_TYPE_descriptor_s *, void **, const void *)
     * }
     */
    public static int SET_OF_copy(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = SET_OF_copy.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SET_OF_copy", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SET_OF_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SET_OF_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SET_OF_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor SET_OF_constraint$descriptor() {
        return SET_OF_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SET_OF_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle SET_OF_constraint$handle() {
        return SET_OF_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SET_OF_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment SET_OF_constraint$address() {
        return SET_OF_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SET_OF_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int SET_OF_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SET_OF_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SET_OF_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SET_OF_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SET_OF_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor SET_OF_decode_ber$descriptor() {
        return SET_OF_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle SET_OF_decode_ber$handle() {
        return SET_OF_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SET_OF_decode_ber$address() {
        return SET_OF_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SET_OF_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = SET_OF_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SET_OF_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SET_OF_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SET_OF_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SET_OF_encode_der$descriptor() {
        return SET_OF_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SET_OF_encode_der$handle() {
        return SET_OF_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SET_OF_encode_der$address() {
        return SET_OF_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SET_OF_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SET_OF_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SET_OF_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SET_OF_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SET_OF_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SET_OF_decode_xer$descriptor() {
        return SET_OF_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle SET_OF_decode_xer$handle() {
        return SET_OF_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SET_OF_decode_xer$address() {
        return SET_OF_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SET_OF_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SET_OF_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SET_OF_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SET_OF_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SET_OF_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SET_OF_encode_xer$descriptor() {
        return SET_OF_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SET_OF_encode_xer$handle() {
        return SET_OF_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SET_OF_encode_xer$address() {
        return SET_OF_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SET_OF_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SET_OF_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SET_OF_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SET_OF_decode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SET_OF_decode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SET_OF_decode_jer$descriptor() {
        return SET_OF_decode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle SET_OF_decode_jer$handle() {
        return SET_OF_decode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SET_OF_decode_jer$address() {
        return SET_OF_decode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_jer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SET_OF_decode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SET_OF_decode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SET_OF_decode_jer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SET_OF_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SET_OF_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SET_OF_encode_jer$descriptor() {
        return SET_OF_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SET_OF_encode_jer$handle() {
        return SET_OF_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SET_OF_encode_jer$address() {
        return SET_OF_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SET_OF_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = SET_OF_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SET_OF_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SET_OF_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SET_OF_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SET_OF_decode_oer$descriptor() {
        return SET_OF_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle SET_OF_decode_oer$handle() {
        return SET_OF_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SET_OF_decode_oer$address() {
        return SET_OF_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SET_OF_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SET_OF_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SET_OF_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SET_OF_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SET_OF_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SET_OF_encode_oer$descriptor() {
        return SET_OF_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SET_OF_encode_oer$handle() {
        return SET_OF_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SET_OF_encode_oer$address() {
        return SET_OF_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SET_OF_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SET_OF_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SET_OF_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SET_OF_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SET_OF_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SET_OF_decode_uper$descriptor() {
        return SET_OF_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SET_OF_decode_uper$handle() {
        return SET_OF_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SET_OF_decode_uper$address() {
        return SET_OF_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SET_OF_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SET_OF_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SET_OF_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SET_OF_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SET_OF_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SET_OF_encode_uper$descriptor() {
        return SET_OF_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SET_OF_encode_uper$handle() {
        return SET_OF_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SET_OF_encode_uper$address() {
        return SET_OF_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SET_OF_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SET_OF_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SET_OF_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SET_OF_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SET_OF_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SET_OF_decode_aper$descriptor() {
        return SET_OF_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SET_OF_decode_aper$handle() {
        return SET_OF_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SET_OF_decode_aper$address() {
        return SET_OF_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SET_OF_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SET_OF_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SET_OF_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SET_OF_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SET_OF_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SET_OF_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SET_OF_encode_aper$descriptor() {
        return SET_OF_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SET_OF_encode_aper$handle() {
        return SET_OF_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SET_OF_encode_aper$address() {
        return SET_OF_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SET_OF_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SET_OF_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SET_OF_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SET_OF_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SET_OF_random_fill {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_random_fill_result_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SET_OF_random_fill");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_random_fill_result_t SET_OF_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static FunctionDescriptor SET_OF_random_fill$descriptor() {
        return SET_OF_random_fill.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_random_fill_result_t SET_OF_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static MethodHandle SET_OF_random_fill$handle() {
        return SET_OF_random_fill.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_random_fill_result_t SET_OF_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static MemorySegment SET_OF_random_fill$address() {
        return SET_OF_random_fill.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_random_fill_result_t SET_OF_random_fill(const struct asn_TYPE_descriptor_s *, void **, const struct asn_encoding_constraints_s *, size_t)
     * }
     */
    public static MemorySegment SET_OF_random_fill(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, long x3) {
        var mh$ = SET_OF_random_fill.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SET_OF_random_fill", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_OP_SET_OF$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_operation_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_OP_SET_OF").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_SET_OF
     * }
     */
    public static GroupLayout asn_OP_SET_OF$layout() {
        return asn_OP_SET_OF$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_SET_OF
     * }
     */
    public static MemorySegment asn_OP_SET_OF() {
        return asn_OP_SET_OF$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_SET_OF
     * }
     */
    public static void asn_OP_SET_OF(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_OP_SET_OF$constants.SEGMENT, 0L, asn_OP_SET_OF$constants.LAYOUT.byteSize());
    }
    private static final int SOES_DER = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SET_OF__encode_method.SOES_DER = 0
     * }
     */
    public static int SOES_DER() {
        return SOES_DER;
    }
    private static final int SOES_CUPER = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SET_OF__encode_method.SOES_CUPER = 1
     * }
     */
    public static int SOES_CUPER() {
        return SOES_CUPER;
    }
    private static final int SOES_CAPER = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SET_OF__encode_method.SOES_CAPER = 2
     * }
     */
    public static int SOES_CAPER() {
        return SOES_CAPER;
    }

    private static class SET_OF__encode_sorted {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SET_OF__encode_sorted");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * struct _el_buffer *SET_OF__encode_sorted(const asn_TYPE_member_t *elm, const asn_anonymous_set_ *list, enum SET_OF__encode_method method)
     * }
     */
    public static FunctionDescriptor SET_OF__encode_sorted$descriptor() {
        return SET_OF__encode_sorted.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * struct _el_buffer *SET_OF__encode_sorted(const asn_TYPE_member_t *elm, const asn_anonymous_set_ *list, enum SET_OF__encode_method method)
     * }
     */
    public static MethodHandle SET_OF__encode_sorted$handle() {
        return SET_OF__encode_sorted.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * struct _el_buffer *SET_OF__encode_sorted(const asn_TYPE_member_t *elm, const asn_anonymous_set_ *list, enum SET_OF__encode_method method)
     * }
     */
    public static MemorySegment SET_OF__encode_sorted$address() {
        return SET_OF__encode_sorted.ADDR;
    }

    /**
     * {@snippet lang=c :
     * struct _el_buffer *SET_OF__encode_sorted(const asn_TYPE_member_t *elm, const asn_anonymous_set_ *list, enum SET_OF__encode_method method)
     * }
     */
    public static MemorySegment SET_OF__encode_sorted(MemorySegment elm, MemorySegment list, int method) {
        var mh$ = SET_OF__encode_sorted.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SET_OF__encode_sorted", elm, list, method);
            }
            return (MemorySegment)mh$.invokeExact(elm, list, method);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SET_OF__encode_sorted_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SET_OF__encode_sorted_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SET_OF__encode_sorted_free(struct _el_buffer *el_buf, size_t count)
     * }
     */
    public static FunctionDescriptor SET_OF__encode_sorted_free$descriptor() {
        return SET_OF__encode_sorted_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SET_OF__encode_sorted_free(struct _el_buffer *el_buf, size_t count)
     * }
     */
    public static MethodHandle SET_OF__encode_sorted_free$handle() {
        return SET_OF__encode_sorted_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SET_OF__encode_sorted_free(struct _el_buffer *el_buf, size_t count)
     * }
     */
    public static MemorySegment SET_OF__encode_sorted_free$address() {
        return SET_OF__encode_sorted_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SET_OF__encode_sorted_free(struct _el_buffer *el_buf, size_t count)
     * }
     */
    public static void SET_OF__encode_sorted_free(MemorySegment el_buf, long count) {
        var mh$ = SET_OF__encode_sorted_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SET_OF__encode_sorted_free", el_buf, count);
            }
            mh$.invokeExact(el_buf, count);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_OF_compare {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_OF_compare");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SEQUENCE_OF_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static FunctionDescriptor SEQUENCE_OF_compare$descriptor() {
        return SEQUENCE_OF_compare.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SEQUENCE_OF_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static MethodHandle SEQUENCE_OF_compare$handle() {
        return SEQUENCE_OF_compare.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SEQUENCE_OF_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static MemorySegment SEQUENCE_OF_compare$address() {
        return SEQUENCE_OF_compare.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SEQUENCE_OF_compare(const struct asn_TYPE_descriptor_s *, const void *, const void *)
     * }
     */
    public static int SEQUENCE_OF_compare(MemorySegment x0, MemorySegment x1, MemorySegment x2) {
        var mh$ = SEQUENCE_OF_compare.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_OF_compare", x0, x1, x2);
            }
            return (int)mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_OF_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_OF_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_OF_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SEQUENCE_OF_encode_der$descriptor() {
        return SEQUENCE_OF_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_OF_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SEQUENCE_OF_encode_der$handle() {
        return SEQUENCE_OF_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_OF_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SEQUENCE_OF_encode_der$address() {
        return SEQUENCE_OF_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_OF_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SEQUENCE_OF_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SEQUENCE_OF_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_OF_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_OF_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_OF_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_OF_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SEQUENCE_OF_encode_xer$descriptor() {
        return SEQUENCE_OF_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_OF_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SEQUENCE_OF_encode_xer$handle() {
        return SEQUENCE_OF_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_OF_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SEQUENCE_OF_encode_xer$address() {
        return SEQUENCE_OF_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_OF_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SEQUENCE_OF_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SEQUENCE_OF_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_OF_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_OF_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_OF_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_OF_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SEQUENCE_OF_encode_jer$descriptor() {
        return SEQUENCE_OF_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_OF_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SEQUENCE_OF_encode_jer$handle() {
        return SEQUENCE_OF_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_OF_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SEQUENCE_OF_encode_jer$address() {
        return SEQUENCE_OF_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_OF_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SEQUENCE_OF_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = SEQUENCE_OF_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_OF_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_OF_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_OF_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_OF_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SEQUENCE_OF_encode_uper$descriptor() {
        return SEQUENCE_OF_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_OF_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SEQUENCE_OF_encode_uper$handle() {
        return SEQUENCE_OF_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_OF_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SEQUENCE_OF_encode_uper$address() {
        return SEQUENCE_OF_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_OF_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SEQUENCE_OF_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SEQUENCE_OF_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_OF_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SEQUENCE_OF_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SEQUENCE_OF_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_OF_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SEQUENCE_OF_encode_aper$descriptor() {
        return SEQUENCE_OF_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_OF_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SEQUENCE_OF_encode_aper$handle() {
        return SEQUENCE_OF_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_OF_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SEQUENCE_OF_encode_aper$address() {
        return SEQUENCE_OF_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SEQUENCE_OF_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SEQUENCE_OF_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SEQUENCE_OF_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SEQUENCE_OF_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_OP_SEQUENCE_OF$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_operation_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_OP_SEQUENCE_OF").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_SEQUENCE_OF
     * }
     */
    public static GroupLayout asn_OP_SEQUENCE_OF$layout() {
        return asn_OP_SEQUENCE_OF$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_SEQUENCE_OF
     * }
     */
    public static MemorySegment asn_OP_SEQUENCE_OF() {
        return asn_OP_SEQUENCE_OF$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_operation_t asn_OP_SEQUENCE_OF
     * }
     */
    public static void asn_OP_SEQUENCE_OF(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_OP_SEQUENCE_OF$constants.SEGMENT, 0L, asn_OP_SEQUENCE_OF$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_BasicSafetyMessage$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_BasicSafetyMessage").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BasicSafetyMessage
     * }
     */
    public static GroupLayout asn_DEF_BasicSafetyMessage$layout() {
        return asn_DEF_BasicSafetyMessage$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BasicSafetyMessage
     * }
     */
    public static MemorySegment asn_DEF_BasicSafetyMessage() {
        return asn_DEF_BasicSafetyMessage$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BasicSafetyMessage
     * }
     */
    public static void asn_DEF_BasicSafetyMessage(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_BasicSafetyMessage$constants.SEGMENT, 0L, asn_DEF_BasicSafetyMessage$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_BasicSafetyMessage_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_BasicSafetyMessage_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_BasicSafetyMessage_specs_1
     * }
     */
    public static GroupLayout asn_SPC_BasicSafetyMessage_specs_1$layout() {
        return asn_SPC_BasicSafetyMessage_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_BasicSafetyMessage_specs_1
     * }
     */
    public static MemorySegment asn_SPC_BasicSafetyMessage_specs_1() {
        return asn_SPC_BasicSafetyMessage_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_BasicSafetyMessage_specs_1
     * }
     */
    public static void asn_SPC_BasicSafetyMessage_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_BasicSafetyMessage_specs_1$constants.SEGMENT, 0L, asn_SPC_BasicSafetyMessage_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_BasicSafetyMessage_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(3, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_BasicSafetyMessage_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 3 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BasicSafetyMessage_1[3]
     * }
     */
    public static SequenceLayout asn_MBR_BasicSafetyMessage_1$layout() {
        return asn_MBR_BasicSafetyMessage_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BasicSafetyMessage_1[3]
     * }
     */
    public static long[] asn_MBR_BasicSafetyMessage_1$dimensions() {
        return asn_MBR_BasicSafetyMessage_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BasicSafetyMessage_1[3]
     * }
     */
    public static MemorySegment asn_MBR_BasicSafetyMessage_1() {
        return asn_MBR_BasicSafetyMessage_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BasicSafetyMessage_1[3]
     * }
     */
    public static void asn_MBR_BasicSafetyMessage_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_BasicSafetyMessage_1$constants.SEGMENT, 0L, asn_MBR_BasicSafetyMessage_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BasicSafetyMessage_1[3]
     * }
     */
    public static MemorySegment asn_MBR_BasicSafetyMessage_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_BasicSafetyMessage_1$constants.HANDLE.invokeExact(asn_MBR_BasicSafetyMessage_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_BasicSafetyMessage_1[3]
     * }
     */
    public static void asn_MBR_BasicSafetyMessage_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_BasicSafetyMessage_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef long BasicSafetyMessage_PartII_Id_t
     * }
     */
    public static final OfLong BasicSafetyMessage_PartII_Id_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_BasicSafetyMessage_PartII_Id_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_BasicSafetyMessage_PartII_Id_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_BasicSafetyMessage_PartII_Id_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_BasicSafetyMessage_PartII_Id_constr_1$layout() {
        return asn_PER_type_BasicSafetyMessage_PartII_Id_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_BasicSafetyMessage_PartII_Id_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_BasicSafetyMessage_PartII_Id_constr_1() {
        return asn_PER_type_BasicSafetyMessage_PartII_Id_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_BasicSafetyMessage_PartII_Id_constr_1
     * }
     */
    public static void asn_PER_type_BasicSafetyMessage_PartII_Id_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_BasicSafetyMessage_PartII_Id_constr_1$constants.SEGMENT, 0L, asn_PER_type_BasicSafetyMessage_PartII_Id_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_BasicSafetyMessage_PartII_Id$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_BasicSafetyMessage_PartII_Id").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BasicSafetyMessage_PartII_Id
     * }
     */
    public static GroupLayout asn_DEF_BasicSafetyMessage_PartII_Id$layout() {
        return asn_DEF_BasicSafetyMessage_PartII_Id$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BasicSafetyMessage_PartII_Id
     * }
     */
    public static MemorySegment asn_DEF_BasicSafetyMessage_PartII_Id() {
        return asn_DEF_BasicSafetyMessage_PartII_Id$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_BasicSafetyMessage_PartII_Id
     * }
     */
    public static void asn_DEF_BasicSafetyMessage_PartII_Id(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_BasicSafetyMessage_PartII_Id$constants.SEGMENT, 0L, asn_DEF_BasicSafetyMessage_PartII_Id$constants.LAYOUT.byteSize());
    }

    private static class BasicSafetyMessage_PartII_Id_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BasicSafetyMessage_PartII_Id_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void BasicSafetyMessage_PartII_Id_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor BasicSafetyMessage_PartII_Id_free$descriptor() {
        return BasicSafetyMessage_PartII_Id_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void BasicSafetyMessage_PartII_Id_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle BasicSafetyMessage_PartII_Id_free$handle() {
        return BasicSafetyMessage_PartII_Id_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void BasicSafetyMessage_PartII_Id_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_free$address() {
        return BasicSafetyMessage_PartII_Id_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void BasicSafetyMessage_PartII_Id_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void BasicSafetyMessage_PartII_Id_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = BasicSafetyMessage_PartII_Id_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BasicSafetyMessage_PartII_Id_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BasicSafetyMessage_PartII_Id_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BasicSafetyMessage_PartII_Id_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int BasicSafetyMessage_PartII_Id_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BasicSafetyMessage_PartII_Id_print$descriptor() {
        return BasicSafetyMessage_PartII_Id_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int BasicSafetyMessage_PartII_Id_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BasicSafetyMessage_PartII_Id_print$handle() {
        return BasicSafetyMessage_PartII_Id_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int BasicSafetyMessage_PartII_Id_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_print$address() {
        return BasicSafetyMessage_PartII_Id_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int BasicSafetyMessage_PartII_Id_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int BasicSafetyMessage_PartII_Id_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = BasicSafetyMessage_PartII_Id_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BasicSafetyMessage_PartII_Id_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BasicSafetyMessage_PartII_Id_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BasicSafetyMessage_PartII_Id_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int BasicSafetyMessage_PartII_Id_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor BasicSafetyMessage_PartII_Id_constraint$descriptor() {
        return BasicSafetyMessage_PartII_Id_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int BasicSafetyMessage_PartII_Id_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle BasicSafetyMessage_PartII_Id_constraint$handle() {
        return BasicSafetyMessage_PartII_Id_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int BasicSafetyMessage_PartII_Id_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_constraint$address() {
        return BasicSafetyMessage_PartII_Id_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int BasicSafetyMessage_PartII_Id_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int BasicSafetyMessage_PartII_Id_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = BasicSafetyMessage_PartII_Id_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BasicSafetyMessage_PartII_Id_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BasicSafetyMessage_PartII_Id_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BasicSafetyMessage_PartII_Id_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BasicSafetyMessage_PartII_Id_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor BasicSafetyMessage_PartII_Id_decode_ber$descriptor() {
        return BasicSafetyMessage_PartII_Id_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BasicSafetyMessage_PartII_Id_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle BasicSafetyMessage_PartII_Id_decode_ber$handle() {
        return BasicSafetyMessage_PartII_Id_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BasicSafetyMessage_PartII_Id_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_decode_ber$address() {
        return BasicSafetyMessage_PartII_Id_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BasicSafetyMessage_PartII_Id_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = BasicSafetyMessage_PartII_Id_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BasicSafetyMessage_PartII_Id_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BasicSafetyMessage_PartII_Id_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BasicSafetyMessage_PartII_Id_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BasicSafetyMessage_PartII_Id_encode_der$descriptor() {
        return BasicSafetyMessage_PartII_Id_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BasicSafetyMessage_PartII_Id_encode_der$handle() {
        return BasicSafetyMessage_PartII_Id_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_encode_der$address() {
        return BasicSafetyMessage_PartII_Id_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = BasicSafetyMessage_PartII_Id_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BasicSafetyMessage_PartII_Id_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BasicSafetyMessage_PartII_Id_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BasicSafetyMessage_PartII_Id_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BasicSafetyMessage_PartII_Id_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor BasicSafetyMessage_PartII_Id_decode_xer$descriptor() {
        return BasicSafetyMessage_PartII_Id_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BasicSafetyMessage_PartII_Id_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle BasicSafetyMessage_PartII_Id_decode_xer$handle() {
        return BasicSafetyMessage_PartII_Id_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BasicSafetyMessage_PartII_Id_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_decode_xer$address() {
        return BasicSafetyMessage_PartII_Id_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BasicSafetyMessage_PartII_Id_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = BasicSafetyMessage_PartII_Id_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BasicSafetyMessage_PartII_Id_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BasicSafetyMessage_PartII_Id_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BasicSafetyMessage_PartII_Id_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BasicSafetyMessage_PartII_Id_encode_xer$descriptor() {
        return BasicSafetyMessage_PartII_Id_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BasicSafetyMessage_PartII_Id_encode_xer$handle() {
        return BasicSafetyMessage_PartII_Id_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_encode_xer$address() {
        return BasicSafetyMessage_PartII_Id_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = BasicSafetyMessage_PartII_Id_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BasicSafetyMessage_PartII_Id_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BasicSafetyMessage_PartII_Id_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BasicSafetyMessage_PartII_Id_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BasicSafetyMessage_PartII_Id_encode_jer$descriptor() {
        return BasicSafetyMessage_PartII_Id_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BasicSafetyMessage_PartII_Id_encode_jer$handle() {
        return BasicSafetyMessage_PartII_Id_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_encode_jer$address() {
        return BasicSafetyMessage_PartII_Id_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = BasicSafetyMessage_PartII_Id_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BasicSafetyMessage_PartII_Id_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BasicSafetyMessage_PartII_Id_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BasicSafetyMessage_PartII_Id_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BasicSafetyMessage_PartII_Id_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor BasicSafetyMessage_PartII_Id_decode_oer$descriptor() {
        return BasicSafetyMessage_PartII_Id_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BasicSafetyMessage_PartII_Id_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle BasicSafetyMessage_PartII_Id_decode_oer$handle() {
        return BasicSafetyMessage_PartII_Id_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BasicSafetyMessage_PartII_Id_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_decode_oer$address() {
        return BasicSafetyMessage_PartII_Id_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BasicSafetyMessage_PartII_Id_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = BasicSafetyMessage_PartII_Id_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BasicSafetyMessage_PartII_Id_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BasicSafetyMessage_PartII_Id_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BasicSafetyMessage_PartII_Id_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor BasicSafetyMessage_PartII_Id_encode_oer$descriptor() {
        return BasicSafetyMessage_PartII_Id_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle BasicSafetyMessage_PartII_Id_encode_oer$handle() {
        return BasicSafetyMessage_PartII_Id_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_encode_oer$address() {
        return BasicSafetyMessage_PartII_Id_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = BasicSafetyMessage_PartII_Id_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BasicSafetyMessage_PartII_Id_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BasicSafetyMessage_PartII_Id_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BasicSafetyMessage_PartII_Id_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BasicSafetyMessage_PartII_Id_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor BasicSafetyMessage_PartII_Id_decode_uper$descriptor() {
        return BasicSafetyMessage_PartII_Id_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BasicSafetyMessage_PartII_Id_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle BasicSafetyMessage_PartII_Id_decode_uper$handle() {
        return BasicSafetyMessage_PartII_Id_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BasicSafetyMessage_PartII_Id_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_decode_uper$address() {
        return BasicSafetyMessage_PartII_Id_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BasicSafetyMessage_PartII_Id_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = BasicSafetyMessage_PartII_Id_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BasicSafetyMessage_PartII_Id_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BasicSafetyMessage_PartII_Id_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BasicSafetyMessage_PartII_Id_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor BasicSafetyMessage_PartII_Id_encode_uper$descriptor() {
        return BasicSafetyMessage_PartII_Id_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle BasicSafetyMessage_PartII_Id_encode_uper$handle() {
        return BasicSafetyMessage_PartII_Id_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_encode_uper$address() {
        return BasicSafetyMessage_PartII_Id_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = BasicSafetyMessage_PartII_Id_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BasicSafetyMessage_PartII_Id_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BasicSafetyMessage_PartII_Id_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BasicSafetyMessage_PartII_Id_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t BasicSafetyMessage_PartII_Id_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor BasicSafetyMessage_PartII_Id_decode_aper$descriptor() {
        return BasicSafetyMessage_PartII_Id_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t BasicSafetyMessage_PartII_Id_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle BasicSafetyMessage_PartII_Id_decode_aper$handle() {
        return BasicSafetyMessage_PartII_Id_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t BasicSafetyMessage_PartII_Id_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_decode_aper$address() {
        return BasicSafetyMessage_PartII_Id_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t BasicSafetyMessage_PartII_Id_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = BasicSafetyMessage_PartII_Id_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BasicSafetyMessage_PartII_Id_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class BasicSafetyMessage_PartII_Id_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("BasicSafetyMessage_PartII_Id_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor BasicSafetyMessage_PartII_Id_encode_aper$descriptor() {
        return BasicSafetyMessage_PartII_Id_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle BasicSafetyMessage_PartII_Id_encode_aper$handle() {
        return BasicSafetyMessage_PartII_Id_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_encode_aper$address() {
        return BasicSafetyMessage_PartII_Id_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t BasicSafetyMessage_PartII_Id_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment BasicSafetyMessage_PartII_Id_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = BasicSafetyMessage_PartII_Id_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("BasicSafetyMessage_PartII_Id_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int VehicleEventFlags_eventHazardLights = (int)0L;
    /**
     * {@snippet lang=c :
     * enum VehicleEventFlags.VehicleEventFlags_eventHazardLights = 0
     * }
     */
    public static int VehicleEventFlags_eventHazardLights() {
        return VehicleEventFlags_eventHazardLights;
    }
    private static final int VehicleEventFlags_eventStopLineViolation = (int)1L;
    /**
     * {@snippet lang=c :
     * enum VehicleEventFlags.VehicleEventFlags_eventStopLineViolation = 1
     * }
     */
    public static int VehicleEventFlags_eventStopLineViolation() {
        return VehicleEventFlags_eventStopLineViolation;
    }
    private static final int VehicleEventFlags_eventABSactivated = (int)2L;
    /**
     * {@snippet lang=c :
     * enum VehicleEventFlags.VehicleEventFlags_eventABSactivated = 2
     * }
     */
    public static int VehicleEventFlags_eventABSactivated() {
        return VehicleEventFlags_eventABSactivated;
    }
    private static final int VehicleEventFlags_eventTractionControlLoss = (int)3L;
    /**
     * {@snippet lang=c :
     * enum VehicleEventFlags.VehicleEventFlags_eventTractionControlLoss = 3
     * }
     */
    public static int VehicleEventFlags_eventTractionControlLoss() {
        return VehicleEventFlags_eventTractionControlLoss;
    }
    private static final int VehicleEventFlags_eventStabilityControlactivated = (int)4L;
    /**
     * {@snippet lang=c :
     * enum VehicleEventFlags.VehicleEventFlags_eventStabilityControlactivated = 4
     * }
     */
    public static int VehicleEventFlags_eventStabilityControlactivated() {
        return VehicleEventFlags_eventStabilityControlactivated;
    }
    private static final int VehicleEventFlags_eventHazardousMaterials = (int)5L;
    /**
     * {@snippet lang=c :
     * enum VehicleEventFlags.VehicleEventFlags_eventHazardousMaterials = 5
     * }
     */
    public static int VehicleEventFlags_eventHazardousMaterials() {
        return VehicleEventFlags_eventHazardousMaterials;
    }
    private static final int VehicleEventFlags_eventReserved1 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum VehicleEventFlags.VehicleEventFlags_eventReserved1 = 6
     * }
     */
    public static int VehicleEventFlags_eventReserved1() {
        return VehicleEventFlags_eventReserved1;
    }
    private static final int VehicleEventFlags_eventHardBraking = (int)7L;
    /**
     * {@snippet lang=c :
     * enum VehicleEventFlags.VehicleEventFlags_eventHardBraking = 7
     * }
     */
    public static int VehicleEventFlags_eventHardBraking() {
        return VehicleEventFlags_eventHardBraking;
    }
    private static final int VehicleEventFlags_eventLightsChanged = (int)8L;
    /**
     * {@snippet lang=c :
     * enum VehicleEventFlags.VehicleEventFlags_eventLightsChanged = 8
     * }
     */
    public static int VehicleEventFlags_eventLightsChanged() {
        return VehicleEventFlags_eventLightsChanged;
    }
    private static final int VehicleEventFlags_eventWipersChanged = (int)9L;
    /**
     * {@snippet lang=c :
     * enum VehicleEventFlags.VehicleEventFlags_eventWipersChanged = 9
     * }
     */
    public static int VehicleEventFlags_eventWipersChanged() {
        return VehicleEventFlags_eventWipersChanged;
    }
    private static final int VehicleEventFlags_eventFlatTire = (int)10L;
    /**
     * {@snippet lang=c :
     * enum VehicleEventFlags.VehicleEventFlags_eventFlatTire = 10
     * }
     */
    public static int VehicleEventFlags_eventFlatTire() {
        return VehicleEventFlags_eventFlatTire;
    }
    private static final int VehicleEventFlags_eventDisabledVehicle = (int)11L;
    /**
     * {@snippet lang=c :
     * enum VehicleEventFlags.VehicleEventFlags_eventDisabledVehicle = 11
     * }
     */
    public static int VehicleEventFlags_eventDisabledVehicle() {
        return VehicleEventFlags_eventDisabledVehicle;
    }
    private static final int VehicleEventFlags_eventAirBagDeployment = (int)12L;
    /**
     * {@snippet lang=c :
     * enum VehicleEventFlags.VehicleEventFlags_eventAirBagDeployment = 12
     * }
     */
    public static int VehicleEventFlags_eventAirBagDeployment() {
        return VehicleEventFlags_eventAirBagDeployment;
    }
    private static final int VehicleEventFlags_eventJackKnife = (int)13L;
    /**
     * {@snippet lang=c :
     * enum VehicleEventFlags.VehicleEventFlags_eventJackKnife = 13
     * }
     */
    public static int VehicleEventFlags_eventJackKnife() {
        return VehicleEventFlags_eventJackKnife;
    }

    private static class asn_PER_type_VehicleEventFlags_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_VehicleEventFlags_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VehicleEventFlags_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_VehicleEventFlags_constr_1$layout() {
        return asn_PER_type_VehicleEventFlags_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VehicleEventFlags_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_VehicleEventFlags_constr_1() {
        return asn_PER_type_VehicleEventFlags_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VehicleEventFlags_constr_1
     * }
     */
    public static void asn_PER_type_VehicleEventFlags_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_VehicleEventFlags_constr_1$constants.SEGMENT, 0L, asn_PER_type_VehicleEventFlags_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_VehicleEventFlags$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_VehicleEventFlags").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleEventFlags
     * }
     */
    public static GroupLayout asn_DEF_VehicleEventFlags$layout() {
        return asn_DEF_VehicleEventFlags$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleEventFlags
     * }
     */
    public static MemorySegment asn_DEF_VehicleEventFlags() {
        return asn_DEF_VehicleEventFlags$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleEventFlags
     * }
     */
    public static void asn_DEF_VehicleEventFlags(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_VehicleEventFlags$constants.SEGMENT, 0L, asn_DEF_VehicleEventFlags$constants.LAYOUT.byteSize());
    }

    private static class VehicleEventFlags_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleEventFlags_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void VehicleEventFlags_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor VehicleEventFlags_free$descriptor() {
        return VehicleEventFlags_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void VehicleEventFlags_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle VehicleEventFlags_free$handle() {
        return VehicleEventFlags_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void VehicleEventFlags_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment VehicleEventFlags_free$address() {
        return VehicleEventFlags_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void VehicleEventFlags_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void VehicleEventFlags_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = VehicleEventFlags_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleEventFlags_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleEventFlags_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleEventFlags_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int VehicleEventFlags_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleEventFlags_print$descriptor() {
        return VehicleEventFlags_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int VehicleEventFlags_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VehicleEventFlags_print$handle() {
        return VehicleEventFlags_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int VehicleEventFlags_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleEventFlags_print$address() {
        return VehicleEventFlags_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int VehicleEventFlags_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int VehicleEventFlags_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VehicleEventFlags_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleEventFlags_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleEventFlags_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleEventFlags_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int VehicleEventFlags_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleEventFlags_constraint$descriptor() {
        return VehicleEventFlags_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int VehicleEventFlags_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle VehicleEventFlags_constraint$handle() {
        return VehicleEventFlags_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int VehicleEventFlags_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment VehicleEventFlags_constraint$address() {
        return VehicleEventFlags_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int VehicleEventFlags_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int VehicleEventFlags_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = VehicleEventFlags_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleEventFlags_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleEventFlags_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleEventFlags_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleEventFlags_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor VehicleEventFlags_decode_ber$descriptor() {
        return VehicleEventFlags_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleEventFlags_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle VehicleEventFlags_decode_ber$handle() {
        return VehicleEventFlags_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleEventFlags_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment VehicleEventFlags_decode_ber$address() {
        return VehicleEventFlags_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleEventFlags_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment VehicleEventFlags_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = VehicleEventFlags_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleEventFlags_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleEventFlags_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleEventFlags_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleEventFlags_encode_der$descriptor() {
        return VehicleEventFlags_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VehicleEventFlags_encode_der$handle() {
        return VehicleEventFlags_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleEventFlags_encode_der$address() {
        return VehicleEventFlags_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleEventFlags_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = VehicleEventFlags_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleEventFlags_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleEventFlags_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleEventFlags_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleEventFlags_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor VehicleEventFlags_decode_xer$descriptor() {
        return VehicleEventFlags_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleEventFlags_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle VehicleEventFlags_decode_xer$handle() {
        return VehicleEventFlags_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleEventFlags_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment VehicleEventFlags_decode_xer$address() {
        return VehicleEventFlags_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleEventFlags_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment VehicleEventFlags_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = VehicleEventFlags_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleEventFlags_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleEventFlags_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleEventFlags_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleEventFlags_encode_xer$descriptor() {
        return VehicleEventFlags_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VehicleEventFlags_encode_xer$handle() {
        return VehicleEventFlags_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleEventFlags_encode_xer$address() {
        return VehicleEventFlags_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleEventFlags_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = VehicleEventFlags_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleEventFlags_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleEventFlags_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleEventFlags_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleEventFlags_encode_jer$descriptor() {
        return VehicleEventFlags_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VehicleEventFlags_encode_jer$handle() {
        return VehicleEventFlags_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleEventFlags_encode_jer$address() {
        return VehicleEventFlags_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleEventFlags_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = VehicleEventFlags_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleEventFlags_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleEventFlags_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleEventFlags_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleEventFlags_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor VehicleEventFlags_decode_oer$descriptor() {
        return VehicleEventFlags_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleEventFlags_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle VehicleEventFlags_decode_oer$handle() {
        return VehicleEventFlags_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleEventFlags_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment VehicleEventFlags_decode_oer$address() {
        return VehicleEventFlags_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleEventFlags_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment VehicleEventFlags_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = VehicleEventFlags_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleEventFlags_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleEventFlags_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleEventFlags_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VehicleEventFlags_encode_oer$descriptor() {
        return VehicleEventFlags_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VehicleEventFlags_encode_oer$handle() {
        return VehicleEventFlags_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleEventFlags_encode_oer$address() {
        return VehicleEventFlags_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VehicleEventFlags_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VehicleEventFlags_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleEventFlags_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleEventFlags_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleEventFlags_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleEventFlags_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor VehicleEventFlags_decode_uper$descriptor() {
        return VehicleEventFlags_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleEventFlags_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle VehicleEventFlags_decode_uper$handle() {
        return VehicleEventFlags_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleEventFlags_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VehicleEventFlags_decode_uper$address() {
        return VehicleEventFlags_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleEventFlags_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VehicleEventFlags_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VehicleEventFlags_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleEventFlags_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleEventFlags_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleEventFlags_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor VehicleEventFlags_encode_uper$descriptor() {
        return VehicleEventFlags_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle VehicleEventFlags_encode_uper$handle() {
        return VehicleEventFlags_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VehicleEventFlags_encode_uper$address() {
        return VehicleEventFlags_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VehicleEventFlags_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = VehicleEventFlags_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleEventFlags_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleEventFlags_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleEventFlags_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleEventFlags_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor VehicleEventFlags_decode_aper$descriptor() {
        return VehicleEventFlags_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleEventFlags_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle VehicleEventFlags_decode_aper$handle() {
        return VehicleEventFlags_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleEventFlags_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VehicleEventFlags_decode_aper$address() {
        return VehicleEventFlags_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VehicleEventFlags_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VehicleEventFlags_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VehicleEventFlags_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleEventFlags_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VehicleEventFlags_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VehicleEventFlags_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor VehicleEventFlags_encode_aper$descriptor() {
        return VehicleEventFlags_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle VehicleEventFlags_encode_aper$handle() {
        return VehicleEventFlags_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VehicleEventFlags_encode_aper$address() {
        return VehicleEventFlags_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VehicleEventFlags_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VehicleEventFlags_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = VehicleEventFlags_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VehicleEventFlags_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ExteriorLights_lowBeamHeadlightsOn = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ExteriorLights.ExteriorLights_lowBeamHeadlightsOn = 0
     * }
     */
    public static int ExteriorLights_lowBeamHeadlightsOn() {
        return ExteriorLights_lowBeamHeadlightsOn;
    }
    private static final int ExteriorLights_highBeamHeadlightsOn = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ExteriorLights.ExteriorLights_highBeamHeadlightsOn = 1
     * }
     */
    public static int ExteriorLights_highBeamHeadlightsOn() {
        return ExteriorLights_highBeamHeadlightsOn;
    }
    private static final int ExteriorLights_leftTurnSignalOn = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ExteriorLights.ExteriorLights_leftTurnSignalOn = 2
     * }
     */
    public static int ExteriorLights_leftTurnSignalOn() {
        return ExteriorLights_leftTurnSignalOn;
    }
    private static final int ExteriorLights_rightTurnSignalOn = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ExteriorLights.ExteriorLights_rightTurnSignalOn = 3
     * }
     */
    public static int ExteriorLights_rightTurnSignalOn() {
        return ExteriorLights_rightTurnSignalOn;
    }
    private static final int ExteriorLights_hazardSignalOn = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ExteriorLights.ExteriorLights_hazardSignalOn = 4
     * }
     */
    public static int ExteriorLights_hazardSignalOn() {
        return ExteriorLights_hazardSignalOn;
    }
    private static final int ExteriorLights_automaticLightControlOn = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ExteriorLights.ExteriorLights_automaticLightControlOn = 5
     * }
     */
    public static int ExteriorLights_automaticLightControlOn() {
        return ExteriorLights_automaticLightControlOn;
    }
    private static final int ExteriorLights_daytimeRunningLightsOn = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ExteriorLights.ExteriorLights_daytimeRunningLightsOn = 6
     * }
     */
    public static int ExteriorLights_daytimeRunningLightsOn() {
        return ExteriorLights_daytimeRunningLightsOn;
    }
    private static final int ExteriorLights_fogLightOn = (int)7L;
    /**
     * {@snippet lang=c :
     * enum ExteriorLights.ExteriorLights_fogLightOn = 7
     * }
     */
    public static int ExteriorLights_fogLightOn() {
        return ExteriorLights_fogLightOn;
    }
    private static final int ExteriorLights_parkingLightsOn = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ExteriorLights.ExteriorLights_parkingLightsOn = 8
     * }
     */
    public static int ExteriorLights_parkingLightsOn() {
        return ExteriorLights_parkingLightsOn;
    }

    private static class asn_PER_type_ExteriorLights_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_ExteriorLights_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ExteriorLights_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_ExteriorLights_constr_1$layout() {
        return asn_PER_type_ExteriorLights_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ExteriorLights_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_ExteriorLights_constr_1() {
        return asn_PER_type_ExteriorLights_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ExteriorLights_constr_1
     * }
     */
    public static void asn_PER_type_ExteriorLights_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_ExteriorLights_constr_1$constants.SEGMENT, 0L, asn_PER_type_ExteriorLights_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_ExteriorLights$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_ExteriorLights").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ExteriorLights
     * }
     */
    public static GroupLayout asn_DEF_ExteriorLights$layout() {
        return asn_DEF_ExteriorLights$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ExteriorLights
     * }
     */
    public static MemorySegment asn_DEF_ExteriorLights() {
        return asn_DEF_ExteriorLights$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ExteriorLights
     * }
     */
    public static void asn_DEF_ExteriorLights(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_ExteriorLights$constants.SEGMENT, 0L, asn_DEF_ExteriorLights$constants.LAYOUT.byteSize());
    }

    private static class ExteriorLights_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ExteriorLights_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ExteriorLights_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor ExteriorLights_free$descriptor() {
        return ExteriorLights_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ExteriorLights_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle ExteriorLights_free$handle() {
        return ExteriorLights_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ExteriorLights_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment ExteriorLights_free$address() {
        return ExteriorLights_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ExteriorLights_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void ExteriorLights_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = ExteriorLights_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExteriorLights_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExteriorLights_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ExteriorLights_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ExteriorLights_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ExteriorLights_print$descriptor() {
        return ExteriorLights_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ExteriorLights_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ExteriorLights_print$handle() {
        return ExteriorLights_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ExteriorLights_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ExteriorLights_print$address() {
        return ExteriorLights_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ExteriorLights_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int ExteriorLights_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ExteriorLights_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExteriorLights_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExteriorLights_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ExteriorLights_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ExteriorLights_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor ExteriorLights_constraint$descriptor() {
        return ExteriorLights_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ExteriorLights_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle ExteriorLights_constraint$handle() {
        return ExteriorLights_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ExteriorLights_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment ExteriorLights_constraint$address() {
        return ExteriorLights_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ExteriorLights_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int ExteriorLights_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ExteriorLights_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExteriorLights_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExteriorLights_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ExteriorLights_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ExteriorLights_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor ExteriorLights_decode_ber$descriptor() {
        return ExteriorLights_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ExteriorLights_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle ExteriorLights_decode_ber$handle() {
        return ExteriorLights_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ExteriorLights_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment ExteriorLights_decode_ber$address() {
        return ExteriorLights_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ExteriorLights_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment ExteriorLights_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = ExteriorLights_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExteriorLights_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExteriorLights_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ExteriorLights_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ExteriorLights_encode_der$descriptor() {
        return ExteriorLights_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ExteriorLights_encode_der$handle() {
        return ExteriorLights_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ExteriorLights_encode_der$address() {
        return ExteriorLights_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ExteriorLights_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ExteriorLights_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExteriorLights_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExteriorLights_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ExteriorLights_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ExteriorLights_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor ExteriorLights_decode_xer$descriptor() {
        return ExteriorLights_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ExteriorLights_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle ExteriorLights_decode_xer$handle() {
        return ExteriorLights_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ExteriorLights_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment ExteriorLights_decode_xer$address() {
        return ExteriorLights_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ExteriorLights_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment ExteriorLights_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = ExteriorLights_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExteriorLights_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExteriorLights_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ExteriorLights_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ExteriorLights_encode_xer$descriptor() {
        return ExteriorLights_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ExteriorLights_encode_xer$handle() {
        return ExteriorLights_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ExteriorLights_encode_xer$address() {
        return ExteriorLights_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ExteriorLights_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ExteriorLights_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExteriorLights_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExteriorLights_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ExteriorLights_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ExteriorLights_encode_jer$descriptor() {
        return ExteriorLights_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ExteriorLights_encode_jer$handle() {
        return ExteriorLights_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ExteriorLights_encode_jer$address() {
        return ExteriorLights_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ExteriorLights_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = ExteriorLights_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExteriorLights_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExteriorLights_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ExteriorLights_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ExteriorLights_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor ExteriorLights_decode_oer$descriptor() {
        return ExteriorLights_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ExteriorLights_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle ExteriorLights_decode_oer$handle() {
        return ExteriorLights_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ExteriorLights_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ExteriorLights_decode_oer$address() {
        return ExteriorLights_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ExteriorLights_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ExteriorLights_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = ExteriorLights_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExteriorLights_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExteriorLights_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ExteriorLights_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ExteriorLights_encode_oer$descriptor() {
        return ExteriorLights_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ExteriorLights_encode_oer$handle() {
        return ExteriorLights_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ExteriorLights_encode_oer$address() {
        return ExteriorLights_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ExteriorLights_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ExteriorLights_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExteriorLights_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExteriorLights_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ExteriorLights_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ExteriorLights_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor ExteriorLights_decode_uper$descriptor() {
        return ExteriorLights_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ExteriorLights_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle ExteriorLights_decode_uper$handle() {
        return ExteriorLights_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ExteriorLights_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ExteriorLights_decode_uper$address() {
        return ExteriorLights_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ExteriorLights_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ExteriorLights_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ExteriorLights_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExteriorLights_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExteriorLights_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ExteriorLights_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor ExteriorLights_encode_uper$descriptor() {
        return ExteriorLights_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle ExteriorLights_encode_uper$handle() {
        return ExteriorLights_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ExteriorLights_encode_uper$address() {
        return ExteriorLights_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ExteriorLights_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ExteriorLights_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExteriorLights_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExteriorLights_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ExteriorLights_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ExteriorLights_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor ExteriorLights_decode_aper$descriptor() {
        return ExteriorLights_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ExteriorLights_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle ExteriorLights_decode_aper$handle() {
        return ExteriorLights_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ExteriorLights_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ExteriorLights_decode_aper$address() {
        return ExteriorLights_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ExteriorLights_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ExteriorLights_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ExteriorLights_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExteriorLights_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ExteriorLights_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ExteriorLights_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor ExteriorLights_encode_aper$descriptor() {
        return ExteriorLights_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle ExteriorLights_encode_aper$handle() {
        return ExteriorLights_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ExteriorLights_encode_aper$address() {
        return ExteriorLights_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ExteriorLights_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ExteriorLights_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ExteriorLights_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ExteriorLights_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_VehicleSafetyExtensions$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_VehicleSafetyExtensions").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleSafetyExtensions
     * }
     */
    public static GroupLayout asn_DEF_VehicleSafetyExtensions$layout() {
        return asn_DEF_VehicleSafetyExtensions$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleSafetyExtensions
     * }
     */
    public static MemorySegment asn_DEF_VehicleSafetyExtensions() {
        return asn_DEF_VehicleSafetyExtensions$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VehicleSafetyExtensions
     * }
     */
    public static void asn_DEF_VehicleSafetyExtensions(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_VehicleSafetyExtensions$constants.SEGMENT, 0L, asn_DEF_VehicleSafetyExtensions$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_VehicleSafetyExtensions_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_VehicleSafetyExtensions_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_VehicleSafetyExtensions_specs_1
     * }
     */
    public static GroupLayout asn_SPC_VehicleSafetyExtensions_specs_1$layout() {
        return asn_SPC_VehicleSafetyExtensions_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_VehicleSafetyExtensions_specs_1
     * }
     */
    public static MemorySegment asn_SPC_VehicleSafetyExtensions_specs_1() {
        return asn_SPC_VehicleSafetyExtensions_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_VehicleSafetyExtensions_specs_1
     * }
     */
    public static void asn_SPC_VehicleSafetyExtensions_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_VehicleSafetyExtensions_specs_1$constants.SEGMENT, 0L, asn_SPC_VehicleSafetyExtensions_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_VehicleSafetyExtensions_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(4, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_VehicleSafetyExtensions_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 4 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleSafetyExtensions_1[4]
     * }
     */
    public static SequenceLayout asn_MBR_VehicleSafetyExtensions_1$layout() {
        return asn_MBR_VehicleSafetyExtensions_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleSafetyExtensions_1[4]
     * }
     */
    public static long[] asn_MBR_VehicleSafetyExtensions_1$dimensions() {
        return asn_MBR_VehicleSafetyExtensions_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleSafetyExtensions_1[4]
     * }
     */
    public static MemorySegment asn_MBR_VehicleSafetyExtensions_1() {
        return asn_MBR_VehicleSafetyExtensions_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleSafetyExtensions_1[4]
     * }
     */
    public static void asn_MBR_VehicleSafetyExtensions_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_VehicleSafetyExtensions_1$constants.SEGMENT, 0L, asn_MBR_VehicleSafetyExtensions_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleSafetyExtensions_1[4]
     * }
     */
    public static MemorySegment asn_MBR_VehicleSafetyExtensions_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_VehicleSafetyExtensions_1$constants.HANDLE.invokeExact(asn_MBR_VehicleSafetyExtensions_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_VehicleSafetyExtensions_1[4]
     * }
     */
    public static void asn_MBR_VehicleSafetyExtensions_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_VehicleSafetyExtensions_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    private static final int GNSSstatus_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum GNSSstatus.GNSSstatus_unavailable = 0
     * }
     */
    public static int GNSSstatus_unavailable() {
        return GNSSstatus_unavailable;
    }
    private static final int GNSSstatus_isHealthy = (int)1L;
    /**
     * {@snippet lang=c :
     * enum GNSSstatus.GNSSstatus_isHealthy = 1
     * }
     */
    public static int GNSSstatus_isHealthy() {
        return GNSSstatus_isHealthy;
    }
    private static final int GNSSstatus_isMonitored = (int)2L;
    /**
     * {@snippet lang=c :
     * enum GNSSstatus.GNSSstatus_isMonitored = 2
     * }
     */
    public static int GNSSstatus_isMonitored() {
        return GNSSstatus_isMonitored;
    }
    private static final int GNSSstatus_baseStationType = (int)3L;
    /**
     * {@snippet lang=c :
     * enum GNSSstatus.GNSSstatus_baseStationType = 3
     * }
     */
    public static int GNSSstatus_baseStationType() {
        return GNSSstatus_baseStationType;
    }
    private static final int GNSSstatus_aPDOPofUnder5 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum GNSSstatus.GNSSstatus_aPDOPofUnder5 = 4
     * }
     */
    public static int GNSSstatus_aPDOPofUnder5() {
        return GNSSstatus_aPDOPofUnder5;
    }
    private static final int GNSSstatus_inViewOfUnder5 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum GNSSstatus.GNSSstatus_inViewOfUnder5 = 5
     * }
     */
    public static int GNSSstatus_inViewOfUnder5() {
        return GNSSstatus_inViewOfUnder5;
    }
    private static final int GNSSstatus_localCorrectionsPresent = (int)6L;
    /**
     * {@snippet lang=c :
     * enum GNSSstatus.GNSSstatus_localCorrectionsPresent = 6
     * }
     */
    public static int GNSSstatus_localCorrectionsPresent() {
        return GNSSstatus_localCorrectionsPresent;
    }
    private static final int GNSSstatus_networkCorrectionsPresent = (int)7L;
    /**
     * {@snippet lang=c :
     * enum GNSSstatus.GNSSstatus_networkCorrectionsPresent = 7
     * }
     */
    public static int GNSSstatus_networkCorrectionsPresent() {
        return GNSSstatus_networkCorrectionsPresent;
    }

    private static class asn_PER_type_GNSSstatus_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_GNSSstatus_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_GNSSstatus_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_GNSSstatus_constr_1$layout() {
        return asn_PER_type_GNSSstatus_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_GNSSstatus_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_GNSSstatus_constr_1() {
        return asn_PER_type_GNSSstatus_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_GNSSstatus_constr_1
     * }
     */
    public static void asn_PER_type_GNSSstatus_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_GNSSstatus_constr_1$constants.SEGMENT, 0L, asn_PER_type_GNSSstatus_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_GNSSstatus$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_GNSSstatus").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_GNSSstatus
     * }
     */
    public static GroupLayout asn_DEF_GNSSstatus$layout() {
        return asn_DEF_GNSSstatus$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_GNSSstatus
     * }
     */
    public static MemorySegment asn_DEF_GNSSstatus() {
        return asn_DEF_GNSSstatus$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_GNSSstatus
     * }
     */
    public static void asn_DEF_GNSSstatus(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_GNSSstatus$constants.SEGMENT, 0L, asn_DEF_GNSSstatus$constants.LAYOUT.byteSize());
    }

    private static class GNSSstatus_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GNSSstatus_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void GNSSstatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor GNSSstatus_free$descriptor() {
        return GNSSstatus_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void GNSSstatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle GNSSstatus_free$handle() {
        return GNSSstatus_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void GNSSstatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment GNSSstatus_free$address() {
        return GNSSstatus_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void GNSSstatus_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void GNSSstatus_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = GNSSstatus_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GNSSstatus_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GNSSstatus_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GNSSstatus_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GNSSstatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor GNSSstatus_print$descriptor() {
        return GNSSstatus_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GNSSstatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle GNSSstatus_print$handle() {
        return GNSSstatus_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GNSSstatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment GNSSstatus_print$address() {
        return GNSSstatus_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GNSSstatus_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int GNSSstatus_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = GNSSstatus_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GNSSstatus_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GNSSstatus_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GNSSstatus_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int GNSSstatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor GNSSstatus_constraint$descriptor() {
        return GNSSstatus_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int GNSSstatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle GNSSstatus_constraint$handle() {
        return GNSSstatus_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int GNSSstatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment GNSSstatus_constraint$address() {
        return GNSSstatus_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int GNSSstatus_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int GNSSstatus_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = GNSSstatus_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GNSSstatus_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GNSSstatus_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GNSSstatus_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t GNSSstatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor GNSSstatus_decode_ber$descriptor() {
        return GNSSstatus_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t GNSSstatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle GNSSstatus_decode_ber$handle() {
        return GNSSstatus_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t GNSSstatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment GNSSstatus_decode_ber$address() {
        return GNSSstatus_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t GNSSstatus_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment GNSSstatus_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = GNSSstatus_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GNSSstatus_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GNSSstatus_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GNSSstatus_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor GNSSstatus_encode_der$descriptor() {
        return GNSSstatus_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle GNSSstatus_encode_der$handle() {
        return GNSSstatus_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment GNSSstatus_encode_der$address() {
        return GNSSstatus_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment GNSSstatus_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = GNSSstatus_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GNSSstatus_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GNSSstatus_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GNSSstatus_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t GNSSstatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor GNSSstatus_decode_xer$descriptor() {
        return GNSSstatus_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t GNSSstatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle GNSSstatus_decode_xer$handle() {
        return GNSSstatus_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t GNSSstatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment GNSSstatus_decode_xer$address() {
        return GNSSstatus_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t GNSSstatus_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment GNSSstatus_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = GNSSstatus_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GNSSstatus_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GNSSstatus_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GNSSstatus_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor GNSSstatus_encode_xer$descriptor() {
        return GNSSstatus_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle GNSSstatus_encode_xer$handle() {
        return GNSSstatus_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment GNSSstatus_encode_xer$address() {
        return GNSSstatus_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment GNSSstatus_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = GNSSstatus_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GNSSstatus_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GNSSstatus_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GNSSstatus_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor GNSSstatus_encode_jer$descriptor() {
        return GNSSstatus_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle GNSSstatus_encode_jer$handle() {
        return GNSSstatus_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment GNSSstatus_encode_jer$address() {
        return GNSSstatus_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment GNSSstatus_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = GNSSstatus_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GNSSstatus_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GNSSstatus_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GNSSstatus_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t GNSSstatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor GNSSstatus_decode_oer$descriptor() {
        return GNSSstatus_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t GNSSstatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle GNSSstatus_decode_oer$handle() {
        return GNSSstatus_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t GNSSstatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment GNSSstatus_decode_oer$address() {
        return GNSSstatus_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t GNSSstatus_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment GNSSstatus_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = GNSSstatus_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GNSSstatus_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GNSSstatus_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GNSSstatus_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor GNSSstatus_encode_oer$descriptor() {
        return GNSSstatus_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle GNSSstatus_encode_oer$handle() {
        return GNSSstatus_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment GNSSstatus_encode_oer$address() {
        return GNSSstatus_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment GNSSstatus_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = GNSSstatus_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GNSSstatus_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GNSSstatus_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GNSSstatus_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t GNSSstatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor GNSSstatus_decode_uper$descriptor() {
        return GNSSstatus_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t GNSSstatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle GNSSstatus_decode_uper$handle() {
        return GNSSstatus_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t GNSSstatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment GNSSstatus_decode_uper$address() {
        return GNSSstatus_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t GNSSstatus_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment GNSSstatus_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = GNSSstatus_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GNSSstatus_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GNSSstatus_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GNSSstatus_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor GNSSstatus_encode_uper$descriptor() {
        return GNSSstatus_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle GNSSstatus_encode_uper$handle() {
        return GNSSstatus_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment GNSSstatus_encode_uper$address() {
        return GNSSstatus_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment GNSSstatus_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = GNSSstatus_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GNSSstatus_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GNSSstatus_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GNSSstatus_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t GNSSstatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor GNSSstatus_decode_aper$descriptor() {
        return GNSSstatus_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t GNSSstatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle GNSSstatus_decode_aper$handle() {
        return GNSSstatus_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t GNSSstatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment GNSSstatus_decode_aper$address() {
        return GNSSstatus_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t GNSSstatus_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment GNSSstatus_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = GNSSstatus_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GNSSstatus_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class GNSSstatus_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("GNSSstatus_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor GNSSstatus_encode_aper$descriptor() {
        return GNSSstatus_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle GNSSstatus_encode_aper$handle() {
        return GNSSstatus_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment GNSSstatus_encode_aper$address() {
        return GNSSstatus_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t GNSSstatus_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment GNSSstatus_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = GNSSstatus_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("GNSSstatus_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_PathHistoryPointList$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_PathHistoryPointList").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PathHistoryPointList
     * }
     */
    public static GroupLayout asn_DEF_PathHistoryPointList$layout() {
        return asn_DEF_PathHistoryPointList$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PathHistoryPointList
     * }
     */
    public static MemorySegment asn_DEF_PathHistoryPointList() {
        return asn_DEF_PathHistoryPointList$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PathHistoryPointList
     * }
     */
    public static void asn_DEF_PathHistoryPointList(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_PathHistoryPointList$constants.SEGMENT, 0L, asn_DEF_PathHistoryPointList$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_PathHistoryPointList_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SET_OF_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_PathHistoryPointList_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_PathHistoryPointList_specs_1
     * }
     */
    public static GroupLayout asn_SPC_PathHistoryPointList_specs_1$layout() {
        return asn_SPC_PathHistoryPointList_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_PathHistoryPointList_specs_1
     * }
     */
    public static MemorySegment asn_SPC_PathHistoryPointList_specs_1() {
        return asn_SPC_PathHistoryPointList_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SET_OF_specifics_t asn_SPC_PathHistoryPointList_specs_1
     * }
     */
    public static void asn_SPC_PathHistoryPointList_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_PathHistoryPointList_specs_1$constants.SEGMENT, 0L, asn_SPC_PathHistoryPointList_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_PathHistoryPointList_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(1, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_PathHistoryPointList_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 1 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathHistoryPointList_1[1]
     * }
     */
    public static SequenceLayout asn_MBR_PathHistoryPointList_1$layout() {
        return asn_MBR_PathHistoryPointList_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathHistoryPointList_1[1]
     * }
     */
    public static long[] asn_MBR_PathHistoryPointList_1$dimensions() {
        return asn_MBR_PathHistoryPointList_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathHistoryPointList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_PathHistoryPointList_1() {
        return asn_MBR_PathHistoryPointList_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathHistoryPointList_1[1]
     * }
     */
    public static void asn_MBR_PathHistoryPointList_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_PathHistoryPointList_1$constants.SEGMENT, 0L, asn_MBR_PathHistoryPointList_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathHistoryPointList_1[1]
     * }
     */
    public static MemorySegment asn_MBR_PathHistoryPointList_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_PathHistoryPointList_1$constants.HANDLE.invokeExact(asn_MBR_PathHistoryPointList_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathHistoryPointList_1[1]
     * }
     */
    public static void asn_MBR_PathHistoryPointList_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_PathHistoryPointList_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_PER_type_PathHistoryPointList_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_PathHistoryPointList_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PathHistoryPointList_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_PathHistoryPointList_constr_1$layout() {
        return asn_PER_type_PathHistoryPointList_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PathHistoryPointList_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_PathHistoryPointList_constr_1() {
        return asn_PER_type_PathHistoryPointList_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PathHistoryPointList_constr_1
     * }
     */
    public static void asn_PER_type_PathHistoryPointList_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_PathHistoryPointList_constr_1$constants.SEGMENT, 0L, asn_PER_type_PathHistoryPointList_constr_1$constants.LAYOUT.byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef long OffsetLL_B18_t
     * }
     */
    public static final OfLong OffsetLL_B18_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_OffsetLL_B18_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_OffsetLL_B18_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_OffsetLL_B18_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_OffsetLL_B18_constr_1$layout() {
        return asn_PER_type_OffsetLL_B18_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_OffsetLL_B18_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_OffsetLL_B18_constr_1() {
        return asn_PER_type_OffsetLL_B18_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_OffsetLL_B18_constr_1
     * }
     */
    public static void asn_PER_type_OffsetLL_B18_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_OffsetLL_B18_constr_1$constants.SEGMENT, 0L, asn_PER_type_OffsetLL_B18_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_OffsetLL_B18$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_OffsetLL_B18").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_OffsetLL_B18
     * }
     */
    public static GroupLayout asn_DEF_OffsetLL_B18$layout() {
        return asn_DEF_OffsetLL_B18$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_OffsetLL_B18
     * }
     */
    public static MemorySegment asn_DEF_OffsetLL_B18() {
        return asn_DEF_OffsetLL_B18$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_OffsetLL_B18
     * }
     */
    public static void asn_DEF_OffsetLL_B18(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_OffsetLL_B18$constants.SEGMENT, 0L, asn_DEF_OffsetLL_B18$constants.LAYOUT.byteSize());
    }

    private static class OffsetLL_B18_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B18_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void OffsetLL_B18_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor OffsetLL_B18_free$descriptor() {
        return OffsetLL_B18_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void OffsetLL_B18_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle OffsetLL_B18_free$handle() {
        return OffsetLL_B18_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void OffsetLL_B18_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment OffsetLL_B18_free$address() {
        return OffsetLL_B18_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void OffsetLL_B18_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void OffsetLL_B18_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = OffsetLL_B18_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B18_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B18_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B18_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int OffsetLL_B18_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B18_print$descriptor() {
        return OffsetLL_B18_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int OffsetLL_B18_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OffsetLL_B18_print$handle() {
        return OffsetLL_B18_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int OffsetLL_B18_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B18_print$address() {
        return OffsetLL_B18_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int OffsetLL_B18_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int OffsetLL_B18_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = OffsetLL_B18_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B18_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B18_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B18_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int OffsetLL_B18_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B18_constraint$descriptor() {
        return OffsetLL_B18_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int OffsetLL_B18_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle OffsetLL_B18_constraint$handle() {
        return OffsetLL_B18_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int OffsetLL_B18_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B18_constraint$address() {
        return OffsetLL_B18_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int OffsetLL_B18_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int OffsetLL_B18_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = OffsetLL_B18_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B18_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B18_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B18_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B18_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor OffsetLL_B18_decode_ber$descriptor() {
        return OffsetLL_B18_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B18_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle OffsetLL_B18_decode_ber$handle() {
        return OffsetLL_B18_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B18_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment OffsetLL_B18_decode_ber$address() {
        return OffsetLL_B18_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B18_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment OffsetLL_B18_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = OffsetLL_B18_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B18_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B18_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B18_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B18_encode_der$descriptor() {
        return OffsetLL_B18_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OffsetLL_B18_encode_der$handle() {
        return OffsetLL_B18_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B18_encode_der$address() {
        return OffsetLL_B18_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B18_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = OffsetLL_B18_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B18_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B18_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B18_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B18_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor OffsetLL_B18_decode_xer$descriptor() {
        return OffsetLL_B18_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B18_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle OffsetLL_B18_decode_xer$handle() {
        return OffsetLL_B18_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B18_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment OffsetLL_B18_decode_xer$address() {
        return OffsetLL_B18_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B18_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment OffsetLL_B18_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = OffsetLL_B18_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B18_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B18_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B18_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B18_encode_xer$descriptor() {
        return OffsetLL_B18_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OffsetLL_B18_encode_xer$handle() {
        return OffsetLL_B18_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B18_encode_xer$address() {
        return OffsetLL_B18_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B18_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = OffsetLL_B18_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B18_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B18_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B18_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B18_encode_jer$descriptor() {
        return OffsetLL_B18_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OffsetLL_B18_encode_jer$handle() {
        return OffsetLL_B18_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B18_encode_jer$address() {
        return OffsetLL_B18_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B18_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = OffsetLL_B18_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B18_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B18_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B18_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B18_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor OffsetLL_B18_decode_oer$descriptor() {
        return OffsetLL_B18_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B18_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle OffsetLL_B18_decode_oer$handle() {
        return OffsetLL_B18_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B18_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment OffsetLL_B18_decode_oer$address() {
        return OffsetLL_B18_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B18_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment OffsetLL_B18_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = OffsetLL_B18_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B18_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B18_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B18_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B18_encode_oer$descriptor() {
        return OffsetLL_B18_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle OffsetLL_B18_encode_oer$handle() {
        return OffsetLL_B18_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B18_encode_oer$address() {
        return OffsetLL_B18_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment OffsetLL_B18_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = OffsetLL_B18_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B18_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B18_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B18_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B18_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B18_decode_uper$descriptor() {
        return OffsetLL_B18_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B18_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle OffsetLL_B18_decode_uper$handle() {
        return OffsetLL_B18_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B18_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment OffsetLL_B18_decode_uper$address() {
        return OffsetLL_B18_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B18_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment OffsetLL_B18_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = OffsetLL_B18_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B18_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B18_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B18_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B18_encode_uper$descriptor() {
        return OffsetLL_B18_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle OffsetLL_B18_encode_uper$handle() {
        return OffsetLL_B18_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment OffsetLL_B18_encode_uper$address() {
        return OffsetLL_B18_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment OffsetLL_B18_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = OffsetLL_B18_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B18_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B18_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B18_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B18_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B18_decode_aper$descriptor() {
        return OffsetLL_B18_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B18_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle OffsetLL_B18_decode_aper$handle() {
        return OffsetLL_B18_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B18_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment OffsetLL_B18_decode_aper$address() {
        return OffsetLL_B18_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t OffsetLL_B18_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment OffsetLL_B18_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = OffsetLL_B18_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B18_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class OffsetLL_B18_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("OffsetLL_B18_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor OffsetLL_B18_encode_aper$descriptor() {
        return OffsetLL_B18_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle OffsetLL_B18_encode_aper$handle() {
        return OffsetLL_B18_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment OffsetLL_B18_encode_aper$address() {
        return OffsetLL_B18_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t OffsetLL_B18_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment OffsetLL_B18_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = OffsetLL_B18_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("OffsetLL_B18_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long VertOffset_B12_t
     * }
     */
    public static final OfLong VertOffset_B12_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_VertOffset_B12_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_VertOffset_B12_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VertOffset_B12_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_VertOffset_B12_constr_1$layout() {
        return asn_PER_type_VertOffset_B12_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VertOffset_B12_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_VertOffset_B12_constr_1() {
        return asn_PER_type_VertOffset_B12_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_VertOffset_B12_constr_1
     * }
     */
    public static void asn_PER_type_VertOffset_B12_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_VertOffset_B12_constr_1$constants.SEGMENT, 0L, asn_PER_type_VertOffset_B12_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_VertOffset_B12$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_VertOffset_B12").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VertOffset_B12
     * }
     */
    public static GroupLayout asn_DEF_VertOffset_B12$layout() {
        return asn_DEF_VertOffset_B12$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VertOffset_B12
     * }
     */
    public static MemorySegment asn_DEF_VertOffset_B12() {
        return asn_DEF_VertOffset_B12$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_VertOffset_B12
     * }
     */
    public static void asn_DEF_VertOffset_B12(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_VertOffset_B12$constants.SEGMENT, 0L, asn_DEF_VertOffset_B12$constants.LAYOUT.byteSize());
    }

    private static class VertOffset_B12_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VertOffset_B12_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void VertOffset_B12_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor VertOffset_B12_free$descriptor() {
        return VertOffset_B12_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void VertOffset_B12_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle VertOffset_B12_free$handle() {
        return VertOffset_B12_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void VertOffset_B12_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment VertOffset_B12_free$address() {
        return VertOffset_B12_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void VertOffset_B12_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void VertOffset_B12_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = VertOffset_B12_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VertOffset_B12_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VertOffset_B12_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VertOffset_B12_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int VertOffset_B12_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VertOffset_B12_print$descriptor() {
        return VertOffset_B12_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int VertOffset_B12_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VertOffset_B12_print$handle() {
        return VertOffset_B12_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int VertOffset_B12_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VertOffset_B12_print$address() {
        return VertOffset_B12_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int VertOffset_B12_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int VertOffset_B12_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VertOffset_B12_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VertOffset_B12_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VertOffset_B12_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VertOffset_B12_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int VertOffset_B12_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor VertOffset_B12_constraint$descriptor() {
        return VertOffset_B12_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int VertOffset_B12_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle VertOffset_B12_constraint$handle() {
        return VertOffset_B12_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int VertOffset_B12_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment VertOffset_B12_constraint$address() {
        return VertOffset_B12_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int VertOffset_B12_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int VertOffset_B12_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = VertOffset_B12_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VertOffset_B12_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VertOffset_B12_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VertOffset_B12_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VertOffset_B12_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor VertOffset_B12_decode_ber$descriptor() {
        return VertOffset_B12_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VertOffset_B12_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle VertOffset_B12_decode_ber$handle() {
        return VertOffset_B12_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VertOffset_B12_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment VertOffset_B12_decode_ber$address() {
        return VertOffset_B12_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VertOffset_B12_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment VertOffset_B12_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = VertOffset_B12_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VertOffset_B12_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VertOffset_B12_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VertOffset_B12_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VertOffset_B12_encode_der$descriptor() {
        return VertOffset_B12_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VertOffset_B12_encode_der$handle() {
        return VertOffset_B12_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VertOffset_B12_encode_der$address() {
        return VertOffset_B12_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VertOffset_B12_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = VertOffset_B12_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VertOffset_B12_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VertOffset_B12_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VertOffset_B12_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VertOffset_B12_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor VertOffset_B12_decode_xer$descriptor() {
        return VertOffset_B12_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VertOffset_B12_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle VertOffset_B12_decode_xer$handle() {
        return VertOffset_B12_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VertOffset_B12_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment VertOffset_B12_decode_xer$address() {
        return VertOffset_B12_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VertOffset_B12_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment VertOffset_B12_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = VertOffset_B12_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VertOffset_B12_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VertOffset_B12_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VertOffset_B12_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VertOffset_B12_encode_xer$descriptor() {
        return VertOffset_B12_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VertOffset_B12_encode_xer$handle() {
        return VertOffset_B12_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VertOffset_B12_encode_xer$address() {
        return VertOffset_B12_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VertOffset_B12_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = VertOffset_B12_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VertOffset_B12_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VertOffset_B12_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VertOffset_B12_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VertOffset_B12_encode_jer$descriptor() {
        return VertOffset_B12_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VertOffset_B12_encode_jer$handle() {
        return VertOffset_B12_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VertOffset_B12_encode_jer$address() {
        return VertOffset_B12_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VertOffset_B12_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = VertOffset_B12_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VertOffset_B12_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VertOffset_B12_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VertOffset_B12_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VertOffset_B12_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor VertOffset_B12_decode_oer$descriptor() {
        return VertOffset_B12_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VertOffset_B12_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle VertOffset_B12_decode_oer$handle() {
        return VertOffset_B12_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VertOffset_B12_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment VertOffset_B12_decode_oer$address() {
        return VertOffset_B12_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VertOffset_B12_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment VertOffset_B12_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = VertOffset_B12_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VertOffset_B12_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VertOffset_B12_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VertOffset_B12_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor VertOffset_B12_encode_oer$descriptor() {
        return VertOffset_B12_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle VertOffset_B12_encode_oer$handle() {
        return VertOffset_B12_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VertOffset_B12_encode_oer$address() {
        return VertOffset_B12_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment VertOffset_B12_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VertOffset_B12_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VertOffset_B12_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VertOffset_B12_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VertOffset_B12_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VertOffset_B12_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor VertOffset_B12_decode_uper$descriptor() {
        return VertOffset_B12_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VertOffset_B12_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle VertOffset_B12_decode_uper$handle() {
        return VertOffset_B12_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VertOffset_B12_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VertOffset_B12_decode_uper$address() {
        return VertOffset_B12_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VertOffset_B12_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VertOffset_B12_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VertOffset_B12_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VertOffset_B12_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VertOffset_B12_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VertOffset_B12_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor VertOffset_B12_encode_uper$descriptor() {
        return VertOffset_B12_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle VertOffset_B12_encode_uper$handle() {
        return VertOffset_B12_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VertOffset_B12_encode_uper$address() {
        return VertOffset_B12_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VertOffset_B12_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = VertOffset_B12_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VertOffset_B12_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VertOffset_B12_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VertOffset_B12_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t VertOffset_B12_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor VertOffset_B12_decode_aper$descriptor() {
        return VertOffset_B12_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t VertOffset_B12_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle VertOffset_B12_decode_aper$handle() {
        return VertOffset_B12_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t VertOffset_B12_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VertOffset_B12_decode_aper$address() {
        return VertOffset_B12_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t VertOffset_B12_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment VertOffset_B12_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = VertOffset_B12_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VertOffset_B12_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class VertOffset_B12_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("VertOffset_B12_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor VertOffset_B12_encode_aper$descriptor() {
        return VertOffset_B12_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle VertOffset_B12_encode_aper$handle() {
        return VertOffset_B12_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VertOffset_B12_encode_aper$address() {
        return VertOffset_B12_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t VertOffset_B12_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment VertOffset_B12_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = VertOffset_B12_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("VertOffset_B12_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long TimeOffset_t
     * }
     */
    public static final OfLong TimeOffset_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_TimeOffset_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_TimeOffset_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TimeOffset_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_TimeOffset_constr_1$layout() {
        return asn_PER_type_TimeOffset_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TimeOffset_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_TimeOffset_constr_1() {
        return asn_PER_type_TimeOffset_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TimeOffset_constr_1
     * }
     */
    public static void asn_PER_type_TimeOffset_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_TimeOffset_constr_1$constants.SEGMENT, 0L, asn_PER_type_TimeOffset_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_TimeOffset$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_TimeOffset").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TimeOffset
     * }
     */
    public static GroupLayout asn_DEF_TimeOffset$layout() {
        return asn_DEF_TimeOffset$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TimeOffset
     * }
     */
    public static MemorySegment asn_DEF_TimeOffset() {
        return asn_DEF_TimeOffset$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TimeOffset
     * }
     */
    public static void asn_DEF_TimeOffset(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_TimeOffset$constants.SEGMENT, 0L, asn_DEF_TimeOffset$constants.LAYOUT.byteSize());
    }

    private static class TimeOffset_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeOffset_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void TimeOffset_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor TimeOffset_free$descriptor() {
        return TimeOffset_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void TimeOffset_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle TimeOffset_free$handle() {
        return TimeOffset_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void TimeOffset_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment TimeOffset_free$address() {
        return TimeOffset_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void TimeOffset_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void TimeOffset_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = TimeOffset_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeOffset_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeOffset_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeOffset_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TimeOffset_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TimeOffset_print$descriptor() {
        return TimeOffset_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TimeOffset_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TimeOffset_print$handle() {
        return TimeOffset_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TimeOffset_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TimeOffset_print$address() {
        return TimeOffset_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TimeOffset_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int TimeOffset_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TimeOffset_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeOffset_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeOffset_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeOffset_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TimeOffset_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor TimeOffset_constraint$descriptor() {
        return TimeOffset_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TimeOffset_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle TimeOffset_constraint$handle() {
        return TimeOffset_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TimeOffset_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment TimeOffset_constraint$address() {
        return TimeOffset_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TimeOffset_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int TimeOffset_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TimeOffset_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeOffset_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeOffset_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeOffset_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeOffset_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor TimeOffset_decode_ber$descriptor() {
        return TimeOffset_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeOffset_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle TimeOffset_decode_ber$handle() {
        return TimeOffset_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeOffset_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment TimeOffset_decode_ber$address() {
        return TimeOffset_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TimeOffset_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment TimeOffset_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = TimeOffset_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeOffset_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeOffset_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeOffset_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TimeOffset_encode_der$descriptor() {
        return TimeOffset_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TimeOffset_encode_der$handle() {
        return TimeOffset_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TimeOffset_encode_der$address() {
        return TimeOffset_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TimeOffset_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = TimeOffset_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeOffset_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeOffset_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeOffset_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeOffset_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor TimeOffset_decode_xer$descriptor() {
        return TimeOffset_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeOffset_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle TimeOffset_decode_xer$handle() {
        return TimeOffset_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeOffset_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment TimeOffset_decode_xer$address() {
        return TimeOffset_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TimeOffset_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment TimeOffset_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = TimeOffset_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeOffset_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeOffset_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeOffset_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TimeOffset_encode_xer$descriptor() {
        return TimeOffset_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TimeOffset_encode_xer$handle() {
        return TimeOffset_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TimeOffset_encode_xer$address() {
        return TimeOffset_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TimeOffset_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = TimeOffset_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeOffset_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeOffset_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeOffset_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TimeOffset_encode_jer$descriptor() {
        return TimeOffset_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TimeOffset_encode_jer$handle() {
        return TimeOffset_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TimeOffset_encode_jer$address() {
        return TimeOffset_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TimeOffset_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = TimeOffset_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeOffset_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeOffset_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeOffset_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeOffset_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor TimeOffset_decode_oer$descriptor() {
        return TimeOffset_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeOffset_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle TimeOffset_decode_oer$handle() {
        return TimeOffset_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeOffset_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment TimeOffset_decode_oer$address() {
        return TimeOffset_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TimeOffset_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment TimeOffset_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = TimeOffset_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeOffset_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeOffset_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeOffset_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TimeOffset_encode_oer$descriptor() {
        return TimeOffset_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TimeOffset_encode_oer$handle() {
        return TimeOffset_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TimeOffset_encode_oer$address() {
        return TimeOffset_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TimeOffset_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TimeOffset_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeOffset_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeOffset_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeOffset_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeOffset_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor TimeOffset_decode_uper$descriptor() {
        return TimeOffset_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeOffset_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle TimeOffset_decode_uper$handle() {
        return TimeOffset_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeOffset_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TimeOffset_decode_uper$address() {
        return TimeOffset_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TimeOffset_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TimeOffset_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TimeOffset_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeOffset_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeOffset_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeOffset_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor TimeOffset_encode_uper$descriptor() {
        return TimeOffset_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle TimeOffset_encode_uper$handle() {
        return TimeOffset_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TimeOffset_encode_uper$address() {
        return TimeOffset_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TimeOffset_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TimeOffset_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeOffset_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeOffset_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeOffset_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeOffset_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor TimeOffset_decode_aper$descriptor() {
        return TimeOffset_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeOffset_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle TimeOffset_decode_aper$handle() {
        return TimeOffset_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeOffset_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TimeOffset_decode_aper$address() {
        return TimeOffset_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TimeOffset_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TimeOffset_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TimeOffset_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeOffset_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeOffset_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeOffset_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor TimeOffset_encode_aper$descriptor() {
        return TimeOffset_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle TimeOffset_encode_aper$handle() {
        return TimeOffset_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TimeOffset_encode_aper$address() {
        return TimeOffset_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TimeOffset_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TimeOffset_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TimeOffset_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeOffset_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long CoarseHeading_t
     * }
     */
    public static final OfLong CoarseHeading_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_CoarseHeading_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_CoarseHeading_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_CoarseHeading_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_CoarseHeading_constr_1$layout() {
        return asn_PER_type_CoarseHeading_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_CoarseHeading_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_CoarseHeading_constr_1() {
        return asn_PER_type_CoarseHeading_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_CoarseHeading_constr_1
     * }
     */
    public static void asn_PER_type_CoarseHeading_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_CoarseHeading_constr_1$constants.SEGMENT, 0L, asn_PER_type_CoarseHeading_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_CoarseHeading$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_CoarseHeading").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_CoarseHeading
     * }
     */
    public static GroupLayout asn_DEF_CoarseHeading$layout() {
        return asn_DEF_CoarseHeading$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_CoarseHeading
     * }
     */
    public static MemorySegment asn_DEF_CoarseHeading() {
        return asn_DEF_CoarseHeading$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_CoarseHeading
     * }
     */
    public static void asn_DEF_CoarseHeading(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_CoarseHeading$constants.SEGMENT, 0L, asn_DEF_CoarseHeading$constants.LAYOUT.byteSize());
    }

    private static class CoarseHeading_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CoarseHeading_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void CoarseHeading_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor CoarseHeading_free$descriptor() {
        return CoarseHeading_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void CoarseHeading_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle CoarseHeading_free$handle() {
        return CoarseHeading_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void CoarseHeading_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment CoarseHeading_free$address() {
        return CoarseHeading_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void CoarseHeading_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void CoarseHeading_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = CoarseHeading_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CoarseHeading_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CoarseHeading_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CoarseHeading_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CoarseHeading_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor CoarseHeading_print$descriptor() {
        return CoarseHeading_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CoarseHeading_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle CoarseHeading_print$handle() {
        return CoarseHeading_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int CoarseHeading_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment CoarseHeading_print$address() {
        return CoarseHeading_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int CoarseHeading_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int CoarseHeading_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = CoarseHeading_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CoarseHeading_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CoarseHeading_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CoarseHeading_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int CoarseHeading_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor CoarseHeading_constraint$descriptor() {
        return CoarseHeading_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int CoarseHeading_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle CoarseHeading_constraint$handle() {
        return CoarseHeading_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int CoarseHeading_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment CoarseHeading_constraint$address() {
        return CoarseHeading_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int CoarseHeading_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int CoarseHeading_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = CoarseHeading_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CoarseHeading_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CoarseHeading_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CoarseHeading_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t CoarseHeading_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor CoarseHeading_decode_ber$descriptor() {
        return CoarseHeading_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t CoarseHeading_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle CoarseHeading_decode_ber$handle() {
        return CoarseHeading_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t CoarseHeading_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment CoarseHeading_decode_ber$address() {
        return CoarseHeading_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t CoarseHeading_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment CoarseHeading_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = CoarseHeading_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CoarseHeading_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CoarseHeading_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CoarseHeading_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor CoarseHeading_encode_der$descriptor() {
        return CoarseHeading_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle CoarseHeading_encode_der$handle() {
        return CoarseHeading_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment CoarseHeading_encode_der$address() {
        return CoarseHeading_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment CoarseHeading_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = CoarseHeading_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CoarseHeading_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CoarseHeading_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CoarseHeading_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t CoarseHeading_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor CoarseHeading_decode_xer$descriptor() {
        return CoarseHeading_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t CoarseHeading_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle CoarseHeading_decode_xer$handle() {
        return CoarseHeading_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t CoarseHeading_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment CoarseHeading_decode_xer$address() {
        return CoarseHeading_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t CoarseHeading_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment CoarseHeading_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = CoarseHeading_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CoarseHeading_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CoarseHeading_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CoarseHeading_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor CoarseHeading_encode_xer$descriptor() {
        return CoarseHeading_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle CoarseHeading_encode_xer$handle() {
        return CoarseHeading_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment CoarseHeading_encode_xer$address() {
        return CoarseHeading_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment CoarseHeading_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = CoarseHeading_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CoarseHeading_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CoarseHeading_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CoarseHeading_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor CoarseHeading_encode_jer$descriptor() {
        return CoarseHeading_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle CoarseHeading_encode_jer$handle() {
        return CoarseHeading_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment CoarseHeading_encode_jer$address() {
        return CoarseHeading_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment CoarseHeading_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = CoarseHeading_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CoarseHeading_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CoarseHeading_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CoarseHeading_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t CoarseHeading_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor CoarseHeading_decode_oer$descriptor() {
        return CoarseHeading_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t CoarseHeading_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle CoarseHeading_decode_oer$handle() {
        return CoarseHeading_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t CoarseHeading_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment CoarseHeading_decode_oer$address() {
        return CoarseHeading_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t CoarseHeading_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment CoarseHeading_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = CoarseHeading_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CoarseHeading_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CoarseHeading_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CoarseHeading_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor CoarseHeading_encode_oer$descriptor() {
        return CoarseHeading_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle CoarseHeading_encode_oer$handle() {
        return CoarseHeading_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment CoarseHeading_encode_oer$address() {
        return CoarseHeading_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment CoarseHeading_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = CoarseHeading_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CoarseHeading_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CoarseHeading_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CoarseHeading_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t CoarseHeading_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor CoarseHeading_decode_uper$descriptor() {
        return CoarseHeading_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t CoarseHeading_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle CoarseHeading_decode_uper$handle() {
        return CoarseHeading_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t CoarseHeading_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment CoarseHeading_decode_uper$address() {
        return CoarseHeading_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t CoarseHeading_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment CoarseHeading_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = CoarseHeading_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CoarseHeading_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CoarseHeading_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CoarseHeading_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor CoarseHeading_encode_uper$descriptor() {
        return CoarseHeading_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle CoarseHeading_encode_uper$handle() {
        return CoarseHeading_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment CoarseHeading_encode_uper$address() {
        return CoarseHeading_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment CoarseHeading_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = CoarseHeading_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CoarseHeading_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CoarseHeading_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CoarseHeading_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t CoarseHeading_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor CoarseHeading_decode_aper$descriptor() {
        return CoarseHeading_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t CoarseHeading_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle CoarseHeading_decode_aper$handle() {
        return CoarseHeading_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t CoarseHeading_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment CoarseHeading_decode_aper$address() {
        return CoarseHeading_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t CoarseHeading_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment CoarseHeading_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = CoarseHeading_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CoarseHeading_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class CoarseHeading_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("CoarseHeading_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor CoarseHeading_encode_aper$descriptor() {
        return CoarseHeading_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle CoarseHeading_encode_aper$handle() {
        return CoarseHeading_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment CoarseHeading_encode_aper$address() {
        return CoarseHeading_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t CoarseHeading_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment CoarseHeading_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = CoarseHeading_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("CoarseHeading_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_PathHistoryPoint$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_PathHistoryPoint").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PathHistoryPoint
     * }
     */
    public static GroupLayout asn_DEF_PathHistoryPoint$layout() {
        return asn_DEF_PathHistoryPoint$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PathHistoryPoint
     * }
     */
    public static MemorySegment asn_DEF_PathHistoryPoint() {
        return asn_DEF_PathHistoryPoint$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PathHistoryPoint
     * }
     */
    public static void asn_DEF_PathHistoryPoint(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_PathHistoryPoint$constants.SEGMENT, 0L, asn_DEF_PathHistoryPoint$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_PathHistoryPoint_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_PathHistoryPoint_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_PathHistoryPoint_specs_1
     * }
     */
    public static GroupLayout asn_SPC_PathHistoryPoint_specs_1$layout() {
        return asn_SPC_PathHistoryPoint_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_PathHistoryPoint_specs_1
     * }
     */
    public static MemorySegment asn_SPC_PathHistoryPoint_specs_1() {
        return asn_SPC_PathHistoryPoint_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_PathHistoryPoint_specs_1
     * }
     */
    public static void asn_SPC_PathHistoryPoint_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_PathHistoryPoint_specs_1$constants.SEGMENT, 0L, asn_SPC_PathHistoryPoint_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_PathHistoryPoint_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(7, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_PathHistoryPoint_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 7 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathHistoryPoint_1[7]
     * }
     */
    public static SequenceLayout asn_MBR_PathHistoryPoint_1$layout() {
        return asn_MBR_PathHistoryPoint_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathHistoryPoint_1[7]
     * }
     */
    public static long[] asn_MBR_PathHistoryPoint_1$dimensions() {
        return asn_MBR_PathHistoryPoint_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathHistoryPoint_1[7]
     * }
     */
    public static MemorySegment asn_MBR_PathHistoryPoint_1() {
        return asn_MBR_PathHistoryPoint_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathHistoryPoint_1[7]
     * }
     */
    public static void asn_MBR_PathHistoryPoint_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_PathHistoryPoint_1$constants.SEGMENT, 0L, asn_MBR_PathHistoryPoint_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathHistoryPoint_1[7]
     * }
     */
    public static MemorySegment asn_MBR_PathHistoryPoint_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_PathHistoryPoint_1$constants.HANDLE.invokeExact(asn_MBR_PathHistoryPoint_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathHistoryPoint_1[7]
     * }
     */
    public static void asn_MBR_PathHistoryPoint_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_PathHistoryPoint_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }

    private static class asn_DEF_PathHistory$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_PathHistory").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PathHistory
     * }
     */
    public static GroupLayout asn_DEF_PathHistory$layout() {
        return asn_DEF_PathHistory$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PathHistory
     * }
     */
    public static MemorySegment asn_DEF_PathHistory() {
        return asn_DEF_PathHistory$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PathHistory
     * }
     */
    public static void asn_DEF_PathHistory(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_PathHistory$constants.SEGMENT, 0L, asn_DEF_PathHistory$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_PathHistory_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_PathHistory_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_PathHistory_specs_1
     * }
     */
    public static GroupLayout asn_SPC_PathHistory_specs_1$layout() {
        return asn_SPC_PathHistory_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_PathHistory_specs_1
     * }
     */
    public static MemorySegment asn_SPC_PathHistory_specs_1() {
        return asn_SPC_PathHistory_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_PathHistory_specs_1
     * }
     */
    public static void asn_SPC_PathHistory_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_PathHistory_specs_1$constants.SEGMENT, 0L, asn_SPC_PathHistory_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_PathHistory_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(3, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_PathHistory_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 3 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathHistory_1[3]
     * }
     */
    public static SequenceLayout asn_MBR_PathHistory_1$layout() {
        return asn_MBR_PathHistory_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathHistory_1[3]
     * }
     */
    public static long[] asn_MBR_PathHistory_1$dimensions() {
        return asn_MBR_PathHistory_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathHistory_1[3]
     * }
     */
    public static MemorySegment asn_MBR_PathHistory_1() {
        return asn_MBR_PathHistory_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathHistory_1[3]
     * }
     */
    public static void asn_MBR_PathHistory_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_PathHistory_1$constants.SEGMENT, 0L, asn_MBR_PathHistory_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathHistory_1[3]
     * }
     */
    public static MemorySegment asn_MBR_PathHistory_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_PathHistory_1$constants.HANDLE.invokeExact(asn_MBR_PathHistory_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PathHistory_1[3]
     * }
     */
    public static void asn_MBR_PathHistory_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_PathHistory_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    private static final int TimeConfidence_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_unavailable = 0
     * }
     */
    public static int TimeConfidence_unavailable() {
        return TimeConfidence_unavailable;
    }
    private static final int TimeConfidence_time_100_000 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_100_000 = 1
     * }
     */
    public static int TimeConfidence_time_100_000() {
        return TimeConfidence_time_100_000;
    }
    private static final int TimeConfidence_time_050_000 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_050_000 = 2
     * }
     */
    public static int TimeConfidence_time_050_000() {
        return TimeConfidence_time_050_000;
    }
    private static final int TimeConfidence_time_020_000 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_020_000 = 3
     * }
     */
    public static int TimeConfidence_time_020_000() {
        return TimeConfidence_time_020_000;
    }
    private static final int TimeConfidence_time_010_000 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_010_000 = 4
     * }
     */
    public static int TimeConfidence_time_010_000() {
        return TimeConfidence_time_010_000;
    }
    private static final int TimeConfidence_time_002_000 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_002_000 = 5
     * }
     */
    public static int TimeConfidence_time_002_000() {
        return TimeConfidence_time_002_000;
    }
    private static final int TimeConfidence_time_001_000 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_001_000 = 6
     * }
     */
    public static int TimeConfidence_time_001_000() {
        return TimeConfidence_time_001_000;
    }
    private static final int TimeConfidence_time_000_500 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_500 = 7
     * }
     */
    public static int TimeConfidence_time_000_500() {
        return TimeConfidence_time_000_500;
    }
    private static final int TimeConfidence_time_000_200 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_200 = 8
     * }
     */
    public static int TimeConfidence_time_000_200() {
        return TimeConfidence_time_000_200;
    }
    private static final int TimeConfidence_time_000_100 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_100 = 9
     * }
     */
    public static int TimeConfidence_time_000_100() {
        return TimeConfidence_time_000_100;
    }
    private static final int TimeConfidence_time_000_050 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_050 = 10
     * }
     */
    public static int TimeConfidence_time_000_050() {
        return TimeConfidence_time_000_050;
    }
    private static final int TimeConfidence_time_000_020 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_020 = 11
     * }
     */
    public static int TimeConfidence_time_000_020() {
        return TimeConfidence_time_000_020;
    }
    private static final int TimeConfidence_time_000_010 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_010 = 12
     * }
     */
    public static int TimeConfidence_time_000_010() {
        return TimeConfidence_time_000_010;
    }
    private static final int TimeConfidence_time_000_005 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_005 = 13
     * }
     */
    public static int TimeConfidence_time_000_005() {
        return TimeConfidence_time_000_005;
    }
    private static final int TimeConfidence_time_000_002 = (int)14L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_002 = 14
     * }
     */
    public static int TimeConfidence_time_000_002() {
        return TimeConfidence_time_000_002;
    }
    private static final int TimeConfidence_time_000_001 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_001 = 15
     * }
     */
    public static int TimeConfidence_time_000_001() {
        return TimeConfidence_time_000_001;
    }
    private static final int TimeConfidence_time_000_000_5 = (int)16L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_5 = 16
     * }
     */
    public static int TimeConfidence_time_000_000_5() {
        return TimeConfidence_time_000_000_5;
    }
    private static final int TimeConfidence_time_000_000_2 = (int)17L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_2 = 17
     * }
     */
    public static int TimeConfidence_time_000_000_2() {
        return TimeConfidence_time_000_000_2;
    }
    private static final int TimeConfidence_time_000_000_1 = (int)18L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_1 = 18
     * }
     */
    public static int TimeConfidence_time_000_000_1() {
        return TimeConfidence_time_000_000_1;
    }
    private static final int TimeConfidence_time_000_000_05 = (int)19L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_05 = 19
     * }
     */
    public static int TimeConfidence_time_000_000_05() {
        return TimeConfidence_time_000_000_05;
    }
    private static final int TimeConfidence_time_000_000_02 = (int)20L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_02 = 20
     * }
     */
    public static int TimeConfidence_time_000_000_02() {
        return TimeConfidence_time_000_000_02;
    }
    private static final int TimeConfidence_time_000_000_01 = (int)21L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_01 = 21
     * }
     */
    public static int TimeConfidence_time_000_000_01() {
        return TimeConfidence_time_000_000_01;
    }
    private static final int TimeConfidence_time_000_000_005 = (int)22L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_005 = 22
     * }
     */
    public static int TimeConfidence_time_000_000_005() {
        return TimeConfidence_time_000_000_005;
    }
    private static final int TimeConfidence_time_000_000_002 = (int)23L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_002 = 23
     * }
     */
    public static int TimeConfidence_time_000_000_002() {
        return TimeConfidence_time_000_000_002;
    }
    private static final int TimeConfidence_time_000_000_001 = (int)24L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_001 = 24
     * }
     */
    public static int TimeConfidence_time_000_000_001() {
        return TimeConfidence_time_000_000_001;
    }
    private static final int TimeConfidence_time_000_000_000_5 = (int)25L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_000_5 = 25
     * }
     */
    public static int TimeConfidence_time_000_000_000_5() {
        return TimeConfidence_time_000_000_000_5;
    }
    private static final int TimeConfidence_time_000_000_000_2 = (int)26L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_000_2 = 26
     * }
     */
    public static int TimeConfidence_time_000_000_000_2() {
        return TimeConfidence_time_000_000_000_2;
    }
    private static final int TimeConfidence_time_000_000_000_1 = (int)27L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_000_1 = 27
     * }
     */
    public static int TimeConfidence_time_000_000_000_1() {
        return TimeConfidence_time_000_000_000_1;
    }
    private static final int TimeConfidence_time_000_000_000_05 = (int)28L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_000_05 = 28
     * }
     */
    public static int TimeConfidence_time_000_000_000_05() {
        return TimeConfidence_time_000_000_000_05;
    }
    private static final int TimeConfidence_time_000_000_000_02 = (int)29L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_000_02 = 29
     * }
     */
    public static int TimeConfidence_time_000_000_000_02() {
        return TimeConfidence_time_000_000_000_02;
    }
    private static final int TimeConfidence_time_000_000_000_01 = (int)30L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_000_01 = 30
     * }
     */
    public static int TimeConfidence_time_000_000_000_01() {
        return TimeConfidence_time_000_000_000_01;
    }
    private static final int TimeConfidence_time_000_000_000_005 = (int)31L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_000_005 = 31
     * }
     */
    public static int TimeConfidence_time_000_000_000_005() {
        return TimeConfidence_time_000_000_000_005;
    }
    private static final int TimeConfidence_time_000_000_000_002 = (int)32L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_000_002 = 32
     * }
     */
    public static int TimeConfidence_time_000_000_000_002() {
        return TimeConfidence_time_000_000_000_002;
    }
    private static final int TimeConfidence_time_000_000_000_001 = (int)33L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_000_001 = 33
     * }
     */
    public static int TimeConfidence_time_000_000_000_001() {
        return TimeConfidence_time_000_000_000_001;
    }
    private static final int TimeConfidence_time_000_000_000_000_5 = (int)34L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_000_000_5 = 34
     * }
     */
    public static int TimeConfidence_time_000_000_000_000_5() {
        return TimeConfidence_time_000_000_000_000_5;
    }
    private static final int TimeConfidence_time_000_000_000_000_2 = (int)35L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_000_000_2 = 35
     * }
     */
    public static int TimeConfidence_time_000_000_000_000_2() {
        return TimeConfidence_time_000_000_000_000_2;
    }
    private static final int TimeConfidence_time_000_000_000_000_1 = (int)36L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_000_000_1 = 36
     * }
     */
    public static int TimeConfidence_time_000_000_000_000_1() {
        return TimeConfidence_time_000_000_000_000_1;
    }
    private static final int TimeConfidence_time_000_000_000_000_05 = (int)37L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_000_000_05 = 37
     * }
     */
    public static int TimeConfidence_time_000_000_000_000_05() {
        return TimeConfidence_time_000_000_000_000_05;
    }
    private static final int TimeConfidence_time_000_000_000_000_02 = (int)38L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_000_000_02 = 38
     * }
     */
    public static int TimeConfidence_time_000_000_000_000_02() {
        return TimeConfidence_time_000_000_000_000_02;
    }
    private static final int TimeConfidence_time_000_000_000_000_01 = (int)39L;
    /**
     * {@snippet lang=c :
     * enum TimeConfidence.TimeConfidence_time_000_000_000_000_01 = 39
     * }
     */
    public static int TimeConfidence_time_000_000_000_000_01() {
        return TimeConfidence_time_000_000_000_000_01;
    }
    /**
     * {@snippet lang=c :
     * typedef long TimeConfidence_t
     * }
     */
    public static final OfLong TimeConfidence_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_TimeConfidence_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_TimeConfidence_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TimeConfidence_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_TimeConfidence_constr_1$layout() {
        return asn_PER_type_TimeConfidence_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TimeConfidence_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_TimeConfidence_constr_1() {
        return asn_PER_type_TimeConfidence_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_TimeConfidence_constr_1
     * }
     */
    public static void asn_PER_type_TimeConfidence_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_TimeConfidence_constr_1$constants.SEGMENT, 0L, asn_PER_type_TimeConfidence_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_TimeConfidence$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_TimeConfidence").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TimeConfidence
     * }
     */
    public static GroupLayout asn_DEF_TimeConfidence$layout() {
        return asn_DEF_TimeConfidence$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TimeConfidence
     * }
     */
    public static MemorySegment asn_DEF_TimeConfidence() {
        return asn_DEF_TimeConfidence$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TimeConfidence
     * }
     */
    public static void asn_DEF_TimeConfidence(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_TimeConfidence$constants.SEGMENT, 0L, asn_DEF_TimeConfidence$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_TimeConfidence_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_TimeConfidence_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_TimeConfidence_specs_1
     * }
     */
    public static GroupLayout asn_SPC_TimeConfidence_specs_1$layout() {
        return asn_SPC_TimeConfidence_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_TimeConfidence_specs_1
     * }
     */
    public static MemorySegment asn_SPC_TimeConfidence_specs_1() {
        return asn_SPC_TimeConfidence_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_TimeConfidence_specs_1
     * }
     */
    public static void asn_SPC_TimeConfidence_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_TimeConfidence_specs_1$constants.SEGMENT, 0L, asn_SPC_TimeConfidence_specs_1$constants.LAYOUT.byteSize());
    }

    private static class TimeConfidence_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeConfidence_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void TimeConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor TimeConfidence_free$descriptor() {
        return TimeConfidence_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void TimeConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle TimeConfidence_free$handle() {
        return TimeConfidence_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void TimeConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment TimeConfidence_free$address() {
        return TimeConfidence_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void TimeConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void TimeConfidence_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = TimeConfidence_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeConfidence_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeConfidence_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeConfidence_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TimeConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TimeConfidence_print$descriptor() {
        return TimeConfidence_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TimeConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TimeConfidence_print$handle() {
        return TimeConfidence_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TimeConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TimeConfidence_print$address() {
        return TimeConfidence_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TimeConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int TimeConfidence_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TimeConfidence_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeConfidence_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeConfidence_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeConfidence_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int TimeConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor TimeConfidence_constraint$descriptor() {
        return TimeConfidence_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int TimeConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle TimeConfidence_constraint$handle() {
        return TimeConfidence_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int TimeConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment TimeConfidence_constraint$address() {
        return TimeConfidence_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int TimeConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int TimeConfidence_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TimeConfidence_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeConfidence_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeConfidence_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeConfidence_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor TimeConfidence_decode_ber$descriptor() {
        return TimeConfidence_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle TimeConfidence_decode_ber$handle() {
        return TimeConfidence_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment TimeConfidence_decode_ber$address() {
        return TimeConfidence_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TimeConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment TimeConfidence_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = TimeConfidence_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeConfidence_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeConfidence_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeConfidence_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TimeConfidence_encode_der$descriptor() {
        return TimeConfidence_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TimeConfidence_encode_der$handle() {
        return TimeConfidence_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TimeConfidence_encode_der$address() {
        return TimeConfidence_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TimeConfidence_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = TimeConfidence_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeConfidence_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeConfidence_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeConfidence_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor TimeConfidence_decode_xer$descriptor() {
        return TimeConfidence_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle TimeConfidence_decode_xer$handle() {
        return TimeConfidence_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment TimeConfidence_decode_xer$address() {
        return TimeConfidence_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TimeConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment TimeConfidence_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = TimeConfidence_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeConfidence_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeConfidence_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeConfidence_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TimeConfidence_encode_xer$descriptor() {
        return TimeConfidence_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TimeConfidence_encode_xer$handle() {
        return TimeConfidence_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TimeConfidence_encode_xer$address() {
        return TimeConfidence_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TimeConfidence_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = TimeConfidence_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeConfidence_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeConfidence_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeConfidence_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TimeConfidence_encode_jer$descriptor() {
        return TimeConfidence_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TimeConfidence_encode_jer$handle() {
        return TimeConfidence_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TimeConfidence_encode_jer$address() {
        return TimeConfidence_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TimeConfidence_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = TimeConfidence_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeConfidence_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeConfidence_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeConfidence_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor TimeConfidence_decode_oer$descriptor() {
        return TimeConfidence_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle TimeConfidence_decode_oer$handle() {
        return TimeConfidence_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment TimeConfidence_decode_oer$address() {
        return TimeConfidence_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TimeConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment TimeConfidence_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = TimeConfidence_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeConfidence_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeConfidence_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeConfidence_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor TimeConfidence_encode_oer$descriptor() {
        return TimeConfidence_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle TimeConfidence_encode_oer$handle() {
        return TimeConfidence_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TimeConfidence_encode_oer$address() {
        return TimeConfidence_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment TimeConfidence_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TimeConfidence_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeConfidence_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeConfidence_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeConfidence_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor TimeConfidence_decode_uper$descriptor() {
        return TimeConfidence_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle TimeConfidence_decode_uper$handle() {
        return TimeConfidence_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TimeConfidence_decode_uper$address() {
        return TimeConfidence_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TimeConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TimeConfidence_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TimeConfidence_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeConfidence_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeConfidence_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeConfidence_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor TimeConfidence_encode_uper$descriptor() {
        return TimeConfidence_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle TimeConfidence_encode_uper$handle() {
        return TimeConfidence_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TimeConfidence_encode_uper$address() {
        return TimeConfidence_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TimeConfidence_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TimeConfidence_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeConfidence_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeConfidence_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeConfidence_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor TimeConfidence_decode_aper$descriptor() {
        return TimeConfidence_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle TimeConfidence_decode_aper$handle() {
        return TimeConfidence_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t TimeConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TimeConfidence_decode_aper$address() {
        return TimeConfidence_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t TimeConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment TimeConfidence_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = TimeConfidence_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeConfidence_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class TimeConfidence_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("TimeConfidence_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor TimeConfidence_encode_aper$descriptor() {
        return TimeConfidence_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle TimeConfidence_encode_aper$handle() {
        return TimeConfidence_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TimeConfidence_encode_aper$address() {
        return TimeConfidence_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t TimeConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment TimeConfidence_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = TimeConfidence_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("TimeConfidence_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_FullPositionVector$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_FullPositionVector").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_FullPositionVector
     * }
     */
    public static GroupLayout asn_DEF_FullPositionVector$layout() {
        return asn_DEF_FullPositionVector$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_FullPositionVector
     * }
     */
    public static MemorySegment asn_DEF_FullPositionVector() {
        return asn_DEF_FullPositionVector$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_FullPositionVector
     * }
     */
    public static void asn_DEF_FullPositionVector(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_FullPositionVector$constants.SEGMENT, 0L, asn_DEF_FullPositionVector$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_FullPositionVector_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_FullPositionVector_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_FullPositionVector_specs_1
     * }
     */
    public static GroupLayout asn_SPC_FullPositionVector_specs_1$layout() {
        return asn_SPC_FullPositionVector_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_FullPositionVector_specs_1
     * }
     */
    public static MemorySegment asn_SPC_FullPositionVector_specs_1() {
        return asn_SPC_FullPositionVector_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_FullPositionVector_specs_1
     * }
     */
    public static void asn_SPC_FullPositionVector_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_FullPositionVector_specs_1$constants.SEGMENT, 0L, asn_SPC_FullPositionVector_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_FullPositionVector_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(10, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_FullPositionVector_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 10 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_FullPositionVector_1[10]
     * }
     */
    public static SequenceLayout asn_MBR_FullPositionVector_1$layout() {
        return asn_MBR_FullPositionVector_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_FullPositionVector_1[10]
     * }
     */
    public static long[] asn_MBR_FullPositionVector_1$dimensions() {
        return asn_MBR_FullPositionVector_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_FullPositionVector_1[10]
     * }
     */
    public static MemorySegment asn_MBR_FullPositionVector_1() {
        return asn_MBR_FullPositionVector_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_FullPositionVector_1[10]
     * }
     */
    public static void asn_MBR_FullPositionVector_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_FullPositionVector_1$constants.SEGMENT, 0L, asn_MBR_FullPositionVector_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_FullPositionVector_1[10]
     * }
     */
    public static MemorySegment asn_MBR_FullPositionVector_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_FullPositionVector_1$constants.HANDLE.invokeExact(asn_MBR_FullPositionVector_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_FullPositionVector_1[10]
     * }
     */
    public static void asn_MBR_FullPositionVector_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_FullPositionVector_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef long DYear_t
     * }
     */
    public static final OfLong DYear_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_DYear_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_DYear_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DYear_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_DYear_constr_1$layout() {
        return asn_PER_type_DYear_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DYear_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_DYear_constr_1() {
        return asn_PER_type_DYear_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DYear_constr_1
     * }
     */
    public static void asn_PER_type_DYear_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_DYear_constr_1$constants.SEGMENT, 0L, asn_PER_type_DYear_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_DYear$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_DYear").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DYear
     * }
     */
    public static GroupLayout asn_DEF_DYear$layout() {
        return asn_DEF_DYear$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DYear
     * }
     */
    public static MemorySegment asn_DEF_DYear() {
        return asn_DEF_DYear$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DYear
     * }
     */
    public static void asn_DEF_DYear(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_DYear$constants.SEGMENT, 0L, asn_DEF_DYear$constants.LAYOUT.byteSize());
    }

    private static class DYear_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DYear_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DYear_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor DYear_free$descriptor() {
        return DYear_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DYear_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle DYear_free$handle() {
        return DYear_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DYear_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment DYear_free$address() {
        return DYear_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DYear_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void DYear_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = DYear_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DYear_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DYear_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DYear_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DYear_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DYear_print$descriptor() {
        return DYear_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DYear_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DYear_print$handle() {
        return DYear_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DYear_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DYear_print$address() {
        return DYear_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DYear_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int DYear_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DYear_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DYear_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DYear_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DYear_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DYear_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor DYear_constraint$descriptor() {
        return DYear_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DYear_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle DYear_constraint$handle() {
        return DYear_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DYear_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment DYear_constraint$address() {
        return DYear_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DYear_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int DYear_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DYear_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DYear_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DYear_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DYear_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DYear_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor DYear_decode_ber$descriptor() {
        return DYear_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DYear_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle DYear_decode_ber$handle() {
        return DYear_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DYear_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DYear_decode_ber$address() {
        return DYear_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DYear_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DYear_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = DYear_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DYear_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DYear_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DYear_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DYear_encode_der$descriptor() {
        return DYear_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DYear_encode_der$handle() {
        return DYear_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DYear_encode_der$address() {
        return DYear_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DYear_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DYear_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DYear_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DYear_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DYear_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DYear_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DYear_decode_xer$descriptor() {
        return DYear_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DYear_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle DYear_decode_xer$handle() {
        return DYear_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DYear_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DYear_decode_xer$address() {
        return DYear_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DYear_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DYear_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DYear_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DYear_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DYear_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DYear_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DYear_encode_xer$descriptor() {
        return DYear_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DYear_encode_xer$handle() {
        return DYear_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DYear_encode_xer$address() {
        return DYear_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DYear_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DYear_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DYear_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DYear_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DYear_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DYear_encode_jer$descriptor() {
        return DYear_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DYear_encode_jer$handle() {
        return DYear_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DYear_encode_jer$address() {
        return DYear_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DYear_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = DYear_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DYear_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DYear_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DYear_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DYear_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DYear_decode_oer$descriptor() {
        return DYear_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DYear_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle DYear_decode_oer$handle() {
        return DYear_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DYear_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DYear_decode_oer$address() {
        return DYear_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DYear_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DYear_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DYear_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DYear_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DYear_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DYear_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DYear_encode_oer$descriptor() {
        return DYear_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DYear_encode_oer$handle() {
        return DYear_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DYear_encode_oer$address() {
        return DYear_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DYear_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DYear_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DYear_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DYear_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DYear_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DYear_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DYear_decode_uper$descriptor() {
        return DYear_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DYear_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DYear_decode_uper$handle() {
        return DYear_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DYear_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DYear_decode_uper$address() {
        return DYear_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DYear_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DYear_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DYear_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DYear_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DYear_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DYear_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DYear_encode_uper$descriptor() {
        return DYear_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DYear_encode_uper$handle() {
        return DYear_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DYear_encode_uper$address() {
        return DYear_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DYear_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DYear_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DYear_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DYear_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DYear_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DYear_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DYear_decode_aper$descriptor() {
        return DYear_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DYear_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DYear_decode_aper$handle() {
        return DYear_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DYear_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DYear_decode_aper$address() {
        return DYear_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DYear_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DYear_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DYear_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DYear_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DYear_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DYear_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DYear_encode_aper$descriptor() {
        return DYear_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DYear_encode_aper$handle() {
        return DYear_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DYear_encode_aper$address() {
        return DYear_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DYear_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DYear_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DYear_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DYear_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long DMonth_t
     * }
     */
    public static final OfLong DMonth_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_DMonth_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_DMonth_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DMonth_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_DMonth_constr_1$layout() {
        return asn_PER_type_DMonth_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DMonth_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_DMonth_constr_1() {
        return asn_PER_type_DMonth_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DMonth_constr_1
     * }
     */
    public static void asn_PER_type_DMonth_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_DMonth_constr_1$constants.SEGMENT, 0L, asn_PER_type_DMonth_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_DMonth$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_DMonth").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DMonth
     * }
     */
    public static GroupLayout asn_DEF_DMonth$layout() {
        return asn_DEF_DMonth$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DMonth
     * }
     */
    public static MemorySegment asn_DEF_DMonth() {
        return asn_DEF_DMonth$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DMonth
     * }
     */
    public static void asn_DEF_DMonth(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_DMonth$constants.SEGMENT, 0L, asn_DEF_DMonth$constants.LAYOUT.byteSize());
    }

    private static class DMonth_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMonth_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DMonth_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor DMonth_free$descriptor() {
        return DMonth_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DMonth_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle DMonth_free$handle() {
        return DMonth_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DMonth_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment DMonth_free$address() {
        return DMonth_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DMonth_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void DMonth_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = DMonth_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMonth_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMonth_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMonth_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DMonth_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DMonth_print$descriptor() {
        return DMonth_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DMonth_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DMonth_print$handle() {
        return DMonth_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DMonth_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DMonth_print$address() {
        return DMonth_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DMonth_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int DMonth_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DMonth_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMonth_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMonth_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMonth_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DMonth_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor DMonth_constraint$descriptor() {
        return DMonth_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DMonth_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle DMonth_constraint$handle() {
        return DMonth_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DMonth_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment DMonth_constraint$address() {
        return DMonth_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DMonth_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int DMonth_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DMonth_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMonth_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMonth_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMonth_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMonth_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor DMonth_decode_ber$descriptor() {
        return DMonth_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMonth_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle DMonth_decode_ber$handle() {
        return DMonth_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMonth_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DMonth_decode_ber$address() {
        return DMonth_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DMonth_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DMonth_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = DMonth_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMonth_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMonth_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMonth_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DMonth_encode_der$descriptor() {
        return DMonth_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DMonth_encode_der$handle() {
        return DMonth_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DMonth_encode_der$address() {
        return DMonth_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DMonth_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DMonth_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMonth_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMonth_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMonth_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMonth_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DMonth_decode_xer$descriptor() {
        return DMonth_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMonth_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle DMonth_decode_xer$handle() {
        return DMonth_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMonth_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DMonth_decode_xer$address() {
        return DMonth_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DMonth_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DMonth_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DMonth_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMonth_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMonth_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMonth_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DMonth_encode_xer$descriptor() {
        return DMonth_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DMonth_encode_xer$handle() {
        return DMonth_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DMonth_encode_xer$address() {
        return DMonth_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DMonth_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DMonth_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMonth_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMonth_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMonth_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DMonth_encode_jer$descriptor() {
        return DMonth_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DMonth_encode_jer$handle() {
        return DMonth_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DMonth_encode_jer$address() {
        return DMonth_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DMonth_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = DMonth_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMonth_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMonth_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMonth_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMonth_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DMonth_decode_oer$descriptor() {
        return DMonth_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMonth_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle DMonth_decode_oer$handle() {
        return DMonth_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMonth_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DMonth_decode_oer$address() {
        return DMonth_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DMonth_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DMonth_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DMonth_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMonth_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMonth_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMonth_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DMonth_encode_oer$descriptor() {
        return DMonth_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DMonth_encode_oer$handle() {
        return DMonth_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DMonth_encode_oer$address() {
        return DMonth_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DMonth_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DMonth_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMonth_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMonth_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMonth_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMonth_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DMonth_decode_uper$descriptor() {
        return DMonth_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMonth_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DMonth_decode_uper$handle() {
        return DMonth_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMonth_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DMonth_decode_uper$address() {
        return DMonth_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DMonth_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DMonth_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DMonth_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMonth_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMonth_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMonth_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DMonth_encode_uper$descriptor() {
        return DMonth_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DMonth_encode_uper$handle() {
        return DMonth_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DMonth_encode_uper$address() {
        return DMonth_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DMonth_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DMonth_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMonth_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMonth_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMonth_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMonth_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DMonth_decode_aper$descriptor() {
        return DMonth_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMonth_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DMonth_decode_aper$handle() {
        return DMonth_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMonth_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DMonth_decode_aper$address() {
        return DMonth_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DMonth_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DMonth_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DMonth_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMonth_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMonth_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMonth_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DMonth_encode_aper$descriptor() {
        return DMonth_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DMonth_encode_aper$handle() {
        return DMonth_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DMonth_encode_aper$address() {
        return DMonth_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DMonth_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DMonth_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DMonth_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMonth_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long DDay_t
     * }
     */
    public static final OfLong DDay_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_DDay_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_DDay_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DDay_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_DDay_constr_1$layout() {
        return asn_PER_type_DDay_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DDay_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_DDay_constr_1() {
        return asn_PER_type_DDay_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DDay_constr_1
     * }
     */
    public static void asn_PER_type_DDay_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_DDay_constr_1$constants.SEGMENT, 0L, asn_PER_type_DDay_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_DDay$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_DDay").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DDay
     * }
     */
    public static GroupLayout asn_DEF_DDay$layout() {
        return asn_DEF_DDay$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DDay
     * }
     */
    public static MemorySegment asn_DEF_DDay() {
        return asn_DEF_DDay$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DDay
     * }
     */
    public static void asn_DEF_DDay(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_DDay$constants.SEGMENT, 0L, asn_DEF_DDay$constants.LAYOUT.byteSize());
    }

    private static class DDay_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DDay_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DDay_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor DDay_free$descriptor() {
        return DDay_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DDay_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle DDay_free$handle() {
        return DDay_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DDay_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment DDay_free$address() {
        return DDay_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DDay_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void DDay_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = DDay_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DDay_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DDay_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DDay_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DDay_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DDay_print$descriptor() {
        return DDay_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DDay_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DDay_print$handle() {
        return DDay_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DDay_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DDay_print$address() {
        return DDay_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DDay_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int DDay_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DDay_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DDay_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DDay_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DDay_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DDay_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor DDay_constraint$descriptor() {
        return DDay_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DDay_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle DDay_constraint$handle() {
        return DDay_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DDay_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment DDay_constraint$address() {
        return DDay_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DDay_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int DDay_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DDay_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DDay_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DDay_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DDay_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DDay_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor DDay_decode_ber$descriptor() {
        return DDay_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DDay_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle DDay_decode_ber$handle() {
        return DDay_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DDay_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DDay_decode_ber$address() {
        return DDay_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DDay_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DDay_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = DDay_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DDay_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DDay_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DDay_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DDay_encode_der$descriptor() {
        return DDay_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DDay_encode_der$handle() {
        return DDay_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DDay_encode_der$address() {
        return DDay_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DDay_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DDay_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DDay_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DDay_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DDay_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DDay_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DDay_decode_xer$descriptor() {
        return DDay_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DDay_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle DDay_decode_xer$handle() {
        return DDay_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DDay_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DDay_decode_xer$address() {
        return DDay_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DDay_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DDay_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DDay_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DDay_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DDay_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DDay_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DDay_encode_xer$descriptor() {
        return DDay_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DDay_encode_xer$handle() {
        return DDay_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DDay_encode_xer$address() {
        return DDay_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DDay_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DDay_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DDay_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DDay_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DDay_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DDay_encode_jer$descriptor() {
        return DDay_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DDay_encode_jer$handle() {
        return DDay_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DDay_encode_jer$address() {
        return DDay_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DDay_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = DDay_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DDay_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DDay_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DDay_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DDay_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DDay_decode_oer$descriptor() {
        return DDay_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DDay_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle DDay_decode_oer$handle() {
        return DDay_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DDay_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DDay_decode_oer$address() {
        return DDay_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DDay_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DDay_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DDay_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DDay_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DDay_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DDay_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DDay_encode_oer$descriptor() {
        return DDay_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DDay_encode_oer$handle() {
        return DDay_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DDay_encode_oer$address() {
        return DDay_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DDay_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DDay_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DDay_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DDay_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DDay_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DDay_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DDay_decode_uper$descriptor() {
        return DDay_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DDay_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DDay_decode_uper$handle() {
        return DDay_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DDay_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DDay_decode_uper$address() {
        return DDay_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DDay_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DDay_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DDay_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DDay_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DDay_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DDay_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DDay_encode_uper$descriptor() {
        return DDay_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DDay_encode_uper$handle() {
        return DDay_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DDay_encode_uper$address() {
        return DDay_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DDay_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DDay_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DDay_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DDay_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DDay_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DDay_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DDay_decode_aper$descriptor() {
        return DDay_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DDay_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DDay_decode_aper$handle() {
        return DDay_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DDay_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DDay_decode_aper$address() {
        return DDay_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DDay_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DDay_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DDay_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DDay_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DDay_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DDay_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DDay_encode_aper$descriptor() {
        return DDay_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DDay_encode_aper$handle() {
        return DDay_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DDay_encode_aper$address() {
        return DDay_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DDay_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DDay_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DDay_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DDay_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long DHour_t
     * }
     */
    public static final OfLong DHour_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_DHour_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_DHour_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DHour_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_DHour_constr_1$layout() {
        return asn_PER_type_DHour_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DHour_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_DHour_constr_1() {
        return asn_PER_type_DHour_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DHour_constr_1
     * }
     */
    public static void asn_PER_type_DHour_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_DHour_constr_1$constants.SEGMENT, 0L, asn_PER_type_DHour_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_DHour$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_DHour").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DHour
     * }
     */
    public static GroupLayout asn_DEF_DHour$layout() {
        return asn_DEF_DHour$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DHour
     * }
     */
    public static MemorySegment asn_DEF_DHour() {
        return asn_DEF_DHour$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DHour
     * }
     */
    public static void asn_DEF_DHour(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_DHour$constants.SEGMENT, 0L, asn_DEF_DHour$constants.LAYOUT.byteSize());
    }

    private static class DHour_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DHour_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DHour_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor DHour_free$descriptor() {
        return DHour_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DHour_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle DHour_free$handle() {
        return DHour_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DHour_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment DHour_free$address() {
        return DHour_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DHour_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void DHour_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = DHour_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DHour_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DHour_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DHour_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DHour_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DHour_print$descriptor() {
        return DHour_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DHour_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DHour_print$handle() {
        return DHour_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DHour_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DHour_print$address() {
        return DHour_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DHour_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int DHour_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DHour_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DHour_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DHour_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DHour_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DHour_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor DHour_constraint$descriptor() {
        return DHour_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DHour_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle DHour_constraint$handle() {
        return DHour_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DHour_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment DHour_constraint$address() {
        return DHour_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DHour_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int DHour_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DHour_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DHour_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DHour_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DHour_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DHour_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor DHour_decode_ber$descriptor() {
        return DHour_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DHour_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle DHour_decode_ber$handle() {
        return DHour_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DHour_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DHour_decode_ber$address() {
        return DHour_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DHour_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DHour_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = DHour_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DHour_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DHour_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DHour_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DHour_encode_der$descriptor() {
        return DHour_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DHour_encode_der$handle() {
        return DHour_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DHour_encode_der$address() {
        return DHour_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DHour_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DHour_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DHour_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DHour_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DHour_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DHour_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DHour_decode_xer$descriptor() {
        return DHour_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DHour_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle DHour_decode_xer$handle() {
        return DHour_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DHour_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DHour_decode_xer$address() {
        return DHour_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DHour_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DHour_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DHour_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DHour_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DHour_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DHour_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DHour_encode_xer$descriptor() {
        return DHour_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DHour_encode_xer$handle() {
        return DHour_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DHour_encode_xer$address() {
        return DHour_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DHour_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DHour_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DHour_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DHour_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DHour_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DHour_encode_jer$descriptor() {
        return DHour_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DHour_encode_jer$handle() {
        return DHour_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DHour_encode_jer$address() {
        return DHour_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DHour_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = DHour_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DHour_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DHour_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DHour_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DHour_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DHour_decode_oer$descriptor() {
        return DHour_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DHour_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle DHour_decode_oer$handle() {
        return DHour_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DHour_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DHour_decode_oer$address() {
        return DHour_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DHour_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DHour_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DHour_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DHour_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DHour_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DHour_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DHour_encode_oer$descriptor() {
        return DHour_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DHour_encode_oer$handle() {
        return DHour_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DHour_encode_oer$address() {
        return DHour_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DHour_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DHour_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DHour_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DHour_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DHour_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DHour_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DHour_decode_uper$descriptor() {
        return DHour_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DHour_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DHour_decode_uper$handle() {
        return DHour_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DHour_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DHour_decode_uper$address() {
        return DHour_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DHour_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DHour_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DHour_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DHour_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DHour_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DHour_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DHour_encode_uper$descriptor() {
        return DHour_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DHour_encode_uper$handle() {
        return DHour_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DHour_encode_uper$address() {
        return DHour_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DHour_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DHour_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DHour_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DHour_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DHour_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DHour_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DHour_decode_aper$descriptor() {
        return DHour_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DHour_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DHour_decode_aper$handle() {
        return DHour_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DHour_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DHour_decode_aper$address() {
        return DHour_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DHour_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DHour_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DHour_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DHour_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DHour_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DHour_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DHour_encode_aper$descriptor() {
        return DHour_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DHour_encode_aper$handle() {
        return DHour_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DHour_encode_aper$address() {
        return DHour_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DHour_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DHour_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DHour_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DHour_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long DMinute_t
     * }
     */
    public static final OfLong DMinute_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_DMinute_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_DMinute_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DMinute_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_DMinute_constr_1$layout() {
        return asn_PER_type_DMinute_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DMinute_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_DMinute_constr_1() {
        return asn_PER_type_DMinute_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DMinute_constr_1
     * }
     */
    public static void asn_PER_type_DMinute_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_DMinute_constr_1$constants.SEGMENT, 0L, asn_PER_type_DMinute_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_DMinute$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_DMinute").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DMinute
     * }
     */
    public static GroupLayout asn_DEF_DMinute$layout() {
        return asn_DEF_DMinute$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DMinute
     * }
     */
    public static MemorySegment asn_DEF_DMinute() {
        return asn_DEF_DMinute$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DMinute
     * }
     */
    public static void asn_DEF_DMinute(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_DMinute$constants.SEGMENT, 0L, asn_DEF_DMinute$constants.LAYOUT.byteSize());
    }

    private static class DMinute_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMinute_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DMinute_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor DMinute_free$descriptor() {
        return DMinute_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DMinute_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle DMinute_free$handle() {
        return DMinute_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DMinute_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment DMinute_free$address() {
        return DMinute_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DMinute_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void DMinute_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = DMinute_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMinute_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMinute_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMinute_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DMinute_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DMinute_print$descriptor() {
        return DMinute_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DMinute_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DMinute_print$handle() {
        return DMinute_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DMinute_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DMinute_print$address() {
        return DMinute_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DMinute_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int DMinute_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DMinute_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMinute_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMinute_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMinute_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DMinute_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor DMinute_constraint$descriptor() {
        return DMinute_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DMinute_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle DMinute_constraint$handle() {
        return DMinute_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DMinute_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment DMinute_constraint$address() {
        return DMinute_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DMinute_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int DMinute_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DMinute_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMinute_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMinute_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMinute_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMinute_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor DMinute_decode_ber$descriptor() {
        return DMinute_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMinute_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle DMinute_decode_ber$handle() {
        return DMinute_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMinute_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DMinute_decode_ber$address() {
        return DMinute_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DMinute_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DMinute_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = DMinute_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMinute_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMinute_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMinute_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DMinute_encode_der$descriptor() {
        return DMinute_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DMinute_encode_der$handle() {
        return DMinute_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DMinute_encode_der$address() {
        return DMinute_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DMinute_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DMinute_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMinute_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMinute_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMinute_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMinute_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DMinute_decode_xer$descriptor() {
        return DMinute_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMinute_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle DMinute_decode_xer$handle() {
        return DMinute_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMinute_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DMinute_decode_xer$address() {
        return DMinute_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DMinute_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DMinute_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DMinute_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMinute_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMinute_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMinute_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DMinute_encode_xer$descriptor() {
        return DMinute_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DMinute_encode_xer$handle() {
        return DMinute_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DMinute_encode_xer$address() {
        return DMinute_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DMinute_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DMinute_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMinute_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMinute_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMinute_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DMinute_encode_jer$descriptor() {
        return DMinute_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DMinute_encode_jer$handle() {
        return DMinute_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DMinute_encode_jer$address() {
        return DMinute_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DMinute_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = DMinute_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMinute_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMinute_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMinute_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMinute_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DMinute_decode_oer$descriptor() {
        return DMinute_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMinute_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle DMinute_decode_oer$handle() {
        return DMinute_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMinute_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DMinute_decode_oer$address() {
        return DMinute_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DMinute_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DMinute_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DMinute_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMinute_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMinute_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMinute_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DMinute_encode_oer$descriptor() {
        return DMinute_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DMinute_encode_oer$handle() {
        return DMinute_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DMinute_encode_oer$address() {
        return DMinute_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DMinute_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DMinute_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMinute_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMinute_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMinute_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMinute_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DMinute_decode_uper$descriptor() {
        return DMinute_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMinute_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DMinute_decode_uper$handle() {
        return DMinute_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMinute_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DMinute_decode_uper$address() {
        return DMinute_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DMinute_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DMinute_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DMinute_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMinute_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMinute_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMinute_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DMinute_encode_uper$descriptor() {
        return DMinute_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DMinute_encode_uper$handle() {
        return DMinute_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DMinute_encode_uper$address() {
        return DMinute_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DMinute_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DMinute_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMinute_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMinute_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMinute_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMinute_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DMinute_decode_aper$descriptor() {
        return DMinute_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMinute_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DMinute_decode_aper$handle() {
        return DMinute_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DMinute_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DMinute_decode_aper$address() {
        return DMinute_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DMinute_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DMinute_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DMinute_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMinute_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DMinute_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DMinute_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DMinute_encode_aper$descriptor() {
        return DMinute_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DMinute_encode_aper$handle() {
        return DMinute_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DMinute_encode_aper$address() {
        return DMinute_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DMinute_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DMinute_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DMinute_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DMinute_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    /**
     * {@snippet lang=c :
     * typedef long DOffset_t
     * }
     */
    public static final OfLong DOffset_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_DOffset_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_DOffset_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DOffset_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_DOffset_constr_1$layout() {
        return asn_PER_type_DOffset_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DOffset_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_DOffset_constr_1() {
        return asn_PER_type_DOffset_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_DOffset_constr_1
     * }
     */
    public static void asn_PER_type_DOffset_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_DOffset_constr_1$constants.SEGMENT, 0L, asn_PER_type_DOffset_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_DOffset$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_DOffset").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DOffset
     * }
     */
    public static GroupLayout asn_DEF_DOffset$layout() {
        return asn_DEF_DOffset$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DOffset
     * }
     */
    public static MemorySegment asn_DEF_DOffset() {
        return asn_DEF_DOffset$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DOffset
     * }
     */
    public static void asn_DEF_DOffset(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_DOffset$constants.SEGMENT, 0L, asn_DEF_DOffset$constants.LAYOUT.byteSize());
    }

    private static class DOffset_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DOffset_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void DOffset_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor DOffset_free$descriptor() {
        return DOffset_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void DOffset_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle DOffset_free$handle() {
        return DOffset_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void DOffset_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment DOffset_free$address() {
        return DOffset_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void DOffset_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void DOffset_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = DOffset_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DOffset_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DOffset_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DOffset_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DOffset_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DOffset_print$descriptor() {
        return DOffset_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DOffset_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DOffset_print$handle() {
        return DOffset_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DOffset_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DOffset_print$address() {
        return DOffset_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DOffset_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int DOffset_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DOffset_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DOffset_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DOffset_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DOffset_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int DOffset_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor DOffset_constraint$descriptor() {
        return DOffset_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int DOffset_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle DOffset_constraint$handle() {
        return DOffset_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int DOffset_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment DOffset_constraint$address() {
        return DOffset_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int DOffset_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int DOffset_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DOffset_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DOffset_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DOffset_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DOffset_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DOffset_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor DOffset_decode_ber$descriptor() {
        return DOffset_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DOffset_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle DOffset_decode_ber$handle() {
        return DOffset_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DOffset_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DOffset_decode_ber$address() {
        return DOffset_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DOffset_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment DOffset_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = DOffset_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DOffset_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DOffset_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DOffset_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DOffset_encode_der$descriptor() {
        return DOffset_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DOffset_encode_der$handle() {
        return DOffset_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DOffset_encode_der$address() {
        return DOffset_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DOffset_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DOffset_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DOffset_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DOffset_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DOffset_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DOffset_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DOffset_decode_xer$descriptor() {
        return DOffset_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DOffset_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle DOffset_decode_xer$handle() {
        return DOffset_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DOffset_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DOffset_decode_xer$address() {
        return DOffset_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DOffset_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment DOffset_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DOffset_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DOffset_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DOffset_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DOffset_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DOffset_encode_xer$descriptor() {
        return DOffset_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DOffset_encode_xer$handle() {
        return DOffset_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DOffset_encode_xer$address() {
        return DOffset_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DOffset_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = DOffset_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DOffset_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DOffset_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DOffset_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DOffset_encode_jer$descriptor() {
        return DOffset_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DOffset_encode_jer$handle() {
        return DOffset_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DOffset_encode_jer$address() {
        return DOffset_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DOffset_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = DOffset_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DOffset_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DOffset_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DOffset_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DOffset_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor DOffset_decode_oer$descriptor() {
        return DOffset_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DOffset_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle DOffset_decode_oer$handle() {
        return DOffset_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DOffset_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DOffset_decode_oer$address() {
        return DOffset_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DOffset_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment DOffset_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = DOffset_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DOffset_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DOffset_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DOffset_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor DOffset_encode_oer$descriptor() {
        return DOffset_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle DOffset_encode_oer$handle() {
        return DOffset_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DOffset_encode_oer$address() {
        return DOffset_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment DOffset_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DOffset_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DOffset_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DOffset_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DOffset_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DOffset_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DOffset_decode_uper$descriptor() {
        return DOffset_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DOffset_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DOffset_decode_uper$handle() {
        return DOffset_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DOffset_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DOffset_decode_uper$address() {
        return DOffset_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DOffset_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DOffset_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DOffset_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DOffset_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DOffset_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DOffset_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DOffset_encode_uper$descriptor() {
        return DOffset_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DOffset_encode_uper$handle() {
        return DOffset_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DOffset_encode_uper$address() {
        return DOffset_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DOffset_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DOffset_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DOffset_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DOffset_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DOffset_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t DOffset_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor DOffset_decode_aper$descriptor() {
        return DOffset_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t DOffset_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle DOffset_decode_aper$handle() {
        return DOffset_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t DOffset_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DOffset_decode_aper$address() {
        return DOffset_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t DOffset_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment DOffset_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = DOffset_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DOffset_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class DOffset_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("DOffset_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor DOffset_encode_aper$descriptor() {
        return DOffset_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle DOffset_encode_aper$handle() {
        return DOffset_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DOffset_encode_aper$address() {
        return DOffset_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t DOffset_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment DOffset_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = DOffset_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("DOffset_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_DDateTime$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_DDateTime").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DDateTime
     * }
     */
    public static GroupLayout asn_DEF_DDateTime$layout() {
        return asn_DEF_DDateTime$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DDateTime
     * }
     */
    public static MemorySegment asn_DEF_DDateTime() {
        return asn_DEF_DDateTime$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_DDateTime
     * }
     */
    public static void asn_DEF_DDateTime(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_DDateTime$constants.SEGMENT, 0L, asn_DEF_DDateTime$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_DDateTime_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_DDateTime_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_DDateTime_specs_1
     * }
     */
    public static GroupLayout asn_SPC_DDateTime_specs_1$layout() {
        return asn_SPC_DDateTime_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_DDateTime_specs_1
     * }
     */
    public static MemorySegment asn_SPC_DDateTime_specs_1() {
        return asn_SPC_DDateTime_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_DDateTime_specs_1
     * }
     */
    public static void asn_SPC_DDateTime_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_DDateTime_specs_1$constants.SEGMENT, 0L, asn_SPC_DDateTime_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_DDateTime_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(7, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_DDateTime_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 7 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DDateTime_1[7]
     * }
     */
    public static SequenceLayout asn_MBR_DDateTime_1$layout() {
        return asn_MBR_DDateTime_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DDateTime_1[7]
     * }
     */
    public static long[] asn_MBR_DDateTime_1$dimensions() {
        return asn_MBR_DDateTime_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DDateTime_1[7]
     * }
     */
    public static MemorySegment asn_MBR_DDateTime_1() {
        return asn_MBR_DDateTime_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DDateTime_1[7]
     * }
     */
    public static void asn_MBR_DDateTime_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_DDateTime_1$constants.SEGMENT, 0L, asn_MBR_DDateTime_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DDateTime_1[7]
     * }
     */
    public static MemorySegment asn_MBR_DDateTime_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_DDateTime_1$constants.HANDLE.invokeExact(asn_MBR_DDateTime_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_DDateTime_1[7]
     * }
     */
    public static void asn_MBR_DDateTime_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_DDateTime_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    /**
     * {@snippet lang=c :
     * typedef long Velocity_t
     * }
     */
    public static final OfLong Velocity_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_Velocity_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_Velocity_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Velocity_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_Velocity_constr_1$layout() {
        return asn_PER_type_Velocity_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Velocity_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_Velocity_constr_1() {
        return asn_PER_type_Velocity_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_Velocity_constr_1
     * }
     */
    public static void asn_PER_type_Velocity_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_Velocity_constr_1$constants.SEGMENT, 0L, asn_PER_type_Velocity_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_Velocity$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_Velocity").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Velocity
     * }
     */
    public static GroupLayout asn_DEF_Velocity$layout() {
        return asn_DEF_Velocity$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Velocity
     * }
     */
    public static MemorySegment asn_DEF_Velocity() {
        return asn_DEF_Velocity$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_Velocity
     * }
     */
    public static void asn_DEF_Velocity(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_Velocity$constants.SEGMENT, 0L, asn_DEF_Velocity$constants.LAYOUT.byteSize());
    }

    private static class Velocity_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Velocity_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void Velocity_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor Velocity_free$descriptor() {
        return Velocity_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void Velocity_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle Velocity_free$handle() {
        return Velocity_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void Velocity_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment Velocity_free$address() {
        return Velocity_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void Velocity_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void Velocity_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = Velocity_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Velocity_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Velocity_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Velocity_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Velocity_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Velocity_print$descriptor() {
        return Velocity_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Velocity_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Velocity_print$handle() {
        return Velocity_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Velocity_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Velocity_print$address() {
        return Velocity_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Velocity_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int Velocity_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Velocity_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Velocity_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Velocity_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Velocity_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int Velocity_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor Velocity_constraint$descriptor() {
        return Velocity_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int Velocity_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle Velocity_constraint$handle() {
        return Velocity_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int Velocity_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment Velocity_constraint$address() {
        return Velocity_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int Velocity_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int Velocity_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Velocity_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Velocity_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Velocity_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Velocity_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Velocity_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor Velocity_decode_ber$descriptor() {
        return Velocity_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Velocity_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle Velocity_decode_ber$handle() {
        return Velocity_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Velocity_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Velocity_decode_ber$address() {
        return Velocity_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Velocity_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment Velocity_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = Velocity_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Velocity_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Velocity_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Velocity_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Velocity_encode_der$descriptor() {
        return Velocity_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Velocity_encode_der$handle() {
        return Velocity_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Velocity_encode_der$address() {
        return Velocity_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Velocity_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Velocity_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Velocity_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Velocity_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Velocity_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Velocity_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Velocity_decode_xer$descriptor() {
        return Velocity_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Velocity_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle Velocity_decode_xer$handle() {
        return Velocity_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Velocity_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Velocity_decode_xer$address() {
        return Velocity_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Velocity_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment Velocity_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Velocity_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Velocity_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Velocity_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Velocity_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Velocity_encode_xer$descriptor() {
        return Velocity_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Velocity_encode_xer$handle() {
        return Velocity_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Velocity_encode_xer$address() {
        return Velocity_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Velocity_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = Velocity_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Velocity_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Velocity_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Velocity_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Velocity_encode_jer$descriptor() {
        return Velocity_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Velocity_encode_jer$handle() {
        return Velocity_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Velocity_encode_jer$address() {
        return Velocity_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Velocity_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = Velocity_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Velocity_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Velocity_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Velocity_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Velocity_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor Velocity_decode_oer$descriptor() {
        return Velocity_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Velocity_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle Velocity_decode_oer$handle() {
        return Velocity_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Velocity_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Velocity_decode_oer$address() {
        return Velocity_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Velocity_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment Velocity_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = Velocity_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Velocity_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Velocity_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Velocity_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor Velocity_encode_oer$descriptor() {
        return Velocity_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle Velocity_encode_oer$handle() {
        return Velocity_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Velocity_encode_oer$address() {
        return Velocity_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment Velocity_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Velocity_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Velocity_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Velocity_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Velocity_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Velocity_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Velocity_decode_uper$descriptor() {
        return Velocity_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Velocity_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Velocity_decode_uper$handle() {
        return Velocity_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Velocity_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Velocity_decode_uper$address() {
        return Velocity_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Velocity_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Velocity_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Velocity_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Velocity_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Velocity_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Velocity_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Velocity_encode_uper$descriptor() {
        return Velocity_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Velocity_encode_uper$handle() {
        return Velocity_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Velocity_encode_uper$address() {
        return Velocity_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Velocity_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Velocity_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Velocity_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Velocity_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Velocity_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t Velocity_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor Velocity_decode_aper$descriptor() {
        return Velocity_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t Velocity_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle Velocity_decode_aper$handle() {
        return Velocity_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t Velocity_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Velocity_decode_aper$address() {
        return Velocity_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t Velocity_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment Velocity_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = Velocity_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Velocity_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class Velocity_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("Velocity_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor Velocity_encode_aper$descriptor() {
        return Velocity_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle Velocity_encode_aper$handle() {
        return Velocity_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Velocity_encode_aper$address() {
        return Velocity_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t Velocity_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment Velocity_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = Velocity_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("Velocity_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_TransmissionAndSpeed$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_TransmissionAndSpeed").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TransmissionAndSpeed
     * }
     */
    public static GroupLayout asn_DEF_TransmissionAndSpeed$layout() {
        return asn_DEF_TransmissionAndSpeed$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TransmissionAndSpeed
     * }
     */
    public static MemorySegment asn_DEF_TransmissionAndSpeed() {
        return asn_DEF_TransmissionAndSpeed$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_TransmissionAndSpeed
     * }
     */
    public static void asn_DEF_TransmissionAndSpeed(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_TransmissionAndSpeed$constants.SEGMENT, 0L, asn_DEF_TransmissionAndSpeed$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_TransmissionAndSpeed_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_TransmissionAndSpeed_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_TransmissionAndSpeed_specs_1
     * }
     */
    public static GroupLayout asn_SPC_TransmissionAndSpeed_specs_1$layout() {
        return asn_SPC_TransmissionAndSpeed_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_TransmissionAndSpeed_specs_1
     * }
     */
    public static MemorySegment asn_SPC_TransmissionAndSpeed_specs_1() {
        return asn_SPC_TransmissionAndSpeed_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_TransmissionAndSpeed_specs_1
     * }
     */
    public static void asn_SPC_TransmissionAndSpeed_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_TransmissionAndSpeed_specs_1$constants.SEGMENT, 0L, asn_SPC_TransmissionAndSpeed_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_TransmissionAndSpeed_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_TransmissionAndSpeed_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TransmissionAndSpeed_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_TransmissionAndSpeed_1$layout() {
        return asn_MBR_TransmissionAndSpeed_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TransmissionAndSpeed_1[2]
     * }
     */
    public static long[] asn_MBR_TransmissionAndSpeed_1$dimensions() {
        return asn_MBR_TransmissionAndSpeed_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TransmissionAndSpeed_1[2]
     * }
     */
    public static MemorySegment asn_MBR_TransmissionAndSpeed_1() {
        return asn_MBR_TransmissionAndSpeed_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TransmissionAndSpeed_1[2]
     * }
     */
    public static void asn_MBR_TransmissionAndSpeed_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_TransmissionAndSpeed_1$constants.SEGMENT, 0L, asn_MBR_TransmissionAndSpeed_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TransmissionAndSpeed_1[2]
     * }
     */
    public static MemorySegment asn_MBR_TransmissionAndSpeed_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_TransmissionAndSpeed_1$constants.HANDLE.invokeExact(asn_MBR_TransmissionAndSpeed_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_TransmissionAndSpeed_1[2]
     * }
     */
    public static void asn_MBR_TransmissionAndSpeed_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_TransmissionAndSpeed_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    private static final int PositionConfidence_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum PositionConfidence.PositionConfidence_unavailable = 0
     * }
     */
    public static int PositionConfidence_unavailable() {
        return PositionConfidence_unavailable;
    }
    private static final int PositionConfidence_a500m = (int)1L;
    /**
     * {@snippet lang=c :
     * enum PositionConfidence.PositionConfidence_a500m = 1
     * }
     */
    public static int PositionConfidence_a500m() {
        return PositionConfidence_a500m;
    }
    private static final int PositionConfidence_a200m = (int)2L;
    /**
     * {@snippet lang=c :
     * enum PositionConfidence.PositionConfidence_a200m = 2
     * }
     */
    public static int PositionConfidence_a200m() {
        return PositionConfidence_a200m;
    }
    private static final int PositionConfidence_a100m = (int)3L;
    /**
     * {@snippet lang=c :
     * enum PositionConfidence.PositionConfidence_a100m = 3
     * }
     */
    public static int PositionConfidence_a100m() {
        return PositionConfidence_a100m;
    }
    private static final int PositionConfidence_a50m = (int)4L;
    /**
     * {@snippet lang=c :
     * enum PositionConfidence.PositionConfidence_a50m = 4
     * }
     */
    public static int PositionConfidence_a50m() {
        return PositionConfidence_a50m;
    }
    private static final int PositionConfidence_a20m = (int)5L;
    /**
     * {@snippet lang=c :
     * enum PositionConfidence.PositionConfidence_a20m = 5
     * }
     */
    public static int PositionConfidence_a20m() {
        return PositionConfidence_a20m;
    }
    private static final int PositionConfidence_a10m = (int)6L;
    /**
     * {@snippet lang=c :
     * enum PositionConfidence.PositionConfidence_a10m = 6
     * }
     */
    public static int PositionConfidence_a10m() {
        return PositionConfidence_a10m;
    }
    private static final int PositionConfidence_a5m = (int)7L;
    /**
     * {@snippet lang=c :
     * enum PositionConfidence.PositionConfidence_a5m = 7
     * }
     */
    public static int PositionConfidence_a5m() {
        return PositionConfidence_a5m;
    }
    private static final int PositionConfidence_a2m = (int)8L;
    /**
     * {@snippet lang=c :
     * enum PositionConfidence.PositionConfidence_a2m = 8
     * }
     */
    public static int PositionConfidence_a2m() {
        return PositionConfidence_a2m;
    }
    private static final int PositionConfidence_a1m = (int)9L;
    /**
     * {@snippet lang=c :
     * enum PositionConfidence.PositionConfidence_a1m = 9
     * }
     */
    public static int PositionConfidence_a1m() {
        return PositionConfidence_a1m;
    }
    private static final int PositionConfidence_a50cm = (int)10L;
    /**
     * {@snippet lang=c :
     * enum PositionConfidence.PositionConfidence_a50cm = 10
     * }
     */
    public static int PositionConfidence_a50cm() {
        return PositionConfidence_a50cm;
    }
    private static final int PositionConfidence_a20cm = (int)11L;
    /**
     * {@snippet lang=c :
     * enum PositionConfidence.PositionConfidence_a20cm = 11
     * }
     */
    public static int PositionConfidence_a20cm() {
        return PositionConfidence_a20cm;
    }
    private static final int PositionConfidence_a10cm = (int)12L;
    /**
     * {@snippet lang=c :
     * enum PositionConfidence.PositionConfidence_a10cm = 12
     * }
     */
    public static int PositionConfidence_a10cm() {
        return PositionConfidence_a10cm;
    }
    private static final int PositionConfidence_a5cm = (int)13L;
    /**
     * {@snippet lang=c :
     * enum PositionConfidence.PositionConfidence_a5cm = 13
     * }
     */
    public static int PositionConfidence_a5cm() {
        return PositionConfidence_a5cm;
    }
    private static final int PositionConfidence_a2cm = (int)14L;
    /**
     * {@snippet lang=c :
     * enum PositionConfidence.PositionConfidence_a2cm = 14
     * }
     */
    public static int PositionConfidence_a2cm() {
        return PositionConfidence_a2cm;
    }
    private static final int PositionConfidence_a1cm = (int)15L;
    /**
     * {@snippet lang=c :
     * enum PositionConfidence.PositionConfidence_a1cm = 15
     * }
     */
    public static int PositionConfidence_a1cm() {
        return PositionConfidence_a1cm;
    }
    /**
     * {@snippet lang=c :
     * typedef long PositionConfidence_t
     * }
     */
    public static final OfLong PositionConfidence_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_PositionConfidence_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_PositionConfidence_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PositionConfidence_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_PositionConfidence_constr_1$layout() {
        return asn_PER_type_PositionConfidence_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PositionConfidence_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_PositionConfidence_constr_1() {
        return asn_PER_type_PositionConfidence_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_PositionConfidence_constr_1
     * }
     */
    public static void asn_PER_type_PositionConfidence_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_PositionConfidence_constr_1$constants.SEGMENT, 0L, asn_PER_type_PositionConfidence_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_PositionConfidence$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_PositionConfidence").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PositionConfidence
     * }
     */
    public static GroupLayout asn_DEF_PositionConfidence$layout() {
        return asn_DEF_PositionConfidence$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PositionConfidence
     * }
     */
    public static MemorySegment asn_DEF_PositionConfidence() {
        return asn_DEF_PositionConfidence$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PositionConfidence
     * }
     */
    public static void asn_DEF_PositionConfidence(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_PositionConfidence$constants.SEGMENT, 0L, asn_DEF_PositionConfidence$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_PositionConfidence_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_PositionConfidence_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_PositionConfidence_specs_1
     * }
     */
    public static GroupLayout asn_SPC_PositionConfidence_specs_1$layout() {
        return asn_SPC_PositionConfidence_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_PositionConfidence_specs_1
     * }
     */
    public static MemorySegment asn_SPC_PositionConfidence_specs_1() {
        return asn_SPC_PositionConfidence_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_PositionConfidence_specs_1
     * }
     */
    public static void asn_SPC_PositionConfidence_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_PositionConfidence_specs_1$constants.SEGMENT, 0L, asn_SPC_PositionConfidence_specs_1$constants.LAYOUT.byteSize());
    }

    private static class PositionConfidence_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PositionConfidence_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void PositionConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor PositionConfidence_free$descriptor() {
        return PositionConfidence_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void PositionConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle PositionConfidence_free$handle() {
        return PositionConfidence_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void PositionConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment PositionConfidence_free$address() {
        return PositionConfidence_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void PositionConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void PositionConfidence_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = PositionConfidence_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PositionConfidence_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PositionConfidence_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PositionConfidence_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PositionConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PositionConfidence_print$descriptor() {
        return PositionConfidence_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PositionConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PositionConfidence_print$handle() {
        return PositionConfidence_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PositionConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PositionConfidence_print$address() {
        return PositionConfidence_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PositionConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int PositionConfidence_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PositionConfidence_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PositionConfidence_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PositionConfidence_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PositionConfidence_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int PositionConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor PositionConfidence_constraint$descriptor() {
        return PositionConfidence_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int PositionConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle PositionConfidence_constraint$handle() {
        return PositionConfidence_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int PositionConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment PositionConfidence_constraint$address() {
        return PositionConfidence_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int PositionConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int PositionConfidence_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PositionConfidence_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PositionConfidence_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PositionConfidence_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PositionConfidence_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PositionConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor PositionConfidence_decode_ber$descriptor() {
        return PositionConfidence_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PositionConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle PositionConfidence_decode_ber$handle() {
        return PositionConfidence_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PositionConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment PositionConfidence_decode_ber$address() {
        return PositionConfidence_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PositionConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment PositionConfidence_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = PositionConfidence_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PositionConfidence_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PositionConfidence_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PositionConfidence_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PositionConfidence_encode_der$descriptor() {
        return PositionConfidence_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PositionConfidence_encode_der$handle() {
        return PositionConfidence_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PositionConfidence_encode_der$address() {
        return PositionConfidence_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PositionConfidence_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PositionConfidence_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PositionConfidence_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PositionConfidence_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PositionConfidence_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PositionConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor PositionConfidence_decode_xer$descriptor() {
        return PositionConfidence_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PositionConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle PositionConfidence_decode_xer$handle() {
        return PositionConfidence_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PositionConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment PositionConfidence_decode_xer$address() {
        return PositionConfidence_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PositionConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment PositionConfidence_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = PositionConfidence_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PositionConfidence_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PositionConfidence_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PositionConfidence_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PositionConfidence_encode_xer$descriptor() {
        return PositionConfidence_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PositionConfidence_encode_xer$handle() {
        return PositionConfidence_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PositionConfidence_encode_xer$address() {
        return PositionConfidence_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PositionConfidence_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = PositionConfidence_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PositionConfidence_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PositionConfidence_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PositionConfidence_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PositionConfidence_encode_jer$descriptor() {
        return PositionConfidence_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PositionConfidence_encode_jer$handle() {
        return PositionConfidence_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PositionConfidence_encode_jer$address() {
        return PositionConfidence_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PositionConfidence_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = PositionConfidence_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PositionConfidence_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PositionConfidence_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PositionConfidence_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PositionConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor PositionConfidence_decode_oer$descriptor() {
        return PositionConfidence_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PositionConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle PositionConfidence_decode_oer$handle() {
        return PositionConfidence_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PositionConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment PositionConfidence_decode_oer$address() {
        return PositionConfidence_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PositionConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment PositionConfidence_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = PositionConfidence_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PositionConfidence_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PositionConfidence_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PositionConfidence_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor PositionConfidence_encode_oer$descriptor() {
        return PositionConfidence_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle PositionConfidence_encode_oer$handle() {
        return PositionConfidence_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PositionConfidence_encode_oer$address() {
        return PositionConfidence_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment PositionConfidence_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PositionConfidence_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PositionConfidence_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PositionConfidence_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PositionConfidence_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PositionConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor PositionConfidence_decode_uper$descriptor() {
        return PositionConfidence_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PositionConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle PositionConfidence_decode_uper$handle() {
        return PositionConfidence_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PositionConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PositionConfidence_decode_uper$address() {
        return PositionConfidence_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PositionConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PositionConfidence_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PositionConfidence_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PositionConfidence_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PositionConfidence_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PositionConfidence_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor PositionConfidence_encode_uper$descriptor() {
        return PositionConfidence_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle PositionConfidence_encode_uper$handle() {
        return PositionConfidence_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PositionConfidence_encode_uper$address() {
        return PositionConfidence_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PositionConfidence_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PositionConfidence_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PositionConfidence_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PositionConfidence_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PositionConfidence_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t PositionConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor PositionConfidence_decode_aper$descriptor() {
        return PositionConfidence_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t PositionConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle PositionConfidence_decode_aper$handle() {
        return PositionConfidence_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t PositionConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PositionConfidence_decode_aper$address() {
        return PositionConfidence_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t PositionConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment PositionConfidence_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = PositionConfidence_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PositionConfidence_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class PositionConfidence_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("PositionConfidence_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor PositionConfidence_encode_aper$descriptor() {
        return PositionConfidence_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle PositionConfidence_encode_aper$handle() {
        return PositionConfidence_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PositionConfidence_encode_aper$address() {
        return PositionConfidence_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t PositionConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment PositionConfidence_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = PositionConfidence_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("PositionConfidence_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ElevationConfidence_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ElevationConfidence.ElevationConfidence_unavailable = 0
     * }
     */
    public static int ElevationConfidence_unavailable() {
        return ElevationConfidence_unavailable;
    }
    private static final int ElevationConfidence_elev_500_00 = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ElevationConfidence.ElevationConfidence_elev_500_00 = 1
     * }
     */
    public static int ElevationConfidence_elev_500_00() {
        return ElevationConfidence_elev_500_00;
    }
    private static final int ElevationConfidence_elev_200_00 = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ElevationConfidence.ElevationConfidence_elev_200_00 = 2
     * }
     */
    public static int ElevationConfidence_elev_200_00() {
        return ElevationConfidence_elev_200_00;
    }
    private static final int ElevationConfidence_elev_100_00 = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ElevationConfidence.ElevationConfidence_elev_100_00 = 3
     * }
     */
    public static int ElevationConfidence_elev_100_00() {
        return ElevationConfidence_elev_100_00;
    }
    private static final int ElevationConfidence_elev_050_00 = (int)4L;
    /**
     * {@snippet lang=c :
     * enum ElevationConfidence.ElevationConfidence_elev_050_00 = 4
     * }
     */
    public static int ElevationConfidence_elev_050_00() {
        return ElevationConfidence_elev_050_00;
    }
    private static final int ElevationConfidence_elev_020_00 = (int)5L;
    /**
     * {@snippet lang=c :
     * enum ElevationConfidence.ElevationConfidence_elev_020_00 = 5
     * }
     */
    public static int ElevationConfidence_elev_020_00() {
        return ElevationConfidence_elev_020_00;
    }
    private static final int ElevationConfidence_elev_010_00 = (int)6L;
    /**
     * {@snippet lang=c :
     * enum ElevationConfidence.ElevationConfidence_elev_010_00 = 6
     * }
     */
    public static int ElevationConfidence_elev_010_00() {
        return ElevationConfidence_elev_010_00;
    }
    private static final int ElevationConfidence_elev_005_00 = (int)7L;
    /**
     * {@snippet lang=c :
     * enum ElevationConfidence.ElevationConfidence_elev_005_00 = 7
     * }
     */
    public static int ElevationConfidence_elev_005_00() {
        return ElevationConfidence_elev_005_00;
    }
    private static final int ElevationConfidence_elev_002_00 = (int)8L;
    /**
     * {@snippet lang=c :
     * enum ElevationConfidence.ElevationConfidence_elev_002_00 = 8
     * }
     */
    public static int ElevationConfidence_elev_002_00() {
        return ElevationConfidence_elev_002_00;
    }
    private static final int ElevationConfidence_elev_001_00 = (int)9L;
    /**
     * {@snippet lang=c :
     * enum ElevationConfidence.ElevationConfidence_elev_001_00 = 9
     * }
     */
    public static int ElevationConfidence_elev_001_00() {
        return ElevationConfidence_elev_001_00;
    }
    private static final int ElevationConfidence_elev_000_50 = (int)10L;
    /**
     * {@snippet lang=c :
     * enum ElevationConfidence.ElevationConfidence_elev_000_50 = 10
     * }
     */
    public static int ElevationConfidence_elev_000_50() {
        return ElevationConfidence_elev_000_50;
    }
    private static final int ElevationConfidence_elev_000_20 = (int)11L;
    /**
     * {@snippet lang=c :
     * enum ElevationConfidence.ElevationConfidence_elev_000_20 = 11
     * }
     */
    public static int ElevationConfidence_elev_000_20() {
        return ElevationConfidence_elev_000_20;
    }
    private static final int ElevationConfidence_elev_000_10 = (int)12L;
    /**
     * {@snippet lang=c :
     * enum ElevationConfidence.ElevationConfidence_elev_000_10 = 12
     * }
     */
    public static int ElevationConfidence_elev_000_10() {
        return ElevationConfidence_elev_000_10;
    }
    private static final int ElevationConfidence_elev_000_05 = (int)13L;
    /**
     * {@snippet lang=c :
     * enum ElevationConfidence.ElevationConfidence_elev_000_05 = 13
     * }
     */
    public static int ElevationConfidence_elev_000_05() {
        return ElevationConfidence_elev_000_05;
    }
    private static final int ElevationConfidence_elev_000_02 = (int)14L;
    /**
     * {@snippet lang=c :
     * enum ElevationConfidence.ElevationConfidence_elev_000_02 = 14
     * }
     */
    public static int ElevationConfidence_elev_000_02() {
        return ElevationConfidence_elev_000_02;
    }
    private static final int ElevationConfidence_elev_000_01 = (int)15L;
    /**
     * {@snippet lang=c :
     * enum ElevationConfidence.ElevationConfidence_elev_000_01 = 15
     * }
     */
    public static int ElevationConfidence_elev_000_01() {
        return ElevationConfidence_elev_000_01;
    }
    /**
     * {@snippet lang=c :
     * typedef long ElevationConfidence_t
     * }
     */
    public static final OfLong ElevationConfidence_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_ElevationConfidence_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_ElevationConfidence_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ElevationConfidence_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_ElevationConfidence_constr_1$layout() {
        return asn_PER_type_ElevationConfidence_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ElevationConfidence_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_ElevationConfidence_constr_1() {
        return asn_PER_type_ElevationConfidence_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ElevationConfidence_constr_1
     * }
     */
    public static void asn_PER_type_ElevationConfidence_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_ElevationConfidence_constr_1$constants.SEGMENT, 0L, asn_PER_type_ElevationConfidence_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_ElevationConfidence$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_ElevationConfidence").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ElevationConfidence
     * }
     */
    public static GroupLayout asn_DEF_ElevationConfidence$layout() {
        return asn_DEF_ElevationConfidence$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ElevationConfidence
     * }
     */
    public static MemorySegment asn_DEF_ElevationConfidence() {
        return asn_DEF_ElevationConfidence$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_ElevationConfidence
     * }
     */
    public static void asn_DEF_ElevationConfidence(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_ElevationConfidence$constants.SEGMENT, 0L, asn_DEF_ElevationConfidence$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_ElevationConfidence_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_ElevationConfidence_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_ElevationConfidence_specs_1
     * }
     */
    public static GroupLayout asn_SPC_ElevationConfidence_specs_1$layout() {
        return asn_SPC_ElevationConfidence_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_ElevationConfidence_specs_1
     * }
     */
    public static MemorySegment asn_SPC_ElevationConfidence_specs_1() {
        return asn_SPC_ElevationConfidence_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_ElevationConfidence_specs_1
     * }
     */
    public static void asn_SPC_ElevationConfidence_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_ElevationConfidence_specs_1$constants.SEGMENT, 0L, asn_SPC_ElevationConfidence_specs_1$constants.LAYOUT.byteSize());
    }

    private static class ElevationConfidence_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevationConfidence_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void ElevationConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor ElevationConfidence_free$descriptor() {
        return ElevationConfidence_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void ElevationConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle ElevationConfidence_free$handle() {
        return ElevationConfidence_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void ElevationConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment ElevationConfidence_free$address() {
        return ElevationConfidence_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void ElevationConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void ElevationConfidence_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = ElevationConfidence_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevationConfidence_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevationConfidence_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevationConfidence_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ElevationConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ElevationConfidence_print$descriptor() {
        return ElevationConfidence_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ElevationConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ElevationConfidence_print$handle() {
        return ElevationConfidence_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ElevationConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ElevationConfidence_print$address() {
        return ElevationConfidence_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ElevationConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int ElevationConfidence_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ElevationConfidence_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevationConfidence_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevationConfidence_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevationConfidence_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int ElevationConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor ElevationConfidence_constraint$descriptor() {
        return ElevationConfidence_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int ElevationConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle ElevationConfidence_constraint$handle() {
        return ElevationConfidence_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int ElevationConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment ElevationConfidence_constraint$address() {
        return ElevationConfidence_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int ElevationConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int ElevationConfidence_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ElevationConfidence_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevationConfidence_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevationConfidence_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevationConfidence_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevationConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor ElevationConfidence_decode_ber$descriptor() {
        return ElevationConfidence_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevationConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle ElevationConfidence_decode_ber$handle() {
        return ElevationConfidence_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevationConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment ElevationConfidence_decode_ber$address() {
        return ElevationConfidence_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ElevationConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment ElevationConfidence_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = ElevationConfidence_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevationConfidence_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevationConfidence_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevationConfidence_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ElevationConfidence_encode_der$descriptor() {
        return ElevationConfidence_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ElevationConfidence_encode_der$handle() {
        return ElevationConfidence_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ElevationConfidence_encode_der$address() {
        return ElevationConfidence_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ElevationConfidence_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ElevationConfidence_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevationConfidence_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevationConfidence_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevationConfidence_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevationConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor ElevationConfidence_decode_xer$descriptor() {
        return ElevationConfidence_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevationConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle ElevationConfidence_decode_xer$handle() {
        return ElevationConfidence_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevationConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment ElevationConfidence_decode_xer$address() {
        return ElevationConfidence_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ElevationConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment ElevationConfidence_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = ElevationConfidence_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevationConfidence_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevationConfidence_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevationConfidence_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ElevationConfidence_encode_xer$descriptor() {
        return ElevationConfidence_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ElevationConfidence_encode_xer$handle() {
        return ElevationConfidence_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ElevationConfidence_encode_xer$address() {
        return ElevationConfidence_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ElevationConfidence_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = ElevationConfidence_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevationConfidence_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevationConfidence_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevationConfidence_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ElevationConfidence_encode_jer$descriptor() {
        return ElevationConfidence_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ElevationConfidence_encode_jer$handle() {
        return ElevationConfidence_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ElevationConfidence_encode_jer$address() {
        return ElevationConfidence_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ElevationConfidence_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = ElevationConfidence_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevationConfidence_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevationConfidence_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevationConfidence_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevationConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor ElevationConfidence_decode_oer$descriptor() {
        return ElevationConfidence_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevationConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle ElevationConfidence_decode_oer$handle() {
        return ElevationConfidence_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevationConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ElevationConfidence_decode_oer$address() {
        return ElevationConfidence_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ElevationConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment ElevationConfidence_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = ElevationConfidence_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevationConfidence_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevationConfidence_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevationConfidence_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor ElevationConfidence_encode_oer$descriptor() {
        return ElevationConfidence_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle ElevationConfidence_encode_oer$handle() {
        return ElevationConfidence_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ElevationConfidence_encode_oer$address() {
        return ElevationConfidence_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment ElevationConfidence_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ElevationConfidence_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevationConfidence_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevationConfidence_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevationConfidence_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevationConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor ElevationConfidence_decode_uper$descriptor() {
        return ElevationConfidence_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevationConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle ElevationConfidence_decode_uper$handle() {
        return ElevationConfidence_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevationConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ElevationConfidence_decode_uper$address() {
        return ElevationConfidence_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ElevationConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ElevationConfidence_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ElevationConfidence_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevationConfidence_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevationConfidence_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevationConfidence_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor ElevationConfidence_encode_uper$descriptor() {
        return ElevationConfidence_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle ElevationConfidence_encode_uper$handle() {
        return ElevationConfidence_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ElevationConfidence_encode_uper$address() {
        return ElevationConfidence_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ElevationConfidence_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ElevationConfidence_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevationConfidence_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevationConfidence_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevationConfidence_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevationConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor ElevationConfidence_decode_aper$descriptor() {
        return ElevationConfidence_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevationConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle ElevationConfidence_decode_aper$handle() {
        return ElevationConfidence_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t ElevationConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ElevationConfidence_decode_aper$address() {
        return ElevationConfidence_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t ElevationConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment ElevationConfidence_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = ElevationConfidence_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevationConfidence_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class ElevationConfidence_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("ElevationConfidence_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor ElevationConfidence_encode_aper$descriptor() {
        return ElevationConfidence_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle ElevationConfidence_encode_aper$handle() {
        return ElevationConfidence_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ElevationConfidence_encode_aper$address() {
        return ElevationConfidence_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t ElevationConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment ElevationConfidence_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = ElevationConfidence_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("ElevationConfidence_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class asn_DEF_PositionConfidenceSet$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_PositionConfidenceSet").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PositionConfidenceSet
     * }
     */
    public static GroupLayout asn_DEF_PositionConfidenceSet$layout() {
        return asn_DEF_PositionConfidenceSet$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PositionConfidenceSet
     * }
     */
    public static MemorySegment asn_DEF_PositionConfidenceSet() {
        return asn_DEF_PositionConfidenceSet$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_PositionConfidenceSet
     * }
     */
    public static void asn_DEF_PositionConfidenceSet(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_PositionConfidenceSet$constants.SEGMENT, 0L, asn_DEF_PositionConfidenceSet$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_PositionConfidenceSet_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_SEQUENCE_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_PositionConfidenceSet_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_PositionConfidenceSet_specs_1
     * }
     */
    public static GroupLayout asn_SPC_PositionConfidenceSet_specs_1$layout() {
        return asn_SPC_PositionConfidenceSet_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_PositionConfidenceSet_specs_1
     * }
     */
    public static MemorySegment asn_SPC_PositionConfidenceSet_specs_1() {
        return asn_SPC_PositionConfidenceSet_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_SEQUENCE_specifics_t asn_SPC_PositionConfidenceSet_specs_1
     * }
     */
    public static void asn_SPC_PositionConfidenceSet_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_PositionConfidenceSet_specs_1$constants.SEGMENT, 0L, asn_SPC_PositionConfidenceSet_specs_1$constants.LAYOUT.byteSize());
    }

    private static class asn_MBR_PositionConfidenceSet_1$constants {
        public static final SequenceLayout LAYOUT = MemoryLayout.sequenceLayout(2, asn_TYPE_member_s.layout());
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_MBR_PositionConfidenceSet_1").reinterpret(LAYOUT.byteSize());
    public static final MethodHandle HANDLE = LAYOUT.sliceHandle(sequenceElement());
        public static final long[] DIMS = { 2 };
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PositionConfidenceSet_1[2]
     * }
     */
    public static SequenceLayout asn_MBR_PositionConfidenceSet_1$layout() {
        return asn_MBR_PositionConfidenceSet_1$constants.LAYOUT;
    }

    /**
     * Dimensions for array variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PositionConfidenceSet_1[2]
     * }
     */
    public static long[] asn_MBR_PositionConfidenceSet_1$dimensions() {
        return asn_MBR_PositionConfidenceSet_1$constants.DIMS;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PositionConfidenceSet_1[2]
     * }
     */
    public static MemorySegment asn_MBR_PositionConfidenceSet_1() {
        return asn_MBR_PositionConfidenceSet_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PositionConfidenceSet_1[2]
     * }
     */
    public static void asn_MBR_PositionConfidenceSet_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_PositionConfidenceSet_1$constants.SEGMENT, 0L, asn_MBR_PositionConfidenceSet_1$constants.LAYOUT.byteSize());
    }

    /**
     * Indexed getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PositionConfidenceSet_1[2]
     * }
     */
    public static MemorySegment asn_MBR_PositionConfidenceSet_1(long index0) {
        try {
            return (MemorySegment)asn_MBR_PositionConfidenceSet_1$constants.HANDLE.invokeExact(asn_MBR_PositionConfidenceSet_1$constants.SEGMENT, 0L, index0);
        } catch (Throwable ex$) {
            throw new AssertionError("should not reach here", ex$);
        }
    }

    /**
     * Indexed setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_member_t asn_MBR_PositionConfidenceSet_1[2]
     * }
     */
    public static void asn_MBR_PositionConfidenceSet_1(long index0, MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_MBR_PositionConfidenceSet_1(index0), 0L, asn_TYPE_member_s.layout().byteSize());
    }
    private static final int HeadingConfidence_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum HeadingConfidence.HeadingConfidence_unavailable = 0
     * }
     */
    public static int HeadingConfidence_unavailable() {
        return HeadingConfidence_unavailable;
    }
    private static final int HeadingConfidence_prec10deg = (int)1L;
    /**
     * {@snippet lang=c :
     * enum HeadingConfidence.HeadingConfidence_prec10deg = 1
     * }
     */
    public static int HeadingConfidence_prec10deg() {
        return HeadingConfidence_prec10deg;
    }
    private static final int HeadingConfidence_prec05deg = (int)2L;
    /**
     * {@snippet lang=c :
     * enum HeadingConfidence.HeadingConfidence_prec05deg = 2
     * }
     */
    public static int HeadingConfidence_prec05deg() {
        return HeadingConfidence_prec05deg;
    }
    private static final int HeadingConfidence_prec01deg = (int)3L;
    /**
     * {@snippet lang=c :
     * enum HeadingConfidence.HeadingConfidence_prec01deg = 3
     * }
     */
    public static int HeadingConfidence_prec01deg() {
        return HeadingConfidence_prec01deg;
    }
    private static final int HeadingConfidence_prec0_1deg = (int)4L;
    /**
     * {@snippet lang=c :
     * enum HeadingConfidence.HeadingConfidence_prec0_1deg = 4
     * }
     */
    public static int HeadingConfidence_prec0_1deg() {
        return HeadingConfidence_prec0_1deg;
    }
    private static final int HeadingConfidence_prec0_05deg = (int)5L;
    /**
     * {@snippet lang=c :
     * enum HeadingConfidence.HeadingConfidence_prec0_05deg = 5
     * }
     */
    public static int HeadingConfidence_prec0_05deg() {
        return HeadingConfidence_prec0_05deg;
    }
    private static final int HeadingConfidence_prec0_01deg = (int)6L;
    /**
     * {@snippet lang=c :
     * enum HeadingConfidence.HeadingConfidence_prec0_01deg = 6
     * }
     */
    public static int HeadingConfidence_prec0_01deg() {
        return HeadingConfidence_prec0_01deg;
    }
    private static final int HeadingConfidence_prec0_0125deg = (int)7L;
    /**
     * {@snippet lang=c :
     * enum HeadingConfidence.HeadingConfidence_prec0_0125deg = 7
     * }
     */
    public static int HeadingConfidence_prec0_0125deg() {
        return HeadingConfidence_prec0_0125deg;
    }
    /**
     * {@snippet lang=c :
     * typedef long HeadingConfidence_t
     * }
     */
    public static final OfLong HeadingConfidence_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_HeadingConfidence_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_HeadingConfidence_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_HeadingConfidence_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_HeadingConfidence_constr_1$layout() {
        return asn_PER_type_HeadingConfidence_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_HeadingConfidence_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_HeadingConfidence_constr_1() {
        return asn_PER_type_HeadingConfidence_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_HeadingConfidence_constr_1
     * }
     */
    public static void asn_PER_type_HeadingConfidence_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_HeadingConfidence_constr_1$constants.SEGMENT, 0L, asn_PER_type_HeadingConfidence_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_HeadingConfidence$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_HeadingConfidence").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_HeadingConfidence
     * }
     */
    public static GroupLayout asn_DEF_HeadingConfidence$layout() {
        return asn_DEF_HeadingConfidence$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_HeadingConfidence
     * }
     */
    public static MemorySegment asn_DEF_HeadingConfidence() {
        return asn_DEF_HeadingConfidence$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_HeadingConfidence
     * }
     */
    public static void asn_DEF_HeadingConfidence(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_HeadingConfidence$constants.SEGMENT, 0L, asn_DEF_HeadingConfidence$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_HeadingConfidence_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_HeadingConfidence_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_HeadingConfidence_specs_1
     * }
     */
    public static GroupLayout asn_SPC_HeadingConfidence_specs_1$layout() {
        return asn_SPC_HeadingConfidence_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_HeadingConfidence_specs_1
     * }
     */
    public static MemorySegment asn_SPC_HeadingConfidence_specs_1() {
        return asn_SPC_HeadingConfidence_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_HeadingConfidence_specs_1
     * }
     */
    public static void asn_SPC_HeadingConfidence_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_HeadingConfidence_specs_1$constants.SEGMENT, 0L, asn_SPC_HeadingConfidence_specs_1$constants.LAYOUT.byteSize());
    }

    private static class HeadingConfidence_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingConfidence_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void HeadingConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor HeadingConfidence_free$descriptor() {
        return HeadingConfidence_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void HeadingConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle HeadingConfidence_free$handle() {
        return HeadingConfidence_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void HeadingConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment HeadingConfidence_free$address() {
        return HeadingConfidence_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void HeadingConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void HeadingConfidence_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = HeadingConfidence_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingConfidence_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingConfidence_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingConfidence_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int HeadingConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor HeadingConfidence_print$descriptor() {
        return HeadingConfidence_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int HeadingConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle HeadingConfidence_print$handle() {
        return HeadingConfidence_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int HeadingConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HeadingConfidence_print$address() {
        return HeadingConfidence_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int HeadingConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int HeadingConfidence_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = HeadingConfidence_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingConfidence_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingConfidence_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingConfidence_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int HeadingConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor HeadingConfidence_constraint$descriptor() {
        return HeadingConfidence_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int HeadingConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle HeadingConfidence_constraint$handle() {
        return HeadingConfidence_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int HeadingConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment HeadingConfidence_constraint$address() {
        return HeadingConfidence_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int HeadingConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int HeadingConfidence_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = HeadingConfidence_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingConfidence_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingConfidence_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingConfidence_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor HeadingConfidence_decode_ber$descriptor() {
        return HeadingConfidence_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle HeadingConfidence_decode_ber$handle() {
        return HeadingConfidence_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment HeadingConfidence_decode_ber$address() {
        return HeadingConfidence_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment HeadingConfidence_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = HeadingConfidence_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingConfidence_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingConfidence_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingConfidence_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor HeadingConfidence_encode_der$descriptor() {
        return HeadingConfidence_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle HeadingConfidence_encode_der$handle() {
        return HeadingConfidence_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HeadingConfidence_encode_der$address() {
        return HeadingConfidence_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HeadingConfidence_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = HeadingConfidence_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingConfidence_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingConfidence_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingConfidence_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor HeadingConfidence_decode_xer$descriptor() {
        return HeadingConfidence_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle HeadingConfidence_decode_xer$handle() {
        return HeadingConfidence_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment HeadingConfidence_decode_xer$address() {
        return HeadingConfidence_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment HeadingConfidence_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = HeadingConfidence_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingConfidence_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingConfidence_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingConfidence_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor HeadingConfidence_encode_xer$descriptor() {
        return HeadingConfidence_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle HeadingConfidence_encode_xer$handle() {
        return HeadingConfidence_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HeadingConfidence_encode_xer$address() {
        return HeadingConfidence_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HeadingConfidence_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = HeadingConfidence_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingConfidence_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingConfidence_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingConfidence_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor HeadingConfidence_encode_jer$descriptor() {
        return HeadingConfidence_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle HeadingConfidence_encode_jer$handle() {
        return HeadingConfidence_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HeadingConfidence_encode_jer$address() {
        return HeadingConfidence_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HeadingConfidence_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = HeadingConfidence_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingConfidence_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingConfidence_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingConfidence_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor HeadingConfidence_decode_oer$descriptor() {
        return HeadingConfidence_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle HeadingConfidence_decode_oer$handle() {
        return HeadingConfidence_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment HeadingConfidence_decode_oer$address() {
        return HeadingConfidence_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment HeadingConfidence_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = HeadingConfidence_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingConfidence_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingConfidence_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingConfidence_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor HeadingConfidence_encode_oer$descriptor() {
        return HeadingConfidence_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle HeadingConfidence_encode_oer$handle() {
        return HeadingConfidence_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HeadingConfidence_encode_oer$address() {
        return HeadingConfidence_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment HeadingConfidence_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = HeadingConfidence_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingConfidence_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingConfidence_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingConfidence_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor HeadingConfidence_decode_uper$descriptor() {
        return HeadingConfidence_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle HeadingConfidence_decode_uper$handle() {
        return HeadingConfidence_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment HeadingConfidence_decode_uper$address() {
        return HeadingConfidence_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment HeadingConfidence_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = HeadingConfidence_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingConfidence_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingConfidence_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingConfidence_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor HeadingConfidence_encode_uper$descriptor() {
        return HeadingConfidence_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle HeadingConfidence_encode_uper$handle() {
        return HeadingConfidence_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment HeadingConfidence_encode_uper$address() {
        return HeadingConfidence_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment HeadingConfidence_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = HeadingConfidence_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingConfidence_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingConfidence_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingConfidence_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor HeadingConfidence_decode_aper$descriptor() {
        return HeadingConfidence_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle HeadingConfidence_decode_aper$handle() {
        return HeadingConfidence_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment HeadingConfidence_decode_aper$address() {
        return HeadingConfidence_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t HeadingConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment HeadingConfidence_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = HeadingConfidence_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingConfidence_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class HeadingConfidence_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("HeadingConfidence_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor HeadingConfidence_encode_aper$descriptor() {
        return HeadingConfidence_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle HeadingConfidence_encode_aper$handle() {
        return HeadingConfidence_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment HeadingConfidence_encode_aper$address() {
        return HeadingConfidence_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t HeadingConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment HeadingConfidence_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = HeadingConfidence_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("HeadingConfidence_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int SpeedConfidence_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum SpeedConfidence.SpeedConfidence_unavailable = 0
     * }
     */
    public static int SpeedConfidence_unavailable() {
        return SpeedConfidence_unavailable;
    }
    private static final int SpeedConfidence_prec100ms = (int)1L;
    /**
     * {@snippet lang=c :
     * enum SpeedConfidence.SpeedConfidence_prec100ms = 1
     * }
     */
    public static int SpeedConfidence_prec100ms() {
        return SpeedConfidence_prec100ms;
    }
    private static final int SpeedConfidence_prec10ms = (int)2L;
    /**
     * {@snippet lang=c :
     * enum SpeedConfidence.SpeedConfidence_prec10ms = 2
     * }
     */
    public static int SpeedConfidence_prec10ms() {
        return SpeedConfidence_prec10ms;
    }
    private static final int SpeedConfidence_prec5ms = (int)3L;
    /**
     * {@snippet lang=c :
     * enum SpeedConfidence.SpeedConfidence_prec5ms = 3
     * }
     */
    public static int SpeedConfidence_prec5ms() {
        return SpeedConfidence_prec5ms;
    }
    private static final int SpeedConfidence_prec1ms = (int)4L;
    /**
     * {@snippet lang=c :
     * enum SpeedConfidence.SpeedConfidence_prec1ms = 4
     * }
     */
    public static int SpeedConfidence_prec1ms() {
        return SpeedConfidence_prec1ms;
    }
    private static final int SpeedConfidence_prec0_1ms = (int)5L;
    /**
     * {@snippet lang=c :
     * enum SpeedConfidence.SpeedConfidence_prec0_1ms = 5
     * }
     */
    public static int SpeedConfidence_prec0_1ms() {
        return SpeedConfidence_prec0_1ms;
    }
    private static final int SpeedConfidence_prec0_05ms = (int)6L;
    /**
     * {@snippet lang=c :
     * enum SpeedConfidence.SpeedConfidence_prec0_05ms = 6
     * }
     */
    public static int SpeedConfidence_prec0_05ms() {
        return SpeedConfidence_prec0_05ms;
    }
    private static final int SpeedConfidence_prec0_01ms = (int)7L;
    /**
     * {@snippet lang=c :
     * enum SpeedConfidence.SpeedConfidence_prec0_01ms = 7
     * }
     */
    public static int SpeedConfidence_prec0_01ms() {
        return SpeedConfidence_prec0_01ms;
    }
    /**
     * {@snippet lang=c :
     * typedef long SpeedConfidence_t
     * }
     */
    public static final OfLong SpeedConfidence_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_SpeedConfidence_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_SpeedConfidence_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SpeedConfidence_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_SpeedConfidence_constr_1$layout() {
        return asn_PER_type_SpeedConfidence_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SpeedConfidence_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_SpeedConfidence_constr_1() {
        return asn_PER_type_SpeedConfidence_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_SpeedConfidence_constr_1
     * }
     */
    public static void asn_PER_type_SpeedConfidence_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_SpeedConfidence_constr_1$constants.SEGMENT, 0L, asn_PER_type_SpeedConfidence_constr_1$constants.LAYOUT.byteSize());
    }

    private static class asn_DEF_SpeedConfidence$constants {
        public static final GroupLayout LAYOUT = asn_TYPE_descriptor_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_DEF_SpeedConfidence").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SpeedConfidence
     * }
     */
    public static GroupLayout asn_DEF_SpeedConfidence$layout() {
        return asn_DEF_SpeedConfidence$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SpeedConfidence
     * }
     */
    public static MemorySegment asn_DEF_SpeedConfidence() {
        return asn_DEF_SpeedConfidence$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_TYPE_descriptor_t asn_DEF_SpeedConfidence
     * }
     */
    public static void asn_DEF_SpeedConfidence(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_DEF_SpeedConfidence$constants.SEGMENT, 0L, asn_DEF_SpeedConfidence$constants.LAYOUT.byteSize());
    }

    private static class asn_SPC_SpeedConfidence_specs_1$constants {
        public static final GroupLayout LAYOUT = asn_INTEGER_specifics_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_SPC_SpeedConfidence_specs_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_SpeedConfidence_specs_1
     * }
     */
    public static GroupLayout asn_SPC_SpeedConfidence_specs_1$layout() {
        return asn_SPC_SpeedConfidence_specs_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_SpeedConfidence_specs_1
     * }
     */
    public static MemorySegment asn_SPC_SpeedConfidence_specs_1() {
        return asn_SPC_SpeedConfidence_specs_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern const asn_INTEGER_specifics_t asn_SPC_SpeedConfidence_specs_1
     * }
     */
    public static void asn_SPC_SpeedConfidence_specs_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_SPC_SpeedConfidence_specs_1$constants.SEGMENT, 0L, asn_SPC_SpeedConfidence_specs_1$constants.LAYOUT.byteSize());
    }

    private static class SpeedConfidence_free {
        public static final FunctionDescriptor DESC = FunctionDescriptor.ofVoid(
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedConfidence_free");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * void SpeedConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static FunctionDescriptor SpeedConfidence_free$descriptor() {
        return SpeedConfidence_free.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * void SpeedConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MethodHandle SpeedConfidence_free$handle() {
        return SpeedConfidence_free.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * void SpeedConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static MemorySegment SpeedConfidence_free$address() {
        return SpeedConfidence_free.ADDR;
    }

    /**
     * {@snippet lang=c :
     * void SpeedConfidence_free(const struct asn_TYPE_descriptor_s *, void *, enum asn_struct_free_method)
     * }
     */
    public static void SpeedConfidence_free(MemorySegment x0, MemorySegment x1, int x2) {
        var mh$ = SpeedConfidence_free.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedConfidence_free", x0, x1, x2);
            }
            mh$.invokeExact(x0, x1, x2);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedConfidence_print {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedConfidence_print");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SpeedConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SpeedConfidence_print$descriptor() {
        return SpeedConfidence_print.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SpeedConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SpeedConfidence_print$handle() {
        return SpeedConfidence_print.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SpeedConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SpeedConfidence_print$address() {
        return SpeedConfidence_print.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SpeedConfidence_print(const struct asn_TYPE_descriptor_s *, const void *, int, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static int SpeedConfidence_print(MemorySegment x0, MemorySegment x1, int x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SpeedConfidence_print.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedConfidence_print", x0, x1, x2, x3, x4);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedConfidence_constraint {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedConfidence_constraint");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * int SpeedConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static FunctionDescriptor SpeedConfidence_constraint$descriptor() {
        return SpeedConfidence_constraint.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * int SpeedConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MethodHandle SpeedConfidence_constraint$handle() {
        return SpeedConfidence_constraint.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * int SpeedConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static MemorySegment SpeedConfidence_constraint$address() {
        return SpeedConfidence_constraint.ADDR;
    }

    /**
     * {@snippet lang=c :
     * int SpeedConfidence_constraint(const struct asn_TYPE_descriptor_s *, const void *, asn_app_constraint_failed_f *, void *)
     * }
     */
    public static int SpeedConfidence_constraint(MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SpeedConfidence_constraint.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedConfidence_constraint", x0, x1, x2, x3);
            }
            return (int)mh$.invokeExact(x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedConfidence_decode_ber {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG,
            MessageFrame_h.C_INT
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedConfidence_decode_ber");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static FunctionDescriptor SpeedConfidence_decode_ber$descriptor() {
        return SpeedConfidence_decode_ber.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MethodHandle SpeedConfidence_decode_ber$handle() {
        return SpeedConfidence_decode_ber.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SpeedConfidence_decode_ber$address() {
        return SpeedConfidence_decode_ber.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedConfidence_decode_ber(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, void **, const void *, size_t, int)
     * }
     */
    public static MemorySegment SpeedConfidence_decode_ber(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, long x4, int x5) {
        var mh$ = SpeedConfidence_decode_ber.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedConfidence_decode_ber", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedConfidence_encode_der {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedConfidence_encode_der");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SpeedConfidence_encode_der$descriptor() {
        return SpeedConfidence_encode_der.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SpeedConfidence_encode_der$handle() {
        return SpeedConfidence_encode_der.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SpeedConfidence_encode_der$address() {
        return SpeedConfidence_encode_der.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_der(const struct asn_TYPE_descriptor_s *, const void *, int, ber_tlv_tag_t, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SpeedConfidence_encode_der(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SpeedConfidence_encode_der.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedConfidence_encode_der", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedConfidence_decode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedConfidence_decode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SpeedConfidence_decode_xer$descriptor() {
        return SpeedConfidence_decode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MethodHandle SpeedConfidence_decode_xer$handle() {
        return SpeedConfidence_decode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SpeedConfidence_decode_xer$address() {
        return SpeedConfidence_decode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedConfidence_decode_xer(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, void **, const char *, const void *, size_t)
     * }
     */
    public static MemorySegment SpeedConfidence_decode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SpeedConfidence_decode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedConfidence_decode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedConfidence_encode_xer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedConfidence_encode_xer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SpeedConfidence_encode_xer$descriptor() {
        return SpeedConfidence_encode_xer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SpeedConfidence_encode_xer$handle() {
        return SpeedConfidence_encode_xer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SpeedConfidence_encode_xer$address() {
        return SpeedConfidence_encode_xer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_xer(const struct asn_TYPE_descriptor_s *, const void *, int, enum xer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SpeedConfidence_encode_xer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, int x2, int x3, MemorySegment x4, MemorySegment x5) {
        var mh$ = SpeedConfidence_encode_xer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedConfidence_encode_xer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedConfidence_encode_jer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_INT,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedConfidence_encode_jer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SpeedConfidence_encode_jer$descriptor() {
        return SpeedConfidence_encode_jer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SpeedConfidence_encode_jer$handle() {
        return SpeedConfidence_encode_jer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SpeedConfidence_encode_jer$address() {
        return SpeedConfidence_encode_jer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_jer(const struct asn_TYPE_descriptor_s *, const asn_jer_constraints_t *, const void *, int, enum jer_encoder_flags_e, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SpeedConfidence_encode_jer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, int x3, int x4, MemorySegment x5, MemorySegment x6) {
        var mh$ = SpeedConfidence_encode_jer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedConfidence_encode_jer", allocator, x0, x1, x2, x3, x4, x5, x6);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5, x6);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedConfidence_decode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_LONG
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedConfidence_decode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static FunctionDescriptor SpeedConfidence_decode_oer$descriptor() {
        return SpeedConfidence_decode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MethodHandle SpeedConfidence_decode_oer$handle() {
        return SpeedConfidence_decode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SpeedConfidence_decode_oer$address() {
        return SpeedConfidence_decode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedConfidence_decode_oer(const struct asn_codec_ctx_s *, const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, void **, const void *, size_t)
     * }
     */
    public static MemorySegment SpeedConfidence_decode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4, long x5) {
        var mh$ = SpeedConfidence_decode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedConfidence_decode_oer", allocator, x0, x1, x2, x3, x4, x5);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4, x5);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedConfidence_encode_oer {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedConfidence_encode_oer");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static FunctionDescriptor SpeedConfidence_encode_oer$descriptor() {
        return SpeedConfidence_encode_oer.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MethodHandle SpeedConfidence_encode_oer$handle() {
        return SpeedConfidence_encode_oer.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SpeedConfidence_encode_oer$address() {
        return SpeedConfidence_encode_oer.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_oer(const struct asn_TYPE_descriptor_s *, const asn_oer_constraints_t *, const void *, asn_app_consume_bytes_f *, void *)
     * }
     */
    public static MemorySegment SpeedConfidence_encode_oer(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SpeedConfidence_encode_oer.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedConfidence_encode_oer", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedConfidence_decode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedConfidence_decode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SpeedConfidence_decode_uper$descriptor() {
        return SpeedConfidence_decode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SpeedConfidence_decode_uper$handle() {
        return SpeedConfidence_decode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SpeedConfidence_decode_uper$address() {
        return SpeedConfidence_decode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedConfidence_decode_uper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SpeedConfidence_decode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SpeedConfidence_decode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedConfidence_decode_uper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedConfidence_encode_uper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedConfidence_encode_uper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SpeedConfidence_encode_uper$descriptor() {
        return SpeedConfidence_encode_uper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SpeedConfidence_encode_uper$handle() {
        return SpeedConfidence_encode_uper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SpeedConfidence_encode_uper$address() {
        return SpeedConfidence_encode_uper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_uper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SpeedConfidence_encode_uper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SpeedConfidence_encode_uper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedConfidence_encode_uper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedConfidence_decode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_dec_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedConfidence_decode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static FunctionDescriptor SpeedConfidence_decode_aper$descriptor() {
        return SpeedConfidence_decode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MethodHandle SpeedConfidence_decode_aper$handle() {
        return SpeedConfidence_decode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SpeedConfidence_decode_aper$address() {
        return SpeedConfidence_decode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_dec_rval_t SpeedConfidence_decode_aper(const asn_codec_ctx_t *, const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, void **, asn_per_data_t *)
     * }
     */
    public static MemorySegment SpeedConfidence_decode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3, MemorySegment x4) {
        var mh$ = SpeedConfidence_decode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedConfidence_decode_aper", allocator, x0, x1, x2, x3, x4);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3, x4);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }

    private static class SpeedConfidence_encode_aper {
        public static final FunctionDescriptor DESC = FunctionDescriptor.of(
            asn_enc_rval_s.layout(),
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER,
            MessageFrame_h.C_POINTER
        );

        public static final MemorySegment ADDR = MessageFrame_h.findOrThrow("SpeedConfidence_encode_aper");

        public static final MethodHandle HANDLE = Linker.nativeLinker().downcallHandle(ADDR, DESC);
    }

    /**
     * Function descriptor for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static FunctionDescriptor SpeedConfidence_encode_aper$descriptor() {
        return SpeedConfidence_encode_aper.DESC;
    }

    /**
     * Downcall method handle for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MethodHandle SpeedConfidence_encode_aper$handle() {
        return SpeedConfidence_encode_aper.HANDLE;
    }

    /**
     * Address for:
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SpeedConfidence_encode_aper$address() {
        return SpeedConfidence_encode_aper.ADDR;
    }

    /**
     * {@snippet lang=c :
     * asn_enc_rval_t SpeedConfidence_encode_aper(const struct asn_TYPE_descriptor_s *, const asn_per_constraints_t *, const void *, asn_per_outp_t *)
     * }
     */
    public static MemorySegment SpeedConfidence_encode_aper(SegmentAllocator allocator, MemorySegment x0, MemorySegment x1, MemorySegment x2, MemorySegment x3) {
        var mh$ = SpeedConfidence_encode_aper.HANDLE;
        try {
            if (TRACE_DOWNCALLS) {
                traceDowncall("SpeedConfidence_encode_aper", allocator, x0, x1, x2, x3);
            }
            return (MemorySegment)mh$.invokeExact(allocator, x0, x1, x2, x3);
        } catch (Throwable ex$) {
           throw new AssertionError("should not reach here", ex$);
        }
    }
    private static final int ThrottleConfidence_unavailable = (int)0L;
    /**
     * {@snippet lang=c :
     * enum ThrottleConfidence.ThrottleConfidence_unavailable = 0
     * }
     */
    public static int ThrottleConfidence_unavailable() {
        return ThrottleConfidence_unavailable;
    }
    private static final int ThrottleConfidence_prec10percent = (int)1L;
    /**
     * {@snippet lang=c :
     * enum ThrottleConfidence.ThrottleConfidence_prec10percent = 1
     * }
     */
    public static int ThrottleConfidence_prec10percent() {
        return ThrottleConfidence_prec10percent;
    }
    private static final int ThrottleConfidence_prec1percent = (int)2L;
    /**
     * {@snippet lang=c :
     * enum ThrottleConfidence.ThrottleConfidence_prec1percent = 2
     * }
     */
    public static int ThrottleConfidence_prec1percent() {
        return ThrottleConfidence_prec1percent;
    }
    private static final int ThrottleConfidence_prec0_5percent = (int)3L;
    /**
     * {@snippet lang=c :
     * enum ThrottleConfidence.ThrottleConfidence_prec0_5percent = 3
     * }
     */
    public static int ThrottleConfidence_prec0_5percent() {
        return ThrottleConfidence_prec0_5percent;
    }
    /**
     * {@snippet lang=c :
     * typedef long ThrottleConfidence_t
     * }
     */
    public static final OfLong ThrottleConfidence_t = MessageFrame_h.C_LONG;

    private static class asn_PER_type_ThrottleConfidence_constr_1$constants {
        public static final GroupLayout LAYOUT = asn_per_constraints_s.layout();
        public static final MemorySegment SEGMENT = MessageFrame_h.findOrThrow("asn_PER_type_ThrottleConfidence_constr_1").reinterpret(LAYOUT.byteSize());
    }

    /**
     * Layout for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ThrottleConfidence_constr_1
     * }
     */
    public static GroupLayout asn_PER_type_ThrottleConfidence_constr_1$layout() {
        return asn_PER_type_ThrottleConfidence_constr_1$constants.LAYOUT;
    }

    /**
     * Getter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ThrottleConfidence_constr_1
     * }
     */
    public static MemorySegment asn_PER_type_ThrottleConfidence_constr_1() {
        return asn_PER_type_ThrottleConfidence_constr_1$constants.SEGMENT;
    }

    /**
     * Setter for variable:
     * {@snippet lang=c :
     * extern asn_per_constraints_t asn_PER_type_ThrottleConfidence_constr_1
     * }
     */
    public static void asn_PER_type_ThrottleConfidence_constr_1(MemorySegment varValue) {
        MemorySegment.copy(varValue, 0L, asn_PER_type_ThrottleConfidence_constr_1$constants.SEGMENT, 0L, asn_PER_type_ThrottleConfidence_constr_1$constants.LAYOUT.byteSize());
    }
}

